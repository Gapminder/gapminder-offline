(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("Vizabi", [], factory);
	else if(typeof exports === 'object')
		exports["Vizabi"] = factory();
	else
		root["Vizabi"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 479);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var global    = __webpack_require__(4)
  , core      = __webpack_require__(36)
  , hide      = __webpack_require__(18)
  , redefine  = __webpack_require__(19)
  , ctx       = __webpack_require__(37)
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})
    , key, own, out, exp;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if(target)redefine(target, key, out, type & $export.U);
    // export
    if(exports[key] != out)hide(exports, key, exp);
    if(IS_PROTO && expProto[key] != out)expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isMobileOrTablet = exports.capitalize = exports.setIcon = exports.pruneTree = exports.isTouchDevice = exports.debounce = exports.memoize = exports.post = exports.get = exports.ajax = exports.interpolatePoint = exports.interpolateVector = exports.nestArrayToObj = exports.hashCode = exports.clearDelay = exports.delay = exports.defer = exports.diffObject = exports.arrayLast = exports.arrayMedian = exports.arraySum = exports.arrayMean = exports.arrayMax = exports.arrayMin = exports.values = exports.keys = exports.throttle = exports.hasClass = exports.classed = exports.removeClass = exports.addClass = exports.countDecimals = exports.error = exports.groupEnd = exports.groupCollapsed = exports.warn = exports.timeStamp = exports.areaToRadius = exports.radiusToArea = exports.mapRows = exports.preventAncestorScrolling = exports.matchAny = exports.filterAny = exports.filter = exports.find = exports.uniqueLast = exports.unique = exports.without = exports.deepClone = exports.clone = exports.merge = exports.deepExtend = exports.extend = exports.forEach = exports.strToFloat = exports.roundStep = exports.findScrollableAncestor = exports.getViewportPosition = exports.comparePlainObjects = exports.arrayEquals = exports.isPlainObject = exports.isNumber = exports.isEmpty = exports.isNaN = exports.isString = exports.isDate = exports.isObject = exports.isArray = exports.isElement = exports.uniqueId = exports.approxEqual = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.makeAbsoluteContext = makeAbsoluteContext;
exports.firstBy = firstBy;
exports.transform = transform;

var _interpolators = __webpack_require__(472);

var _interpolators2 = _interopRequireDefault(_interpolators);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * Check if value A is in +- proximity of value B
 * @param {Number} a
 * @param {Number} b
 * @param {Number} tolerance
 * @returns {Boolean} true if values are approximately equal or false otherwise
 */
var approxEqual = exports.approxEqual = function approxEqual(a, b, tolerance) {
  tolerance = tolerance || 0;
  if (b > 0) {
    return (1 - tolerance) * b <= a && a <= b * (1 + tolerance);
  } else if (b < 0) {
    return (1 + tolerance) * b <= a && a <= b * (1 - tolerance);
  }
  return Math.abs(a) <= tolerance;
};

/*
 * returns unique id with optional prefix
 * @param {String} prefix
 * @returns {String} id
 */
var uniqueId = exports.uniqueId = function () {
  var id = 0;
  return function (p) {
    return p ? p + (id += 1) : id += 1;
  };
}();

/*
 * checks whether obj is a DOM element
 * @param {Object} obj
 * @returns {Boolean}
 * from underscore: https://github.com/jashkenas/underscore/blob/master/underscore.js
 */
var isElement = exports.isElement = function isElement(obj) {
  return !!(obj && obj.nodeType === 1);
};

/*
 * checks whether obj is an Array
 * @param {Object} obj
 * @returns {Boolean}
 * from underscore: https://github.com/jashkenas/underscore/blob/master/underscore.js
 */
var isArray = exports.isArray = Array.isArray || function (obj) {
  return toString.call(obj) === "[object Array]";
};

/*
 * checks whether obj is an object
 * @param {Object} obj
 * @returns {Boolean}
 * from underscore: https://github.com/jashkenas/underscore/blob/master/underscore.js
 */
var isObject = exports.isObject = function isObject(obj) {
  var type = typeof obj === "undefined" ? "undefined" : _typeof(obj);
  return type === "object" && !!obj;
};

/*
 * checks whether arg is a date
 * @param {Object} arg
 * @returns {Boolean}
 */
var isDate = exports.isDate = function isDate(arg) {
  return arg instanceof Date;
};

/*
 * checks whether arg is a string
 * @param {Object} arg
 * @returns {Boolean}
 */
var isString = exports.isString = function isString(arg) {
  return typeof arg === "string";
};

/*
 * checks whether arg is a NaN
 * @param {*} arg
 * @returns {Boolean}
 * from lodash: https://github.com/lodash/lodash/blob/master/lodash.js
 */
var isNaN = exports.isNaN = function isNaN(arg) {
  // A `NaN` primitive is the only number that is not equal to itself
  return isNumber(arg) && arg !== +arg;
};

var isEmpty = exports.isEmpty = function isEmpty(obj) {
  return Object.keys(obj).length === 0 && obj.constructor === Object;
};

/*
 * checks whether arg is a number. NaN is a number too
 * @param {*} arg
 * @returns {Boolean}
 * from lodash: https://github.com/lodash/lodash/blob/master/lodash.js
 * dependencies are resolved and included here
 */
var isNumber = exports.isNumber = function isNumber(arg) {
  return typeof arg === "number" || !!arg && (typeof arg === "undefined" ? "undefined" : _typeof(arg)) === "object" && Object.prototype.toString.call(arg) === "[object Number]";
};

/*
 * checks whether obj is a plain object {}
 * @param {Object} obj
 * @returns {Boolean}
 */
var isPlainObject = exports.isPlainObject = function isPlainObject(obj) {
  return obj !== null && Object.prototype.toString.call(obj) === "[object Object]";
};

/*
 * checks whether two arrays are equal
 * @param {Array} a
 * @param {Array} b
 * @returns {Boolean}
 */
var arrayEquals = exports.arrayEquals = function arrayEquals(a, b) {
  if (a === b) return true;
  if (a == null || b == null) return false;
  if (a.length != b.length) return false;
  for (var i = 0; i < a.length; ++i) {
    if (a[i] !== b[i]) return false;
  }
  return true;
};

/**
 * Object Comparison
 *
 * http://stamat.wordpress.com/2013/06/22/javascript-object-comparison/
 *
 * No version
 *
 * @param a
 * @param b
 * @returns {boolean} if objects are equal
 */
var comparePlainObjects = exports.comparePlainObjects = function comparePlainObjects(a, b) {

  //Returns the object's class, Array, Date, RegExp, Object are of interest to us
  var getClass = function getClass(val) {
    return Object.prototype.toString.call(val).match(/^\[object\s(.*)\]$/)[1];
  };

  //Defines the type of the value, extended typeof
  var whatis = function whatis(val) {

    if (val === undefined) {
      return "undefined";
    }
    if (val === null) {
      return "null";
    }

    var type = typeof val === "undefined" ? "undefined" : _typeof(val);

    if (type === "object") {
      type = getClass(val).toLowerCase();
    }

    if (type === "number") {
      return val.toString().indexOf(".") > 0 ? "float" : "integer";
    }

    return type;
  };

  var compare = function compare(a, b) {
    if (a === b) {
      return true;
    }
    for (var i in a) {
      if (b.hasOwnProperty(i)) {
        if (!equal(a[i], b[i])) {
          return false;
        }
      } else {
        return false;
      }
    }

    for (var _i in b) {
      if (!a.hasOwnProperty(_i)) {
        return false;
      }
    }
    return true;
  };

  var compareArrays = function compareArrays(a, b) {
    if (a === b) {
      return true;
    }
    if (a.length !== b.length) {
      return false;
    }
    for (var i = 0; i < a.length; i++) {
      if (!equal(a[i], b[i])) {
        return false;
      }
    }
    return true;
  };

  var _equal = {};
  _equal.array = compareArrays;
  _equal.object = compare;
  _equal.date = function (a, b) {
    return a.getTime() === b.getTime();
  };
  _equal.regexp = function (a, b) {
    return a.toString() === b.toString();
  };

  /**
   * Are two values equal, deep compare for objects and arrays.
   * @param a {any}
   * @param b {any}
   * @return {boolean} Are equal?
   */
  var equal = function equal(a, b) {
    if (a !== b) {
      var atype = whatis(a);
      var btype = whatis(b);

      if (atype === btype) {
        return _equal.hasOwnProperty(atype) ? _equal[atype](a, b) : a == b;
      }

      return false;
    }

    return true;
  };

  return compare(a, b);
};

var getViewportPosition = exports.getViewportPosition = function getViewportPosition(element) {
  var xPosition = 0;
  var yPosition = 0;

  while (element) {
    xPosition += element.offsetLeft - element.scrollLeft + element.clientLeft;
    yPosition += element.offsetTop - element.scrollTop + element.clientTop;
    element = element.offsetParent;
  }

  return {
    x: xPosition,
    y: yPosition
  };
};

var findScrollableAncestor = exports.findScrollableAncestor = function findScrollableAncestor(node) {
  var scrollable = ["scroll", "auto"];
  while (node = node.parentNode) {
    var scrollHeight = node.scrollHeight;
    var height = node.clientHeight;
    if (scrollHeight > height && scrollable.indexOf(d3.select(node).style("overflow")) !== -1) {
      return node;
    }
  }
  return null;
};

var roundStep = exports.roundStep = function roundStep(number, step) {
  return Math.round(number / step) * step;
};

/*
 * transforms a string into a validated fload value
 * @param {string} string to be transformed
 */
var strToFloat = exports.strToFloat = function strToFloat(string) {
  return +string.replace(/[^\d.-]/g, "");
};

/*
 * loops through an object or array
 * @param {Object|Array} obj object or array
 * @param {Function} callback callback function
 * @param {Object} ctx context object
 */
var forEach = exports.forEach = function forEach(obj, callback, ctx) {
  if (!obj) {
    return;
  }
  var i = void 0,
      size = void 0;
  if (isArray(obj)) {
    size = obj.length;
    for (i = 0; i < size; i += 1) {
      if (callback.apply(ctx, [obj[i], i]) === false) {
        break;
      }
    }
  } else {
    var _keys = Object.keys(obj);
    size = _keys.length;
    for (i = 0; i < size; i += 1) {
      if (callback.apply(ctx, [obj[_keys[i]], _keys[i]]) === false) {
        break;
      }
    }
  }
};

/*
 * extends an object
 * @param {Object} destination object
 * @returns {Object} extented object
 */
var extend = exports.extend = function extend(dest) {
  //objects to overwrite dest are next arguments
  var objs = Array.prototype.slice.call(arguments, 1);
  //loop through each obj and each argument, left to right
  forEach(objs, function (obj, i) {
    forEach(obj, function (value, k) {
      if (obj.hasOwnProperty(k)) {
        dest[k] = value;
      }
    });
  });
  return dest;
};

// Deep extend and helper functions
// https://github.com/unclechu/node-deep-extend/blob/master/lib/deep-extend.js

function isSpecificValue(val) {
  return Boolean(val instanceof Date || val instanceof RegExp);
}

function cloneSpecificValue(val) {
  if (val instanceof Date) {
    return new Date(val.getTime());
  } else if (val instanceof RegExp) {
    return new RegExp(val);
  }
  throw new Error("Unexpected situation");
}

/**
 * Recursive cloning array.
 */
function deepCloneArray(arr) {
  var clone = [];
  forEach(arr, function (item, index) {
    if ((typeof item === "undefined" ? "undefined" : _typeof(item)) === "object" && item !== null) {
      if (isArray(item)) {
        clone[index] = deepCloneArray(item);
      } else if (isSpecificValue(item)) {
        clone[index] = cloneSpecificValue(item);
      } else {
        clone[index] = deepExtend({}, item);
      }
    } else {
      clone[index] = item;
    }
  });
  return clone;
}

/**
 * Extening object that entered in first argument.
 *
 * Returns extended object or false if have no target object or incorrect type.
 *
 * If you wish to clone source object (without modify it), just use empty new
 * object as first argument, like this:
 *   deepExtend({}, yourObj_1, [yourObj_N]);
 */
var deepExtend = exports.deepExtend = function deepExtend() /*obj_1, [obj_2], [obj_N]*/{
  if (arguments.length < 1 || _typeof(arguments[0]) !== "object") {
    return false;
  }

  if (arguments.length < 2) {
    return arguments[0];
  }

  var target = arguments[0];

  // convert arguments to array and cut off target object
  var args = Array.prototype.slice.call(arguments, 1);

  var val = void 0,
      src = void 0,
      clone = void 0;

  forEach(args, function (obj) {
    // skip argument if it is array or isn't object
    if ((typeof obj === "undefined" ? "undefined" : _typeof(obj)) !== "object" || isArray(obj)) {
      return;
    }

    forEach(Object.keys(obj), function (key) {
      src = target[key]; // source value
      val = obj[key]; // new value

      // recursion prevention
      if (val === target) {
        /*
         * if new value isn't object then just overwrite by new value
         * instead of extending.
         * 2016-11-07 / Jasper: Added specific check for val instanceof Model for merging defaults & values of ComponentModels
         * 2016-11-07 / Jasper: Hack because importing Model doesn't work: instead check for val._data
         */
      } else if ((typeof val === "undefined" ? "undefined" : _typeof(val)) !== "object" || val === null || val._data) {
        target[key] = val;

        // just clone arrays (and recursive clone objects inside)
      } else if (isArray(val)) {
        target[key] = deepCloneArray(val);

        // custom cloning and overwrite for specific objects
      } else if (isSpecificValue(val)) {
        target[key] = cloneSpecificValue(val);

        // overwrite by new value if source isn't object or array
      } else if ((typeof src === "undefined" ? "undefined" : _typeof(src)) !== "object" || src === null || isArray(src)) {
        target[key] = deepExtend({}, val);

        // source value and new value is objects both, extending...
      } else {
        target[key] = deepExtend(src, val);
      }
    });
  });

  return target;
};

/*
 * merges objects instead of replacing
 * @param {Object} destination object
 * @returns {Object} merged object
 */
var merge = exports.merge = function merge(dest) {

  // objects to overwrite dest are next arguments
  var objs = Array.prototype.slice.call(arguments, 1);

  // loop through each obj and each argument, left to right
  forEach(objs, function (obj, i) {
    forEach(obj, function (value, k) {
      if (obj.hasOwnProperty(k)) {
        if (dest.hasOwnProperty(k)) {
          if (!isArray(dest[k])) {
            dest[k] = [dest[k]];
          }
          dest[k].push(value);
        } else {
          dest[k] = value;
        }
      }
    });
  });
  return dest;
};

/*
 * clones an object (shallow copy)
 * @param {Object} src original object
 * @param {Array} arr filter keys
 * @returns {Object} cloned object
 */
var clone = exports.clone = function clone(src, arr, exclude) {
  if (isArray(src)) {
    return src.slice(0);
  }
  var clone = {};
  forEach(src, function (value, k) {
    if (arr && arr.indexOf(k) === -1 || exclude && exclude.indexOf(k) !== -1) {
      return;
    }
    if (src.hasOwnProperty(k)) {
      clone[k] = value;
    }
  });
  return clone;
};

/*
 * deep clones an object (deep copy)
 * @param {Object} src original object
 * @returns {Object} cloned object
 */
var deepClone = exports.deepClone = function deepClone(src) {
  var clone = {};
  if (isArray(src)) clone = [];

  forEach(src, function (value, k) {
    if (isObject(value) || isArray(value)) {
      clone[k] = deepClone(value);
    } else {
      clone[k] = value;
    }
  });
  return clone;
};

/*
 * Prints message to timestamp
 * @param {Arr} arr
 * @param {Object} el
 */
var without = exports.without = function without(arr, el) {
  var idx = arr.indexOf(el);
  if (idx !== -1) {
    arr.splice(idx, 1);
  }
  return arr;
};

/*
 * unique items in an array
 * @param {Array} arr original array
 * @param {Function} func optional evaluation function
 * @returns {Array} unique items
 * Based on:
 * http://stackoverflow.com/questions/1960473/unique-values-in-an-array
 */
var unique = exports.unique = function unique(arr, func) {
  var u = {};
  var a = [];
  if (!func) {
    func = function func(d) {
      return d;
    };
  }
  for (var i = 0, l = arr.length; i < l; i += 1) {
    var key = func(arr[i]);
    if (u.hasOwnProperty(key)) {
      continue;
    }
    a.push(arr[i]);
    u[key] = 1;
  }
  return a;
};

/*
 * unique items in an array keeping the last item
 * @param {Array} arr original array
 * @param {Function} func optional evaluation function
 * @returns {Array} unique items
 * Based on the previous method
 */
var uniqueLast = exports.uniqueLast = function uniqueLast(arr, func) {
  var u = {};
  var a = [];
  if (!func) {
    func = function func(d) {
      return d;
    };
  }
  for (var i = 0, l = arr.length; i < l; i += 1) {
    var key = func(arr[i]);
    if (u.hasOwnProperty(key)) {
      a.splice(u[key], 1); //remove old item from array
    }
    a.push(arr[i]);
    u[key] = a.length - 1;
  }
  return a;
};

/*
 * returns first value that passes the test
 * @param {Array} arr original collection
 * @returns {Function} func test function
 */
var find = exports.find = function find(arr, func) {
  var found = void 0;
  forEach(arr, function (i) {
    if (func(i)) {
      found = i;
      return false; //break
    }
  });
  return found;
};

/*
 * filters an array based on object properties
 * @param {Array} arr original array
 * @returns {Object} filter properties to use as filter
 */
var filter = exports.filter = function filter(arr, _filter) {
  var index = -1;
  var length = arr.length;
  var resIndex = -1;
  var result = [];
  var keys = Object.keys(_filter);
  var s_keys = keys.length;
  var i = void 0;
  var f = void 0;
  while ((index += 1) < length) {
    var value = arr[index];
    var match = true;
    for (i = 0; i < s_keys; i += 1) {
      f = keys[i];
      if (!value.hasOwnProperty(f) || value[f] !== _filter[f]) {
        match = false;
        break;
      }
    }
    if (match) {
      result[resIndex += 1] = value;
    }
  }
  return result;
};

/*
 * filters an array based on object properties.
 * Properties may be arrays determining possible values
 * @param {Array} arr original array
 * @returns {Object} filter properties to use as filter
 */
var filterAny = exports.filterAny = function filterAny(arr, filter, wildcard) {
  var index = -1;
  var length = arr.length;
  var resIndex = -1;
  var result = [];
  var keys = Object.keys(filter);
  var s_keys = keys.length;
  var i = void 0,
      f = void 0;
  while ((index += 1) < length) {
    var value = arr[index];
    //normalize to array
    var match = true;
    for (i = 0; i < s_keys; i += 1) {
      f = keys[i];
      if (!value.hasOwnProperty(f) || !matchAny(value[f], filter[f], wildcard)) {
        match = false;
        break;
      }
    }
    if (match) {
      result[resIndex += 1] = value;
    }
  }
  return result;
};

/*
 * checks if the value matches the comparison value or any in array
 * compare may be an determining possible values
 * @param value original value
 * @param compare value or array
 * @param {String} wildc wildcard value
 * @returns {Boolean} try
 */
var matchAny = exports.matchAny = function matchAny(values, compare, wildc) {
  //normalize value
  if (!isArray(values)) values = [values];
  if (!wildc) wildc = "*"; //star by default
  var match = false;
  for (var e = 0; e < values.length; e++) {
    var value = values[e];

    if (!isArray(compare) && value == compare) {
      match = true;
      break;
    } else if (isArray(compare)) {
      var found = -1;
      for (var i = 0; i < compare.length; i++) {
        var c = compare[i];
        if (!isArray(c) && (c == value || c === wildc)) {
          found = i;
          break;
        } else if (isArray(c)) {
          //range
          var min = c[0];
          var max = c[1] || min;
          if (value >= min && value <= max) {
            found = i;
            break;
          }
        }
      }
      if (found !== -1) {
        match = true;
        break;
      }
    }
  }
  return match;
};

/**
 * prevent scrolling parent scrollable elements for 2 second when element scrolled to end
 * @param node
 */

var preventAncestorScrolling = exports.preventAncestorScrolling = function preventAncestorScrolling(element) {
  var preventScrolling = false;
  element.on("mousewheel", function (d, i) {
    var scrollTop = this.scrollTop;
    var scrollHeight = this.scrollHeight;
    var height = element.node().offsetHeight;
    var delta = d3.event.wheelDelta;
    var up = delta > 0;
    var prevent = function prevent() {
      d3.event.stopPropagation();
      d3.event.preventDefault();
      d3.event.returnValue = false;
      return false;
    };

    var scrollTopTween = function scrollTopTween(scrollTop) {
      return function () {
        var _this = this;
        var i = d3.interpolateNumber(this.scrollTop, scrollTop);
        return function (t) {
          _this.scrollTop = i(t);
        };
      };
    };
    if (!up) {
      // Scrolling down
      if (-delta > scrollHeight - height - scrollTop && scrollHeight != height + scrollTop) {
        element.transition().delay(0).duration(0).tween("scrolltween", scrollTopTween(scrollHeight));
        //freeze scrolling on 2 seconds on bottom position
        preventScrolling = true;
        setTimeout(function () {
          preventScrolling = false;
        }, 2000);
      } else if (scrollTop == 0) {
        //unfreeze when direction changed
        preventScrolling = false;
      }
    } else if (up) {
      // Scrolling up
      if (delta > scrollTop && scrollTop > 0) {
        //
        //freeze scrolling on 2 seconds on top position
        element.transition().delay(0).duration(0).tween("scrolltween", scrollTopTween(0));
        preventScrolling = true;
        setTimeout(function () {
          preventScrolling = false;
        }, 2000);
      } else if (scrollHeight == height + scrollTop) {
        //unfreeze when direction changed
        preventScrolling = false;
      }
    }
    if (preventScrolling) {
      return prevent();
    }
  });
};

/*
 * maps all rows according to the formatters
 * @param {Array} original original dataset
 * @param {Object} formatters formatters object
 * @returns {Boolean} try
 */
var mapRows = exports.mapRows = function mapRows(original, formatters) {

  function mapRow(value, fmt) {
    if (!isArray(value)) {
      return fmt(value);
    }

    var res = [];
    for (var i = 0; i < value.length; i++) {
      res[i] = mapRow(value[i], fmt);
    }
    return res;
  }

  // default formatter turns empty strings in null and converts numeric values into number
  //TODO: default formatter is moved to utils. need to return it to hook prototype class, but retest #1212 #1230 #1253
  var defaultFormatter = function defaultFormatter(val) {
    var newVal = val;
    if (val === "") {
      newVal = null;
    } else {
      // check for numeric
      var numericVal = parseFloat(val);
      if (!isNaN(numericVal) && isFinite(val)) {
        newVal = numericVal;
      }
    }
    return newVal;
  };

  original = original.map(function (row) {
    var columns = Object.keys(row);

    for (var i = 0; i < columns.length; i++) {
      var col = columns[i];
      row[col] = mapRow(row[col], formatters[col] || defaultFormatter);
    }
    return row;
  });

  return original;
};

/*
 * Converts radius to area, simple math
 * @param {Number} radius
 * @returns {Number} area
 */
var radiusToArea = exports.radiusToArea = function radiusToArea(r) {
  return r * r * Math.PI;
};

/*
 * Converts area to radius, simple math
 * @param {Number} area
 * @returns {Number} radius
 */
var areaToRadius = exports.areaToRadius = function areaToRadius(a) {
  return Math.sqrt(a / Math.PI);
};

/*
 * Prints message to timestamp
 * @param {String} message
 */
var timeStamp = exports.timeStamp = function timeStamp(message) {
  if (console && typeof console.timeStamp === "function") {
    console.timeStamp(message);
  }
};

/*
 * Prints warning
 * @param {String} message
 */
var warn = exports.warn = function warn(message) {
  message = Array.prototype.slice.call(arguments).map(function (m) {
    return m instanceof Object ? JSON.stringify(m, null, 4) : m;
  }).join(" ");
  if (console && typeof console.warn === "function") {

    console.warn(message);
  }
  // "return true" is needed to find out if a parent function is exited with warning
  // example:
  // myfunction = function() { if(brokenstuff) return utils.warn("broken stuff found") }
  // if(myfunction()) return; // stopped execution after myfunction finds broken stuff
  // ... or moving on
  return true;
};

/*
 * Prints message for group
 * @param {String} message
 */
var groupCollapsed = exports.groupCollapsed = function groupCollapsed(message) {
  message = Array.prototype.slice.call(arguments).join(" ");
  if (console && typeof console.groupCollapsed === "function") {
    console.groupCollapsed(message);
  }
};

/*
 * Prints end of group
 * @param {String} message
 */
var groupEnd = exports.groupEnd = function groupEnd() {
  if (console && typeof console.groupEnd === "function") {
    console.groupEnd();
  }
};

/*
 * Prints error
 * @param {String} message
 */
var error = exports.error = function error(err) {
  if (console && typeof console.error === "function") {
    if (err.stack) {
      console.error(err.stack);
    } else {
      console.error(err);
    }
    if (arguments.length > 1) {
      console.error.apply(this, Array.prototype.slice.call(arguments, 1));
    }
  }
};

/*
 * Count the number of decimal numbers
 * @param {Number} number
 */
var countDecimals = exports.countDecimals = function countDecimals(number) {
  if (Math.floor(number.valueOf()) === number.valueOf()) {
    return 0;
  }
  return number.toString().split(".")[1].length || 0;
};

/*
 * Adds class to DOM element
 * @param {Element} el
 * @param {String} className
 */
var addClass = exports.addClass = function addClass(el, className) {
  if (el.classList) {
    el.classList.add(className);
  } else {
    //IE<10
    el.className += " " + className;
  }
};

/*
 * Remove class from DOM element
 * @param {Element} el
 * @param {String} className
 */
var removeClass = exports.removeClass = function removeClass(el, className) {
  if (el.classList) {
    el.classList.remove(className);
  } else {
    //IE<10
    el.className = el.className.replace(new RegExp("(^|\\b)" + className.split(" ").join("|") + "(\\b|$)", "gi"), " ");
  }
};

/*
 * Adds or removes class depending on value
 * @param {Element} el
 * @param {String} className
 * @param {Boolean} value
 */
var classed = exports.classed = function classed(el, className, value) {
  if (value === true) {
    addClass(el, className);
  } else if (value === false) {
    removeClass(el, className);
  } else {
    return hasClass(el, className);
  }
};

/*
 * Checks whether a DOM element has a class or not
 * @param {Element} el
 * @param {String} className
 * @return {Boolean}
 */
var hasClass = exports.hasClass = function hasClass(el, className) {
  return el.classList ? el.classList.contains(className) : new RegExp("(^| )" + className + "( |$)", "gi").test(el.className);
};

/*
 * Throttles a function
 * @param {Function} func
 * @param {Number} ms duration
 * @return {Function}
 * Function recallLast was added to prototype of returned function.
 * Call Function.recallLast() - immediate recall func with last saved arguments,
 *                              else func will be called automaticly after ms duration
 */
var throttle = exports.throttle = function throttle(func, ms) {

  var throttled = false;
  var savedArgs = void 0;
  var savedThis = void 0;
  var nextTime = void 0;

  var __recallLast = function __recallLast() {
    if (throttled) {
      throttled = false;
      func.apply(savedThis, savedArgs);
    }
  };

  var wrapper = function wrapper() {

    if (nextTime > Date.now()) {
      throttled = true;
      savedArgs = arguments;
      savedThis = this;
      return;
    }

    nextTime = Date.now() + ms;
    throttled = false;

    func.apply(this, arguments);

    setTimeout(function () {
      __recallLast();
    }, ms);
  };

  wrapper.recallLast = __recallLast;

  return wrapper;
};

/*
 * Returns keys of an object as array
 * @param {Object} arg
 * @returns {Array} keys
 */
var keys = exports.keys = function keys(arg) {
  return Object.keys(arg);
};

/*
 * returns the values of an object in an array format
 * @param {Object} obj
 * @return {Array}
 */
var values = exports.values = function values(obj) {
  var arr = [];
  var keys = Object.keys(obj);
  var size = keys.length;
  for (var i = 0; i < size; i += 1) {
    arr.push(obj[keys[i]]);
  }
  return arr;
};

/*
 * Computes the minumum value in an array
 * @param {Array} arr
 */
var arrayMin = exports.arrayMin = function arrayMin(arr) {
  return arr.reduce(function (p, v) {
    return p < v ? p : v;
  });
};

/*
 * Computes the minumum value in an array
 * @param {Array} arr
 */
var arrayMax = exports.arrayMax = function arrayMax(arr) {
  return arr.reduce(function (p, v) {
    return p > v ? p : v;
  });
};

/*
 * Computes the mean of an array
 * @param {Array} arr
 */
var arrayMean = exports.arrayMean = function arrayMean(arr) {
  return arraySum(arr) / arr.length;
};

/*
 * Computes the sum of an array
 * @param {Array} arr
 */
var arraySum = exports.arraySum = function arraySum(arr) {
  return arr.reduce(function (a, b) {
    return a + b;
  });
};

/*
 * Computes the median of an array
 * @param {Array} arr
 */
var arrayMedian = exports.arrayMedian = function arrayMedian(arr) {
  arr = arr.sort(function (a, b) {
    return a - b;
  });
  var middle = Math.floor((arr.length - 1) / 2);

  return arr.length % 2 ? arr[middle] : (arr[middle] + arr[middle + 1]) / 2;
};

/*
 * Returns the last value of array
 * @param {Array} arr
 */
var arrayLast = exports.arrayLast = function arrayLast(arr) {
  if (!arr.length) return null;
  return arr[arr.length - 1];
};

/*
 * Returns the resulting object of the difference between two objects
 * @param {Object} obj2
 * @param {Object} obj1
 * @returns {Object}
 */
var diffObject = exports.diffObject = function diffObject(obj2, obj1) {
  var diff = {};
  forEach(obj2, function (value, key) {
    if (!obj1.hasOwnProperty(key)) {
      diff[key] = value;
    } else if (value !== obj1[key]) {
      if (isPlainObject(value) && isPlainObject(obj1[key])) {
        var d = diffObject(value, obj1[key]);
        if (Object.keys(d).length > 0) {
          diff[key] = d;
        }
      } else if (!isArray(value) || !isArray(obj1[key]) || !arrayEquals(value, obj1[key])) {
        diff[key] = value;
      }
    }
  });
  return diff;
};

/*
 * Defers a function
 * @param {Function} func
 */
var defer = exports.defer = function defer(func) {
  setTimeout(func, 1);
};

/*
 * Defers a function
 * @param {Function} func
 */
var delay = exports.delay = function delay(_delay) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, _delay);
  });
};

var clearDelay = exports.clearDelay = function clearDelay(delayId) {
  return clearTimeout(delayId);
};

/*
 * Creates a hashcode for a string or array
 * @param {String|Array} str
 * @return {Number} hashCode
 */
var hashCode = exports.hashCode = function hashCode(str) {
  if (!isString(str)) {
    str = JSON.stringify(str);
  }
  var hash = 0;
  var size = str.length;
  var c = void 0;
  if (size === 0) {
    return hash;
  }
  for (var i = 0; i < size; i += 1) {
    c = str.charCodeAt(i);
    hash = (hash << 5) - hash + c;
    hash &= hash; // Convert to 32bit integer
  }
  return hash.toString();
};

/*
 * Converts D3 nest array into the object with key-value pairs, recursively
 * @param {Array} arr - array like this [{key: k, values: [a, b, ...]}, {...} ... {...}]
 * @return {Object} object like this {k: [a, b, ...], ...}
 */
//
var nestArrayToObj = exports.nestArrayToObj = function nestArrayToObj(arr) {
  if (!arr || !arr.length || !arr[0].key) return arr;
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    res[arr[i].key] = nestArrayToObj(arr[i].values);
  }
  return res;
};

var interpolateVector = exports.interpolateVector = function interpolateVector() {};

/**
 * interpolates the specific value
 * @param {Array} items -- an array of items, sorted by "dimTime", filtered so that no item[which] is null
 * @param {String} use -- a use of hook that wants to interpolate. can be "indicator" or "property" or "constant"
 * @param {String} which -- a hook pointer to indicator or property, e.g. "lex"
 * @param {Number} next -- an index of next item in "items" array after the value to be interpolated. if omitted, then calculated here, but it's expensive
 * @param {String} dimTime -- a pointer to time dimension, usually "time"
 * @param {Date} time -- reference point for interpolation. here the valus is to be found
 * @param {String} method refers to which formula to use. "linear" or "exp". Falls back to "linear" if undefined
 * @param {Boolean} extrapolate indicates if we should use zero-order extrapolation outside the range of available data
 * @returns {Number} interpolated value
 */
var interpolatePoint = exports.interpolatePoint = function interpolatePoint(items, use, which, next, dimTime, time, method, extrapolate) {

  if (!items || items.length === 0) {
    warn("interpolatePoint failed because incoming array is empty. It was " + which);
    return null;
  }
  // return constant for the use of "constant"
  if (use === "constant") return which;

  // zero-order interpolation for the use of properties
  if (use === "property") return items[0][which];

  // the rest is for the continuous measurements

  if (extrapolate) {
    // check if the desired value is out of range. 0-order extrapolation
    if (time - items[0][dimTime] <= 0) return items[0][which];
    if (time - items[items.length - 1][dimTime] >= 0) return items[items.length - 1][which];
  } else {
    // no extrapolation according to Ola's request
    if (time < items[0][dimTime] || time > items[items.length - 1][dimTime]) return null;
  }

  if (!next && next !== 0) next = d3.bisectLeft(items.map(function (m) {
    return m[dimTime];
  }), time);

  if (next === 0) return items[0][which];

  //return null if data is missing
  if (items[next] === undefined || items[next][which] === null || items[next - 1][which] === null || items[next][which] === "") {
    warn("interpolatePoint failed because next/previous points are bad in " + which);
    return null;
  }

  //do the math to calculate a value between the two points
  var result = _interpolators2.default[method || "linear"](items[next - 1][dimTime], items[next][dimTime], items[next - 1][which], items[next][which], time);

  // cast to time object if we are interpolating time
  if (which === dimTime) result = new Date(result);
  if (isNaN(result)) {
    warn("interpolatePoint failed because result is NaN. It was " + which);
    result = null;
  }

  return result;
};

/*
 * Performs an ajax request
 * @param {Object} options
 * @param {String} className
 * @return {Boolean}
 */
var ajax = exports.ajax = function ajax(options) {
  var request = new XMLHttpRequest();
  request.open(options.method, options.url, true);
  if (options.method === "POST" && !options.json) {
    request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8");
  } else if (options.method === "POST" && options.json) {
    request.setRequestHeader("Content-Type", "application/json; charset=UTF-8");
  }
  request.onload = function () {
    if (request.status >= 200 && request.status < 400) {
      // Success!
      var data = options.json ? JSON.parse(request.responseText) : request.responseText;
      if (options.success) {
        options.success(data);
      }
    } else {
      if (options.error) {
        options.error();
      }
    }
  };
  request.onerror = function () {
    if (options.error) {
      options.error();
    }
  };
  request.send(options.data);
};

/*
 * Performs a GET http request
 */
var get = exports.get = function get(url, pars, success, error, json) {
  pars = pars || [];
  forEach(pars, function (value, key) {
    pars.push(key + "=" + value);
  });
  url = pars.length ? url + "?" + pars.join("&") : url;
  ajax({
    method: "GET",
    url: url,
    success: success,
    error: error,
    json: json
  });
};

/*
 * Performs a POST http request
 */
var post = exports.post = function post(url, pars, success, error, json) {
  ajax({
    method: "POST",
    url: url,
    success: success,
    error: error,
    json: json,
    data: pars
  });
};

/**
 * Make function memoized
 * @param {Function} fn
 * @returns {Function}
 */
var memoize = exports.memoize = function memoize(fn) {
  return function () {
    var args = Array.prototype.slice.call(arguments);
    var hash = "";
    var i = args.length;
    var currentArg = null;

    while (i--) {
      currentArg = args[i];
      hash += currentArg === Object(currentArg) ? JSON.stringify(currentArg) : currentArg;
      fn.memoize || (fn.memoize = {});
    }

    return hash in fn.memoize ? fn.memoize[hash] : fn.memoize[hash] = fn.apply(this, args);
  };
};

// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds. If `immediate` is passed, trigger the function on the
// leading edge, instead of the trailing.
var debounce = exports.debounce = function debounce(func, wait, immediate) {
  var timeout = void 0;
  return function () {
    var context = this;
    var args = arguments;
    var later = function later() {
      timeout = null;
      if (!immediate) func.apply(context, args);
    };
    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) func.apply(context, args);
  };
};

var isTouchDevice = exports.isTouchDevice = function isTouchDevice() {
  //'ontouchstart' is not reliable in Google Chrome #2116, but Chrome has this firesTouchEvents flag
  if (((d3.event || {}).sourceCapabilities || {}).firesTouchEvents != null) {
    return d3.event.sourceCapabilities.firesTouchEvents;
  }
  return !!("ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch);
};

//return a pruneed tree
var pruneTree = exports.pruneTree = function pruneTree(tree, filterCallback) {
  var filteredTree = {};
  var filteredChildrens = [];
  if (tree.hasOwnProperty("children")) {
    filteredChildrens = tree.children.map(function (childrenTree) {
      return pruneTree(childrenTree, filterCallback);
    }).filter(function (childrenTree) {
      return Object.keys(childrenTree).length !== 0;
    });
  }
  if (filteredChildrens.length != 0 || filterCallback(tree)) {
    //copy all the properties to the new tree
    forEach(tree, function (value, key) {
      filteredTree[key] = value;
    });
  }
  if (filteredChildrens.length != 0) {
    filteredTree["children"] = filteredChildrens;
  }
  return filteredTree;
};

var setIcon = exports.setIcon = function setIcon(element, icon) {
  element.selectAll("*").remove();
  element.node().appendChild(element.node().ownerDocument.importNode(new DOMParser().parseFromString(icon, "application/xml").documentElement, true));
  return element;
};

//http://stackoverflow.com/questions/26049488/how-to-get-absolute-coordinates-of-object-inside-a-g-group
function makeAbsoluteContext(element, svgDocument) {
  return function (x, y) {
    var offset = svgDocument.getBoundingClientRect();
    var matrix = element.getScreenCTM();
    return {
      x: matrix.a * x + matrix.c * y + matrix.e - offset.left,
      y: matrix.b * x + matrix.d * y + matrix.f - offset.top
    };
  };
}

/***
 thenBy.js
 Copyright 2013 Teun Duynstee
 https://github.com/Teun/thenBy.js/blob/master/thenBy.module.js

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at
 http://www.apache.org/licenses/LICENSE-2.0
 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */
function firstBy() {

  function identity(v) {
    return v;
  }

  function ignoreCase(v) {
    return typeof v === "string" ? v.toLowerCase() : v;
  }

  function makeCompareFunction(f, opt) {
    opt = typeof opt === "number" ? { direction: opt } : opt || {};
    if (typeof f != "function") {
      var prop = f;
      // make unary function
      f = function f(v1) {
        return v1[prop] ? v1[prop] : "";
      };
    }
    if (f.length === 1) {
      // f is a unary function mapping a single item to its sort score
      var uf = f;
      var preprocess = opt.ignoreCase ? ignoreCase : identity;
      f = function f(v1, v2) {
        return preprocess(uf(v1)) < preprocess(uf(v2)) ? -1 : preprocess(uf(v1)) > preprocess(uf(v2)) ? 1 : 0;
      };
    }
    if (opt.direction === -1) return function (v1, v2) {
      return -f(v1, v2);
    };
    return f;
  }

  /* adds a secondary compare function to the target function (`this` context)
   which is applied in case the first one returns 0 (equal)
   returns a new compare function, which has a `thenBy` method as well */
  function tb(func, opt) {
    var x = typeof this == "function" ? this : false;
    var y = makeCompareFunction(func, opt);
    var f = x ? function (a, b) {
      return x(a, b) || y(a, b);
    } : y;
    f.thenBy = tb;
    return f;
  }

  return tb;
}

function transform(node) {
  var _node$transform$baseV = node.transform.baseVal.consolidate().matrix,
      a = _node$transform$baseV.a,
      b = _node$transform$baseV.b,
      c = _node$transform$baseV.c,
      d = _node$transform$baseV.d,
      e = _node$transform$baseV.e,
      f = _node$transform$baseV.f;


  return function (a, b, c, d, e, f) {
    var scaleX = void 0,
        scaleY = void 0,
        skewX = void 0;
    if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
    if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
    if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
    if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
    return {
      translateX: e,
      translateY: f,
      rotate: Math.atan2(b, a) * Math.PI / 180,
      skewX: Math.atan(skewX) * Math.PI / 180,
      scaleX: scaleX,
      scaleY: scaleY
    };
  }(a, b, c, d, e, f);
}

var capitalize = exports.capitalize = function capitalize(string) {
  return string.slice(0, 1).toUpperCase() + string.slice(1).toLowerCase();
};

// http://stackoverflow.com/questions/11381673/detecting-a-mobile-browser
var isMobileOrTablet = exports.isMobileOrTablet = function isMobileOrTablet() {
  var agent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : navigator.userAgent || navigator.vendor || window.opera;
  return (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(agent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(agent.substr(0, 4))
  );
};

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _events = __webpack_require__(46);

var _events2 = _interopRequireDefault(_events);

var _model = __webpack_require__(47);

var _model2 = _interopRequireDefault(_model);

var _globals = __webpack_require__(34);

var _globals2 = _interopRequireDefault(_globals);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var class_loading_first = "vzb-loading-first";
var class_loading_data = "vzb-loading-data";
var class_error = "vzb-error";

var templates = {};
var Component = _events2.default.extend({

  /**
   * Initializes the component
   * @param {Object} config Initial config, with name and placeholder
   * @param {Object} parent Reference to tool
   */
  init: function init(config, parent) {
    this._id = this._id || utils.uniqueId("c");
    this._ready = false;
    this._readyOnce = false;
    this.name = this.name || config.name || this._id;
    this.template = this.template || "<div></div>";
    this.placeholder = this.placeholder || config.placeholder;
    this.template_data = this.template_data || {
      name: this.name
    };
    //make sure placeholder is DOM element
    if (this.placeholder && !utils.isElement(this.placeholder)) {
      try {
        this.placeholder = parent.placeholder.querySelector(this.placeholder);
      } catch (e) {
        utils.error("Error finding placeholder '" + this.placeholder + "' for component '" + this.name + "'");
      }
    }
    this.parent = parent || null;
    this.root = this.parent ? this.parent.root : this;

    this.components = this.components || [];
    this._components_config = this.components.map(function (x) {
      return utils.clone(x);
    });

    //define expected models for this component
    this.model_expects = this.model_expects || [];
    this.model_binds = this.model_binds || {};
    this.createModel(config.model);

    this.ui = this.model.ui || this.ui || config.ui;
    this._super();

    this.registerListeners();
  },
  createModel: function createModel(configModel) {
    this.model = this._modelMapping(configModel);
  },
  registerListeners: function registerListeners() {
    this.on({
      "readyOnce": this.readyOnce,
      "ready": this.ready,
      "domReady": this.domReady,
      "resize": this.resize
    });
  },


  /**
   * Recursively starts preloading in components
   * @return {[type]} [description]
   */
  startPreload: function startPreload() {

    var promises = [];
    promises.push(this.preload());

    utils.forEach(this.components, function (subComponent) {
      return promises.push(subComponent.startPreload());
    });

    return Promise.all(promises);
  },
  preload: function preload() {
    return Promise.resolve();
  },


  /**
   * Executes after preloading is finished
   */
  afterPreload: function afterPreload() {
    if (this.model) {
      this.model.afterPreload();
    }
    utils.forEach(this.components, function (subcomp) {
      subcomp.afterPreload();
    });
  },


  /**
   * Renders the component (after data is ready)
   */
  render: function render() {
    var _this = this;
    this.loadTemplate();
    this.loadSubComponents();

    //render each subcomponent
    utils.forEach(this.components, function (subcomp) {
      subcomp.render();
      _this.on("resize", function () {
        subcomp.trigger("resize");
      });
    });

    this.startLoading();
  },


  /**
   * Overloaded by Tool which starts loading of model
   * @return {[type]} [description]
   */
  startLoading: function startLoading() {
    var _this = this;

    // if a componente's model is ready, the component is ready
    this.model.on("ready", function () {
      _this.loadingDone();
    });

    if (!(this.model && this.model.isLoading())) {
      this.loadingDone();
    }
  },
  loadingDone: function loadingDone() {
    utils.removeClass(this.placeholder, class_loading_first);
    utils.removeClass(this.placeholder, class_loading_data);
    this.setReady();
  },
  renderError: function renderError() {
    utils.removeClass(this.placeholder, class_loading_first);
    utils.removeClass(this.placeholder, class_loading_data);
    utils.addClass(this.placeholder, class_error);
    this.setError({
      type: "data"
    });
  },
  setError: function setError(opts) {
    if (typeof this.error === "function") {
      this.error(opts);
    }
  },
  setReady: function setReady(value) {
    if (!this._readyOnce) {
      this.trigger("readyOnce");
      this._readyOnce = true;
    }
    this._ready = true;
    this.trigger("ready");
  },


  /**
   * Loads the template
   * @returns defer a promise to be resolved when template is loaded
   */
  loadTemplate: function loadTemplate() {
    var tmpl = this.template;
    var data = this.template_data;
    var _this = this;
    var rendered = "";
    if (!this.placeholder) {
      return;
    }
    //todo: improve t function getter + generalize this
    data = utils.extend(data, {
      t: this.getTranslationFunction(true)
    });
    if (this.template) {
      try {
        rendered = templateFunc(tmpl, data);
      } catch (e) {
        utils.error("Templating error for component: '" + this.name + "' - Check if template name is unique and correct. E.g.: 'bubblechart'");

        utils.removeClass(this.placeholder, class_loading_data);
        utils.addClass(this.placeholder, class_error);
        this.setError({
          type: "template"
        });
      }
    }
    //add loading class and html
    utils.addClass(this.placeholder, class_loading_data);
    utils.addClass(this.placeholder, class_loading_first);
    this.placeholder.innerHTML = rendered;
    this.element = this.placeholder.children[0];

    //template is ready
    this.trigger("domReady");
  },
  getActiveProfile: function getActiveProfile(profiles, presentationProfileChanges) {
    // get layout values
    var layoutProfile = this.getLayoutProfile();
    var presentationMode = this.getPresentationMode();
    var activeProfile = utils.deepClone(profiles[layoutProfile]); // clone so it can be extended without changing the original profile

    // extend the profile with presentation mode values
    if (presentationMode && (presentationProfileChanges || {})[layoutProfile]) {
      utils.deepExtend(activeProfile, presentationProfileChanges[layoutProfile]);
    }

    return activeProfile;
  },


  /*
   * Loads all subcomponents
   */
  loadSubComponents: function loadSubComponents() {
    var _this = this;
    var config = void 0;
    var comp = void 0;
    //use the same name for collection
    this.components = [];

    // Loops through components, loading them.
    utils.forEach(this._components_config, function (component_config) {

      component_config.model = component_config.model || {};

      if (!component_config.component) {
        utils.error("Error loading component: name not provided");
        return;
      }

      comp = utils.isString(component_config.component) ? Component.get(component_config.component) : component_config.component;

      if (!comp) return;

      config = utils.extend(component_config, {
        name: component_config.component,
        ui: _this._uiMapping(component_config.placeholder, component_config.ui)
      });
      //instantiate new subcomponent
      var subcomp = new comp(config, _this);
      _this.components.push(subcomp);
    });
  },


  /**
   * Returns subcomponent by name
   * @returns {Boolean}
   */
  findChildByName: function findChildByName(name) {
    return utils.find(this.components, function (f) {
      return f.name === name;
    });
  },


  /**
   * Get layout profile of the current resolution
   * @returns {String} profile
   */
  getLayoutProfile: function getLayoutProfile() {
    // get profile from parent if layout is not available
    return this.model.ui ? this.model.ui.currentProfile() : this.parent.getLayoutProfile();
  },


  /**
   * Get if presentation mode is set of the current tool
   * @returns {Bool} presentation mode
   */
  getPresentationMode: function getPresentationMode() {
    // get profile from parent if layout is not available
    return this.model.ui ? this.model.ui.getPresentationMode() : this.parent.getPresentationMode();
  },


  //TODO: make ui mapping more powerful
  /**
   * Maps the current ui to the subcomponents
   * @param {String} id subcomponent id (placeholder)
   * @param {Object} ui Optional ui parameters to overwrite existing
   * @returns {Object} the UI object
   */
  _uiMapping: function _uiMapping(id, ui) {
    //if overwritting UI
    if (ui) {
      return new _model2.default("ui", ui);
    }
    if (id && this.ui) {
      id = id.replace(".", "");
      //remove trailing period
      var sub_ui = this.ui[id];
      if (sub_ui) {
        return sub_ui;
      }
    }
    return this.ui;
  },


  /**
   * Maps the current model to the subcomponents
   * @param {String|Array} model_config Configuration of model
   * @returns {Object} the model
   */
  _modelMapping: function _modelMapping(model_config) {
    var _this = this;
    var values = {};
    //If model_config is an array, we map it
    if (utils.isArray(model_config) && utils.isArray(this.model_expects)) {

      //if there's a different number of models received and expected
      if (this.model_expects.length !== model_config.length) {
        utils.groupCollapsed("DIFFERENCE IN NUMBER OF MODELS EXPECTED AND RECEIVED");
        utils.warn("Please, configure the 'model_expects' attribute accordingly in '" + this.name + "' or check the models passed in '" + _this.parent.name + "'.\n\n" + "Component: '" + _this.parent.name + "'\n" + "Subcomponent: '" + this.name + "'\n" + "Number of Models Expected: " + this.model_expects.length + "\nNumber of Models Received: " + model_config.length);
        utils.groupEnd();
      }
      utils.forEach(model_config, function (m, i) {
        var model_info = _mapOne(m);
        var new_name = void 0;
        if (_this.model_expects[i]) {
          new_name = _this.model_expects[i].name;
          if (_this.model_expects[i].type && model_info.type !== _this.model_expects[i].type && (!utils.isArray(_this.model_expects[i].type) || _this.model_expects[i].type.indexOf(model_info.type) === -1)) {

            utils.groupCollapsed("UNEXPECTED MODEL TYPE: '" + model_info.type + "' instead of '" + _this.model_expects[i].type + "'");
            utils.warn("Please, configure the 'model_expects' attribute accordingly in '" + _this.name + "' or check the models passed in '" + _this.parent.name + "'.\n\n" + "Component: '" + _this.parent.name + "'\n" + "Subcomponent: '" + _this.name + "'\n" + "Expected Model: '" + _this.model_expects[i].type + "'\n" + "Received Model: '" + model_info.type + "'\n" + "Model order: " + i);
            utils.groupEnd();
          }
        } else {

          utils.groupCollapsed("UNEXPECTED MODEL: '" + model_config[i] + "'");
          utils.warn("Please, configure the 'model_expects' attribute accordingly in '" + _this.name + "' or check the models passed in '" + _this.parent.name + "'.\n\n" + "Component: '" + _this.parent.name + "'\n" + "Subcomponent: '" + _this.name + "'\n" + "Number of Models Expected: " + _this.model_expects.length + "\n" + "Number of Models Received: " + model_config.length);
          utils.groupEnd();
          new_name = model_info.name;
        }
        values[new_name] = model_info.model;
      });

      // fill the models that weren't passed with empty objects
      // e.g. if expected = [ui, locale, color] and passed/existing = [ui, locale]
      // it will fill values up to [ui, locale, {}]
      var existing = model_config.length;
      var expected = this.model_expects.length;
      if (expected > existing) {
        //skip existing
        this.model_expects.splice(0, existing);
        //adds new expected models if needed
        utils.forEach(expected, function (m) {
          values[m.name] = {};
        });
      }
    } else {
      return;
    }
    //return a new model with the defined submodels
    return new _model2.default(this.name, values, null, this.model_binds);
    /**
     * Maps one model name to current submodel and returns info
     * @param {String} name Full model path. E.g.: "state.marker.color"
     * @returns {Object} the model info, with name and the actual model
     */
    function _mapOne(name) {
      var parts = name.split(".");
      var current = _this.parent.model;
      var current_name = "";
      while (parts.length) {
        current_name = parts.shift();
        current = current[current_name];
      }
      return {
        name: name,
        model: current,
        type: current ? current.getType() : null
      };
    }
  },


  /**
   * Get translation function for templates
   * @param {Boolean} wrap wrap in spam tags
   * @returns {Function}
   */
  getTranslationFunction: function getTranslationFunction(wrap) {
    var t_func = void 0;
    try {
      t_func = this.model.get("locale").getTFunction();
    } catch (err) {
      if (this.parent && this.parent !== this) {
        t_func = this.parent.getTranslationFunction();
      }
    }
    if (!t_func) {
      t_func = function t_func(s) {
        return s;
      };
    }

    return wrap ? this._translatedStringFunction(t_func) : t_func;
  },


  /**
   * Get function for translated string
   * @param {Function} translation_function The translation function
   * @returns {Function}
   */
  _translatedStringFunction: function _translatedStringFunction(translation_function) {
    return function (string) {
      var translated = translation_function(string);
      return '<span data-vzb-translate="' + string + '">' + translated + "</span>";
    };
  },


  /**
   * Translate all strings in the template
   */
  translateStrings: function translateStrings() {
    var t = this.getTranslationFunction();
    var strings = this.placeholder.querySelectorAll("[data-vzb-translate]");
    if (strings.length === 0) {
      return;
    }
    utils.forEach(strings, function (str) {
      if (!str || !str.getAttribute) {
        return;
      }
      str.innerHTML = t(str.getAttribute("data-vzb-translate"));
    });
  },


  /**
   * Executes after the template is loaded and rendered.
   * Ideally, it contains HTML instantiations related to template
   * At this point, this.element and this.placeholder are available
   * as DOM elements
   */
  readyOnce: function readyOnce() {},


  /**
   * Executes after the template and model (if any) are ready
   */
  ready: function ready() {},


  /**
   * Executes when the resize event is triggered.
   * Ideally, it only contains operations related to size
   */
  resize: function resize() {},


  /**
   * Executed after template is loaded
   * Ideally, it contains instantiations related to template
   */
  domReady: function domReady() {},


  /**
   * Clears a component
   */
  clear: function clear() {
    this.freeze();
    if (this.model) this.model.freeze();
    utils.forEach(this.components, function (c) {
      c.clear();
    });
  }
});

// Based on Simple JavaScript Templating by John Resig
//generic templating function
function templateFunc(str, data) {

  var func = function func(obj) {
    return str.replace(/<%=([^%]*)%>/g, function (match) {
      //match t("...")
      var s = match.match(/t\s*\(([^)]+)\)/g);
      //replace with translation
      if (s.length) {
        s = obj.t(s[0].match(/"([^"]+)"/g)[0].split('"').join(""));
      }
      //use object[name]
      else {
          s = match.match(/([a-z\-A-Z]+([a-z\-A-Z0-9]?[a-zA-Z0-9]?)?)/g)[0];
          s = obj[s] || s;
        }
      return s;
    });
  };
  // Figure out if we're getting a template, or if we need to
  // load the template - and be sure to cache the result.
  var fn = !/<[a-z][\s\S]*>/i.test(str) ? templates[str] = templates[str] || templateFunc(_globals2.default.templates[str]) : func;

  // Provide some basic currying to the user
  return data ? fn(data) : fn;
}

//utility function to check if a component is a component
//TODO: Move to utils?
Component.isComponent = function (c) {
  return c._id && (c._id[0] === "t" || c._id[0] === "c");
};

exports.default = Component;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(6);
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};

/***/ }),
/* 4 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var store      = __webpack_require__(83)('wks')
  , uid        = __webpack_require__(58)
  , Symbol     = __webpack_require__(4).Symbol
  , USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function(name){
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(5)(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

var anObject       = __webpack_require__(3)
  , IE8_DOM_DEFINE = __webpack_require__(161)
  , toPrimitive    = __webpack_require__(33)
  , dP             = Object.defineProperty;

exports.f = __webpack_require__(8) ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
// source https://github.com/encharm/Font-Awesome-SVG-PNG/tree/master/black/svg

var paintbrush = exports.paintbrush = '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M1615 0q70 0 122.5 46.5t52.5 116.5q0 63-45 151-332 629-465 752-97 91-218 91-126 0-216.5-92.5t-90.5-219.5q0-128 92-212l638-579q59-54 130-54zm-909 1034q39 76 106.5 130t150.5 76l1 71q4 213-129.5 347t-348.5 134q-123 0-218-46.5t-152.5-127.5-86.5-183-29-220q7 5 41 30t62 44.5 59 36.5 46 17q41 0 55-37 25-66 57.5-112.5t69.5-76 88-47.5 103-25.5 125-10.5z"/></svg>';
var search = exports.search = '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M1216 832q0-185-131.5-316.5t-316.5-131.5-316.5 131.5-131.5 316.5 131.5 316.5 316.5 131.5 316.5-131.5 131.5-316.5zm512 832q0 52-38 90t-90 38q-54 0-90-38l-343-342q-179 124-399 124-143 0-273.5-55.5t-225-150-150-225-55.5-273.5 55.5-273.5 150-225 225-150 273.5-55.5 273.5 55.5 225 150 150 225 55.5 273.5q0 220-124 399l343 343q37 37 37 90z"/></svg>';
var circle = exports.circle = '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M1664 896q0 209-103 385.5t-279.5 279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5 385.5-103 385.5 103 279.5 279.5 103 385.5z"/></svg>';
var expand = exports.expand = '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M883 1056q0 13-10 23l-332 332 144 144q19 19 19 45t-19 45-45 19h-448q-26 0-45-19t-19-45v-448q0-26 19-45t45-19 45 19l144 144 332-332q10-10 23-10t23 10l114 114q10 10 10 23zm781-864v448q0 26-19 45t-45 19-45-19l-144-144-332 332q-10 10-23 10t-23-10l-114-114q-10-10-10-23t10-23l332-332-144-144q-19-19-19-45t19-45 45-19h448q26 0 45 19t19 45z"/></svg>';
var asterisk = exports.asterisk = '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M1546 1050q46 26 59.5 77.5t-12.5 97.5l-64 110q-26 46-77.5 59.5t-97.5-12.5l-266-153v307q0 52-38 90t-90 38h-128q-52 0-90-38t-38-90v-307l-266 153q-46 26-97.5 12.5t-77.5-59.5l-64-110q-26-46-12.5-97.5t59.5-77.5l266-154-266-154q-46-26-59.5-77.5t12.5-97.5l64-110q26-46 77.5-59.5t97.5 12.5l266 153v-307q0-52 38-90t90-38h128q52 0 90 38t38 90v307l266-153q46-26 97.5-12.5t77.5 59.5l64 110q26 46 12.5 97.5t-59.5 77.5l-266 154z"/></svg>';
var trails = exports.trails = '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M 1381.375 17.1875 C 1375.7825 17.176804 1370.1216 17.316078 1364.4375 17.5625 C 1273.4913 21.505489 1197.0982 57.199956 1135.2188 124.6875 C 1076.5961 188.62338 1047.6964 263.96059 1048.5312 350.65625 L 835.71875 433 C 797.77288 391.67699 749.96961 361.96416 692.3125 343.84375 C 604.96227 316.39162 520.95691 323.70366 440.25 365.8125 C 359.5432 407.92133 305.45225 472.64985 278 560 C 250.54783 647.35004 257.89117 731.38694 300 812.09375 C 342.10886 892.80075 406.83755 946.89147 494.1875 974.34375 C 576.9404 1000.3512 657.38873 994.58645 735.5625 957.09375 L 959.28125 1171.4375 L 972.375 1184.4062 C 966.2931 1198.3454 961.94845 1209.2226 959.34375 1217.0625 C 956.73915 1224.9024 953.7186 1236.224 950.25 1251.0312 L 711.03125 1285.1875 C 669.59175 1209.0324 607.72526 1157.2863 525.40625 1129.9375 C 438.51381 1101.0693 354.34933 1107.021 272.96875 1147.8125 C 191.58796 1188.6039 136.49335 1252.4513 107.625 1339.3438 C 78.756758 1426.2362 84.708528 1510.3694 125.5 1591.75 C 166.29138 1673.1307 230.1387 1728.2567 317.03125 1757.125 C 403.92369 1785.9933 488.05682 1780.0415 569.4375 1739.25 C 650.81799 1698.4587 705.94425 1634.6111 734.8125 1547.7188 C 737.41718 1539.8788 740.43763 1528.5573 743.90625 1513.75 L 983.125 1479.5938 C 1024.5644 1555.7487 1086.4309 1607.4948 1168.75 1634.8438 C 1255.6425 1663.7119 1339.8069 1657.7603 1421.1875 1616.9688 C 1502.5682 1576.1772 1557.6631 1512.3299 1586.5312 1425.4375 C 1615.3996 1338.5451 1609.4477 1254.4119 1568.6562 1173.0312 C 1527.8647 1091.6506 1464.0174 1036.5244 1377.125 1007.6562 C 1294.9259 980.34721 1214.5066 984.74084 1135.8438 1020.8125 L 1120.2812 1005.9062 L 898.0625 785.96875 C 902.79653 774.40321 906.33847 765.03422 908.5 758.15625 C 920.42249 720.22 925.7916 682.90194 924.59375 646.21875 L 1130.9688 566.34375 C 1141.2015 577.59424 1149.3796 586.0106 1155.4688 591.59375 C 1222.9566 653.47326 1302.1474 682.44278 1393.0938 678.5 C 1484.04 674.55731 1560.4642 638.83151 1622.3438 571.34375 C 1684.2232 503.85591 1713.1929 424.6337 1709.25 333.6875 C 1705.3072 242.74139 1669.5816 166.34819 1602.0938 104.46875 C 1538.8238 46.456824 1465.2625 17.347946 1381.375 17.1875 z "/></svg>';
var lock = exports.lock = '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M640 768h512v-192q0-106-75-181t-181-75-181 75-75 181v192zm832 96v576q0 40-28 68t-68 28h-960q-40 0-68-28t-28-68v-576q0-40 28-68t68-28h32v-192q0-184 132-316t316-132 316 132 132 316v192h32q40 0 68 28t28 68z"/></svg>';
var unlock = exports.unlock = '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M1376 768q40 0 68 28t28 68v576q0 40-28 68t-68 28h-960q-40 0-68-28t-28-68v-576q0-40 28-68t68-28h32v-320q0-185 131.5-316.5t316.5-131.5 316.5 131.5 131.5 316.5q0 26-19 45t-45 19h-64q-26 0-45-19t-19-45q0-106-75-181t-181-75-181 75-75 181v320h736z"/></svg>';
var unexpand = exports.unexpand = '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M896 960v448q0 26-19 45t-45 19-45-19l-144-144-332 332q-10 10-23 10t-23-10l-114-114q-10-10-10-23t10-23l332-332-144-144q-19-19-19-45t19-45 45-19h448q26 0 45 19t19 45zm755-672q0 13-10 23l-332 332 144 144q19 19 19 45t-19 45-45 19h-448q-26 0-45-19t-19-45v-448q0-26 19-45t45-19 45 19l144 144 332-332q10-10 23-10t23 10l114 114q10 10 10 23z"/></svg>';
var axes = exports.axes = '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 500 500"><path d="M430.25,379.655l-75.982-43.869v59.771H120.73V151.966h59.774l-43.869-75.983L92.767,0L48.898,75.983L5.029,151.966h59.775 v271.557c0,15.443,12.52,27.965,27.963,27.965h261.5v59.773l75.982-43.869l75.982-43.867L430.25,379.655z"/></svg>';
var gear = exports.gear = '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M1152 896q0-106-75-181t-181-75-181 75-75 181 75 181 181 75 181-75 75-181zm512-109v222q0 12-8 23t-20 13l-185 28q-19 54-39 91 35 50 107 138 10 12 10 25t-9 23q-27 37-99 108t-94 71q-12 0-26-9l-138-108q-44 23-91 38-16 136-29 186-7 28-36 28h-222q-14 0-24.5-8.5t-11.5-21.5l-28-184q-49-16-90-37l-141 107q-10 9-25 9-14 0-25-11-126-114-165-168-7-10-7-23 0-12 8-23 15-21 51-66.5t54-70.5q-27-50-41-99l-183-27q-13-2-21-12.5t-8-23.5v-222q0-12 8-23t19-13l186-28q14-46 39-92-40-57-107-138-10-12-10-24 0-10 9-23 26-36 98.5-107.5t94.5-71.5q13 0 26 10l138 107q44-23 91-38 16-136 29-186 7-28 36-28h222q14 0 24.5 8.5t11.5 21.5l28 184q49 16 90 37l142-107q9-9 24-9 13 0 25 10 129 119 165 170 7 8 7 22 0 12-8 23-15 21-51 66.5t-54 70.5q26 50 41 98l183 28q13 2 21 12.5t8 23.5z"/></svg>';
var stack = exports.stack = '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 54.849 54.849"><g><path d="M54.497,39.614l-10.363-4.49l-14.917,5.968c-0.537,0.214-1.165,0.319-1.793,0.319c-0.627,0-1.254-0.104-1.79-0.318     l-14.921-5.968L0.351,39.614c-0.472,0.203-0.467,0.524,0.01,0.716L26.56,50.81c0.477,0.191,1.251,0.191,1.729,0L54.488,40.33     C54.964,40.139,54.969,39.817,54.497,39.614z"/><path d="M54.497,27.512l-10.364-4.491l-14.916,5.966c-0.536,0.215-1.165,0.321-1.792,0.321c-0.628,0-1.256-0.106-1.793-0.321     l-14.918-5.966L0.351,27.512c-0.472,0.203-0.467,0.523,0.01,0.716L26.56,38.706c0.477,0.19,1.251,0.19,1.729,0l26.199-10.479     C54.964,28.036,54.969,27.716,54.497,27.512z"/><path d="M0.361,16.125l13.662,5.465l12.537,5.015c0.477,0.191,1.251,0.191,1.729,0l12.541-5.016l13.658-5.463     c0.477-0.191,0.48-0.511,0.01-0.716L28.277,4.048c-0.471-0.204-1.236-0.204-1.708,0L0.351,15.41     C-0.121,15.614-0.116,15.935,0.361,16.125z"/></g></svg>';
var drag = exports.drag = '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M896 384q-53 0-90.5 37.5t-37.5 90.5v128h-32v-93q0-48-32-81.5t-80-33.5q-46 0-79 33t-33 79v429l-32-30v-172q0-48-32-81.5t-80-33.5q-46 0-79 33t-33 79v224q0 47 35 82l310 296q39 39 39 102 0 26 19 45t45 19h640q26 0 45-19t19-45v-25q0-41 10-77l108-436q10-36 10-77v-246q0-48-32-81.5t-80-33.5q-46 0-79 33t-33 79v32h-32v-125q0-40-25-72.5t-64-40.5q-14-2-23-2-46 0-79 33t-33 79v128h-32v-122q0-51-32.5-89.5t-82.5-43.5q-5-1-13-1zm0-128q84 0 149 50 57-34 123-34 59 0 111 27t86 76q27-7 59-7 100 0 170 71.5t70 171.5v246q0 51-13 108l-109 436q-6 24-6 71 0 80-56 136t-136 56h-640q-84 0-138-58.5t-54-142.5l-308-296q-76-73-76-175v-224q0-99 70.5-169.5t169.5-70.5q11 0 16 1 6-95 75.5-160t164.5-65q52 0 98 21 72-69 174-69z"/></svg>';
var warn = exports.warn = '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512.209 512.209"><path d="M507.345,439.683L288.084,37.688c-3.237-5.899-7.71-10.564-13.429-13.988c-5.705-3.427-11.893-5.142-18.554-5.142   s-12.85,1.718-18.558,5.142c-5.708,3.424-10.184,8.089-13.418,13.988L4.859,439.683c-6.663,11.998-6.473,23.989,0.57,35.98   c3.239,5.517,7.664,9.897,13.278,13.128c5.618,3.237,11.66,4.859,18.132,4.859h438.529c6.479,0,12.519-1.622,18.134-4.859   c5.62-3.23,10.038-7.611,13.278-13.128C513.823,463.665,514.015,451.681,507.345,439.683z M292.655,411.132   c0,2.662-0.91,4.897-2.71,6.704c-1.807,1.811-3.949,2.71-6.427,2.71h-54.816c-2.474,0-4.616-0.899-6.423-2.71   c-1.809-1.807-2.713-4.042-2.713-6.704v-54.248c0-2.662,0.905-4.897,2.713-6.704c1.807-1.811,3.946-2.71,6.423-2.71h54.812   c2.479,0,4.62,0.899,6.428,2.71c1.803,1.807,2.71,4.042,2.71,6.704v54.248H292.655z M292.088,304.357   c-0.198,1.902-1.198,3.47-3.001,4.709c-1.811,1.238-4.046,1.854-6.711,1.854h-52.82c-2.663,0-4.947-0.62-6.849-1.854   c-1.908-1.243-2.858-2.807-2.858-4.716l-4.853-130.47c0-2.667,0.953-4.665,2.856-5.996c2.474-2.093,4.758-3.14,6.854-3.14h62.809   c2.098,0,4.38,1.043,6.854,3.14c1.902,1.331,2.851,3.14,2.851,5.424L292.088,304.357z"/></svg>';
var pin = exports.pin = '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M800 864v-448q0-14-9-23t-23-9-23 9-9 23v448q0 14 9 23t23 9 23-9 9-23zm672 352q0 26-19 45t-45 19h-429l-51 483q-2 12-10.5 20.5t-20.5 8.5h-1q-27 0-32-27l-76-485h-404q-26 0-45-19t-19-45q0-123 78.5-221.5t177.5-98.5v-512q-52 0-90-38t-38-90 38-90 90-38h640q52 0 90 38t38 90-38 90-90 38v512q99 0 177.5 98.5t78.5 221.5z"/></svg>';
var question = exports.question = '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="17 17 483 483"> <circle stroke-width="40" cx="258.57" cy="258.57" r="220"/> <path d="M299.756,413.021v-61.78c0-3.003-0.966-5.472-2.896-7.401s-4.398-2.896-7.401-2.896h-61.78 c-3.003,0-5.47,0.965-7.4,2.896c-1.932,1.931-2.896,4.398-2.896,7.401v61.78c0,3.002,0.965,5.47,2.896,7.399 c1.931,1.931,4.396,2.896,7.4,2.896h61.779c3.003,0,5.472-0.967,7.401-2.896S299.756,416.021,299.756,413.021z"/> <path d="M382.128,196.789c0-18.877-5.952-36.36-17.856-52.449c-11.905-16.088-26.762-28.53-44.566-37.325 c-17.804-8.795-36.037-13.192-54.7-13.192c-52.127,0-91.919,22.845-119.377,68.537c-3.218,5.148-2.359,9.653,2.574,13.514 l42.474,32.177c1.502,1.287,3.54,1.931,6.114,1.931c3.433,0,6.115-1.287,8.044-3.861c11.369-14.587,20.594-24.454,27.672-29.603 c7.294-5.148,16.519-7.723,27.673-7.723c10.297,0,19.468,2.789,27.513,8.366c8.044,5.578,12.065,11.906,12.065,18.985 c0,8.151-2.146,14.694-6.437,19.628c-4.29,4.934-11.583,9.76-21.881,14.479c-13.514,6.006-25.901,15.284-37.164,27.834 c-11.263,12.549-16.894,26.01-16.894,40.382v11.583c0,3.004,0.965,5.472,2.896,7.401c1.931,1.93,4.396,2.896,7.4,2.896h61.779 c3.003,0,5.471-0.965,7.401-2.896c1.93-1.931,2.896-4.397,2.896-7.401c0-4.075,2.306-9.385,6.917-15.928 c4.612-6.542,10.458-11.852,17.537-15.927c6.863-3.861,12.119-6.918,15.768-9.171c3.646-2.252,8.579-6.008,14.802-11.263 c6.22-5.255,10.993-10.402,14.317-15.443c3.325-5.042,6.328-11.53,9.01-19.467C380.788,214.916,382.128,206.228,382.128,196.789z"/> </svg>';
var close = exports.close = '<svg class="vzb-icon vzb-icon-pin" viewBox="-150 -250 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1149 414q0 26 -19 45l-181 181l181 181q19 19 19 45q0 27 -19 46l-90 90q-19 19 -46 19q-26 0 -45 -19l-181 -181l-181 181q-19 19 -45 19q-27 0 -46 -19l-90 -90q-19 -19 -19 -46q0 -26 19 -45l181 -181l-181 -181q-19 -19 -19 -45q0 -27 19 -46l90 -90q19 -19 46 -19 q26 0 45 19l181 181l181 -181q19 -19 45 -19q27 0 46 19l90 90q19 19 19 46z"/></svg>';
var presentation = exports.presentation = '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path id="flip-chart-1" d="M334.549,393.834l58.607,68.666h-45.096l-58.709-68.666H334.549z M240.333,462.5h34.333v-68.666h-34.333 V462.5z M360.5,153.5h-34.334v137.334H360.5V153.5z M121.566,462.5h45.113l58.709-68.666h-45.197L121.566,462.5z M206,273.666 h-34.333v17.168H206V273.666z M257.5,239.333h-34.333v51.5H257.5V239.333z M309,205h-34.334v85.834H309V205z M446.334,102h-17.168 v257.5H85.833V102H68.667V50.5h377.667V102z M394.834,102H120.167v223.166h274.667V102z"/></svg>';
var about = exports.about = '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1792 1792"><path d="M1088 1256v240q0 16-12 28t-28 12h-240q-16 0-28-12t-12-28v-240q0-16 12-28t28-12h240q16 0 28 12t12 28zm316-600q0 54-15.5 101t-35 76.5-55 59.5-57.5 43.5-61 35.5q-41 23-68.5 65t-27.5 67q0 17-12 32.5t-28 15.5h-240q-15 0-25.5-18.5t-10.5-37.5v-45q0-83 65-156.5t143-108.5q59-27 84-56t25-76q0-42-46.5-74t-107.5-32q-65 0-108 29-35 25-107 115-13 16-31 16-12 0-25-8l-164-125q-13-10-15.5-25t5.5-28q160-266 464-266 80 0 161 31t146 83 106 127.5 41 158.5z"/></svg>';
var cursorArrow = exports.cursorArrow = '<svg class="vzb-icon" viewBox="-200 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1389 1043q31 30 14 69-17 40-59 40h-382l201 476q10 25 0 49t-34 35l-177 75q-25 10-49 0t-35-34l-191-452-312 312q-19 19-45 19-12 0-24-5-40-17-40-59v-1504q0-42 40-59 12-5 24-5 27 0 45 19z"/></svg>';
var cursorPlus = exports.cursorPlus = '<svg class="vzb-icon" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1088 800v64q0 13-9.5 22.5t-22.5 9.5h-224v224q0 13-9.5 22.5t-22.5 9.5h-64q-13 0-22.5-9.5t-9.5-22.5v-224h-224q-13 0-22.5-9.5t-9.5-22.5v-64q0-13 9.5-22.5t22.5-9.5h224v-224q0-13 9.5-22.5t22.5-9.5h64q13 0 22.5 9.5t9.5 22.5v224h224q13 0 22.5 9.5t9.5 22.5zm128 32q0-185-131.5-316.5t-316.5-131.5-316.5 131.5-131.5 316.5 131.5 316.5 316.5 131.5 316.5-131.5 131.5-316.5zm512 832q0 53-37.5 90.5t-90.5 37.5q-54 0-90-38l-343-342q-179 124-399 124-143 0-273.5-55.5t-225-150-150-225-55.5-273.5 55.5-273.5 150-225 225-150 273.5-55.5 273.5 55.5 225 150 150 225 55.5 273.5q0 220-124 399l343 343q37 37 37 90z"/></svg>';
var cursorMinus = exports.cursorMinus = '<svg class="vzb-icon" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1088 800v64q0 13-9.5 22.5t-22.5 9.5h-576q-13 0-22.5-9.5t-9.5-22.5v-64q0-13 9.5-22.5t22.5-9.5h576q13 0 22.5 9.5t9.5 22.5zm128 32q0-185-131.5-316.5t-316.5-131.5-316.5 131.5-131.5 316.5 131.5 316.5 316.5 131.5 316.5-131.5 131.5-316.5zm512 832q0 53-37.5 90.5t-90.5 37.5q-54 0-90-38l-343-342q-179 124-399 124-143 0-273.5-55.5t-225-150-150-225-55.5-273.5 55.5-273.5 150-225 225-150 273.5-55.5 273.5 55.5 225 150 150 225 55.5 273.5q0 220-124 399l343 343q37 37 37 90z"/></svg>';
var hundredPercent = exports.hundredPercent = '<svg class="vzb-icon" xmlns="http://www.w3.org/2000/svg"><g transform="translate(18 11)"><text transform="scale(0.9 1)" x="0" y="0">100</text><text transform="scale(0.6 1)" class="percent" x="0" y="0">%</text></g></svg>';
var percent = exports.percent = '<svg class="vzb-icon" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg"><path d="M1408 1280q0-52-38-90t-90-38-90 38-38 90 38 90 90 38 90-38 38-90zm-768-768q0-52-38-90t-90-38-90 38-38 90 38 90 90 38 90-38 38-90zm1024 768q0 159-112.5 271.5t-271.5 112.5-271.5-112.5-112.5-271.5 112.5-271.5 271.5-112.5 271.5 112.5 112.5 271.5zm-96-1088q0 20-13 38l-1056 1408q-19 26-51 26h-160q-26 0-45-19t-19-45q0-20 13-38l1056-1408q19-26 51-26h160q26 0 45 19t19 45zm-672 320q0 159-112.5 271.5t-271.5 112.5-271.5-112.5-112.5-271.5 112.5-271.5 271.5-112.5 271.5 112.5 112.5 271.5z"/></svg>';
var side = exports.side = '<svg class="vzb-icon" viewBox="-120 -1540 1792 1792" xmlns="http://www.w3.org/2000/svg"><path transform="rotate(-90) scale(1.2)" d="M1024 448q0 -26 -19 -45l-448 -448q-19 -19 -45 -19t-45 19l-448 448q-19 19 -19 45t19 45t45 19h896q26 0 45 -19t19 -45zM1024 832q0 -26 -19 -45t-45 -19h-896q-26 0 -45 19t-19 45t19 45l448 448q19 19 45 19t45 -19l448 -448q19 -19 19 -45z"/></svg>';
var cursorHand = exports.cursorHand = '<svg class="vzb-icon" viewBox="0 -1540 1792 1792" xmlns="http://www.w3.org/2000/svg"><path transform="scale(1,-1)" d="M880 1408q-46 0 -79 -33t-33 -79v-656h-32v528q0 46 -33 79t-79 33t-79 -33t-33 -79v-528v-256l-154 205q-38 51 -102 51q-53 0 -90.5 -37.5t-37.5 -90.5q0 -43 26 -77l384 -512q38 -51 102 -51h688q34 0 61 22t34 56l76 405q5 32 5 59v498q0 46 -33 79t-79 33t-79 -33t-33 -79v-272h-32v528q0 46 -33 79t-79 33t-79 -33t-33 -79v-528h-32v656q0 46 -33 79t-79 33zM880 1536q68 0 125.5 -35.5t88.5 -96.5q19 4 42 4q99 0 169.5 -70.5t70.5 -169.5v-17q105 6 180.5 -64t75.5 -175v-498q0 -40 -8 -83l-76 -404q-14 -79 -76.5 -131t-143.5 -52h-688q-60 0 -114.5 27.5t-90.5 74.5l-384 512q-51 68 -51 154q0 106 75 181t181 75q78 0 128 -34v434q0 99 70.5 169.5t169.5 70.5q23 0 42 -4q31 61 88.5 96.5t125.5 35.5z"/></svg>';

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _iconset = __webpack_require__(10);

var _requireAll = __webpack_require__(71);

var _requireAll2 = _interopRequireDefault(_requireAll);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var dialogTemplates = (0, _requireAll2.default)(__webpack_require__(474));

/*!
 * VIZABI DIALOG
 * Reusable Dialog component
 */

var Dialog = _component2.default.extend({
  /**
   * Initializes the dialog
   * @param {Object} config Initial config, with name and placeholder
   * @param {Object} parent Reference to tool
   */
  init: function init(config, parent) {
    this.name = this.name || "";

    this.model_expects = this.model_expects || [{
      name: "state",
      type: "model"
    }, {
      name: "ui",
      type: "ui"
    }, {
      name: "locale",
      type: "locale"
    }];

    this.template = dialogTemplates[this.name];

    this._super(config, parent);
  },


  /**
   * Executed when the dialog has been rendered
   */
  readyOnce: function readyOnce() {
    this.element = d3.select(this.element);
    this.titleEl = this.element.selectAll(".vzb-top-dialog > .vzb-dialog-modal > .vzb-dialog-title");
    this.buttonsEl = this.element.selectAll(".vzb-top-dialog > .vzb-dialog-modal > .vzb-dialog-buttons");
    this.contentEl = this.element.selectAll(".vzb-top-dialog > .vzb-dialog-modal > .vzb-dialog-content");
  },
  ready: function ready() {
    var _this = this;
    this.placeholderEl = d3.select(this.placeholder);
    this.rootEl = this.root.element instanceof Array ? this.root.element : d3.select(this.root.element);
    this.dragHandler = this.placeholderEl.select("[data-click='dragDialog']");
    this.dragHandler.html(_iconset.drag);
    this.pinIcon = this.placeholderEl.select("[data-click='pinDialog']");
    this.pinIcon.html(_iconset.pin);
    this.topPos = "";
    var profile = this.getLayoutProfile();

    var dg = dialogDrag(this.placeholderEl, this.rootEl, 10);
    var dragBehavior = d3.drag().on("start", function () {
      var topPos = _this.placeholderEl.node().offsetTop;
      _this.placeholderEl.style("top", topPos + "px");
      _this.placeholderEl.style("bottom", "auto");
      _this.trigger("dragstart");
      dg.dragStart(d3.event);
    }).on("drag", function () {
      _this.trigger("drag");
      dg.drag(d3.event);
    }).on("end", function () {
      _this.rightPos = _this.placeholderEl.style("right");
      _this.topPos = _this.placeholderEl.style("top");
      _this.trigger("dragend");
    });
    this.dragHandler.call(dragBehavior);

    this.dragHandler.classed("vzb-hidden", profile === "small");
    this.pinIcon.classed("vzb-hidden", profile === "small");
    this.resize();
  },
  resize: function resize() {
    if (this.placeholderEl && this.rootEl && this.placeholderEl.classed("vzb-top-dialog")) {
      this.placeholderEl.classed("notransition", true);

      var profile = this.getLayoutProfile();

      if (profile !== "small") {
        var chartWidth = parseInt(this.rootEl.style("width"), 10);
        var dialogRight = parseInt(this.rightPos, 10);
        var chartHeight = parseInt(this.rootEl.style("height"), 10);
        var dialogTop = parseInt(this.topPos, 10);
        var dialogWidth = parseInt(this.placeholderEl.style("width"), 10);
        var dialogHeight = parseInt(this.placeholderEl.style("height"), 10);
        var dialogRightMargin = parseInt(this.placeholderEl.style("margin-right"), 10) || 0;
        if (utils.isNumber(dialogRight) && dialogRight > chartWidth - dialogWidth - dialogRightMargin) {
          if (this.rightPos) {
            this.rightPos = chartWidth - dialogWidth - dialogRightMargin + "px";
            if (this.isOpen) this.placeholderEl.style("right", this.rightPos);
          }
        }
        if (utils.isNumber(dialogTop) && utils.isNumber(dialogHeight) && dialogTop >= 0 && dialogTop > chartHeight - dialogHeight) {
          if (this.topPos) {
            this.topPos = (chartHeight - dialogHeight > 0 ? chartHeight - dialogHeight : 0) + "px";
            if (this.isOpen) this.placeholderEl.style("top", this.topPos);
          }
        }

        if (this.topPos && this.getLayoutProfile() === "large" && this.rootEl.classed("vzb-dialog-expand-true")) {
          this.placeholderEl.style("bottom", "auto");
        }

        if (this.rootEl.classed("vzb-landscape")) {}
        // var contentHeight = parseInt(this.rootEl.style('height'));
        // var placeholderHeight = parseInt(this.placeholderEl.style('height'));
        // if (contentHeight < placeholderHeight) {
        //   this.topPos = (-contentHeight + 50) + 'px';
        //   this.rightPos = '';
        //   this.placeholderEl.style('right', this.rightPos);
        //   this.placeholderEl.style('bottom', 'auto');
        // } else {
        //   //this.topPos = '';
        //   this.placeholderEl.style('bottom', '');
        // }

        //this.placeholderEl.style('top', this.topPos);
        this.element.style("max-height", "");
      } else {
        this.rightPos = "";
        this.topPos = "";
        this.placeholderEl.attr("style", "");
        // var totalHeight = this.root.element.offsetHeight;
        // if(this.rootEl.classed('vzb-portrait')) totalHeight = totalHeight - 50;
        // this.element.style('max-height', (totalHeight - 10) + 'px');
      }

      this.dragHandler.classed("vzb-hidden", profile === "small");
      this.pinIcon.classed("vzb-hidden", profile === "small");

      this._setMaxHeight();
    }
  },
  _setMaxHeight: function _setMaxHeight() {
    var totalHeight = this.root.element.offsetHeight;
    if (this.getLayoutProfile() !== "small") {
      if (!this.topPos && this.getLayoutProfile() === "large" && this.rootEl.classed("vzb-dialog-expand-true")) {
        var dialogBottom = parseInt(this.placeholderEl.style("bottom"), 10);
        totalHeight -= dialogBottom;
      } else {
        var topPos = this.topPos ? parseInt(this.topPos, 10) : this.placeholderEl.node().offsetTop;
        totalHeight -= topPos;
      }
    } else {
      totalHeight = this.rootEl.classed("vzb-portrait") ? totalHeight - 50 : totalHeight - 10;
    }

    this.element.style("max-height", totalHeight + "px");

    //set 'max-height' to content for IE11
    var contentHeight = totalHeight - this.titleEl.node().offsetHeight - this.buttonsEl.node().offsetHeight;
    this.contentEl.style("max-height", contentHeight + "px");
  },
  beforeOpen: function beforeOpen() {
    var _this = this;

    this.transitionEvents = ["webkitTransitionEnd", "transitionend", "msTransitionEnd", "oTransitionEnd"];
    this.transitionEvents.forEach(function (event) {
      _this.placeholderEl.on(event, _this.transitionEnd.bind(_this, event));
    });

    this.placeholderEl.classed("notransition", true);

    this.placeholderEl.style("top", ""); // issues: 369 & 442
    this.placeholderEl.style("bottom", ""); // issues: 369 & 442

    if (this.topPos && this.getLayoutProfile() === "large" && this.rootEl.classed("vzb-dialog-expand-true")) {
      var topPos = this.placeholderEl.node().offsetTop;
      this.placeholderEl.style("top", topPos + "px"); // issues: 369 & 442
      this.placeholderEl.style("bottom", "auto"); // issues: 369 & 442
    } else if (this.getLayoutProfile() !== "small") {
      //if(this.rightPos) this.placeholderEl.style('right', this.rightPos);
    }

    this.placeholderEl.node().offsetTop;
    this.placeholderEl.classed("notransition", false);

    if (this.getLayoutProfile() === "small") {
      this.placeholderEl.style("top", ""); // issues: 369 & 442
    } else if (this.rootEl.classed("vzb-landscape")) {// need to recalculate popup position (Safari 8 bug)
      // var contentHeight = parseInt(this.rootEl.style('height'));
      // var placeholderHeight = parseInt(this.placeholderEl.style('height'));
      // if (contentHeight < placeholderHeight) {
      //   this.topPos = (-contentHeight + 50) + 'px';
      //   this.rightPos = '';
      //   this.placeholderEl.style('right', this.rightPos);
      //   this.placeholderEl.style('bottom', 'auto');
      // } else {
      //   this.topPos = '';
      //   this.placeholderEl.style('bottom', '');
      // }
      //this.placeholderEl.style('top', this.topPos);
    }
  },


  /**
   * User has clicked to open this dialog
   */
  open: function open() {
    this.isOpen = true;
    if (this.getLayoutProfile() !== "small") {
      if (this.topPos) {
        this.placeholderEl.style("top", this.topPos);
        this.placeholderEl.style("right", this.rightPos);
      }
    }
  },
  beforeClose: function beforeClose() {
    //issues: 369 & 442
    if (this.rootEl.classed("vzb-portrait") && this.getLayoutProfile() === "small") {
      this.placeholderEl.style("top", "auto"); // issues: 369 & 442
    }
    if (this.getLayoutProfile() === "large" && this.rootEl.classed("vzb-dialog-expand-true")) {
      this.topPos0 = this.topPos ? this.placeholderEl.node().parentNode.offsetHeight - this.placeholderEl.node().offsetHeight + "px" : "";
    }
    this.placeholderEl.classed("notransition", false);
    this.placeholderEl.node().offsetHeight; // trigger a reflow (flushing the css changes)
  },


  /**
   * User has closed this dialog
   */
  close: function close() {
    //issues: 369 & 442
    if (!(this.rootEl.classed("vzb-portrait") && this.getLayoutProfile() === "small")) {
      this.placeholderEl.style("top", ""); // issues: 369 & 442
      this.placeholderEl.style("right", ""); // issues: 369 & 442
    }

    if (this.getLayoutProfile() === "large" && this.rootEl.classed("vzb-dialog-expand-true")) {
      this.placeholderEl.style("top", this.topPos0);
      this.placeholderEl.style("right", "");
    }
    this.isOpen = false;
    this.trigger("close");
  },
  transitionEnd: function transitionEnd(eventName) {
    var _this = this;

    this.transitionEvents.forEach(function (event) {
      _this.placeholderEl.on(event, null);
    });
    if (this.isOpen) {
      this.placeholderEl.classed("notransition", true);
    }
  }
});

function dialogDrag(element, container, xOffset) {
  var posX = void 0,
      posY = void 0,
      divTop = void 0,
      divRight = void 0,
      marginRight = void 0,
      marginLeft = void 0,
      xOffsetRight = void 0,
      xOffsetLeft = void 0,
      eWi = void 0,
      eHe = void 0,
      cWi = void 0,
      cHe = void 0,
      diffX = void 0,
      diffY = void 0;

  return {
    move: function move(x, y) {
      element.style("right", x + "px");
      element.style("top", y + "px");
    },
    dragStart: function dragStart(evt) {
      if (!utils.isTouchDevice()) {
        posX = evt.sourceEvent.clientX;
        posY = evt.sourceEvent.clientY;
      } else {
        var touchCoord = d3.touches(container.node());
        posX = touchCoord[0][0];
        posY = touchCoord[0][1];
      }
      divTop = parseInt(element.style("top")) || 0;
      divRight = parseInt(element.style("right")) || 0;
      marginLeft = parseInt(element.style("margin-left")) || 0;
      marginRight = parseInt(element.style("margin-right")) || 0;
      xOffsetLeft = Math.min(xOffset, marginLeft);
      xOffsetRight = Math.min(xOffset, marginRight);
      eWi = parseInt(element.style("width")) + marginLeft - xOffsetLeft;
      eHe = parseInt(element.style("height"));
      cWi = parseInt(container.style("width")) - marginRight;
      cHe = parseInt(container.style("height"));
      diffX = posX + divRight;
      diffY = posY - divTop;
    },
    drag: function drag(evt) {
      if (!utils.isTouchDevice()) {
        posX = evt.sourceEvent.clientX;
        posY = evt.sourceEvent.clientY;
      } else {
        var touchCoord = d3.touches(container.node());
        posX = touchCoord[0][0];
        posY = touchCoord[0][1];
      }
      var aX = -posX + diffX,
          aY = posY - diffY;
      if (aX < -xOffsetRight) aX = -xOffsetRight;
      if (aY < 0) aY = 0;
      if (aX + eWi > cWi) aX = cWi - eWi;
      if (aY + eHe > cHe) aY = cHe - eHe;

      this.move(aX, aY);
    }
  };
}

exports.default = Dialog;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(45)
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(29);
module.exports = function(it){
  return Object(defined(it));
};

/***/ }),
/* 14 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _model = __webpack_require__(47);

var _model2 = _interopRequireDefault(_model);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _iconset = __webpack_require__(10);

var _events = __webpack_require__(46);

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var class_loading_first = "vzb-loading-first";
var class_loading_data = "vzb-loading-data";
var class_placeholder = "vzb-placeholder";
var class_buttons_off = "vzb-buttonlist-off";

var templates = {};

//tool model is quite simple and doesn't need to be registered
var ToolModel = _model2.default.extend({
  /**
   * Initializes the tool model.
   * @param {Tool}   the tool this tool model belongs to
   * @param {Object} values The initial values of this model
   */
  init: function init(tool, external_model) {
    this._id = utils.uniqueId("tm");
    this._type = "tool";
    this._component = tool;

    // defaults are defined on the Tool
    // this way, each tool can have it's own default model
    this.getClassDefaults = function () {
      return tool.default_model;
    };

    // combine listeners from tool and external page to one object
    var listeners = utils.extend(tool.getToolListeners(), external_model.bind);
    delete external_model.bind; // bind shouldn't go to model tree

    this._super(tool.name, external_model, null, listeners);
  },


  /**
   * @return {object} Defaults of tool model and children
   * Tool defaults overwrite other models' default
   */
  getDefaults: function getDefaults() {
    return utils.deepExtend({}, this.getSubmodelDefaults(), this.getClassDefaults());
  },
  validate: function validate() {

    var max = 10;
    var c = 0;
    var _this = this;

    function validate_func(c) {
      // ToolModel uses validate function declared on Tool so each Tool can have its own validation.
      var model = JSON.stringify(_this.getPlainObject());
      _this._component.validate(_this);
      var model2 = JSON.stringify(_this.getPlainObject());

      if (c >= max) {
        utils.error("Max validation loop.");
      } else if (model !== model2) {
        validate_func(c++);
      }
    }

    validate_func(c);
  }
});

//tool
var Tool = _component2.default.extend({
  /**
    * Initializes the tool
    * @param {Object} placeholder object
    * @param {Object} external_model External model such as state, data, etc
    */
  init: function init(placeholder, external_model) {
    this._id = utils.uniqueId("t");

    this.template = this.getToolTemplate();

    // super also calls createModel
    this._super({
      placeholder: placeholder,
      model: external_model
    });

    this.render();

    this.setCSSClasses();
    this.setResizeHandler();
  },
  createModel: function createModel(external_model) {
    external_model = external_model || {}; //external model can be undefined
    external_model.bind = external_model.bind || {}; //bind functions can be undefined
    this.model = new ToolModel(this, external_model);
    this.model.setInterModelListeners();
  },
  getToolTemplate: function getToolTemplate() {
    return this.template || '<div class="vzb-tool vzb-tool-' + this.name + '">' + '<div class="vzb-tool-stage">' + '<div class="vzb-tool-viz">' + "</div>" + '<div class="vzb-tool-time-speed-sliders">' + '<div class="vzb-tool-timeslider">' + "</div>" + '<div class="vzb-tool-stepped-speed-slider">' + "</div>" + "</div>" + "</div>" + '<div class="vzb-tool-sidebar">' + '<div class="vzb-tool-dialogs">' + "</div>" + '<div class="vzb-tool-buttonlist">' + "</div>" + "</div>" + '<div class="vzb-tool-datanotes vzb-hidden">' + "</div>" + '<div class="vzb-tool-treemenu vzb-hidden">' + "</div>" + '<div class="vzb-tool-datawarning vzb-hidden">' + "</div>" + '<div class="vzb-tool-labels vzb-hidden">' + "</div>" + "</div>";
  },
  getToolListeners: function getToolListeners() {
    var _this2 = this;

    var _this = this;
    return utils.extend(this.model_binds, {
      "change": function change(evt, path) {
        if (_this._ready) {
          _this.model.validate();

          if (evt.source.persistent) _this.model.trigger(new _events.DefaultEvent(evt.source, "persistentChange"));
        }
      },
      "hook_change": function hook_change() {
        if (!_this.model.state.time.splash) {
          // not block when it initial splash screen
          _this.beforeLoading();
        }
      },
      "resize:ui": function resizeUi() {
        if (_this._ready) {
          _this.triggerResize();
        }
      },
      "translate:locale": function translateLocale() {
        _this.translateStrings();
        _this.model.ui.setRTL(_this.model.locale.isRTL());
      },
      "load_error": function load_error() {
        _this2.renderError();
        _this2.error.apply(_this2, arguments);
      }
    });
  },
  setResizeHandler: function setResizeHandler() {
    //only tools have layout (manage sizes)
    this.model.ui.setContainer(this.element);
  },


  triggerResize: utils.throttle(function () {
    this.trigger("resize");
  }, 100),

  startLoading: function startLoading() {
    var _this3 = this;

    this._super();

    Promise.all([this.model.startPreload(), this.startPreload()]).then(this.afterPreload.bind(this)).then(this.loadSplashScreen.bind(this)).then(function () {
      return utils.delay(300);
    }).then(this.model.startLoading.bind(this.model)).then(this.finishLoading.bind(this)).catch(function (error) {
      _events2.default.unfreezeAll();
      _this3.model.triggerLoadError(error);
    });
  },
  loadSplashScreen: function loadSplashScreen() {
    if (this.model.ui.splash) {
      //TODO: cleanup hardcoded splash screen
      this.model.state.time.splash = true;
      return this.model.startLoading({
        splashScreen: true
      });
    }
    return Promise.resolve();
  },
  finishLoading: function finishLoading() {
    this.model.state.time.splash = false;
  },
  getPersistentModel: function getPersistentModel() {
    //try to find functions in properties of model.
    var removeFunctions = function removeFunctions(model) {
      for (var childKey in model) {
        if (typeof model[childKey] === "function") {
          delete model[childKey];
          utils.warn("minModel validation. Function found in enumerable properties of " + childKey + ". This key is deleted from minModel");
        } else if (_typeof(model[childKey]) === "object") removeFunctions(model[childKey]);
      }
    };

    var currentToolModel = this.model.getPlainObject(true); // true = get only persistent model values
    removeFunctions(currentToolModel);
    return currentToolModel;
  },
  getPersistentMinimalModel: function getPersistentMinimalModel(diffModel) {
    var defaultModel = this.model.getDefaults();
    var currentPersistentModel = this.getPersistentModel();
    var redundantModel = utils.deepExtend(defaultModel, diffModel);
    return utils.diffObject(currentPersistentModel, redundantModel);
  },


  /**
   * Clears a tool
   */

  clear: function clear() {
    this.model.ui.clear();
    this.setModel = this.getModel = function () {
      return void 0;
    };
    this._super();
  },


  /**
   * Visually display errors
   */
  error: function error(options, message) {
    if (!message) {
      message = options && options.type === "data" ? "Error loading chart data. <br>Please, try again later." : "Error loading chart";
    }

    this.placeholder.innerHTML = "<div class=\"vzb-error-message\"><h1>" + _iconset.warn + "</h1><p>" + message + "</p></div>";
  },


  /**
   * Sets model from external page
   * @param {Object} JSONModel new model in JSON format
   * @param {Boolean} overwrite overwrite everything instead of extending
   */
  setModel: function setModel(newModelJSON, overwrite) {
    if (overwrite) {
      this.model.reset(newModelJSON);
    } else {
      this.model.set(newModelJSON);
    }
    this.setCSSClasses();
  },


  /**
   * get model
   * @return {Object} JSON object of model
   */
  getModel: function getModel() {
    return this.model.getPlainObject() || {};
  },

  /**
   * Displays loading class
   */
  beforeLoading: function beforeLoading() {
    utils.addClass(this.placeholder, class_loading_data);
  },


  /* ==========================
   * Validation and query
   * ==========================
   */
  /**
   * Validating the tool model
   * @param model the current tool model to be validated
   */
  validate: function validate(model) {
    model = this.model || model;

    if (!model || !model.state) return utils.warn("tool validation aborted: model.state looks wrong: " + model);
  },
  setCSSClasses: function setCSSClasses() {
    //add placeholder class
    utils.addClass(this.placeholder, class_placeholder);
    //add-remove buttonlist class
    if (!this.model.ui || !this.model.ui.buttons || !this.model.ui.buttons.length) {
      utils.addClass(this.element, class_buttons_off);
    } else {
      utils.removeClass(this.element, class_buttons_off);
    }
  }
});

exports.default = Tool;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var initializing = false;
var fnTest = /xyz/.test(function () {
  var xyz = void 0;
}) ? /\b_super\b/ : /.*/;

function extend(name, extensions) {

  //in case there are two args
  extensions = arguments.length === 1 ? name : extensions;
  var _super = this.prototype;
  initializing = true;
  var prototype = new this();
  initializing = false;

  (0, _utils.forEach)(extensions, function (method, name) {
    if (typeof extensions[name] === "function" && typeof _super[name] === "function" && fnTest.test(extensions[name])) {
      prototype[name] = function (name, fn) {
        return function () {
          var tmp = this._super;
          this._super = _super[name];
          var ret = fn.apply(this, arguments);
          this._super = tmp;
          return ret;
        };
      }(name, extensions[name]);
    } else {
      prototype[name] = method;
    }
  });

  function Class() {
    if (this.trackInstances) Class.instances.push(this);
    if (!initializing && this.init) {
      this.init.apply(this, arguments);
    }
  }

  // Populate our constructed prototype object
  Class.prototype = prototype;
  Class.prototype.constructor = Class;
  Class.extend = extend;

  Class._collection = {};
  Class.instances = [];
  Class.register = function (name, code) {
    if (typeof this._collection[name] !== "undefined") {
      (0, _utils.warn)('"' + name + '" is already registered. Overwriting...');
    }
    this._collection[name] = code;
  };

  Class.unregister = function (name) {
    this._collection[name] = void 0;
  };

  Class.getCollection = function () {
    return this._collection;
  };

  //define a method or field in this prototype
  Class.define = function (name, value) {
    this.prototype[name] = value;
  };

  //get an item of the collection from this class
  Class.get = function (name, silent) {
    if (this._collection.hasOwnProperty(name)) {
      return this._collection[name];
    }
    if (!silent) {
      (0, _utils.warn)('"' + name + '" was not found.');
    }
    return false;
  };
  //register extension by name
  if (arguments.length > 1 && this.register) {
    this.register(name, Class);
  }
  return Class;
}

var Class = function Class() {};
Class.extend = extend;

exports.default = Class;

/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

var dP         = __webpack_require__(9)
  , createDesc = __webpack_require__(44);
module.exports = __webpack_require__(8) ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var global    = __webpack_require__(4)
  , hide      = __webpack_require__(18)
  , has       = __webpack_require__(14)
  , SRC       = __webpack_require__(58)('src')
  , TO_STRING = 'toString'
  , $toString = Function[TO_STRING]
  , TPL       = ('' + $toString).split(TO_STRING);

__webpack_require__(36).inspectSource = function(it){
  return $toString.call(it);
};

(module.exports = function(O, key, val, safe){
  var isFunction = typeof val == 'function';
  if(isFunction)has(val, 'name') || hide(val, 'name', key);
  if(O[key] === val)return;
  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if(O === global){
    O[key] = val;
  } else {
    if(!safe){
      delete O[key];
      hide(O, key, val);
    } else {
      if(O[key])O[key] = val;
      else hide(O, key, val);
    }
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString(){
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0)
  , fails   = __webpack_require__(5)
  , defined = __webpack_require__(29)
  , quot    = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function(string, tag, attribute, value) {
  var S  = String(defined(string))
    , p1 = '<' + tag;
  if(attribute !== '')p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function(NAME, exec){
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function(){
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(69)
  , defined = __webpack_require__(29);
module.exports = function(it){
  return IObject(defined(it));
};

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _iconset = __webpack_require__(10);

var iconset = _interopRequireWildcard(_iconset);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*!
 * VIZABI BUTTONLIST
 * Reusable buttonlist component
 */

//default existing buttons
var class_active = "vzb-active";
var class_hidden = "vzb-hidden";
var class_active_locked = "vzb-active-locked";
var class_expand_dialog = "vzb-dialog-side";
var class_hide_btn = "vzb-dialog-side-btn";
var class_unavailable = "vzb-unavailable";
var class_vzb_fullscreen = "vzb-force-fullscreen";
var class_container_fullscreen = "vzb-container-fullscreen";

var ButtonList = _component2.default.extend({

  /**
   * Initializes the buttonlist
   * @param config component configuration
   * @param context component context (parent)
   */
  init: function init(config, context) {

    //set properties
    var _this = this;
    this.name = this.name || "gapminder-buttonlist";
    //    this.template = '<div class="vzb-buttonlist"></div>';

    this.model_expects = [{
      name: "state",
      type: "model"
    }, {
      name: "ui",
      type: "ui"
    }, {
      name: "locale",
      type: "locale"
    }];

    this._available_buttons = {
      "find": {
        title: "buttons/find",
        icon: "search",
        required: false
      },
      "show": {
        title: "buttons/show",
        icon: "asterisk",
        required: false
      },
      "moreoptions": {
        title: "buttons/more_options",
        icon: "gear",
        required: true
      },
      "colors": {
        title: "buttons/colors",
        icon: "paintbrush",
        required: false
      },
      "size": {
        title: "buttons/size",
        icon: "circle",
        required: false
      },
      "fullscreen": {
        title: "buttons/expand",
        icon: "expand",
        func: this.toggleFullScreen.bind(this),
        required: true
      },
      "trails": {
        title: "buttons/trails",
        icon: "trails",
        func: this.toggleBubbleTrails.bind(this),
        required: false,
        statebind: "ui.chart.trails",
        statebindfunc: this.setBubbleTrails.bind(this)
      },
      "lock": {
        title: "buttons/lock",
        icon: "lock",
        func: this.toggleBubbleLock.bind(this),
        required: false,
        statebind: "ui.chart.lockNonSelected",
        statebindfunc: this.setBubbleLock.bind(this)
      },
      "inpercent": {
        title: "buttons/inpercent",
        icon: "percent",
        func: this.toggleInpercent.bind(this),
        required: false,
        statebind: "ui.chart.inpercent",
        statebindfunc: this.setInpercent.bind(this)
      },
      "presentation": {
        title: "buttons/presentation",
        icon: "presentation",
        func: this.togglePresentationMode.bind(this),
        required: false,
        statebind: "ui.presentation",
        statebindfunc: this.setPresentationMode.bind(this)
      },
      "about": {
        title: "buttons/about",
        icon: "about",
        required: false
      },
      "axes": {
        title: "buttons/axes",
        icon: "axes",
        required: false
      },
      "axesmc": {
        title: "buttons/axesmc",
        icon: "axes",
        required: false
      },
      "stack": {
        title: "buttons/stack",
        icon: "stack",
        required: false
      },
      "side": {
        title: "buttons/side",
        icon: "side",
        required: false
      },
      "_default": {
        title: "Button",
        icon: "asterisk",
        required: false
      }
    };

    this._active_comp = false;

    this.model_binds = {
      "change:state.marker.select": function changeStateMarkerSelect(evt) {
        if (!_this._readyOnce) return;

        _this.setBubbleTrails();
        _this.setBubbleLock();
        _this._toggleButtons();

        //scroll button list to end if bottons appeared or disappeared
        // if(_this.entitiesSelected_1 !== (_this.model.state.marker.select.length > 0)) {
        //   _this.scrollToEnd();
        // }
        // _this.entitiesSelected_1 = _this.model.state.marker.select.length > 0;
      },
      "change:ui.chart": function changeUiChart(evt, path) {
        if (path.indexOf("lockActive") > -1) {
          _this.setBubbleLock();
        }
      }
    };

    // config.ui is same as this.model.ui here but this.model.ui is not yet available because constructor hasn't been called.
    // can't call constructor earlier because this.model_binds needs to be complete before calling constructor
    config.ui.buttons.forEach(function (buttonId) {
      var button = _this._available_buttons[buttonId];
      if (button && button.statebind) {
        _this.model_binds["change:" + button.statebind] = function (evt) {
          button.statebindfunc(buttonId, evt.source.value);
        };
      }
    });

    // builds model
    this._super(config, context);

    this.validatePopupButtons(this.model.ui.buttons, this.model.ui.dialogs);
  },
  readyOnce: function readyOnce() {
    var _this = this;

    this.element = d3.select(this.placeholder);
    this.element.selectAll("div").remove();

    this.root.findChildByName("gapminder-dialogs").on("close", function (evt, params) {
      _this.setButtonActive(params.id, false);
    });

    var button_expand = (this.model.ui.dialogs || {}).sidebar || [];

    // // if button_expand has been passed in with boolean param or array must check and covert to array
    // if (button_expand){
    //   this.model.ui.dialogs.sidebar = (button_expand === true) ? this.model.ui.buttons : button_expand;
    // }

    // if (button_expand && button_expand.length !== 0) {
    //     d3.select(this.root.element).classed("vzb-dialog-expand-true", true);
    // }

    var button_list = [].concat(this.model.ui.buttons);

    // (button_expand||[]).forEach(function(button) {
    //   if (button_list.indexOf(button) === -1) {
    //     button_list.push(button);
    //   }
    // });

    this.model.ui.buttons = button_list;

    //add buttons and render components
    this._addButtons(button_list, button_expand);

    //store body overflow
    this._prev_body_overflow = document.body.style.overflow;

    this.setBubbleTrails();
    this.setBubbleLock();
    this.setInpercent();
    this.setPresentationMode();

    this._toggleButtons();
  },
  proceedClick: function proceedClick(id) {
    var _this = this;
    var btn = _this.element.selectAll(".vzb-buttonlist-btn[data-btn='" + id + "']");
    var classes = btn.attr("class");
    var btn_config = _this._available_buttons[id];

    if (btn_config && btn_config.func) {
      btn_config.func(id);
    } else {
      var btn_active = classes.indexOf(class_active) === -1;

      btn.classed(class_active, btn_active);
      var evt = {};
      evt["id"] = id;
      evt["active"] = btn_active;
      _this.trigger("click", evt);
    }
  },
  validatePopupButtons: function validatePopupButtons(buttons, dialogs) {
    var _this = this;

    var popupDialogs = dialogs.popup;
    var popupButtons = buttons.filter(function (d) {
      return _this._available_buttons[d] && !_this._available_buttons[d].func;
    });
    for (var i = 0, j = popupButtons.length; i < j; i++) {
      if (popupDialogs.indexOf(popupButtons[i]) == -1) {
        return utils.error('Buttonlist: bad buttons config: "' + popupButtons[i] + '" is missing in popups list');
      }
    }
    return false; //all good
  },


  /*
   * reset buttons show state
   */
  _showAllButtons: function _showAllButtons() {
    // show all existing buttons
    var _this = this;
    var buttons = this.element.selectAll(".vzb-buttonlist-btn");
    buttons.each(function (d, i) {
      var button = d3.select(this);
      button.style("display", "");
    });
  },


  /*
  * determine which buttons are shown on the buttonlist
  */
  _toggleButtons: function _toggleButtons() {
    var _this = this;
    var parent = this.parent.element.node ? this.parent.element : d3.select(this.parent.element);

    //HERE
    var button_expand = (this.model.ui.dialogs || {}).sidebar || [];
    _this._showAllButtons();

    var buttons = this.element.selectAll(".vzb-buttonlist-btn");

    var container = this.element.node().getBoundingClientRect();

    var not_required = [];
    var required = [];

    var button_width = 80;
    var button_height = 80;
    var container_width = this.element.node().getBoundingClientRect().width;
    var container_height = this.element.node().getBoundingClientRect().height;
    var buttons_width = 0;
    var buttons_height = 0;

    buttons.each(function (d, i) {
      var button_data = d;
      var button = d3.select(this);
      var expandable = button_expand.indexOf(button_data.id) !== -1;
      var button_margin = { top: parseInt(button.style("margin-top")), right: parseInt(button.style("margin-right")), left: parseInt(button.style("margin-left")), bottom: parseInt(button.style("margin-bottom")) };
      button_width = button.node().getBoundingClientRect().width + button_margin.right + button_margin.left;
      button_height = button.node().getBoundingClientRect().height + button_margin.top + button_margin.bottom;

      if (!button.classed(class_hidden)) {
        if (!expandable || _this.getLayoutProfile() !== "large") {
          buttons_width += button_width;
          buttons_height += button_height;
          //sort buttons between required and not required buttons.
          // Not required buttons will only be shown if there is space available
          if (button_data.required) {
            required.push(button);
          } else {
            not_required.push(button);
          }
        } else {
          button.style("display", "none");
        }
      }
    });
    var width_diff = buttons_width - container_width;
    var height_diff = buttons_height - container_height;
    var number_of_buttons = 1;

    //check if container is landscape or portrait
    // if portrait small or large with expand, use width
    if (parent.classed("vzb-large") && parent.classed("vzb-dialog-expand-true") || parent.classed("vzb-small") && parent.classed("vzb-portrait")) {
      //check if the width_diff is small. If it is, add to the container
      // width, to allow more buttons in a way that is still usable
      if (width_diff > 0 && width_diff <= 10) {
        container_width += width_diff;
      }
      number_of_buttons = Math.floor(container_width / button_width) - required.length;
      if (number_of_buttons < 0) {
        number_of_buttons = 0;
      }
      // else, use height
    } else {
      //check if the width_diff is small. If it is, add to the container
      // width, to allow more buttons in a way that is still usable
      if (height_diff > 0 && height_diff <= 10) {
        container_height += height_diff;
      }
      number_of_buttons = Math.floor(container_height / button_height) - required.length;
      if (number_of_buttons < 0) {
        number_of_buttons = 0;
      }
    }
    //change the display property of non required buttons, from right to
    // left
    not_required.reverse();
    var hiddenButtons = [];
    for (var i = 0, j = not_required.length - number_of_buttons; i < j; i++) {
      not_required[i].style("display", "none");
      hiddenButtons.push(not_required[i].attr("data-btn"));
    }

    var evt = {};
    evt["hiddenButtons"] = hiddenButtons;
    _this.trigger("toggle", evt);
  },


  /*
   * adds buttons configuration to the components and template_data
   * @param {Array} button_list list of buttons to be added
   */
  _addButtons: function _addButtons(button_list, button_expand) {
    var _this = this;
    this._components_config = [];
    var details_btns = [];
    if (!button_list.length) return;
    //add a component for each button
    for (var i = 0; i < button_list.length; i++) {

      var btn = button_list[i];
      var btn_config = this._available_buttons[btn];

      //add template data
      var d = btn_config ? btn : "_default";
      var details_btn = utils.clone(this._available_buttons[d]);
      if (d == "_default") {
        details_btn.title = "buttons/" + btn;
      }
      details_btn.id = btn;
      details_btn.icon = iconset[details_btn.icon];
      details_btns.push(details_btn);
    }

    var t = this.getTranslationFunction(true);

    this.element.selectAll("button").data(details_btns).enter().append("button").attr("class", function (d) {
      var cls = "vzb-buttonlist-btn";
      if (button_expand.length > 0) {
        if (button_expand.indexOf(d.id) > -1) {
          cls += " vzb-dialog-side-btn";
        }
      }

      return cls;
    }).attr("data-btn", function (d) {
      return d.id;
    }).html(function (btn) {
      return "<span class='vzb-buttonlist-btn-icon fa'>" + btn.icon + "</span><span class='vzb-buttonlist-btn-title'>" + t(btn.title) + "</span>";
    });

    var buttons = this.element.selectAll(".vzb-buttonlist-btn");

    //clicking the button
    buttons.on("click", function () {

      d3.event.preventDefault();
      d3.event.stopPropagation();

      var id = d3.select(this).attr("data-btn");
      _this.proceedClick(id);
    });
  },
  scrollToEnd: function scrollToEnd() {
    var target = 0;
    var parent = d3.select(".vzb-tool");

    if (parent.classed("vzb-portrait") && parent.classed("vzb-small")) {
      if (this.model.state.marker.select.length > 0) target = this.element.node().scrollWidth;
      this.element.node().scrollLeft = target;
    } else {
      if (this.model.state.marker.select.length > 0) target = this.element.node().scrollHeight;
      this.element.node().scrollTop = target;
    }
  },


  /*
   * RESIZE:
   * Executed whenever the container is resized
   * Ideally, it contains only operations related to size
   */
  resize: function resize() {
    //TODO: what to do when resizing?

    //toggle presentaion off is switch to 'small' profile
    if (this.getLayoutProfile() === "small" && this.model.ui.presentation) {
      this.togglePresentationMode();
    }

    this._toggleButtons();
  },
  setButtonActive: function setButtonActive(id, boolActive) {
    var btn = this.element.selectAll(".vzb-buttonlist-btn[data-btn='" + id + "']");

    btn.classed(class_active, boolActive);
  },
  toggleBubbleTrails: function toggleBubbleTrails() {
    this.model.ui.chart.trails = !this.model.ui.chart.trails;
    this.setBubbleTrails();
  },
  setBubbleTrails: function setBubbleTrails() {
    var trails = (this.model.ui.chart || {}).trails;
    if (!trails && trails !== false) return;
    var id = "trails";
    var btn = this.element.selectAll(".vzb-buttonlist-btn[data-btn='" + id + "']");
    if (!btn.node()) return utils.warn("setBubbleTrails: no button '" + id + "' found in DOM. doing nothing");

    btn.classed(class_active_locked, trails);
    btn.classed(class_hidden, this.model.state.marker.select.length == 0);
  },
  toggleBubbleLock: function toggleBubbleLock(id) {
    var active = (this.model.ui.chart || {}).lockActive;

    if (this.model.state.marker.select.length == 0 && !active) return;

    var locked = this.model.ui.chart.lockNonSelected;
    var time = this.model.state.time;
    locked = locked ? 0 : time.formatDate(time.value);
    this.model.ui.chart.lockNonSelected = locked;

    this.setBubbleLock();
  },
  setBubbleLock: function setBubbleLock() {
    var locked = (this.model.ui.chart || {}).lockNonSelected;
    var active = (this.model.ui.chart || {}).lockActive;
    if (!locked && locked !== 0) return;

    if (locked !== 0 && this.model.state.marker.select.length === 0 && !active) {
      locked = this.model.ui.chart.lockNonSelected = 0;
    }

    var id = "lock";
    var btn = this.element.selectAll(".vzb-buttonlist-btn[data-btn='" + id + "']");
    if (!btn.node()) return utils.warn("setBubbleLock: no button '" + id + "' found in DOM. doing nothing");

    var translator = this.model.locale.getTFunction();

    btn.classed(class_unavailable, this.model.state.marker.select.length == 0 && !active);
    if (typeof active == "undefined") {
      btn.classed(class_hidden, this.model.state.marker.select.length == 0);
    } else {
      btn.classed(class_hidden, !active);
    }

    btn.classed(class_active_locked, locked);
    btn.select(".vzb-buttonlist-btn-title").text(locked ? locked : translator("buttons/lock"));

    btn.select(".vzb-buttonlist-btn-icon").html(iconset[locked ? "lock" : "unlock"]);
  },
  toggleInpercent: function toggleInpercent() {
    this.model.ui.chart.inpercent = !this.model.ui.chart.inpercent;
    this.setInpercent();
  },
  setInpercent: function setInpercent() {
    if (typeof (this.model.ui.chart || {}).inpercent == "undefined") return;
    var id = "inpercent";
    var translator = this.model.locale.getTFunction();
    var btn = this.element.selectAll(".vzb-buttonlist-btn[data-btn='" + id + "']");

    btn.classed(class_active_locked, this.model.ui.chart.inpercent);
  },
  togglePresentationMode: function togglePresentationMode() {
    this.model.ui.presentation = !this.model.ui.presentation;
    this.setPresentationMode();
  },
  setPresentationMode: function setPresentationMode() {
    var id = "presentation";
    var translator = this.model.locale.getTFunction();
    var btn = this.element.selectAll(".vzb-buttonlist-btn[data-btn='" + id + "']");

    btn.classed(class_active_locked, this.model.ui.presentation);
  },
  toggleFullScreen: function toggleFullScreen(id, emulateClick) {

    if (!window) return;

    var component = this;
    var pholder = component.placeholder;
    var pholder_found = false;
    var btn = this.element.selectAll(".vzb-buttonlist-btn[data-btn='" + id + "']");
    var fs = !this.model.ui.fullscreen;
    var body_overflow = fs ? "hidden" : this._prev_body_overflow;

    while (!(pholder_found = utils.hasClass(pholder, "vzb-placeholder"))) {
      component = component.parent;
      pholder = component.placeholder;
    }

    //TODO: figure out a way to avoid fullscreen resize delay in firefox
    if (fs) {
      this.resizeInExitHandler = false;
      launchIntoFullscreen(pholder);
      subscribeFullscreenChangeEvent.call(this, this.toggleFullScreen.bind(this, id, true));
    } else {
      this.resizeInExitHandler = !emulateClick;
      exitFullscreen.call(this);
    }
    utils.classed(pholder, class_vzb_fullscreen, fs);
    if (typeof container != "undefined") {
      utils.classed(container, class_container_fullscreen, fs);
    }

    this.model.ui.fullscreen = fs;
    var translator = this.model.locale.getTFunction();
    btn.classed(class_active_locked, fs);

    btn.select(".vzb-buttonlist-btn-icon").html(iconset[fs ? "unexpand" : "expand"]);

    btn.select(".vzb-buttonlist-btn-title>span").text(translator("buttons/" + (fs ? "unexpand" : "expand"))).attr("data-vzb-translate", "buttons/" + (fs ? "unexpand" : "expand"));

    //restore body overflow
    document.body.style.overflow = body_overflow;

    if (!this.resizeInExitHandler) this.root.ui.resizeHandler();

    //force window resize event
    // utils.defer(function() {
    //   event = window.document.createEvent("HTMLEvents");
    //   event.initEvent("resize", true, true);
    //   event.eventName = "resize";
    //   window.dispatchEvent(event);
    // });
  }
});

function isFullscreen() {
  if (!window) return false;
  if (window.document.webkitIsFullScreen !== undefined) return window.document.webkitIsFullScreen;
  if (window.document.mozFullScreen !== undefined) return window.document.mozFullScreen;
  if (window.document.msFullscreenElement !== undefined) return window.document.msFullscreenElement;

  return false;
}

function exitHandler(emulateClickFunc) {
  if (!isFullscreen()) {
    removeFullscreenChangeEvent.call(this);
    if (!this.resizeInExitHandler) {
      emulateClickFunc();
    } else {
      this.root.ui.resizeHandler();
    }
  }
}

function subscribeFullscreenChangeEvent(exitFunc) {
  if (!window) return;
  var doc = window.document;

  this.exitFullscreenHandler = exitHandler.bind(this, exitFunc);
  doc.addEventListener("webkitfullscreenchange", this.exitFullscreenHandler, false);
  doc.addEventListener("mozfullscreenchange", this.exitFullscreenHandler, false);
  doc.addEventListener("fullscreenchange", this.exitFullscreenHandler, false);
  doc.addEventListener("MSFullscreenChange", this.exitFullscreenHandler, false);
}

function removeFullscreenChangeEvent() {
  var doc = window.document;

  doc.removeEventListener("webkitfullscreenchange", this.exitFullscreenHandler);
  doc.removeEventListener("mozfullscreenchange", this.exitFullscreenHandler);
  doc.removeEventListener("fullscreenchange", this.exitFullscreenHandler);
  doc.removeEventListener("MSFullscreenChange", this.exitFullscreenHandler);
}

function launchIntoFullscreen(elem) {
  if (elem.requestFullscreen) {
    elem.requestFullscreen();
  } else if (elem.msRequestFullscreen) {
    elem.msRequestFullscreen();
  } else if (elem.mozRequestFullScreen) {
    elem.mozRequestFullScreen();
  } else if (elem.webkitRequestFullscreen && allowWebkitFullscreenAPI()) {
    elem.webkitRequestFullscreen();
  }
}

function exitFullscreen() {
  if (document.exitFullscreen) {
    document.exitFullscreen();
  } else if (document.msExitFullscreen) {
    document.msExitFullscreen();
  } else if (document.mozCancelFullScreen) {
    document.mozCancelFullScreen();
  } else if (document.webkitExitFullscreen && allowWebkitFullscreenAPI()) {
    document.webkitExitFullscreen();
  } else {
    removeFullscreenChangeEvent.call(this);
    this.resizeInExitHandler = false;
  }
}

function allowWebkitFullscreenAPI() {
  return !(navigator.vendor && navigator.vendor.indexOf("Apple") > -1 && navigator.userAgent && !navigator.userAgent.match("CriOS"));
}

exports.default = ButtonList;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _requireAll = __webpack_require__(71);

var _requireAll2 = _interopRequireDefault(_requireAll);

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _iconset = __webpack_require__(10);

var iconset = _interopRequireWildcard(_iconset);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//dialogs
var dialogs = (0, _requireAll2.default)(__webpack_require__(475), 1);

/*!
 * VIZABI DIALOGS
 * Reusable dialogs component
 */

//default existing dialogs
var class_active = "vzb-active";
var class_expand_dialog = "vzb-dialog-side";

var Dialogs = _component2.default.extend({

  /**
   * Initializes the dialogs
   * @param config component configuration
   * @param context component context (parent)
   */
  init: function init(config, context) {

    //set properties
    var _this = this;
    this.name = "gapminder-dialogs";
    this._curr_dialog_index = 20;

    this.model_expects = [{
      name: "state",
      type: "model"
    }, {
      name: "ui",
      type: "ui"
    }, {
      name: "locale",
      type: "locale"
    }];

    this._available_dialogs = {
      "timedisplay": {
        dialog: dialogs.timedisplay
      },
      "find": {
        dialog: dialogs.find
      },
      "show": {
        dialog: dialogs.show
      },
      "moreoptions": {
        dialog: dialogs.moreoptions
      },
      "colors": {
        dialog: dialogs.colors
      },
      "size": {
        dialog: dialogs.size
      },
      "side": {
        dialog: dialogs.side
      },
      "label": {
        dialog: dialogs.label
      },
      "zoom": {
        dialog: dialogs.zoom
      },
      "axes": {
        dialog: dialogs.axes
      },
      "axesmc": {
        dialog: dialogs.axesmc
      },
      "stack": {
        dialog: dialogs.stack
      },
      "speed": {
        dialog: dialogs.speed
      },
      "opacity": {
        dialog: dialogs.opacity
      },
      "presentation": {
        dialog: dialogs.presentation
      },
      "about": {
        dialog: dialogs.about
      },
      "mapoptions": {
        dialog: dialogs.mapoptions
      }
    };

    this._super(config, context);
  },
  domReady: function domReady() {
    var dialog_popup = (this.model.ui.dialogs || {}).popup || [];
    var dialog_sidebar = (this.model.ui.dialogs || {}).sidebar || [];

    this.rootEl = this.root.element instanceof Array ? this.root.element : d3.select(this.root.element);

    // if dialog_sidebar has been passed in with boolean param or array must check and covert to array
    if (dialog_sidebar === true) {
      dialog_sidebar = dialog_popup;
      (this.model.ui.dialogs || {}).sidebar = dialog_sidebar;
    }
    if (dialog_sidebar.length !== 0) {
      this.rootEl.classed("vzb-dialog-expand-true", true);
    }
    this.dialog_popup = dialog_popup;
    this.dialog_sidebar = dialog_sidebar;
  },
  readyOnce: function readyOnce() {
    var _this = this;

    this.element = d3.select(this.placeholder);
    this.element.selectAll("div").remove();

    this._addDialogs(this.dialog_popup, this.dialog_sidebar);

    this.resize();

    if (this.dialog_popup.length !== 0) {
      this.root.findChildByName("gapminder-buttonlist").on("click", function (evt, button) {
        if (!_this._available_dialogs[button.id]) return;

        if (button.active) {
          _this.openDialog(button.id);
        } else {
          _this.closeDialog(button.id);
        }
      });

      var popupDialogs = this.element.selectAll(".vzb-top-dialog").filter(function (d) {
        return _this.dialog_popup.indexOf(d.id) > -1;
      });

      var close_buttons = popupDialogs.select(".vzb-top-dialog>.vzb-dialog-modal>.vzb-dialog-buttons>[data-click='closeDialog']");
      close_buttons.on("click", function (d, i) {
        _this.closeDialog(d.id);
      });

      var pinDialog = popupDialogs.select(".vzb-top-dialog>.vzb-dialog-modal>[data-click='pinDialog']");
      pinDialog.on("click", function (d, i) {
        _this.pinDialog(d.id);
      });

      this.rootEl.node().addEventListener("click", function () {
        _this.closeAllDialogs();
      });

      this.rootEl.on("mousedown", function (e) {
        if (!this._active_comp) return; //don't do anything if nothing is open

        var target = d3.event.target;
        var closeDialog = true;
        while (target) {
          if (target.classList.contains("vzb-dialog-modal")) {
            closeDialog = false;
            break;
          }
          target = target.parentElement;
        }
        if (closeDialog) {
          _this.closeAllDialogs();
        }
      });
    }

    this.element.on("click", function () {
      d3.event.stopPropagation();
    });
  },
  resize: function resize() {
    var _this = this;
    var profile = this.getLayoutProfile();

    this.element.selectAll(".vzb-top-dialog").each(function (d) {
      var dialogEl = d3.select(this);
      var cls = dialogEl.attr("class").replace(" vzb-popup", "").replace(" vzb-sidebar", "");

      if (profile === "large" && _this.dialog_sidebar.indexOf(d.id) > -1) {
        cls += " vzb-sidebar";
      } else if (_this.dialog_popup.indexOf(d.id) > -1) {
        cls += " vzb-popup";
      }

      dialogEl.attr("class", cls);
    });
  },


  /*
   * adds dialogs configuration to the components and template_data
   * @param {Array} dialog_list list of dialogs to be added
   */
  _addDialogs: function _addDialogs(dialog_popup, dialog_sidebar) {

    var profile = this.getLayoutProfile();
    var dialog_list = [];

    dialog_list = dialog_popup ? dialog_list.concat(dialog_popup) : dialog_list;
    dialog_list = dialog_sidebar ? dialog_list.concat(dialog_sidebar) : dialog_list;

    dialog_list = utils.unique(dialog_list);

    this._components_config = [];
    var details_dlgs = [];
    if (!dialog_list.length) return;
    //add a component for each dialog
    for (var i = 0; i < dialog_list.length; i++) {

      var dlg = dialog_list[i];
      var dlg_config = this._available_dialogs[dlg];

      //if it's a dialog, add component
      if (dlg_config && dlg_config.dialog) {
        var comps = this._components_config;

        //add corresponding component
        comps.push({
          component: dlg_config.dialog,
          placeholder: '.vzb-dialogs-dialog[data-dlg="' + dlg + '"]',
          model: ["state", "ui", "locale"]
        });

        dlg_config.component = comps.length - 1;
      }

      dlg_config.id = dlg;
      details_dlgs.push(dlg_config);
    }

    this.element.selectAll("div").data(details_dlgs).enter().append("div").attr("data-dlg", function (d) {
      return d.id;
    }).attr("class", "vzb-top-dialog vzb-dialogs-dialog vzb-dialog-shadow");

    this.loadSubComponents();

    var _this = this;
    //render each subcomponent
    utils.forEach(this.components, function (subcomp) {
      subcomp.render();
      _this.on("resize", function () {
        subcomp.trigger("resize");
      });
      subcomp.on("dragstart", function () {
        _this.bringForward(subcomp.name);
      });
      subcomp.on("close", function () {
        this.placeholderEl.each(function (d) {
          var evt = {};
          evt.id = d.id;
          _this.trigger("close", evt);
        });
      });
    });
  },
  bringForward: function bringForward(id) {
    var dialog = this.element.select(".vzb-popup.vzb-dialogs-dialog[data-dlg='" + id + "']");
    dialog.style("z-index", this._curr_dialog_index);
    this._curr_dialog_index += 10;
  },


  //TODO: make opening/closing a dialog via update and model
  /*
   * Activate a dialog
   * @param {String} id dialog id
   */
  openDialog: function openDialog(id) {
    //close pinned dialogs for small profile
    var forceClose = this.getLayoutProfile() === "small";
    this.closeAllDialogs(forceClose);

    var dialog = this.element.selectAll(".vzb-popup.vzb-dialogs-dialog[data-dlg='" + id + "']");

    this._active_comp = this.components[this._available_dialogs[id].component];

    this._active_comp.beforeOpen();
    //add classes
    dialog.classed(class_active, true);

    this.bringForward(id);

    //call component function
    this._active_comp.open();
  },
  pinDialog: function pinDialog(id) {
    var dialog = this.element.select(".vzb-popup.vzb-dialogs-dialog[data-dlg='" + id + "']");

    if (this._available_dialogs[id].ispin) {
      dialog.classed("pinned", false);
      this._available_dialogs[id].ispin = false;
    } else {
      dialog.classed("pinned", true);
      this._available_dialogs[id].ispin = true;
    }
  },


  /*
   * Closes a dialog
   * @param {String} id dialog id
   */
  closeDialog: function closeDialog(id) {
    var dialog = this.element.selectAll(".vzb-popup.vzb-dialogs-dialog[data-dlg='" + id + "']");

    this._active_comp = this.components[this._available_dialogs[id].component];

    if (this._active_comp && !this._active_comp.isOpen) return;

    if (this._available_dialogs[id].ispin) this.pinDialog(id);

    if (this._active_comp) {
      this._active_comp.beforeClose();
    }
    //remove classes
    dialog.classed(class_active, false);

    //call component close function
    if (this._active_comp) {
      this._active_comp.close();
    }
    this._active_comp = false;
  },


  /*
   * Close all dialogs
   */
  closeAllDialogs: function closeAllDialogs(forceclose) {
    var _this = this;
    //remove classes
    var dialogClass = forceclose ? ".vzb-popup.vzb-dialogs-dialog.vzb-active" : ".vzb-popup.vzb-dialogs-dialog.vzb-active:not(.pinned)";
    var all_dialogs = this.element.selectAll(dialogClass);
    all_dialogs.each(function (d) {
      _this.closeDialog(d.id);
    });
  }
});

exports.default = Dialogs;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var pIE            = __webpack_require__(70)
  , createDesc     = __webpack_require__(44)
  , toIObject      = __webpack_require__(21)
  , toPrimitive    = __webpack_require__(33)
  , has            = __webpack_require__(14)
  , IE8_DOM_DEFINE = __webpack_require__(161)
  , gOPD           = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(8) ? gOPD : function getOwnPropertyDescriptor(O, P){
  O = toIObject(O);
  P = toPrimitive(P, true);
  if(IE8_DOM_DEFINE)try {
    return gOPD(O, P);
  } catch(e){ /* empty */ }
  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has         = __webpack_require__(14)
  , toObject    = __webpack_require__(13)
  , IE_PROTO    = __webpack_require__(106)('IE_PROTO')
  , ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function(O){
  O = toObject(O);
  if(has(O, IE_PROTO))return O[IE_PROTO];
  if(typeof O.constructor == 'function' && O instanceof O.constructor){
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var precision = 1;

//constants
var class_playing = "vzb-playing";
var class_loading = "vzb-ts-loading";
var class_hide_play = "vzb-ts-hide-play-button";
var class_dragging = "vzb-ts-dragging";
var class_axis_aligned = "vzb-ts-axis-aligned";
var class_show_value = "vzb-ts-show-value";
var class_show_value_when_drag_play = "vzb-ts-show-value-when-drag-play";

//margins for slider
var profiles = {
  small: {
    margin: {
      top: 7,
      right: 15,
      bottom: 10,
      left: 15
    },
    radius: 8,
    label_spacing: 10
  },
  medium: {
    margin: {
      top: 16,
      right: 15,
      bottom: 10,
      left: 15
    },
    radius: 9,
    label_spacing: 12
  },
  large: {
    margin: {
      top: 14,
      right: 15,
      bottom: 10,
      left: 15
    },
    radius: 11,
    label_spacing: 14
  }
};

var presentationProfileChanges = {
  "medium": {
    margin: {
      top: 9
    }
  },
  "large": {
    margin: {}
  }
};

var TimeSlider = _component2.default.extend({
  /**
   * Initializes the timeslider.
   * Executed once before any template is rendered.
   * @param model The model passed to the component
   * @param context The component's parent
   */
  init: function init(model, context) {

    this.name = "gapminder-timeslider";
    this.template = this.template || __webpack_require__(456);
    this.prevPosition = null;
    //define expected models/hooks for this component
    this.model_expects = [{
      name: "time",
      type: "time"
    }, {
      name: "entities",
      type: "entities"
    }, {
      name: "marker",
      type: "model"
    }, {
      name: "ui",
      type: "ui"
    }];

    var _this = this;
    //binds methods to this model
    this.model_binds = {
      "change:time": function changeTime(evt, path) {
        if (_this.slide) {
          if (["time.start", "time.end"].indexOf(path) !== -1) {
            if (!_this.xScale) return;
            _this.changeLimits();
          }
          _this._optionClasses();
          //only set handle position if change is external
          if (!_this.model.time.dragging) _this._setHandle(_this.model.time.playing);
        }
      },
      "change:time.start": function changeTimeStart(evt, path) {
        if (_this.slide) {
          //only set handle position if change is external
          if (!_this.model.time.dragging) _this._setHandle(_this.model.time.playing);
        }
      },
      "change:time.end": function changeTimeEnd(evt, path) {
        if (_this.slide) {
          //only set handle position if change is external
          if (!_this.model.time.dragging) _this._setHandle(_this.model.time.playing);
        }
      },
      "change:time.startSelected": function changeTimeStartSelected(evt, path) {
        if (_this.slide) {
          _this.updateSelectedStartLimiter();
        }
      },
      "change:time.endSelected": function changeTimeEndSelected(evt, path) {
        if (_this.slide) {
          _this.updateSelectedEndLimiter();
        }
      },
      "change:marker.select": function changeMarkerSelect(evt, path) {
        _this.setSelectedLimits();
      }
    };

    // Same constructor as the superclass
    this._super(model, context);

    // Sort of defaults. Actually should be in ui default or bubblechart.
    // By not having "this.model.ui =" we prevent it from going to url (not defined in defaults)
    // Should be in defaults when we make components config part of external config (& every component gets own config)
    this.ui = utils.extend({
      show_limits: false,
      show_value: false,
      show_value_when_drag_play: true,
      show_button: true,
      class_axis_aligned: false
    }, model.ui, this.ui);

    //defaults
    this.width = 0;
    this.height = 0;
    this.availableTimeFrames = [];
    this.completedTimeFrames = [];
    this.getValueWidth = utils.memoize(this.getValueWidth);
    this._setTime = utils.throttle(this._setTime, 50);
  },


  //template is ready
  readyOnce: function readyOnce() {

    var _this = this;

    //DOM to d3
    //TODO: remove this ugly hack
    this.element = utils.isArray(this.element) ? this.element : d3.select(this.element);

    //html elements
    this.slider_outer = this.element.select(".vzb-ts-slider");
    this.slider = this.slider_outer.select("g");
    this.axis = this.element.select(".vzb-ts-slider-axis");
    this.select = this.element.select(".vzb-ts-slider-select");
    this.progressBar = this.element.select(".vzb-ts-slider-progress");
    this.slide = this.element.select(".vzb-ts-slider-slide");
    this.handle = this.element.select(".vzb-ts-slider-handle");
    this.valueText = this.element.select(".vzb-ts-slider-value");
    //Scale
    this.xScale = d3.time.scale.utc().clamp(true);

    //Axis
    this.xAxis = d3.axisBottom().tickSize(0);
    //Value
    this.valueText.attr("text-anchor", "middle").attr("dy", "-0.7em");

    var brushed = _this._getBrushed();
    var brushedEnd = _this._getBrushedEnd();

    //Brush for dragging
    // this.brush = d3.brushX()
    //   //.x(this.xScale)
    //   .extent([[0, 0], [0, 0]])
    //   .on("start brush", function () {
    //     brushed.call(this);
    //   })
    //   .on("end", function () {
    //     brushedEnd.call(this);
    //   });

    // //Slide
    // this.slide.call(this.brush);

    this.brush = d3.drag()
    //.on("start.interrupt", function() { _this.slide.interrupt(); })
    .on("start drag", function () {
      brushed.call(this);
    }).on("end", function () {
      brushedEnd.call(this);
    });

    //Slide
    this.slide.call(this.brush);

    this.slider_outer.on("mousewheel", function () {
      //do nothing and dont pass the event on if we are currently dragging the slider
      if (_this.model.time.dragging) {
        d3.event.stopPropagation();
        d3.event.preventDefault();
        d3.event.returnValue = false;
        return false;
      }
    });

    //this.slide.selectAll(".extent,.resize")
    //  .remove();

    this._setSelectedLimitsId = 0; //counter for setSelectedLimits

    if (this.model.time.startSelected > this.model.time.start) {
      _this.updateSelectedStartLimiter();
    }

    if (this.model.time.endSelected < this.model.time.end) {
      _this.updateSelectedEndLimiter();
    }

    // special for linechart: resize timeslider to match time x-axis length
    this.parent.on("myEvent", function (evt, arg) {
      var layoutProfile = _this.getLayoutProfile();

      if (arg.profile && arg.profile.margin) {
        profiles[layoutProfile].margin = arg.profile.margin;
      }

      // set the right margin that depends on longest label width
      _this.element.select(".vzb-ts-slider-wrapper").style("right", arg.mRight - profiles[layoutProfile].margin.right + "px");

      _this.updateSize([0, arg.rangeMax]);
    });

    this.on("resize", function () {
      _this.updateSize();
    });
  },


  //template and model are ready
  ready: function ready() {
    if (this.model.time.splash) return;

    this.element.classed(class_loading, false);

    var play = this.element.select(".vzb-ts-btn-play");
    var pause = this.element.select(".vzb-ts-btn-pause");
    var _this = this;
    var time = this.model.time;

    play.on("click", function () {

      _this.model.time.play();
    });

    pause.on("click", function () {
      _this.model.time.pause("soft");
    });

    this.changeLimits();
    this.changeTime();
    this.updateSize();

    _this._updateProgressBar();
    _this.model.marker.listenFramesQueue(null, function (time) {
      _this._updateProgressBar(time);
    });
    _this.setSelectedLimits(true);
  },
  changeLimits: function changeLimits() {
    var minValue = this.model.time.start;
    var maxValue = this.model.time.end;
    //scale
    this.xScale.domain([minValue, maxValue]);
    //axis
    this.xAxis.tickValues([minValue, maxValue]).tickFormat(this.model.time.getFormatter());
  },
  changeTime: function changeTime() {
    //time slider should always receive a time model
    var time = this.model.time.value;
    //special classes
    this._optionClasses();
  },


  /**
   * Executes everytime the container or vizabi is resized
   * Ideally,it contains only operations related to size
   */
  updateSize: function updateSize(range) {
    if (this.model.time.splash) return;

    this.model.time.pause();

    this.profile = this.getActiveProfile(profiles, presentationProfileChanges);

    var slider_w = parseInt(this.slider_outer.style("width"), 10) || 0;
    var slider_h = parseInt(this.slider_outer.style("height"), 10) || 0;

    if (!slider_h || !slider_w) return utils.warn("time slider resize() aborted because element is too small or has display:none");

    this.width = slider_w - this.profile.margin.left - this.profile.margin.right;
    this.height = slider_h - this.profile.margin.bottom - this.profile.margin.top;
    var _this = this;

    //translate according to margins
    this.slider.attr("transform", "translate(" + this.profile.margin.left + "," + this.profile.margin.top + ")");

    this.xScale.range(range || [0, this.width]);

    this.slide.attr("transform", "translate(0," + this.height / 2 + ")").attr("x1", this.xScale.range()[0]).attr("x2", this.xScale.range()[1]).style("stroke-width", this.profile.radius * 2 + "px");
    //.call(this.brush
    //.extent([[this.xScale.range()[0], 0], [this.xScale.range()[1], this.height]]));

    //adjust axis with scale
    this.xAxis = this.xAxis.scale(this.xScale).tickPadding(this.profile.label_spacing);

    this.axis.attr("transform", "translate(0," + this.height / 2 + ")").call(this.xAxis);

    this.select.attr("transform", "translate(0," + this.height / 2 + ")");
    this.progressBar.attr("transform", "translate(0," + this.height / 2 + ")");

    this.slide.select(".background").attr("height", this.height);

    //size of handle
    this.handle.attr("transform", "translate(0," + this.height / 2 + ")").attr("r", this.profile.radius);

    this.sliderWidth = _this.slider.node().getBoundingClientRect().width;

    this.resizeSelectedLimiters();
    this._resizeProgressBar();
    this._setHandle();
  },
  setSelectedLimits: function setSelectedLimits(force) {
    var _this = this;
    this._setSelectedLimitsId++;
    var _setSelectedLimitsId = this._setSelectedLimitsId;

    var select = _this.model.marker.select;
    if (select.length == 0) {
      _this.model.time.set({
        startSelected: new Date(_this.model.time.start),
        endSelected: new Date(_this.model.time.end)
      }, null, false /*make change non-persistent for URL and history*/);
      return;
    }
    var KEY = _this.model.entities.getDimension();
    var proms = [];
    utils.forEach(select, function (entity) {
      proms.push(_this.model.marker.getEntityLimits(entity[KEY]));
    });
    Promise.all(proms).then(function (limits) {
      if (_setSelectedLimitsId != _this._setSelectedLimitsId) return;
      var first = limits.shift();
      var min = first.min;
      var max = first.max;
      utils.forEach(limits, function (limit) {
        if (min - limit.min > 0) min = limit.min;
        if (max - limit.max < 0) max = limit.max;
      });
      _this.model.time.set({
        startSelected: d3.max([min, new Date(_this.model.time.start)]),
        endSelected: d3.min([max, new Date(_this.model.time.end)])
      }, force, false /*make change non-persistent for URL and history*/);
    });
  },
  updateSelectedStartLimiter: function updateSelectedStartLimiter() {
    var _this = this;
    this.select.select("#clip-start-" + _this._id).remove();
    this.select.select(".selected-start").remove();
    if (this.model.time.startSelected && this.model.time.startSelected > this.model.time.start) {
      this.select.append("clipPath").attr("id", "clip-start-" + _this._id).append("rect");
      this.select.append("path").attr("clip-path", "url(" + location.pathname + "#clip-start-" + _this._id + ")").classed("selected-start", true);
      this.resizeSelectedLimiters();
    }
  },
  updateSelectedEndLimiter: function updateSelectedEndLimiter() {
    var _this = this;
    this.select.select("#clip-end-" + _this._id).remove();
    this.select.select(".selected-end").remove();
    if (this.model.time.endSelected && this.model.time.endSelected < this.model.time.end) {
      this.select.append("clipPath").attr("id", "clip-end-" + _this._id).append("rect");
      this.select.append("path").attr("clip-path", "url(" + location.pathname + "#clip-end-" + _this._id + ")").classed("selected-end", true);
      this.resizeSelectedLimiters();
    }
  },
  resizeSelectedLimiters: function resizeSelectedLimiters() {
    var _this = this;
    this.select.select(".selected-start").attr("d", "M0,0H" + this.xScale(this.model.time.startSelected));
    this.select.select("#clip-start-" + _this._id).select("rect").attr("x", -this.height / 2).attr("y", -this.height / 2).attr("height", this.height).attr("width", this.xScale(this.model.time.startSelected) + this.height / 2);
    this.select.select(".selected-end").attr("d", "M" + this.xScale(this.model.time.endSelected) + ",0H" + this.xScale(this.model.time.end));
    this.select.select("#clip-end-" + _this._id).select("rect").attr("x", this.xScale(this.model.time.endSelected)).attr("y", -this.height / 2).attr("height", this.height).attr("width", this.xScale(this.model.time.end) - this.xScale(this.model.time.endSelected) + this.height / 2);
  },
  _resizeProgressBar: function _resizeProgressBar() {
    var _this = this;
    this.progressBar.selectAll("path").each(function (d) {
      d3.select(this).attr("d", "M" + _this.xScale(d[0]) + ",0H" + _this.xScale(d[1]));
    });
  },
  _updateProgressBar: function _updateProgressBar(time) {
    var _this = this;
    if (time) {
      if (_this.completedTimeFrames.indexOf(time) != -1) return;
      _this.completedTimeFrames.push(time);
      var next = _this.model.time.incrementTime(time);
      var prev = _this.model.time.decrementTime(time);
      if (next > _this.model.time.end) {
        if (time - _this.model.time.end == 0) {
          next = time;
          time = prev;
        } else {
          return;
        }
      }
      if (_this.availableTimeFrames.length == 0 || _this.availableTimeFrames[_this.availableTimeFrames.length - 1][1] < time) {
        _this.availableTimeFrames.push([time, next]);
      } else if (next < _this.availableTimeFrames[0][0]) {
        _this.availableTimeFrames.unshift([time, next]);
      } else {
        for (var i = 0; i < _this.availableTimeFrames.length; i++) {
          if (time - _this.availableTimeFrames[i][1] == 0) {
            if (i + 1 < _this.availableTimeFrames.length && next - _this.availableTimeFrames[i + 1][0] == 0) {
              _this.availableTimeFrames[i][1] = _this.availableTimeFrames[i + 1][1];
              _this.availableTimeFrames.splice(i + 1, 1);
            } else {
              _this.availableTimeFrames[i][1] = next;
            }
            break;
          }
          if (next - _this.availableTimeFrames[i][0] == 0) {
            _this.availableTimeFrames[i][0] = time;
            break;
          }
          if (time - _this.availableTimeFrames[i][1] > 0 && next - _this.availableTimeFrames[i + 1][0] < 0) {
            _this.availableTimeFrames.splice(i + 1, 0, [time, next]);
            break;
          }
        }
      }
    } else {
      _this.availableTimeFrames = [];
      _this.completedTimeFrames = [];
    }

    var progress = this.progressBar.selectAll("path").data(_this.availableTimeFrames);
    progress.exit().remove();
    progress.enter().append("path").attr("class", "domain").merge(progress).each(function (d) {
      var element = d3.select(this);
      element.attr("d", "M" + _this.xScale(d[0]) + ",0H" + _this.xScale(d[1])).classed("rounded", _this.availableTimeFrames.length == 1);
    });
  },


  /**
   * Returns width of slider text value.
   * Parameters in this function needed for memoize function, so they are not redundant.
   */
  getValueWidth: function getValueWidth(layout, value) {
    return this.valueText.node().getBoundingClientRect().width;
  },


  /**
   * Gets brushed function to be executed when dragging
   * @returns {Function} brushed function
   */
  _getBrushed: function _getBrushed() {
    var _this = this;
    return function () {

      if (_this.model.time.playing) _this.model.time.pause();

      _this._optionClasses();
      _this.element.classed(class_dragging, true);

      var value = void 0; // = _this.brush.extent()[0];
      //var value = d3.brushSelection(_this.slide.node());

      //if(!value) return;

      //set brushed properties

      if (d3.event.sourceEvent) {
        // Prevent window scrolling on cursor drag in Chrome/Chromium.
        d3.event.sourceEvent.preventDefault();

        _this.model.time.dragStart();
        var posX = utils.roundStep(Math.round(d3.mouse(this)[0]), precision);
        value = _this.xScale.invert(posX);
        var maxPosX = _this.width;

        if (posX > maxPosX) {
          posX = maxPosX;
        } else if (posX < 0) {
          posX = 0;
        }

        //set handle position
        _this.handle.attr("cx", posX);
        _this.valueText.attr("transform", "translate(" + posX + "," + _this.height / 2 + ")");
        _this.valueText.text(_this.model.time.formatDate(value, "ui"));
      }

      //set time according to dragged position
      if (value - _this.model.time.value !== 0) {
        _this._setTime(value);
      }
    };
  },


  /**
   * Gets brushedEnd function to be executed when dragging ends
   * @returns {Function} brushedEnd function
   */
  _getBrushedEnd: function _getBrushedEnd() {
    var _this = this;
    return function () {
      _this._setTime.recallLast();
      _this.element.classed(class_dragging, false);
      _this.model.time.dragStop();
      _this.model.time.snap();
    };
  },


  /**
   * Sets the handle to the correct position
   * @param {Boolean} transition whether to use transition or not
   */
  _setHandle: function _setHandle(transition) {
    var _this = this;
    var value = this.model.time.value;
    //this.slide.call(this.brush.extent([value, value]));
    var new_pos = this.xScale(value);
    //this.brush.move(this.slide, [new_pos, new_pos])

    this.element.classed("vzb-ts-disabled", this.model.time.end <= this.model.time.start);
    //    this.valueText.text(this.model.time.formatDate(value));

    //    var old_pos = this.handle.attr("cx");
    //var new_pos = this.xScale(value);
    if (_this.prevPosition == null) _this.prevPosition = new_pos;
    var delayAnimations = new_pos > _this.prevPosition ? this.model.time.delayAnimations : 0;
    if (transition) {
      this.handle.attr("cx", _this.prevPosition).transition().duration(delayAnimations).ease(d3.easeLinear).attr("cx", new_pos);

      this.valueText.attr("transform", "translate(" + _this.prevPosition + "," + this.height / 2 + ")").transition("text").delay(delayAnimations).text(this.model.time.formatDate(value, "ui"));
      this.valueText.transition().duration(delayAnimations).ease(d3.easeLinear).attr("transform", "translate(" + new_pos + "," + this.height / 2 + ")");
    } else {
      this.handle
      //cancel active transition
      .interrupt().attr("cx", new_pos);

      this.valueText
      //cancel active transition
      .interrupt().interrupt("text").transition("text");
      this.valueText.attr("transform", "translate(" + new_pos + "," + this.height / 2 + ")").text(this.model.time.formatDate(value, "ui"));
    }
    _this.prevPosition = new_pos;
  },


  /**
   * Sets the current time model to time
   * @param {number} time The time
   */
  _setTime: function _setTime(time) {
    //update state
    var _this = this;
    //  frameRate = 50;

    //avoid updating more than once in "frameRate"
    //var now = new Date();
    //if (this._updTime != null && now - this._updTime < frameRate) return;
    //this._updTime = now;
    var persistent = !this.model.time.dragging && !this.model.time.playing;
    _this.model.time.getModelObject("value").set(time, false, persistent); // non persistent
  },


  /**
   * Applies some classes to the element according to options
   */
  _optionClasses: function _optionClasses() {
    //show/hide classes

    var show_limits = this.ui.show_limits;
    var show_value = this.ui.show_value;
    var show_value_when_drag_play = this.ui.show_value_when_drag_play;
    var axis_aligned = this.ui.axis_aligned;
    var show_play = this.ui.show_button && this.model.time.playable;

    if (!show_limits) {
      this.xAxis.tickValues([]).ticks(0);
    }

    this.element.classed(class_hide_play, !show_play);
    this.element.classed(class_playing, this.model.time.playing);
    this.element.classed(class_show_value, show_value);
    this.element.classed(class_show_value_when_drag_play, show_value_when_drag_play);
    this.element.classed(class_axis_aligned, axis_aligned);
  }
});

exports.default = TimeSlider;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _class = __webpack_require__(16);

var _class2 = _interopRequireDefault(_class);

var _iconset = __webpack_require__(10);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*!
 * VIZABI INDICATOR PICKER
 * Reusable indicator picker component
 */

var INDICATOR = "which";
var SCALETYPE = "scaleType";
var MODELTYPE_COLOR = "color";
var MENU_HORIZONTAL = 1;
var MENU_VERTICAL = 2;

//css custom classes
var css = {
  wrapper: "vzb-treemenu-wrap",
  wrapper_outer: "vzb-treemenu-wrap-outer",
  background: "vzb-treemenu-background",
  close: "vzb-treemenu-close",
  search: "vzb-treemenu-search",
  list: "vzb-treemenu-list",
  list_outer: "vzb-treemenu-list-outer",
  list_item: "vzb-treemenu-list-item",
  list_item_leaf: "vzb-treemenu-list-item-leaf",
  leaf: "vzb-treemenu-leaf",
  leaf_content: "vzb-treemenu-leaf-content",
  leaf_content_item: "vzb-treemenu-leaf-content-item",
  leaf_content_item_title: "vzb-treemenu-leaf-content-item-title",
  leaf_content_item_descr: "vzb-treemenu-leaf-content-item-descr",
  hasChild: "vzb-treemenu-list-item-children",
  list_item_label: "vzb-treemenu-list-item-label",
  list_top_level: "vzb-treemenu-list-top",
  search_wrap: "vzb-treemenu-search-wrap",
  isSpecial: "vzb-treemenu-list-item-special",
  hidden: "vzb-hidden",
  title: "vzb-treemenu-title",
  scaletypes: "vzb-treemenu-scaletypes",
  scaletypesDisabled: "vzb-treemenu-scaletypes-disabled",
  scaletypesActive: "vzb-treemenu-scaletypes-active",
  alignYt: "vzb-align-y-top",
  alignYb: "vzb-align-y-bottom",
  alignXl: "vzb-align-x-left",
  alignXr: "vzb-align-x-right",
  alignXc: "vzb-align-x-center",
  menuHorizontal: "vzb-treemenu-horizontal",
  menuVertical: "vzb-treemenu-vertical",
  absPosVert: "vzb-treemenu-abs-pos-vert",
  absPosHoriz: "vzb-treemenu-abs-pos-horiz",
  menuOpenLeftSide: "vzb-treemenu-open-left-side",
  noTransition: "notransition"
};

//options and globals
var OPTIONS = {
  MOUSE_LOCS: [], //contains last locations of mouse
  MOUSE_LOCS_TRACKED: 3, //max number of locations of mouse
  DELAY: 200, //amazons multilevel delay
  TOLERANCE: 150, //this parameter is used for controlling the angle of multilevel dropdown
  LAST_DELAY_LOC: null, //this is cached location of mouse, when was a delay
  TIMEOUT: null, //timeout id
  SEARCH_PROPERTY: "id", //property in input data we we'll search by
  SUBMENUS: "children", //property for submenus (used by search)
  SEARCH_MIN_STR: 1, //minimal length of query string to start searching
  RESIZE_TIMEOUT: null, //container resize timeout
  MOBILE_BREAKPOINT: 400, //mobile breakpoint
  CURRENT_PATH: [], //current active path
  MIN_COL_WIDTH: 60, //minimal column size
  MENU_DIRECTION: MENU_HORIZONTAL,
  MAX_MENU_WIDTH: 320,
  MENU_OPEN_LEFTSIDE: false
};

var Menu = _class2.default.extend({
  init: function init(parent, menu, options) {
    var _this = this;
    this.parent = parent;
    this.entity = menu;
    this.OPTIONS = options;
    this.width = this.OPTIONS.MIN_COL_WIDTH;
    this.direction = this.OPTIONS.MENU_DIRECTION;
    this._setDirectionClass();
    this.menuItems = [];
    var menuItemsHolder = void 0;

    if (this.entity.empty()) return this;

    this.entity.each(function () {
      menuItemsHolder = d3.selectAll(this.childNodes).filter(function () {
        return d3.select(this).classed(css.list);
      });
    });
    if (menuItemsHolder.empty()) menuItemsHolder = this.entity;
    menu.selectAll("." + css.list_item).filter(function () {
      return this.parentNode == menuItemsHolder.node();
    }).each(function () {
      _this.addSubmenu(d3.select(this));
    });
    return this;
  },
  setWidth: function setWidth(width, recursive, immediate) {
    if (this.width != width && this.entity.node()) {
      this.width = width;
      if ((this.entity.classed(css.list_top_level) || this.entity.classed("active")) && this.direction == MENU_HORIZONTAL) {
        if (!immediate) {
          this.entity.transition().delay(0).duration(100).style("width", this.width + "px");
        } else {
          this.entity.style("width", this.width + "px");
        }
      }
      if (this.entity.classed(css.list_top_level)) {
        this.entity.selectAll("." + css.leaf).style("width", this.width - 1 + "px");
      }
      if (recursive) {
        for (var i = 0; i < this.menuItems.length; i++) {
          this.menuItems[i].setWidth(this.width, recursive, immediate);
        }
      }
      return this;
    }
  },

  /**
   * configure menu type (horizontal or vertical)
   * @param direction MENU_HORIZONTAL or MENU_VERTICAL
   * @param recursive change direction over menu sublevels
   * @returns {Menu}
   */
  setDirection: function setDirection(direction, recursive) {
    this.direction = direction;
    this.entity.style("width", "").style("height", "");
    if (recursive) {
      for (var i = 0; i < this.menuItems.length; i++) {
        this.menuItems[i].setDirection(this.direction, recursive);
      }
    }
    this._setDirectionClass();
    return this;
  },
  _setDirectionClass: function _setDirectionClass() {
    if (this.direction == MENU_HORIZONTAL) {
      this.entity.classed(css.menuVertical, false);
      this.entity.classed(css.menuHorizontal, true);
    } else {
      this.entity.classed(css.menuHorizontal, false);
      this.entity.classed(css.menuVertical, true);
    }
  },
  addSubmenu: function addSubmenu(item) {
    this.menuItems.push(new MenuItem(this, item, this.OPTIONS));
  },
  open: function open() {
    var _this = this;
    if (!this.isActive()) {
      _this.parent.parentMenu.openSubmenuNow = true;
      this.closeNeighbors(function () {
        if (_this.direction == MENU_HORIZONTAL) {
          _this._openHorizontal();
          _this.calculateMissingWidth(0);
        } else {
          _this._openVertical();
        }
      });
      _this.parent.parentMenu.openSubmenuNow = false;
    }
    return this;
  },

  /**
   * recursively calculate missed width for last menu level
   * @param width
   * @param cb
   */
  calculateMissingWidth: function calculateMissingWidth(width, cb) {
    var _this = this;
    if (this.entity.classed(css.list_top_level)) {
      if (width > this.OPTIONS.MAX_MENU_WIDTH) {
        if (typeof cb === "function") cb(width - this.OPTIONS.MAX_MENU_WIDTH);
      }
    } else {
      this.parent.parentMenu.calculateMissingWidth(width + this.width, function (widthToReduce) {
        if (widthToReduce > 0) {
          _this.reduceWidth(widthToReduce, function (newWidth) {
            if (typeof cb === "function") cb(newWidth); // callback is not defined if it is emitted from this level
          });
        } else if (typeof cb === "function") cb(widthToReduce);
      });
    }
  },

  /**
   * restore width (if it was reduced before)
   * @param width
   * @param isClosedElement (parameter for check if curent element emit this action)
   * @param cb
   */
  restoreWidth: function restoreWidth(width, isClosedElement, cb) {
    var _this = this;
    if (isClosedElement) {
      this.parent.parentMenu.restoreWidth(width, false, cb);
    } else if (width <= 0) {
      if (typeof cb === "function") cb();
    } else if (!this.entity.classed(css.list_top_level)) {
      var currentElementWidth = this.entity.node().offsetWidth;
      var newElementWidth = Math.min(width, _this.width);
      if (currentElementWidth < newElementWidth) {
        var duration = 250 * (currentElementWidth / newElementWidth);
        this.entity.transition().delay(0).duration(duration).style("width", newElementWidth + "px").on("end", function () {});
        _this.parent.parentMenu.restoreWidth(width - newElementWidth, false, cb);
      } else {
        this.parent.parentMenu.restoreWidth(width, false, cb);
      }
    } else {
      if (typeof cb === "function") cb();
    }
  },

  /**
   * made element narrower to free space for other element
   * @param width
   * @param cb
   */
  reduceWidth: function reduceWidth(width, cb) {
    var _this = this;
    var currWidth = this.entity.node().offsetWidth;

    if (currWidth <= this.OPTIONS.MIN_COL_WIDTH) {
      cb(width - _this.width + currWidth);
    } else {

      var newElementWidth = Math.max(this.OPTIONS.MIN_COL_WIDTH, _this.width - width);
      var duration = 250 / (_this.width / newElementWidth);
      this.entity.transition().delay(0).duration(duration).style("width", newElementWidth + "px").on("end", function () {
        cb(width - _this.width + newElementWidth);
      });
    }
  },
  _openHorizontal: function _openHorizontal() {
    var _this = this;
    _this.entity.classed("active", true).transition().delay(0).duration(250).style("width", _this.width + "px").on("end", function () {
      _this.marqueeToggle(true);
    });
  },
  _openVertical: function _openVertical() {
    var _this = this;
    _this.entity.style("height", "0px");
    _this.entity.transition().delay(0).duration(250).style("height", 36 * _this.menuItems.length + "px").on("end", function () {
      _this.entity.style("height", "auto");
      _this.marqueeToggle(true);
      _this.scrollToFitView();
    });
    _this.entity.classed("active", true);
  },
  closeAllChildren: function closeAllChildren(cb) {
    var callbacks = 0;
    for (var i = 0; i < this.menuItems.length; i++) {
      if (this.menuItems[i].isActive()) {
        ++callbacks;
        this.menuItems[i].submenu.close(function () {
          if (--callbacks == 0) {
            if (typeof cb === "function") cb();
          }
        });
      }
    }
    if (callbacks == 0) {
      if (typeof cb === "function") cb();
    }
  },
  closeNeighbors: function closeNeighbors(cb) {
    if (this.parent) {
      this.parent.closeNeighbors(cb);
    } else {
      cb();
    }
  },
  close: function close(cb) {
    var _this = this;
    this.closeAllChildren(function () {
      if (_this.direction == MENU_HORIZONTAL) {
        _this._closeHorizontal(cb);
      } else {
        _this._closeVertical(cb);
      }
    });
  },
  _closeHorizontal: function _closeHorizontal(cb) {
    var elementWidth = this.entity.node().offsetWidth;
    var _this = this;
    var openSubmenuNow = _this.parent.parentMenu.openSubmenuNow;
    _this.entity.transition().delay(0).duration(20).style("width", 0 + "px").on("end", function () {
      _this.marqueeToggle(false);
      _this.entity.classed("active", false);
      if (!openSubmenuNow) {
        _this.restoreWidth(_this.OPTIONS.MAX_MENU_WIDTH, true, function () {
          if (typeof cb === "function") cb();
        });
      } else {
        if (typeof cb === "function") cb();
      }
    });
  },
  _closeVertical: function _closeVertical(cb) {
    var _this = this;
    _this.entity.transition().delay(0).duration(100).style("height", 0 + "px").on("end", function () {
      _this.marqueeToggle(false);
      _this.entity.classed("active", false);
      if (typeof cb === "function") cb();
    });
  },
  isActive: function isActive() {
    return this.entity.classed("active");
  },
  hasActiveParentNeighbour: function hasActiveParentNeighbour() {
    return this.menuItems.filter(function (item) {
      return item.isActive();
    }).some(function (item) {
      return !!d3.select(item.entity).node().classed(css.hasChild);
    });
  },
  marqueeToggle: function marqueeToggle(toggle) {
    for (var i = 0; i < this.menuItems.length; i++) {
      this.menuItems[i].marqueeToggle(toggle);
    }
  },
  marqueeToggleAll: function marqueeToggleAll(toggle) {
    for (var i = 0; i < this.menuItems.length; i++) {
      this.menuItems[i].marqueeToggleAll(toggle);
    }
  },
  findItemById: function findItemById(id) {
    for (var i = 0; i < this.menuItems.length; i++) {
      if (this.menuItems[i].entity.data().id == id) {
        return this.menuItems[i];
      }
      if (this.menuItems[i].submenu) {
        var item = this.menuItems[i].submenu.findItemById(id);
        if (item) return item;
      }
    }
    return null;
  },
  getTopMenu: function getTopMenu() {
    return this.parent ? this.parent.parentMenu.getTopMenu() : this;
  },
  scrollToFitView: function scrollToFitView() {
    var treeMenuNode = this.getTopMenu().entity.node().parentNode;
    var parentItemNode = this.entity.node().parentNode;
    var menuRect = treeMenuNode.getBoundingClientRect();
    var itemRect = parentItemNode.getBoundingClientRect();
    var viewportItemTop = itemRect.top - menuRect.top;
    if (viewportItemTop + itemRect.height > menuRect.height) {
      var newItemTop = itemRect.height > menuRect.height ? menuRect.height - 10 : itemRect.height + 10;

      var newScrollTop = treeMenuNode.scrollTop + newItemTop - menuRect.height + viewportItemTop;

      var scrollTopTween = function scrollTopTween(scrollTop) {
        return function () {
          var i = d3.interpolateNumber(this.scrollTop, scrollTop);
          return function (t) {
            this.scrollTop = i(t);
          };
        };
      };

      d3.select(treeMenuNode).transition().duration(20).tween("scrolltoptween", scrollTopTween(newScrollTop));

      //treeMenuNode.scrollTop = scrollTop;
    }
  }
});

var MenuItem = _class2.default.extend({
  init: function init(parent, item, options) {
    var _this = this;
    this.parentMenu = parent;
    this.entity = item;
    var submenu = item.select("." + css.list_outer);
    if (submenu.node()) {
      this.submenu = new Menu(this, submenu, options);
    }
    this.entity.select("." + css.list_item_label).on("mouseenter", function () {
      if (utils.isTouchDevice()) return;

      if (_this.parentMenu.direction == MENU_HORIZONTAL && !d3.select(this).attr("children")) {
        _this.openSubmenu();
        _this.marqueeToggle(true);
      } else if (!_this.parentMenu.hasActiveParentNeighbour()) {
        _this.closeNeighbors();
      }
    }).on("click.item", function () {
      if (utils.isTouchDevice()) return;
      d3.event.stopPropagation();
      if (_this.parentMenu.direction == MENU_HORIZONTAL) {
        _this.openSubmenu();
      } else {
        var view = d3.select(this);
        //only for leaf nodes
        if (!view.attr("children")) return;
        _this.toggleSubmenu();
      }
    }).onTap(function (evt) {
      d3.event.stopPropagation();
      if (_this.parentMenu.direction == MENU_VERTICAL) {
        var view = _this.entity.select("." + css.list_item_label);
        //only for leaf nodes
        if (!view.attr("children")) return;
      }
      _this.toggleSubmenu();
    });
    return this;
  },
  setWidth: function setWidth(width, recursive, immediate) {
    if (this.submenu && recursive) {
      this.submenu.setWidth(width, recursive, immediate);
    }
    return this;
  },
  setDirection: function setDirection(direction, recursive) {
    if (this.submenu && recursive) {
      this.submenu.setDirection(direction, recursive);
    }
    return this;
  },
  toggleSubmenu: function toggleSubmenu() {
    if (this.submenu) {
      if (this.submenu.isActive()) {
        this.submenu.close();
      } else {
        this.submenu.open();
      }
    }
  },
  openSubmenu: function openSubmenu() {
    if (this.submenu) {
      this.submenu.open();
    } else {
      this.closeNeighbors();
    }
  },
  closeNeighbors: function closeNeighbors(cb) {
    this.parentMenu.closeAllChildren(cb);
  },
  isActive: function isActive() {
    return this.submenu && this.submenu.isActive();
  },
  marqueeToggleAll: function marqueeToggleAll(toggle) {
    var _this = this;
    var labels = this.entity.selectAll("." + css.list_item_label);
    labels.each(function () {
      var label = d3.select(this).select("span");
      var parent = d3.select(this.parentNode);
      parent.classed("marquee", false);
      label.style("left", "");
      label.style("right", "");
      if (toggle) {
        if (label.node().scrollWidth > label.node().offsetWidth) {
          label.attr("data-content", label.text());
          var space = 30;
          label.style("left", -space - label.node().scrollWidth + "px");
          label.style("right", -space - label.node().scrollWidth + "px");
          parent.classed("marquee", true);
        }
      }
    });
  },
  marqueeToggle: function marqueeToggle(toggle) {
    var label = this.entity.select("." + css.list_item_label).select("span");
    this.entity.classed("marquee", false);
    label.style("left", "");
    label.style("right", "");
    if (toggle) {
      if (label.node().scrollWidth > label.node().offsetWidth) {
        label.attr("data-content", label.text());
        var space = 30;
        label.style("left", -space - label.node().scrollWidth + "px");
        label.style("right", -space - label.node().scrollWidth + "px");
        this.entity.classed("marquee", true);
      }
    }
  }
});

var TreeMenu = _component2.default.extend({

  //setters-getters
  tree: function tree(input) {
    if (!arguments.length) return this._tree;
    this._tree = input;
    return this;
  },
  callback: function callback(input) {
    if (!arguments.length) return this._callback;
    this._callback = input;
    return this;
  },
  markerID: function markerID(input) {
    if (!arguments.length) return this._markerID;
    this._markerID = input;
    return this;
  },
  alignX: function alignX(input) {
    if (!arguments.length) return this._alignX;
    this._alignX = input;
    return this;
  },
  alignY: function alignY(input) {
    if (!arguments.length) return this._alignY;
    this._alignY = input;
    return this;
  },
  top: function top(input) {
    if (!arguments.length) return this._top;
    this._top = input;
    return this;
  },
  left: function left(input) {
    if (!arguments.length) return this._left;
    this._left = input;
    return this;
  },
  init: function init(config, context) {

    var _this = this;

    this.name = "gapminder-treemenu";
    this.model_expects = [{
      name: "marker",
      type: "model"
    }, {
      name: "marker_tags",
      type: "model"
    }, {
      name: "time",
      type: "time"
    }, {
      name: "locale",
      type: "locale"
    }];

    this.context = context;
    // object for manipulation with menu representation level
    this.menuEntity = null;
    this.model_binds = {
      "change:marker": function changeMarker(evt, path) {
        if (path.indexOf(_this._markerID + ".which") == -1 && path.indexOf(_this._markerID + ".scaleType") == -1) return;
        _this.updateView();
      }
    };

    //contructor is the same as any component
    this._super(config, context);

    //default callback
    this._callback = function (indicator) {
      console.log("Indicator selector: stub callback fired. New indicator is ", indicator);
    };
    this._alignX = "center";
    this._alignY = "center";

    //options
    this.OPTIONS = utils.deepClone(OPTIONS);
  },
  ready: function ready() {
    this.updateView();

    //TODO: hack! potentially unsafe operation here
    var tags = this.model.marker_tags.label.getData();
    this._buildIndicatorsTree(tags);
  },
  readyOnce: function readyOnce() {
    //this function is only called once at start, when both DOM and this.model are ready
    //this.element contains the view where you can append the menu
    this.element = d3.select(this.placeholder);
    //menu class private
    var _this = this;

    this.element.selectAll("div").remove();

    //general markup

    this.element.append("div").attr("class", css.background).on("click", function () {
      d3.event.stopPropagation();
      _this.toggle();
    });

    this.wrapperOuter = this.element.append("div").classed(css.wrapper_outer, true).classed(css.noTransition, true);

    this.wrapper = this.wrapperOuter.append("div").classed(css.wrapper, true).classed(css.noTransition, true).classed("vzb-dialog-scrollable", true);

    this.wrapper.on("click", function () {
      d3.event.stopPropagation();
    });

    this.wrapper.append("div").attr("class", css.close).html(_iconset.close).on("click", function () {
      d3.event.stopPropagation();
      _this.toggle();
    }).select("svg").attr("width", "0px").attr("height", "0px").attr("class", css.close + "-icon");

    this.wrapper.append("div").classed(css.scaletypes, true).append("span");
    this.wrapper.append("div").classed(css.title, true).append("span");

    this.wrapper.append("div").classed(css.search_wrap, true).append("input").classed(css.search, true).attr("type", "search").attr("id", css.search);

    //init functions
    d3.select("body").on("mousemove", _this._mousemoveDocument);
    this.wrapper.on("mouseleave", function () {
      //if(_this.menuEntity.direction != MENU_VERTICAL) _this.menuEntity.closeAllChildren();
    });

    this.translator = this.model.locale.getTFunction();

    _this._enableSearch();

    _this.resize();
  },
  _buildIndicatorsTree: function _buildIndicatorsTree(tagsArray) {
    if (tagsArray === true || !tagsArray) tagsArray = [];

    var _this = this;
    var ROOT = "_root";
    var DEFAULT = "_default";
    var UNCLASSIFIED = "_unclassified";
    var ADVANCED = "advanced";

    //init the dictionary of tags
    var tags = {};
    tags[ROOT] = { id: ROOT, children: [] };
    tags[UNCLASSIFIED] = { id: UNCLASSIFIED, type: "folder", name: this.translator("buttons/unclassified"), children: [] };

    //populate the dictionary of tags
    tagsArray.forEach(function (tag) {
      tags[tag.tag] = { id: tag.tag, name: tag.name, type: "folder", children: [] };
    });

    //init the tag tree
    var indicatorsTree = tags[ROOT];
    indicatorsTree.children.push(tags[UNCLASSIFIED]);

    //populate the tag tree
    tagsArray.forEach(function (tag) {
      if (!tag.parent || !tags[tag.parent]) {
        // add tag to a root
        indicatorsTree.children.push(tags[tag.tag]);
      } else {
        //add tag to a branch
        tags[tag.parent].children.push(tags[tag.tag]);
      }
    });

    utils.forEach(this.model.marker._root._data, function (dataSource) {
      if (dataSource._type !== "data") return;

      var indicatorsDB = dataSource.getConceptprops();
      var datasetName = dataSource.getDatasetName();
      tags[datasetName] = { id: datasetName, type: "dataset", children: [] };
      tags[ROOT].children.push(tags[datasetName]);

      utils.forEach(indicatorsDB, function (entry, id) {
        //if entry's tag are empty don't include it in the menu
        if (entry.tags == "_none") return;
        if (!entry.tags) entry.tags = datasetName || UNCLASSIFIED;
        var concept = { id: id, name: entry.name, unit: entry.unit, description: entry.description, dataSource: dataSource._name };
        entry.tags.split(",").forEach(function (tag) {
          if (tags[tag.trim()]) {
            tags[tag.trim()].children.push(concept);
          } else {
            //if entry's tag is not found in the tag dictionary
            if (!_this.consoleGroupOpen) {
              console.groupCollapsed("Some tags were are not found, so indicators went under 'Unclassified' menu");
              _this.consoleGroupOpen = true;
            }
            utils.warn("tag '" + tag + "' for indicator '" + id + "'");
            tags[UNCLASSIFIED].children.push(concept);
          }
        });
      });
    });
    if (_this.consoleGroupOpen) {
      console.groupEnd();
      delete _this.consoleGroupOpen;
    }
    this._sortChildren(indicatorsTree);
    this.indicatorsTree = indicatorsTree;
  },
  _sortChildren: function _sortChildren(tree, isSubfolder) {
    var _this = this;
    if (!tree.children) return;
    tree.children.sort(utils
    //in each folder including root: put subfolders below loose items
    .firstBy()(function (a, b) {
      a = a.type === "dataset" ? 1 : 0;b = b.type === "dataset" ? 1 : 0;return b - a;
    }).thenBy(function (a, b) {
      a = a.children ? 1 : 0;b = b.children ? 1 : 0;return a - b;
    }).thenBy(function (a, b) {
      //in the root level put "time" on top and send "anvanced" to the bottom
      if (!isSubfolder) {
        if (a.id == "time") return -1;
        if (b.id == "time") return 1;
        if (a.id == "advanced") return 1;
        if (b.id == "advanced") return -1;
        if (a.id == "_default") return 1;
        if (b.id == "_default") return -1;
      }
      //sort items alphabetically. folders go down because of the emoji folder in the beginning of the name
      return a.name > b.name ? 1 : -1;
    }));

    //recursively sort items in subfolders too
    tree.children.forEach(function (d) {
      _this._sortChildren(d, true);
    });
  },


  //happens on resizing of the container
  resize: function resize() {
    var _this = this;

    this.profiles = {
      "small": {
        col_width: 200
      },
      "medium": {
        col_width: 200
      },
      "large": {
        col_width: 200
      }
    };

    var top = this._top;
    var left = this._left;

    this.wrapper.classed(css.noTransition, true);
    this.wrapper.node().scrollTop = 0;

    this.activeProfile = this.profiles[this.getLayoutProfile()];
    this.OPTIONS.IS_MOBILE = this.getLayoutProfile() === "small";

    if (this.menuEntity) {
      this.menuEntity.setWidth(this.activeProfile.col_width, true, true);

      if (this.OPTIONS.IS_MOBILE) {
        if (this.menuEntity.direction != MENU_VERTICAL) {
          this.menuEntity.setDirection(MENU_VERTICAL, true);
          this.OPTIONS.MENU_DIRECTION = MENU_VERTICAL;
        }
      } else {
        if (this.menuEntity.direction != MENU_HORIZONTAL) {
          this.menuEntity.setDirection(MENU_HORIZONTAL, true);
          this.OPTIONS.MENU_DIRECTION = MENU_HORIZONTAL;
        }
      }
    }

    this.width = _this.element.node().offsetWidth;
    this.height = _this.element.node().offsetHeight;
    var rect = this.wrapperOuter.node().getBoundingClientRect();
    var containerWidth = rect.width;
    var containerHeight = rect.height;
    if (containerWidth) {
      if (this.OPTIONS.IS_MOBILE) {
        this.clearPos();
      } else {
        if (top || left) {
          if (this.wrapperOuter.node().offsetTop < 10) {
            this.wrapperOuter.style("top", "10px");
          }
          if (this.height - _this.wrapperOuter.node().offsetTop - containerHeight < 0) {
            if (containerHeight > this.height) {
              containerHeight = this.height - 20;
            }
            this.wrapperOuter.style("top", this.height - containerHeight - 10 + "px");
            this.wrapperOuter.style("bottom", "auto");
          }
          if (top) top = _this.wrapperOuter.node().offsetTop;
        }

        var maxHeight = void 0;
        if (this.wrapperOuter.classed(css.alignYb)) {
          maxHeight = this.wrapperOuter.node().offsetTop + this.wrapperOuter.node().offsetHeight;
        } else {
          maxHeight = this.height - this.wrapperOuter.node().offsetTop;
        }
        this.wrapper.style("max-height", maxHeight - 10 + "px");

        this.wrapperOuter.classed(css.alignXc, this._alignX === "center");
        this.wrapperOuter.style("margin-left", this._alignX === "center" ? "-" + containerWidth / 2 + "px" : null);
        if (this._alignX === "center") {
          this.OPTIONS.MAX_MENU_WIDTH = this.width / 2 - containerWidth * 0.5 - 10;
        } else {
          this.OPTIONS.MAX_MENU_WIDTH = this.width - this.wrapperOuter.node().offsetLeft - containerWidth - 10; // 10 - padding around wrapper
        }

        var minMenuWidth = this.activeProfile.col_width + this.OPTIONS.MIN_COL_WIDTH * 2;
        var leftPos = this.wrapperOuter.node().offsetLeft;
        this.OPTIONS.MENU_OPEN_LEFTSIDE = this.OPTIONS.MAX_MENU_WIDTH < minMenuWidth && leftPos > this.OPTIONS.MAX_MENU_WIDTH + 10;
        if (this.OPTIONS.MENU_OPEN_LEFTSIDE) {
          if (leftPos < minMenuWidth + 10) leftPos = minMenuWidth + 10;
          this.OPTIONS.MAX_MENU_WIDTH = leftPos - 10; // 10 - padding around wrapper
        } else {
          if (this.OPTIONS.MAX_MENU_WIDTH < minMenuWidth) {
            leftPos -= minMenuWidth - this.OPTIONS.MAX_MENU_WIDTH;
            this.OPTIONS.MAX_MENU_WIDTH = minMenuWidth;
          }
        }

        if (left) {
          left = leftPos;
        } else {
          if (leftPos != this.wrapperOuter.node().offsetLeft) {
            this.wrapperOuter.style("left", "auto");
            this.wrapperOuter.style("right", this.width - leftPos - rect.width + "px");
          }
        }

        this._top = top;
        this._left = left;

        if (left || top) this.setPos();

        this.wrapperOuter.classed("vzb-treemenu-open-left-side", !this.OPTIONS.IS_MOBILE && this.OPTIONS.MENU_OPEN_LEFTSIDE);
      }
    }

    this.wrapper.node().offsetHeight;
    this.wrapper.classed(css.noTransition, false);

    this.setHorizontalMenuHeight();

    return this;
  },
  toggle: function toggle() {
    var _this = this;
    var hidden = !this.element.classed(css.hidden);
    this.element.classed(css.hidden, hidden);

    if (hidden) {
      this.clearPos();
      this.menuEntity.marqueeToggle(false);
    } else {
      if (top || left) this.setPos();
      this.resize();
      this.scrollToSelected();
    }

    this.wrapper.classed(css.noTransition, hidden);

    this.parent.components.forEach(function (c) {
      if (c.name == "gapminder-dialogs") {
        d3.select(c.placeholder.parentNode).classed("vzb-blur", !hidden);
      } else if (c.element.classed) {
        c.element.classed("vzb-blur", c != _this && !hidden);
      } else {
        d3.select(c.element).classed("vzb-blur", c != _this && !hidden);
      }
    });

    this.width = _this.element.node().offsetWidth;
  },
  scrollToSelected: function scrollToSelected() {
    var _this = this;
    var scrollToItem = function scrollToItem(listNode, itemNode) {
      listNode.scrollTop = 0;
      var rect = listNode.getBoundingClientRect();
      var itemRect = itemNode.getBoundingClientRect();
      var scrollTop = itemRect.bottom - rect.top - listNode.offsetHeight + 10;
      listNode.scrollTop = scrollTop;
    };

    if (this.menuEntity.direction == MENU_VERTICAL) {
      scrollToItem(this.wrapper.node(), this.selectedNode);
      _this.menuEntity.marqueeToggleAll(true);
    } else {
      var selectedItem = this.menuEntity.findItemById(d3.select(this.selectedNode).data().id);
      selectedItem.submenu.calculateMissingWidth(0, function () {
        _this.menuEntity.marqueeToggleAll(true);
      });

      var parent = this.selectedNode;
      var listNode = void 0;
      while (!utils.hasClass(parent, css.list_top_level)) {
        if (parent.tagName == "LI") {
          listNode = utils.hasClass(parent.parentNode, css.list_top_level) ? parent.parentNode.parentNode : parent.parentNode;
          scrollToItem(listNode, parent);
        }
        parent = parent.parentNode;
      }
    }
  },
  setPos: function setPos() {
    var top = this._top;
    var left = this._left;
    var rect = this.wrapperOuter.node().getBoundingClientRect();

    if (top) {
      this.wrapperOuter.style("top", top + "px");
      this.wrapperOuter.style("bottom", "auto");
      this.wrapperOuter.classed(css.absPosVert, top);
    }
    if (left) {
      var right = this.element.node().offsetWidth - left - rect.width;
      right = right < 10 ? 10 : right;
      this.wrapperOuter.style("right", right + "px");
      this.wrapperOuter.style("left", "auto");
      this.wrapperOuter.classed(css.absPosHoriz, right);
    }
  },
  clearPos: function clearPos() {
    this._top = "";
    this._left = "";
    this.wrapperOuter.attr("style", "");
    this.wrapperOuter.classed(css.absPosVert, "");
    this.wrapperOuter.classed(css.absPosHoriz, "");
    this.wrapperOuter.classed(css.menuOpenLeftSide, "");
    this.wrapper.style("max-height", "");
  },
  setHorizontalMenuHeight: function setHorizontalMenuHeight() {
    var wrapperHeight = null;
    if (this.menuEntity && this.OPTIONS.MENU_DIRECTION == MENU_HORIZONTAL && this.menuEntity.menuItems.length) {
      var oneItemHeight = parseInt(this.menuEntity.menuItems[0].entity.style("height"), 10);
      var menuMaxHeight = oneItemHeight * this._maxChildCount;
      var rootMenuHeight = Math.max(this.menuEntity.menuItems.length, 3) * oneItemHeight + this.menuEntity.entity.node().offsetTop + parseInt(this.wrapper.style("padding-bottom"), 10);
      wrapperHeight = "" + Math.max(menuMaxHeight, rootMenuHeight) + "px";
    }
    this.wrapper.classed(css.noTransition, true);
    this.wrapper.node().offsetHeight;
    this.wrapper.style("height", wrapperHeight);
    this.wrapper.node().offsetHeight;
    this.wrapper.classed(css.noTransition, false);
  },

  //search listener
  _enableSearch: function _enableSearch() {
    var _this = this;

    var input = this.wrapper.select("." + css.search);

    //it forms the array of possible queries
    var getMatches = function getMatches(value) {
      var matches = {
        _id: "root",
        children: []
      };

      //translation integration
      var translationMatch = function translationMatch(value, data, i) {

        var translate = data[i].name;
        if (!translate && _this.translator) {
          var t1 = _this.translator("indicator" + "/" + data[i][_this.OPTIONS.SEARCH_PROPERTY] + "/" + _this.model.marker[_this._markerID]._type);
          translate = t1 || _this.translator("indicator/" + data[i][_this.OPTIONS.SEARCH_PROPERTY]);
        }
        return translate && translate.toLowerCase().indexOf(value.toLowerCase()) >= 0;
      };

      var matching = function matching(data) {
        var SUBMENUS = _this.OPTIONS.SUBMENUS;
        for (var i = 0; i < data.length; i++) {
          var match = false;
          match = translationMatch(value, data, i);
          if (match) {
            matches.children.push(data[i]);
          }
          if (!match && data[i][SUBMENUS]) {
            matching(data[i][SUBMENUS]);
          }
        }
      };
      matching(_this.dataFiltered.children);
      return matches;
    };

    var searchValueNonEmpty = false;

    var searchIt = utils.debounce(function () {
      var value = input.node().value;

      //Protection from unwanted IE11 input events.
      //IE11 triggers an 'input' event when 'placeholder' attr is set to input element and
      //on 'focusin' and on 'focusout', if nothing has been entered into the input.
      if (!searchValueNonEmpty && value == "") return;
      searchValueNonEmpty = value != "";

      if (value.length >= _this.OPTIONS.SEARCH_MIN_STR) {
        _this.redraw(getMatches(value), true);
      } else {
        _this.redraw();
      }
    }, 250);

    input.on("input", searchIt);
  },
  _selectIndicator: function _selectIndicator(value) {
    this._callback("which", value, this._markerID);
    this.toggle();
  },


  //function is redrawing data and built structure
  redraw: function redraw(data, useDataFiltered) {
    var _this = this;

    var markerID = this._markerID;

    var dataFiltered = void 0,
        allowedIDs = void 0;

    var indicatorsDB = {};
    utils.forEach(this.model.marker._root._data, function (m) {
      if (m._type === "data") utils.deepExtend(indicatorsDB, m.getConceptprops());
    });

    var hookType = _this.model.marker[markerID]._type;

    if (useDataFiltered) {
      dataFiltered = data;
    } else {
      if (data == null) data = this._tree;

      allowedIDs = utils.keys(indicatorsDB).filter(function (f) {
        //check if indicator is denied to show with allow->names->!indicator
        if (_this.model.marker[markerID].allow && _this.model.marker[markerID].allow.names) {
          if (_this.model.marker[markerID].allow.names.indexOf("!" + f) != -1) return false;
          if (_this.model.marker[markerID].allow.names.indexOf(f) != -1) return true;
        }
        //keep indicator if nothing is specified in tool properties
        if (!_this.model.marker[markerID].allow || !_this.model.marker[markerID].allow.scales) return true;
        //keep indicator if any scale is allowed in tool properties
        if (_this.model.marker[markerID].allow.scales[0] == "*") return true;

        // if no scales defined, all are allowed
        if (!indicatorsDB[f].scales) return true;

        //check if there is an intersection between the allowed tool scale types and the ones of indicator
        for (var i = indicatorsDB[f].scales.length - 1; i >= 0; i--) {
          if (_this.model.marker[markerID].allow.scales.indexOf(indicatorsDB[f].scales[i]) > -1) return true;
        }

        return false;
      });

      dataFiltered = utils.pruneTree(data, function (f) {
        return allowedIDs.indexOf(f.id) > -1;
      });

      this.dataFiltered = dataFiltered;
    }

    this.wrapper.select("ul").remove();

    this.element.select("." + css.title).select("span").text(this.translator("buttons/" + markerID));

    this.element.select("." + css.search).attr("placeholder", this.translator("placeholder/search") + "...");

    this._maxChildCount = 0;

    var createSubmeny = function createSubmeny(select, data, toplevel) {
      if (!data.children) return;
      _this._maxChildCount = Math.max(_this._maxChildCount, data.children.length);
      var _select = toplevel ? select : select.append("div").classed(css.list_outer, true);

      var li = _select.append("ul").classed(css.list, !toplevel).classed(css.list_top_level, toplevel).classed("vzb-dialog-scrollable", true).selectAll("li").data(data.children, function (d) {
        return d["id"];
      }).enter().append("li");

      li.append("span").classed(css.list_item_label, true)
      // .attr("info", function(d) {
      //   return d.id;
      // })
      .attr("children", function (d) {
        return d.children ? "true" : null;
      }).attr("type", function (d) {
        return d.type ? d.type : null;
      }).on("click", function (d) {
        var view = d3.select(this);
        //only for leaf nodes
        if (view.attr("children")) return;
        d3.event.stopPropagation();
        _this._selectIndicator({ concept: d.id, dataSource: d.dataSource });
      }).append("span").text(function (d) {
        //Let the indicator "_default" in tree menu be translated differnetly for every hook type
        var translated = d.id === "_default" ? _this.translator("indicator/_default/" + hookType) : d.name || d.id;
        if (!translated && translated !== "") utils.warn("translation missing: NAME of " + d.id);
        return translated || "";
      });

      li.classed(css.list_item, true).classed(css.hasChild, function (d) {
        return d["children"];
      }).classed(css.isSpecial, function (d) {
        return d["special"];
      }).each(function (d) {
        var view = d3.select(this);

        //deepLeaf
        if (!d.children) {
          var deepLeaf = view.append("div").attr("class", css.menuHorizontal + " " + css.list_outer + " " + css.list_item_leaf);
          deepLeaf.on("click", function (d) {
            _this._selectIndicator({ concept: d.id, dataSource: d.dataSource });
          });
          var deepLeafContent = deepLeaf.append("div").classed(css.leaf + " " + css.leaf_content + " vzb-dialog-scrollable", true);
          deepLeafContent.append("span").classed(css.leaf_content_item + " " + css.leaf_content_item_title, true).text(function (d) {
            //Let the indicator "_default" in tree menu be translated differnetly for every hook type
            var translated = d.id === "_default" ? _this.translator("indicator/_default/" + hookType) : d.name;
            return translated || "";
          });
          var hideUnits = void 0;
          var units = deepLeafContent.append("span").classed(css.leaf_content_item, true).text(function (d) {
            //Let the indicator "_default" in tree menu be translated differnetly for every hook type
            var translated = d.id === "_default" ? _this.translator("unit/_default/" + hookType) : d.unit;
            hideUnits = !translated;
            return _this.translator("hints/units") + ": " + translated || "";
          });
          units.classed("vzb-hidden", hideUnits);
          var hideDescription = void 0;
          var description = deepLeafContent.append("span").classed(css.leaf_content_item + " " + css.leaf_content_item_descr, true).text(function (d) {
            //Let the indicator "_default" in tree menu be translated differnetly for every hook type
            var translated = d.id === "_default" ? _this.translator("description/_default/" + hookType) : d.description;
            hideDescription = !translated;
            return hideUnits && hideDescription ? _this.translator("hints/nodescr") : translated || "";
          });
          description.classed("vzb-hidden", hideDescription && !hideUnits);
        }

        if (d.id == _this.model.marker[markerID].which) {
          var parent = void 0;
          if (_this.selectedNode && toplevel) {
            parent = _this.selectedNode.parentNode;
            d3.select(_this.selectedNode).select("." + css.list_item_leaf).classed("active", false);
            while (!utils.hasClass(parent, css.list_top_level)) {
              if (parent.tagName == "UL") {
                d3.select(parent.parentNode).classed("active", false);
              }
              parent = parent.parentNode;
            }
          }
          if (!_this.selectedNode || toplevel) {
            parent = this.parentNode;
            d3.select(this).classed("item-active", true).select("." + css.list_item_leaf).classed("active", true);
            while (!utils.hasClass(parent, css.list_top_level)) {
              if (parent.tagName == "UL") {
                d3.select(parent.parentNode).classed("active", true);
              }
              if (parent.tagName == "LI") {
                d3.select(parent).classed("item-active", true);
              }
              parent = parent.parentNode;
            }
            _this.selectedNode = this;
          }
        }
        createSubmeny(view, d);
      });
    };

    if (this.OPTIONS.IS_MOBILE) {
      this.OPTIONS.MENU_DIRECTION = MENU_VERTICAL;
    } else {
      this.OPTIONS.MENU_DIRECTION = MENU_HORIZONTAL;
    }
    this.selectedNode = null;
    createSubmeny(this.wrapper, dataFiltered, true);
    this.menuEntity = new Menu(null, this.wrapper.selectAll("." + css.list_top_level), this.OPTIONS);
    if (this.menuEntity) this.menuEntity.setDirection(this.OPTIONS.MENU_DIRECTION);
    if (this.menuEntity) this.menuEntity.setWidth(this.activeProfile.col_width, true, true);

    this.setHorizontalMenuHeight();

    if (!useDataFiltered) {
      var pointer = "_default";
      if (allowedIDs.indexOf(this.model.marker[markerID].which) > -1) pointer = this.model.marker[markerID].which;
      if (!indicatorsDB[pointer]) utils.error("Concept properties of " + pointer + " are missing from the set, or the set is empty. Put a breakpoint here and check what you have in indicatorsDB");

      if (!indicatorsDB[pointer].scales) {
        this.element.select("." + css.scaletypes).classed(css.hidden, true);
        return true;
      }
      var scaleTypesData = indicatorsDB[pointer].scales.filter(function (f) {
        if (!_this.model.marker[markerID].allow || !_this.model.marker[markerID].allow.scales) return true;
        if (_this.model.marker[markerID].allow.scales[0] == "*") return true;
        return _this.model.marker[markerID].allow.scales.indexOf(f) > -1;
      });
      if (scaleTypesData.length == 0) {
        this.element.select("." + css.scaletypes).classed(css.hidden, true);
      } else {

        var scaleTypes = this.element.select("." + css.scaletypes).classed(css.hidden, false).selectAll("span").data(scaleTypesData, function (d) {
          return d;
        });

        scaleTypes.exit().remove();

        scaleTypes = scaleTypes.enter().append("span").on("click", function (d) {
          d3.event.stopPropagation();
          _this._setModel("scaleType", d, _this._markerID);
        }).merge(scaleTypes);

        var mdlScaleType = _this.model.marker[markerID].scaleType;

        scaleTypes.classed(css.scaletypesDisabled, scaleTypesData.length < 2).classed(css.scaletypesActive, function (d) {
          return (d == mdlScaleType || d === "log" && mdlScaleType === "genericLog") && scaleTypesData.length > 1;
        }).text(function (d) {
          return _this.translator("scaletype/" + d);
        });
      }
    }

    return this;
  },
  updateView: function updateView() {
    var _this = this;

    if (!this._markerID) return;

    this.wrapperOuter.classed(css.absPosVert, this._top);
    this.wrapperOuter.classed(css.alignYt, this._alignY === "top");
    this.wrapperOuter.classed(css.alignYb, this._alignY === "bottom");
    this.wrapperOuter.classed(css.absPosHoriz, this._left);
    this.wrapperOuter.classed(css.alignXl, this._alignX === "left");
    this.wrapperOuter.classed(css.alignXr, this._alignX === "right");

    var setModel = this._setModel.bind(this);
    this.callback(setModel).tree(this.indicatorsTree).redraw();

    this.wrapper.select("." + css.search).node().value = "";

    return this;
  },
  _setModel: function _setModel(what, value, hookID) {

    var mdl = this.model.marker[hookID];
    if (what == "which") mdl.setWhich(value);
    if (what == "scaleType") mdl.setScaleType(value);
  }
});

exports.default = TreeMenu;

/***/ }),
/* 28 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};

/***/ }),
/* 29 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(5);

module.exports = function(method, arg){
  return !!method && fails(function(){
    arg ? method.call(null, function(){}, 1) : method.call(null);
  });
};

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx      = __webpack_require__(37)
  , IObject  = __webpack_require__(69)
  , toObject = __webpack_require__(13)
  , toLength = __webpack_require__(12)
  , asc      = __webpack_require__(236);
module.exports = function(TYPE, $create){
  var IS_MAP        = TYPE == 1
    , IS_FILTER     = TYPE == 2
    , IS_SOME       = TYPE == 3
    , IS_EVERY      = TYPE == 4
    , IS_FIND_INDEX = TYPE == 6
    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
    , create        = $create || asc;
  return function($this, callbackfn, that){
    var O      = toObject($this)
      , self   = IObject(O)
      , f      = ctx(callbackfn, that, 3)
      , length = toLength(self.length)
      , index  = 0
      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
      , val, res;
    for(;length > index; index++)if(NO_HOLES || index in self){
      val = self[index];
      res = f(val, index, O);
      if(TYPE){
        if(IS_MAP)result[index] = res;            // map
        else if(res)switch(TYPE){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(IS_EVERY)return false;          // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(0)
  , core    = __webpack_require__(36)
  , fails   = __webpack_require__(5);
module.exports = function(KEY, exec){
  var fn  = (core.Object || {})[KEY] || Object[KEY]
    , exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
};

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(6);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S){
  if(!isObject(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  ext_resources: {},
  build: 1488202909259,
  version: "0.19.1"
};

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _iconset = __webpack_require__(10);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var hidden = true;
var showNotes = false;
var _pin = false;
var left = 0;
var top = 0;
var hookName = null;
var newHookName = null;

var DataNotes = _component2.default.extend({
  init: function init(config, context) {
    var _this = this;

    this.name = "gapminder-datanotes";

    this.model_expects = [{
      name: "marker",
      type: "model"
    }, {
      name: "locale",
      type: "locale"
    }];

    this.context = context;

    this.model_binds = {
      "translate:locale": function translateLocale(evt) {
        if (!_this._ready || !_this._readyOnce) return;
        _this.ready();
      }
    };

    //contructor is the same as any component
    this._super(config, context);

    this.close = this.close.bind(this);
  },
  ready: function ready() {
    this.setValues();
  },
  readyOnce: function readyOnce() {
    var _this = this;

    this.translator = this.model.locale.getTFunction();
    this.element = d3.select(this.placeholder);

    this.element.selectAll("div").remove();

    var container = this.element;

    container.append("div").html(_iconset.close).on("click", function () {
      d3.event.stopPropagation();
      _this.close();
    }).select("svg").attr("width", "0px").attr("height", "0px").attr("class", "vzb-data-notes-close").classed("vzb-hidden", true);

    container.append("div").attr("class", "vzb-data-notes-body vzb-dialog-scrollable");

    container.append("div").attr("class", "vzb-data-notes-link");
  },
  resize: function resize() {
    this.close();
  },
  close: function close() {
    if (!hidden) {
      this.pin(false).hide();
    }
  },
  setHook: function setHook(_hookName) {
    if (!this._readyOnce) return this;
    if (_pin) {
      newHookName = _hookName;
      return this;
    }
    if (hookName) this.model.marker[hookName].off("change:which", this.close);
    hookName = newHookName = _hookName;
    this.model.marker[hookName].on("change:which", this.close);

    this.setValues();

    return this;
  },
  setValues: function setValues() {
    if (!hookName) return;
    var hook = this.model.marker[hookName];
    var concept = hook.getConceptprops();

    this.element.select(".vzb-data-notes-body").classed("vzb-hidden", !concept.description).text(concept.description || "");

    this.element.select(".vzb-data-notes-link").classed("vzb-hidden", !concept.sourceLink);

    if (concept.sourceLink) {
      var _source = this.translator("hints/source");
      var sourceName = concept.sourceName || "";
      this.element.select(".vzb-data-notes-link").html("<span>" + (sourceName ? _source + ":" : "") + '<a href="' + concept.sourceLink + '" target="_blank">' + (sourceName ? sourceName : _source) + "</a></span>");
    }
    showNotes = concept.sourceLink || concept.description;
  },
  setPos: function setPos(_left, _top, force) {
    left = _left;
    top = _top;
    if (_pin && !force) return this;
    var parentHeight = this.parent.element.offsetHeight;
    var width = this.element.node().offsetWidth;
    var height = this.element.node().offsetHeight;
    var leftMove = void 0;
    var topMove = void 0;
    var leftPos = left - width;
    var topPos = top;
    if (leftPos < 10) {
      leftPos = 10;
      leftMove = true;
    }
    if (topPos + height + 10 > parentHeight) {
      topPos = parentHeight - height - 10;
      topMove = true;
    }

    if (leftMove && topMove) {
      topPos = top - height - 30;
    }

    this.element.style("top", topPos + "px");
    this.element.style("left", leftPos + "px");

    return this;
  },
  pin: function pin(arg) {
    if (hidden) return this;
    _pin = !_pin;
    if (arg != null) _pin = arg;
    this.element.select(".vzb-data-notes-close").classed("vzb-hidden", !_pin);
    this.element.classed("vzb-data-notes-pinned", _pin);
    if (hookName != newHookName) this.setHook(newHookName);
    this.element.select(".vzb-data-notes-body").node().scrollTop = 0;

    return showNotes ? this.setPos(left, top, true) : this.hide();
  },
  toggle: function toggle(arg) {
    if (_pin || !hookName) return this;
    if (arg == null) arg = !hidden;
    hidden = arg;
    this.element.classed("vzb-hidden", hidden || !showNotes);
    return this;
  },
  show: function show() {
    return this.toggle(false);
  },
  hide: function hide() {
    return this.toggle(true);
  }
});

exports.default = DataNotes;

/***/ }),
/* 36 */
/***/ (function(module, exports) {

var core = module.exports = {version: '2.4.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(17);
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var Map     = __webpack_require__(177)
  , $export = __webpack_require__(0)
  , shared  = __webpack_require__(83)('metadata')
  , store   = shared.store || (shared.store = new (__webpack_require__(180)));

var getOrCreateMetadataMap = function(target, targetKey, create){
  var targetMetadata = store.get(target);
  if(!targetMetadata){
    if(!create)return undefined;
    store.set(target, targetMetadata = new Map);
  }
  var keyMetadata = targetMetadata.get(targetKey);
  if(!keyMetadata){
    if(!create)return undefined;
    targetMetadata.set(targetKey, keyMetadata = new Map);
  } return keyMetadata;
};
var ordinaryHasOwnMetadata = function(MetadataKey, O, P){
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};
var ordinaryGetOwnMetadata = function(MetadataKey, O, P){
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};
var ordinaryDefineOwnMetadata = function(MetadataKey, MetadataValue, O, P){
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};
var ordinaryOwnMetadataKeys = function(target, targetKey){
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false)
    , keys        = [];
  if(metadataMap)metadataMap.forEach(function(_, key){ keys.push(key); });
  return keys;
};
var toMetaKey = function(it){
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};
var exp = function(O){
  $export($export.S, 'Reflect', O);
};

module.exports = {
  store: store,
  map: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  key: toMetaKey,
  exp: exp
};

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

if(__webpack_require__(8)){
  var LIBRARY             = __webpack_require__(51)
    , global              = __webpack_require__(4)
    , fails               = __webpack_require__(5)
    , $export             = __webpack_require__(0)
    , $typed              = __webpack_require__(84)
    , $buffer             = __webpack_require__(113)
    , ctx                 = __webpack_require__(37)
    , anInstance          = __webpack_require__(50)
    , propertyDesc        = __webpack_require__(44)
    , hide                = __webpack_require__(18)
    , redefineAll         = __webpack_require__(55)
    , toInteger           = __webpack_require__(45)
    , toLength            = __webpack_require__(12)
    , toIndex             = __webpack_require__(57)
    , toPrimitive         = __webpack_require__(33)
    , has                 = __webpack_require__(14)
    , same                = __webpack_require__(174)
    , classof             = __webpack_require__(68)
    , isObject            = __webpack_require__(6)
    , toObject            = __webpack_require__(13)
    , isArrayIter         = __webpack_require__(98)
    , create              = __webpack_require__(52)
    , getPrototypeOf      = __webpack_require__(25)
    , gOPN                = __webpack_require__(53).f
    , getIterFn           = __webpack_require__(115)
    , uid                 = __webpack_require__(58)
    , wks                 = __webpack_require__(7)
    , createArrayMethod   = __webpack_require__(31)
    , createArrayIncludes = __webpack_require__(74)
    , speciesConstructor  = __webpack_require__(107)
    , ArrayIterators      = __webpack_require__(116)
    , Iterators           = __webpack_require__(64)
    , $iterDetect         = __webpack_require__(80)
    , setSpecies          = __webpack_require__(56)
    , arrayFill           = __webpack_require__(91)
    , arrayCopyWithin     = __webpack_require__(154)
    , $DP                 = __webpack_require__(9)
    , $GOPD               = __webpack_require__(24)
    , dP                  = $DP.f
    , gOPD                = $GOPD.f
    , RangeError          = global.RangeError
    , TypeError           = global.TypeError
    , Uint8Array          = global.Uint8Array
    , ARRAY_BUFFER        = 'ArrayBuffer'
    , SHARED_BUFFER       = 'Shared' + ARRAY_BUFFER
    , BYTES_PER_ELEMENT   = 'BYTES_PER_ELEMENT'
    , PROTOTYPE           = 'prototype'
    , ArrayProto          = Array[PROTOTYPE]
    , $ArrayBuffer        = $buffer.ArrayBuffer
    , $DataView           = $buffer.DataView
    , arrayForEach        = createArrayMethod(0)
    , arrayFilter         = createArrayMethod(2)
    , arraySome           = createArrayMethod(3)
    , arrayEvery          = createArrayMethod(4)
    , arrayFind           = createArrayMethod(5)
    , arrayFindIndex      = createArrayMethod(6)
    , arrayIncludes       = createArrayIncludes(true)
    , arrayIndexOf        = createArrayIncludes(false)
    , arrayValues         = ArrayIterators.values
    , arrayKeys           = ArrayIterators.keys
    , arrayEntries        = ArrayIterators.entries
    , arrayLastIndexOf    = ArrayProto.lastIndexOf
    , arrayReduce         = ArrayProto.reduce
    , arrayReduceRight    = ArrayProto.reduceRight
    , arrayJoin           = ArrayProto.join
    , arraySort           = ArrayProto.sort
    , arraySlice          = ArrayProto.slice
    , arrayToString       = ArrayProto.toString
    , arrayToLocaleString = ArrayProto.toLocaleString
    , ITERATOR            = wks('iterator')
    , TAG                 = wks('toStringTag')
    , TYPED_CONSTRUCTOR   = uid('typed_constructor')
    , DEF_CONSTRUCTOR     = uid('def_constructor')
    , ALL_CONSTRUCTORS    = $typed.CONSTR
    , TYPED_ARRAY         = $typed.TYPED
    , VIEW                = $typed.VIEW
    , WRONG_LENGTH        = 'Wrong length!';

  var $map = createArrayMethod(1, function(O, length){
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function(){
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function(){
    new Uint8Array(1).set({});
  });

  var strictToLength = function(it, SAME){
    if(it === undefined)throw TypeError(WRONG_LENGTH);
    var number = +it
      , length = toLength(it);
    if(SAME && !same(number, length))throw RangeError(WRONG_LENGTH);
    return length;
  };

  var toOffset = function(it, BYTES){
    var offset = toInteger(it);
    if(offset < 0 || offset % BYTES)throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function(it){
    if(isObject(it) && TYPED_ARRAY in it)return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function(C, length){
    if(!(isObject(C) && TYPED_CONSTRUCTOR in C)){
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function(O, list){
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function(C, list){
    var index  = 0
      , length = list.length
      , result = allocate(C, length);
    while(length > index)result[index] = list[index++];
    return result;
  };

  var addGetter = function(it, key, internal){
    dP(it, key, {get: function(){ return this._d[internal]; }});
  };

  var $from = function from(source /*, mapfn, thisArg */){
    var O       = toObject(source)
      , aLen    = arguments.length
      , mapfn   = aLen > 1 ? arguments[1] : undefined
      , mapping = mapfn !== undefined
      , iterFn  = getIterFn(O)
      , i, length, values, result, step, iterator;
    if(iterFn != undefined && !isArrayIter(iterFn)){
      for(iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++){
        values.push(step.value);
      } O = values;
    }
    if(mapping && aLen > 2)mapfn = ctx(mapfn, arguments[2], 2);
    for(i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++){
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/*...items*/){
    var index  = 0
      , length = arguments.length
      , result = allocate(this, length);
    while(length > index)result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function(){ arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString(){
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /*, end */){
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /*, thisArg */){
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /*, start, end */){ // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /*, thisArg */){
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /*, thisArg */){
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /*, thisArg */){
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /*, thisArg */){
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /*, fromIndex */){
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /*, fromIndex */){
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator){ // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /*, fromIndex */){ // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /*, thisArg */){
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse(){
      var that   = this
        , length = validate(that).length
        , middle = Math.floor(length / 2)
        , index  = 0
        , value;
      while(index < middle){
        value         = that[index];
        that[index++] = that[--length];
        that[length]  = value;
      } return that;
    },
    some: function some(callbackfn /*, thisArg */){
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn){
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end){
      var O      = validate(this)
        , length = O.length
        , $begin = toIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end){
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /*, offset */){
    validate(this);
    var offset = toOffset(arguments[1], 1)
      , length = this.length
      , src    = toObject(arrayLike)
      , len    = toLength(src.length)
      , index  = 0;
    if(len + offset > length)throw RangeError(WRONG_LENGTH);
    while(index < len)this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries(){
      return arrayEntries.call(validate(this));
    },
    keys: function keys(){
      return arrayKeys.call(validate(this));
    },
    values: function values(){
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function(target, key){
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key){
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc){
    if(isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ){
      target[key] = desc.value;
      return target;
    } else return dP(target, key, desc);
  };

  if(!ALL_CONSTRUCTORS){
    $GOPD.f = $getDesc;
    $DP.f   = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty:           $setDesc
  });

  if(fails(function(){ arrayToString.call({}); })){
    arrayToString = arrayToLocaleString = function toString(){
      return arrayJoin.call(this);
    }
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice:          $slice,
    set:            $set,
    constructor:    function(){ /* noop */ },
    toString:       arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function(){ return this[TYPED_ARRAY]; }
  });

  module.exports = function(KEY, BYTES, wrapper, CLAMPED){
    CLAMPED = !!CLAMPED;
    var NAME       = KEY + (CLAMPED ? 'Clamped' : '') + 'Array'
      , ISNT_UINT8 = NAME != 'Uint8Array'
      , GETTER     = 'get' + KEY
      , SETTER     = 'set' + KEY
      , TypedArray = global[NAME]
      , Base       = TypedArray || {}
      , TAC        = TypedArray && getPrototypeOf(TypedArray)
      , FORCED     = !TypedArray || !$typed.ABV
      , O          = {}
      , TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function(that, index){
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function(that, index, value){
      var data = that._d;
      if(CLAMPED)value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function(that, index){
      dP(that, index, {
        get: function(){
          return getter(this, index);
        },
        set: function(value){
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if(FORCED){
      TypedArray = wrapper(function(that, data, $offset, $length){
        anInstance(that, TypedArray, NAME, '_d');
        var index  = 0
          , offset = 0
          , buffer, byteLength, length, klass;
        if(!isObject(data)){
          length     = strictToLength(data, true)
          byteLength = length * BYTES;
          buffer     = new $ArrayBuffer(byteLength);
        } else if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if($length === undefined){
            if($len % BYTES)throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if(byteLength < 0)throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if(byteLength + offset > $len)throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if(TYPED_ARRAY in data){
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while(index < length)addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if(!$iterDetect(function(iter){
      // V8 works with iterators, but fails in many other cases
      // https://code.google.com/p/v8/issues/detail?id=4552
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)){
      TypedArray = wrapper(function(that, data, $offset, $length){
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if(!isObject(data))return new Base(strictToLength(data, ISNT_UINT8));
        if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if(TYPED_ARRAY in data)return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function(key){
        if(!(key in TypedArray))hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if(!LIBRARY)TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator   = TypedArrayPrototype[ITERATOR]
      , CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined)
      , $iterator         = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if(CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)){
      dP(TypedArrayPrototype, TAG, {
        get: function(){ return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES,
      from: $from,
      of: $of
    });

    if(!(BYTES_PER_ELEMENT in TypedArrayPrototype))hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, {set: $set});

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    $export($export.P + $export.F * (TypedArrayPrototype.toString != arrayToString), NAME, {toString: arrayToString});

    $export($export.P + $export.F * fails(function(){
      new TypedArray(1).slice();
    }), NAME, {slice: $slice});

    $export($export.P + $export.F * (fails(function(){
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString()
    }) || !fails(function(){
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, {toLocaleString: $toLocaleString});

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if(!LIBRARY && !CORRECT_ITER_NAME)hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function(){ /* empty */ };

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _iconset = __webpack_require__(10);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var hidden = true;

var DataWarning = _component2.default.extend({
  init: function init(config, context) {
    var _this = this;

    this.name = "gapminder-datawarning";

    this.model_expects = [{
      name: "locale",
      type: "locale"
    }];

    this.context = context;

    this.model_binds = {
      "translate:locale": function translateLocale(evt) {
        if (!_this._ready) return;
        _this.redraw();
      }
    };

    //contructor is the same as any component
    this._super(config, context);
  },
  ready: function ready() {
    this.redraw();
  },
  readyOnce: function readyOnce() {
    var _this = this;
    this.element = d3.select(this.placeholder);

    this.element.selectAll("div").remove();

    this.element.append("div").attr("class", "vzb-data-warning-background").on("click", function () {
      _this.toggle(true);
    });

    this.container = this.element.append("div").attr("class", "vzb-data-warning-box");

    this.container.append("div").html(_iconset.close).on("click", function () {
      _this.toggle();
    }).select("svg").attr("width", "0px").attr("height", "0px").attr("class", "vzb-data-warning-close");

    var icon = this.container.append("div").attr("class", "vzb-data-warning-link").html(_iconset.warn);

    icon.append("div");

    this.container.append("div").attr("class", "vzb-data-warning-title");

    this.container.append("div").attr("class", "vzb-data-warning-body vzb-dialog-scrollable");
  },
  redraw: function redraw() {
    this.translator = this.model.locale.getTFunction();

    this.container.select(".vzb-data-warning-link div").text(this.translator("hints/dataWarning"));

    var title = this.translator("datawarning/title/" + this.parent.name);
    this.container.select(".vzb-data-warning-title").html(title).classed("vzb-hidden", !title || title == "datawarning/title/" + this.parent.name);

    this.container.select(".vzb-data-warning-body").html(this.translator("datawarning/body/" + this.parent.name));
  },
  toggle: function toggle(arg) {
    if (arg == null) arg = !hidden;
    hidden = arg;
    this.element.classed("vzb-hidden", hidden);

    var _this = this;
    this.parent.components.forEach(function (c) {
      c.element.classed("vzb-blur", c != _this && !hidden);
    });
  }
});

exports.default = DataWarning;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = axisSmart;

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

//d3.axisSmart

function axisSmart(_orient) {

  return function d3_axis_smart(_super) {

    var VERTICAL = "vertical axis";
    var HORIZONTAL = "horizontal axis";
    var X = "labels stack side by side";
    var Y = "labels stack top to bottom";

    var OPTIMISTIC = "optimistic approximation: labels have different lengths";
    var PESSIMISTIC = "pessimistic approximation: all labels have the largest length";
    var DEFAULT_LOGBASE = 10;

    function onlyUnique(value, index, self) {
      return self.indexOf(value) === index;
    }

    function axis(g) {
      var checkDmn = axis.scale().domain();
      var checkRng = axis.scale().range();
      if (!checkDmn[0] && checkDmn[0] !== 0 || !checkDmn[1] && checkDmn[1] !== 0 || !checkRng[0] && checkRng[0] !== 0 || !checkRng[1] && checkRng[1] !== 0) {
        return utils.warn("d3.axisSmart() skips action because of invalid domain " + JSON.stringify(checkDmn) + " or range " + JSON.stringify(checkRng) + " of the attached scale");
      }

      if (highlightValue != null) {
        axis.highlightValueRun(g);
        return;
      }

      // measure the width and height of one digit
      var widthSampleG = g.append("g").attr("class", "tick widthSampling");
      var widthSampleT = widthSampleG.append("text").text("0");
      if (!options.cssMargin) options.cssMargin = {};
      options.cssMargin.top = widthSampleT.style("margin-top");
      options.cssMargin.bottom = widthSampleT.style("margin-bottom");
      options.cssMargin.left = widthSampleT.style("margin-left");
      options.cssMargin.right = widthSampleT.style("margin-right");
      options.widthOfOneDigit = widthSampleT.node().getBBox().width;
      options.heightOfOneDigit = widthSampleT.node().getBBox().height;
      widthSampleG.remove();

      // run label factory - it will store labels in tickValues property of axis
      axis.labelFactory(options);

      // construct the view (d3 constructor is used)
      if (options.transitionDuration > 0) {
        _super(g.transition().duration(options.transitionDuration));
      } else {
        _super(g);
      }

      //remove axis d3v4 hardcoded attributes
      g.attr("fill", null);
      g.attr("font-size", null);
      g.attr("font-family", null);
      g.attr("text-anchor", null);

      //identify the orientation of axis and the direction of labels
      var orient = axis.orient() == "top" || axis.orient() == "bottom" ? HORIZONTAL : VERTICAL;
      var dimension = orient == HORIZONTAL && axis.pivot() || orient == VERTICAL && !axis.pivot() ? Y : X;

      //add an invisible element that would represent hovered value
      g.selectAll(".vzb-axis-value").data([null]).enter().append("g").attr("class", "vzb-axis-value").classed("vzb-hidden", true).append("text");

      // patch the label positioning after the view is generated
      var padding = axis.tickPadding();
      g.selectAll("text").each(function (d, i) {
        if (axis.pivot() == null) return;

        var view = d3.select(this);
        view.attr("transform", "rotate(" + (axis.pivot() ? -90 : 0) + ")");
        view.style("text-anchor", dimension == X ? "middle" : "end");
        view.attr("x", dimension == X ? orient == VERTICAL ? -padding : 0 : -padding);
        view.attr("y", dimension == X ? orient == VERTICAL ? 0 : padding : 0);
        view.attr("dx", dimension == X ? orient == VERTICAL ? padding : 0 : 0);
        view.attr("dy", dimension == X ? orient == VERTICAL ? -padding : ".72em" : ".32em");
      });

      //apply label repositioning: first and last visible values would shift away from the borders
      if (axis.repositionLabels() != null) {
        g.selectAll(".tick").each(function (d) {
          var view = d3.select(this).select("text");
          var shift = axis.repositionLabels()[d] || { x: 0, y: 0 };
          view.attr("x", +view.attr("x") + shift.x);
          view.attr("y", +view.attr("y") + shift.y);
        });
      }

      //hide axis labels that are outside the available viewport
      var scale = axis.scale();
      if (options.viewportLength) {
        g.selectAll(".tick").classed("vzb-hidden", function (d) {
          return scale(d) < 0 || scale(d) > options.viewportLength;
        });
      }

      // add minor ticks. if none exist add an empty array
      if (axis.tickValuesMinor() == null) axis.tickValuesMinor([]);
      var minorTicks = g.selectAll(".tick-minor").data(tickValuesMinor);
      minorTicks.exit().remove();
      minorTicks = minorTicks.enter().append("line").attr("class", "tick-minor").merge(minorTicks);

      var tickLengthOut = axis.tickSizeMinor().outbound;
      var tickLengthIn = axis.tickSizeMinor().inbound;
      minorTicks.classed("vzb-hidden", function (d) {
        return scale(d) < 0 || scale(d) > options.viewportLength;
      }).attr("y1", orient == HORIZONTAL ? (axis.orient() == "top" ? 1 : -1) * tickLengthIn : scale).attr("y2", orient == HORIZONTAL ? (axis.orient() == "top" ? -1 : 1) * tickLengthOut : scale).attr("x1", orient == VERTICAL ? (axis.orient() == "right" ? -1 : 1) * tickLengthIn : scale).attr("x2", orient == VERTICAL ? (axis.orient() == "right" ? 1 : -1) * tickLengthOut : scale);

      //adjust axis rake
      g.selectAll("path").remove();
      var rake = g.selectAll(".vzb-axis-line").data([0]);
      rake.exit().remove();
      rake = rake.enter().append("line").attr("class", "vzb-axis-line").merge(rake);

      if (options.viewportLength) {
        rake.attr("x1", orient == VERTICAL ? 0 : -1).attr("x2", orient == VERTICAL ? 0 : options.viewportLength).attr("y1", orient == HORIZONTAL ? 0 : 0).attr("y2", orient == HORIZONTAL ? 0 : options.viewportLength);
      } else {
        //TODO: this will not work for the "ordinal" scaleType
        rake.attr("x1", orient == VERTICAL ? 0 : d3.min(scale.range()) - (options.bump || 0) - 1).attr("x2", orient == VERTICAL ? 0 : d3.max(scale.range()) + (options.bump || 0)).attr("y1", orient == HORIZONTAL ? 0 : d3.min(scale.range()) - (options.bump || 0)).attr("y2", orient == HORIZONTAL ? 0 : d3.max(scale.range()) + (options.bump || 0));
      }
    }

    axis.highlightValueRun = function (g) {

      //if viewport is defined and HL value is outside then behave as reset HL
      if (options.viewportLength && highlightValue != "none" && (axis.scale()(highlightValue) > options.viewportLength || axis.scale()(highlightValue) < 0)) highlightValue = "none";

      //identify the orientation of axis and the direction of labels
      var orient = axis.orient() == "top" || axis.orient() == "bottom" ? HORIZONTAL : VERTICAL;
      var dimension = orient == HORIZONTAL && axis.pivot() || orient == VERTICAL && !axis.pivot() ? "y" : "x";
      var pivot = axis.pivot() ? -1 : 1;

      //set content and visibility of HL value
      g.select(".vzb-axis-value").classed("vzb-hidden", highlightValue == "none");

      var bbox = void 0;
      var o = {};

      if (highlightValue != "none") {
        // measure its width and height for collision resolving
        bbox = g.select(".vzb-axis-value").node().getBBox();

        // clone a known options object (because we don't want to overwrite widthOfOneDigit / heightOfOneDigit in the original one
        o.bump = options.bump;
        o.formatter = options.formatter;
        o.viewportLength = options.viewportLength;
        o.toolMargin = options.toolMargin;
        o.cssMargin = options.cssMargin;
        o.widthOfOneDigit = bbox[axis.pivot() ? "height" : "width"] / options.formatter(highlightValue).length;
        o.heightOfOneDigit = bbox[axis.pivot() ? "width" : "height"];
      }

      // this will give additive shifting for the hovered value in case it sticks out a little outside viewport
      var hlValueShift = (highlightValue == "none" ? { x: 0, y: 0 } : repositionLabelsThatStickOut([highlightValue], o, orient, axis.scale(), dimension)[highlightValue])[dimension];

      // this function will help to move the hovered value to the right place
      var getTransform = function getTransform(d) {
        return highlightValue == "none" ? "translate(0,0)" : "translate(" + (orient == HORIZONTAL ? axis.scale()(highlightValue) + hlValueShift * pivot : 0) + "," + (orient == VERTICAL ? axis.scale()(highlightValue) + hlValueShift * pivot : 0) + ")";
      };

      // this function will help to compute opacity for the axis labels that would overlap with the HL label
      var getOpacity = function getOpacity(d, t, view) {
        if (highlightValue == "none") return 1;

        var wh = orient == HORIZONTAL ? "width" : "height";
        var shift = (axis.repositionLabels()[d] || { x: 0, y: 0 })[dimension];

        // opacity depends on the collision between label's boundary boxes
        return axis.hlOpacityScale()(
        // this computes the distance between the box centers, this is a 1-d problem because all labels are along the axis
        // shifts of labels that stick out from the viewport are also taken into account
        Math.abs(axis.scale()(d) + shift * pivot - axis.scale()(highlightValue) - hlValueShift * pivot)
        // this computes the sides of boundary boxes, each has a half-size to reduce the distance between centers
        - view.getBBox()[wh] / 2 - bbox[wh] / 2);
      };

      // apply translation of the HL value and opacity of tick labels
      if (highlightTransDuration) {
        g.select(".vzb-axis-value").transition().duration(highlightTransDuration).ease(d3.easeLinear).attr("transform", getTransform);

        g.select(".vzb-axis-value").select("text").transition("text").delay(highlightTransDuration).text(highlightValue == "none" ? "" : options.formatter(highlightValue));

        g.selectAll(".tick:not(.vzb-hidden)").each(function (d, t) {
          d3.select(this).select("text").transition().duration(highlightTransDuration).ease(d3.easeLinear).style("opacity", getOpacity(d, t, this));
        });
      } else {
        g.select(".vzb-axis-value").interrupt().attr("transform", getTransform).transition();

        g.select(".vzb-axis-value").select("text").interrupt().text(highlightValue == "none" ? "" : options.formatter(highlightValue)).transition();

        g.selectAll(".tick:not(.vzb-hidden)").each(function (d, t) {
          d3.select(this).select("text").interrupt().style("opacity", getOpacity(d, t, this)).transition();
        });
      }

      highlightValue = null;
    };

    var hlOpacityScale = d3.scale.linear().domain([0, 5]).range([0, 1]).clamp(true);
    axis.hlOpacityScale = function (arg) {
      if (!arguments.length) return hlOpacityScale;
      hlOpacityScale = arg;
      return axis;
    };

    var highlightValue = null;
    axis.highlightValue = function (arg) {
      if (!arguments.length) return highlightValue;
      highlightValue = arg;
      return axis;
    };

    var highlightTransDuration = 0;
    axis.highlightTransDuration = function (arg) {
      if (!arguments.length) return highlightTransDuration;
      highlightTransDuration = arg;
      return axis;
    };

    var repositionLabels = null;
    axis.repositionLabels = function (arg) {
      if (!arguments.length) return repositionLabels;
      repositionLabels = arg;
      return axis;
    };

    var pivot = false;
    axis.pivot = function (arg) {
      if (!arguments.length) return pivot;
      pivot = !!arg;
      return axis;
    };

    var tickValuesMinor = [];
    axis.tickValuesMinor = function (arg) {
      if (!arguments.length) return tickValuesMinor;
      tickValuesMinor = arg;
      return axis;
    };

    var tickSizeMinor = {
      outbound: 0,
      inbound: 0
    };
    axis.tickSizeMinor = function (arg1, arg2) {
      if (!arguments.length) return tickSizeMinor;
      tickSizeMinor = {
        outbound: arg1,
        inbound: arg2 || 0
      };
      meow("setting", tickSizeMinor);
      return axis;
    };

    var options = {};
    axis.labelerOptions = function (arg) {
      if (!arguments.length) return options;
      options = arg;
      return axis;
    };

    axis.METHOD_REPEATING = "repeating specified powers";
    axis.METHOD_DOUBLING = "doubling the value";

    axis.labelFactory = function (options) {
      if (options == null) options = {};
      if (options.scaleType != "linear" && options.scaleType != "time" && options.scaleType != "genericLog" && options.scaleType != "log" && options.scaleType != "ordinal") {
        return axis.ticks(ticksNumber).tickFormat(null).tickValues(null).tickValuesMinor(null).pivot(null).repositionLabels(null);
      }
      if (options.scaleType == "ordinal") return axis.tickValues(null);

      if (options.logBase == null) options.logBase = DEFAULT_LOGBASE;
      if (options.stops == null) options.stops = [1, 2, 5, 3, 7, 4, 6, 8, 9];

      if (options.removeAllLabels == null) options.removeAllLabels = false;

      if (options.formatter == null) options.formatter = axis.tickFormat() ? axis.tickFormat() : function (d) {
        return d + "";
      };
      options.cssLabelMarginLimit = 5; //px

      if (options.cssMargin == null) options.cssMargin = {};
      if (options.cssMargin.left == null || parseInt(options.cssMargin.left) < options.cssLabelMarginLimit) options.cssMargin.left = options.cssLabelMarginLimit + "px";
      if (options.cssMargin.right == null || parseInt(options.cssMargin.right) < options.cssLabelMarginLimit) options.cssMargin.right = options.cssLabelMarginLimit + "px";
      if (options.cssMargin.top == null || parseInt(options.cssMargin.top) < options.cssLabelMarginLimit) options.cssMargin.top = options.cssLabelMarginLimit + "px";
      if (options.cssMargin.bottom == null || parseInt(options.cssMargin.bottom) < options.cssLabelMarginLimit) options.cssMargin.bottom = options.cssLabelMarginLimit + "px";
      if (options.toolMargin == null) options.toolMargin = {
        left: 30,
        bottom: 30,
        right: 30,
        top: 30
      };
      if (options.bump == null) options.bump = 0;
      if (options.viewportLength == null) options.viewportLength = 0;

      if (options.pivotingLimit == null) options.pivotingLimit = options.toolMargin[this.orient()];

      if (options.showOuter == null) options.showOuter = false;
      if (options.limitMaxTickNumber == null) options.limitMaxTickNumber = 0; //0 is unlimited

      var orient = this.orient() == "top" || this.orient() == "bottom" ? HORIZONTAL : VERTICAL;

      if (options.isPivotAuto == null) options.isPivotAuto = orient == VERTICAL;

      if (options.cssFontSize == null) options.cssFontSize = "13px";
      if (options.widthToFontsizeRatio == null) options.widthToFontsizeRatio = 0.75;
      if (options.heightToFontsizeRatio == null) options.heightToFontsizeRatio = 1.20;
      if (options.widthOfOneDigit == null) options.widthOfOneDigit = parseInt(options.cssFontSize) * options.widthToFontsizeRatio;
      if (options.heightOfOneDigit == null) options.heightOfOneDigit = parseInt(options.cssFontSize) * options.heightToFontsizeRatio;
      if (options.fitIntoScale == null || options.fitIntoScale == "pessimistic") options.fitIntoScale = PESSIMISTIC;
      if (options.fitIntoScale == "optimistic") options.fitIntoScale = OPTIMISTIC;

      meow("********** " + orient + " **********");

      var domain = axis.scale().domain();
      var range = axis.scale().range();
      var lengthDomain = Math.abs(domain[domain.length - 1] - domain[0]);
      var lengthRange = Math.abs(range[range.length - 1] - range[0]);

      var min = d3.min([domain[0], domain[domain.length - 1]]);
      var max = d3.max([domain[0], domain[domain.length - 1]]);
      var bothSidesUsed = min <= 0 && max >= 0 && options.scaleType != "time";

      var tickValues = options.showOuter ? [min, max] : [];
      var tickValuesMinor = []; //[min, max];
      var ticksNumber = 5;

      function getBaseLog(x, base) {
        if (x == 0 || base == 0) {
          return 0;
        }
        if (base == null) base = options.logBase;
        return Math.log(x) / Math.log(base);
      }

      // estimate the longest formatted label in pixels
      var estLongestLabelLength =
      //take 17 sample values and measure the longest formatted label
      d3.max(d3.range(min, max, (max - min) / 17).concat(max).map(function (d) {
        return options.formatter(d).length;
      })) * options.widthOfOneDigit + parseInt(options.cssMargin.left);

      var pivot = options.isPivotAuto && (estLongestLabelLength + axis.tickPadding() > options.pivotingLimit && orient == VERTICAL || !(estLongestLabelLength + axis.tickPadding() > options.pivotingLimit) && !(orient == VERTICAL));

      var labelsStackOnTop = orient == HORIZONTAL && pivot || orient == VERTICAL && !pivot;

      // conditions to remove labels altogether
      var labelsJustDontFit = !labelsStackOnTop && options.heightOfOneDigit > options.pivotingLimit;
      if (options.removeAllLabels) return axis.tickValues([]);

      // return a single tick if have only one point in the domain
      if (min == max) return axis.tickValues([min]).ticks(1).tickFormat(options.formatter);

      // LABELS FIT INTO SCALE
      // measure if all labels in array tickValues can fit into the allotted lengthRange
      // approximationStyle can be OPTIMISTIC or PESSIMISTIC
      // in optimistic style the length of every label is added up and then we check if the total pack of symbols fit
      // in pessimistic style we assume all labels have the length of the longest label from tickValues
      // returns TRUE if labels fit and FALSE otherwise
      var labelsFitIntoScale = function labelsFitIntoScale(tickValues, lengthRange, approximationStyle, rescalingLabels) {
        if (tickValues == null || tickValues.length <= 1) return true;
        if (approximationStyle == null) approximationStyle = PESSIMISTIC;
        if (rescalingLabels == null) scaleType = "none";

        if (labelsStackOnTop) {
          //labels stack on top of each other. digit height matters
          return lengthRange > tickValues.length * (options.heightOfOneDigit + parseInt(options.cssMargin.top) + parseInt(options.cssMargin.bottom));
        }

        //labels stack side by side. label width matters
        var marginsLR = parseInt(options.cssMargin.left) + parseInt(options.cssMargin.right);
        var maxLength = d3.max(tickValues.map(function (d) {
          return options.formatter(d).length;
        }));

        // log scales need to rescale labels, so that 9 takes more space than 2
        if (rescalingLabels == "log") {
          // sometimes only a fragment of axis is used. in this case we want to limit the scope to that fragment
          // yes, this is hacky and experimental
          lengthRange = Math.abs(axis.scale()(d3.max(tickValues)) - axis.scale()(d3.min(tickValues)));

          return lengthRange > d3.sum(tickValues.map(function (d) {
            return (options.widthOfOneDigit * (approximationStyle == PESSIMISTIC ? maxLength : options.formatter(d).length) + marginsLR) * (
            // this is a logarithmic rescaling of labels
            1 + Math.log(d.toString().replace(/([0.])/g, "")[0]) / Math.LN10);
          }));
        }

        return lengthRange > tickValues.length * marginsLR + (approximationStyle == PESSIMISTIC ? options.widthOfOneDigit * tickValues.length * maxLength : 0) + (approximationStyle == OPTIMISTIC ? options.widthOfOneDigit * tickValues.map(function (d) {
          return options.formatter(d);
        }).join("").length : 0);
      };

      // COLLISION BETWEEN
      // Check is there is a collision between labels ONE and TWO
      // ONE is a value, TWO can be a value or an array
      // returns TRUE if collision takes place and FALSE otherwise
      var collisionBetween = function collisionBetween(one, two) {
        if (two == null || two.length == 0) return false;
        if (!(two instanceof Array)) two = [two];

        for (var i = 0; i < two.length; i++) {
          if (one != two[i] && one != 0 && Math.abs(axis.scale()(one) - axis.scale()(two[i])) < (labelsStackOnTop ? options.heightOfOneDigit : (options.formatter(one).length + options.formatter(two[i]).length) * options.widthOfOneDigit / 2)) return true;
        }
        return false;
      };

      if (options.scaleType == "genericLog" || options.scaleType == "log") {
        var eps = axis.scale().eps ? axis.scale().eps() : 0;

        var spawnZero = bothSidesUsed ? [0] : [];

        // check if spawn positive is needed. if yes then spawn!
        var spawnPos = max < eps ? [] : d3.range(Math.floor(getBaseLog(Math.max(eps, min))), Math.ceil(getBaseLog(max)), 1).concat(Math.ceil(getBaseLog(max))).map(function (d) {
          return Math.pow(options.logBase, d);
        });

        // check if spawn negative is needed. if yes then spawn!
        var spawnNeg = min > -eps ? [] : d3.range(Math.floor(getBaseLog(Math.max(eps, -max))), Math.ceil(getBaseLog(-min)), 1).concat(Math.ceil(getBaseLog(-min))).map(function (d) {
          return -Math.pow(options.logBase, d);
        });

        // automatic chosing of method if it's not explicitly defined
        if (options.method == null) {
          var coverage = bothSidesUsed ? Math.max(Math.abs(max), Math.abs(min)) / eps : Math.max(Math.abs(max), Math.abs(min)) / Math.min(Math.abs(max), Math.abs(min));
          options.method = 10 <= coverage && coverage <= 1024 ? this.METHOD_DOUBLING : this.METHOD_REPEATING;
        }

        //meow('spawn pos/neg: ', spawnPos, spawnNeg);


        if (options.method == this.METHOD_DOUBLING) {
          (function () {
            var doublingLabels = [];
            if (bothSidesUsed) tickValues.push(0);
            var avoidCollidingWith = [].concat(tickValues);

            // start with the smallest abs number on the scale, rounded to nearest nice power
            //var startPos = max<eps? null : Math.pow(options.logBase, Math.floor(getBaseLog(Math.max(eps,min))));
            //var startNeg = min>-eps? null : -Math.pow(options.logBase, Math.floor(getBaseLog(Math.max(eps,-max))));

            var startPos = max < eps ? null : 4 * spawnPos[Math.floor(spawnPos.length / 2) - 1];
            var startNeg = min > -eps ? null : 4 * spawnNeg[Math.floor(spawnNeg.length / 2) - 1];

            //meow('starter pos/neg: ', startPos, startNeg);

            if (startPos) {
              for (var l = startPos; l <= max; l *= 2) {
                doublingLabels.push(l);
              }
            }
            if (startPos) {
              for (var _l = startPos / 2; _l >= Math.max(min, eps); _l /= 2) {
                doublingLabels.push(_l);
              }
            }
            if (startNeg) {
              for (var _l2 = startNeg; _l2 >= min; _l2 *= 2) {
                doublingLabels.push(_l2);
              }
            }
            if (startNeg) {
              for (var _l3 = startNeg / 2; _l3 <= Math.min(max, -eps); _l3 /= 2) {
                doublingLabels.push(_l3);
              }
            }

            doublingLabels = doublingLabels.sort(d3.ascending).filter(function (d) {
              return min <= d && d <= max;
            });

            tickValuesMinor = tickValuesMinor.concat(doublingLabels);

            doublingLabels = groupByPriorities(doublingLabels, false); // don't skip taken values

            var tickValues_1 = tickValues;
            for (var j = 0; j < doublingLabels.length; j++) {

              // compose an attempt to add more axis labels
              var trytofit = tickValues_1.concat(doublingLabels[j]).filter(function (d) {
                return !collisionBetween(d, avoidCollidingWith);
              }).filter(onlyUnique);

              // stop populating if labels don't fit
              if (!labelsFitIntoScale(trytofit, lengthRange, PESSIMISTIC, "none")) break;

              // apply changes if no blocking instructions
              tickValues = trytofit;
            }
          })();
        }

        if (options.method == this.METHOD_REPEATING) {

          var spawn = spawnZero.concat(spawnPos).concat(spawnNeg).sort(d3.ascending);

          options.stops.forEach(function (stop, i) {
            tickValuesMinor = tickValuesMinor.concat(spawn.map(function (d) {
              return d * stop;
            }));
          });

          spawn = groupByPriorities(spawn);
          var avoidCollidingWith = spawnZero.concat(tickValues);

          var stopTrying = false;

          options.stops.forEach(function (stop, i) {
            if (i == 0) {
              var _ref;

              for (var j = 0; j < spawn.length; j++) {

                // compose an attempt to add more axis labels
                var trytofit = tickValues.concat(spawn[j].map(function (d) {
                  return d * stop;
                }))
                // throw away labels that collide with "special" labels 0, min, max
                .filter(function (d) {
                  return !collisionBetween(d, avoidCollidingWith);
                }).filter(function (d) {
                  return min <= d && d <= max;
                }).filter(onlyUnique);

                // stop populating if labels don't fit
                if (!labelsFitIntoScale(trytofit, lengthRange, PESSIMISTIC, "none")) break;

                // apply changes if no blocking instructions
                tickValues = trytofit;
              }

              // flatten the spawn array
              spawn = (_ref = []).concat.apply(_ref, _toConsumableArray(spawn));
            } else {
              if (stopTrying) return;

              // compose an attempt to add more axis labels
              var _trytofit = tickValues.concat(spawn.map(function (d) {
                return d * stop;
              })).filter(function (d) {
                return min <= d && d <= max;
              }).filter(onlyUnique);

              // stop populating if the new composition doesn't fit
              if (!labelsFitIntoScale(_trytofit, lengthRange, PESSIMISTIC, "log")) {
                stopTrying = true;
                return;
              }
              // stop populating if the number of labels is limited in options
              if (tickValues.length > options.limitMaxTickNumber && options.limitMaxTickNumber != 0) {
                stopTrying = true;
                return;
              }

              // apply changes if no blocking instructions
              tickValues = _trytofit;
            }
          });
        } //method

      } //logarithmic


      if (options.scaleType == "linear" || options.scaleType == "time") {
        (function () {
          if (bothSidesUsed) tickValues.push(0);
          var avoidCollidingWith = [].concat(tickValues);

          if (labelsStackOnTop) {
            ticksNumber = Math.max(Math.floor(lengthRange / (options.heightOfOneDigit + parseInt(options.cssMargin.top))), 2);
          } else {
            ticksNumber = Math.max(Math.floor(lengthRange / estLongestLabelLength), 2);
          }

          // limit maximum ticks number
          if (options.limitMaxTickNumber != 0 && ticksNumber > options.limitMaxTickNumber) ticksNumber = options.limitMaxTickNumber;

          var addLabels = axis.scale().ticks(ticksNumber).sort(d3.ascending).filter(function (d) {
            return min <= d && d <= max;
          });

          tickValuesMinor = tickValuesMinor.concat(addLabels);

          addLabels = groupByPriorities(addLabels, false);

          var tickValues_1 = tickValues;
          for (var j = 0; j < addLabels.length; j++) {

            // compose an attempt to add more axis labels
            var trytofit = tickValues_1.concat(addLabels[j]).filter(function (d) {
              return !collisionBetween(d, avoidCollidingWith);
            }).filter(onlyUnique);

            // stop populating if labels don't fit
            if (!labelsFitIntoScale(trytofit, lengthRange, options.fitIntoScale, "none")) break;

            // apply changes if no blocking instructions
            tickValues = trytofit;
          }

          tickValues = tickValues //.concat(addLabels)
          .filter(function (d) {
            return !collisionBetween(d, avoidCollidingWith);
          }).filter(onlyUnique);
        })();
      }

      if (tickValues != null && tickValues.length <= 2 && !bothSidesUsed) tickValues = [min, max];

      if (tickValues != null && tickValues.length <= 3 && bothSidesUsed) {
        if (!collisionBetween(0, [min, max])) {
          tickValues = [min, 0, max];
        } else {
          tickValues = [min, max];
        }
      }

      if (tickValues != null) tickValues.sort(function (a, b) {
        return (orient == HORIZONTAL ? -1 : 1) * (axis.scale()(b) - axis.scale()(a));
      });

      if (labelsJustDontFit) tickValues = [];
      tickValuesMinor = tickValuesMinor.filter(function (d) {
        return tickValues.indexOf(d) == -1 && min <= d && d <= max;
      });

      meow("final result", tickValues);

      return axis.ticks(ticksNumber).tickFormat(options.formatter).tickValues(tickValues).tickValuesMinor(tickValuesMinor).pivot(pivot).repositionLabels(repositionLabelsThatStickOut(tickValues, options, orient, axis.scale(), labelsStackOnTop ? "y" : "x"));
    };

    // GROUP ELEMENTS OF AN ARRAY, SO THAT...
    // less-prio elements are between the high-prio elements
    // Purpose: enable adding axis labels incrementally, like this for 9 labels:
    // PRIO 1: +--------, concat result: +-------- first we show only 1 label
    // PRIO 2: ----+---+, concat result: +---+---+ then we add 2 more, that are maximally spaced
    // PRIO 3: --+---+--, concat result: +-+-+-+-+ then we fill spaces with 2 more labels
    // PRIO 4: -+-+-+-+-, concat result: +++++++++ then we fill the remaing spaces and show all labels
    // exception: zero jumps to the front, if it's on the list
    // example1: [1 2 3 4 5 6 7] --> [[1][4 7][2 3 5 6]]
    // example2: [1 2 3 4 5 6 7 8 9] --> [[1][5 9][3 7][2 4 6 8]]
    // example3: [-4 -3 -2 -1 0 1 2 3 4 5 6 7] --> [[0][-4][2][-1 5][-3 -2 1 3 4 6 7]]
    // inputs:
    // array - the source array to be processed. Only makes sense if sorted
    // removeDuplicates - return incremental groups (true, default), or return concatinated result (false)
    // returns:
    // the nested array
    function groupByPriorities(array, removeDuplicates) {
      if (removeDuplicates == null) removeDuplicates = true;

      var result = [];
      var taken = [];

      //zero is an exception, if it's present we manually take it to the front
      if (array.indexOf(0) != -1) {
        result.push([0]);
        taken.push(array.indexOf(0));
      }

      var _loop = function _loop(k) {
        // push the next group of elements to the result
        result.push(array.filter(function (d, i) {
          if (i % Math.floor(k) == 0 && (taken.indexOf(i) == -1 || !removeDuplicates)) {
            taken.push(i);
            return true;
          }
          return false;
        }));
      };

      for (var k = array.length; k >= 1; k = k < 4 ? k - 1 : k / 2) {
        _loop(k);
      }

      return result;
    }

    // REPOSITION LABELS THAT STICK OUT
    // Purpose: the outer labels can easily be so large, they stick out of the allotted area
    // Example:
    // Label is fine:    Label sticks out:    Label sticks out more:    Solution - label is shifted:
    //      12345 |           1234|                123|5                   12345|
    // _______.   |      _______. |           _______.|                 _______.|
    //
    // this is what the function does on the first step (only outer labels)
    // on the second step it shifts the inner labels that start to overlap with the shifted outer labels
    //
    // requires tickValues array to be sorted from tail-first
    // tail means left or bottom, head means top or right
    //
    // dimension - which dimension requires shifting
    // X if labels stack side by side, Y if labels stack on top of one another
    //
    // returns the array of recommended {x,y} shifts

    function repositionLabelsThatStickOut(tickValues, options, orient, scale, dimension) {
      if (!tickValues) return null;
      var result = {};

      // make an abstraction layer for margin sizes
      // tail means left or bottom, head means top or right
      var margin = orient == VERTICAL ? {
        head: options.toolMargin.top,
        tail: options.toolMargin.bottom
      } : {
        head: options.toolMargin.right,
        tail: options.toolMargin.left
      };

      var range = scale.range();
      var bump = options.bump;

      //when a viewportLength is given: adjust outer VISIBLE tick values
      //this is helpful when the scaled is zoomed, so labels don't get truncated by a viewport svg
      if (options.viewportLength) {
        //remove invisible ticks from the array
        tickValues = tickValues.filter(function (d) {
          return scale(d) >= 0 && scale(d) <= options.viewportLength;
        });
        //overwrite the available range with viewport limits. direction doesn't matter because we take min-max later anyway
        range = [0, options.viewportLength];
        //reset the bump because zoomed axis has no bump
        bump = 0;
      }

      // STEP 1:
      // for outer labels: avoid sticking out from the tool margin
      tickValues.forEach(function (d, i) {
        if (i != 0 && i != tickValues.length - 1) return;

        // compute the influence of the axis head
        var repositionHead = Math.min(margin.head, options.widthOfOneDigit * 0.5) + bump + (orient == HORIZONTAL ? 1 : 0) * d3.max(range) - (orient == HORIZONTAL ? 0 : 1) * d3.min(range) + (orient == HORIZONTAL ? -1 : 1) * scale(d) - (dimension == "x") * options.formatter(d).length * options.widthOfOneDigit / 2 - (dimension == "y") * options.heightOfOneDigit / 2
        // we may consider or not the label margins to give them a bit of spacing from the edges
        - (dimension == "x") * parseInt(options.cssMargin.right) - (dimension == "y") * parseInt(options.cssMargin.top);

        // compute the influence of the axis tail
        var repositionTail = Math.min(margin.tail, options.widthOfOneDigit * 0.5) + bump + (orient == VERTICAL ? 1 : 0) * d3.max(range) - (orient == VERTICAL ? 0 : 1) * d3.min(range) + (orient == VERTICAL ? -1 : 1) * scale(d) - (dimension == "x") * options.formatter(d).length * options.widthOfOneDigit / 2 - (dimension == "y") * options.heightOfOneDigit / 2
        // we may consider or not the label margins to give them a bit of spacing from the edges
        - (dimension == "x") * parseInt(options.cssMargin.left) - (dimension == "y") * parseInt(options.cssMargin.bottom);

        // apply limits in order to cancel repositioning of labels that are good
        if (repositionHead > 0) repositionHead = 0;
        if (repositionTail > 0) repositionTail = 0;

        // add them up with appropriate signs, save to the axis
        result[d] = { x: 0, y: 0 };
        result[d][dimension] = (dimension == "y" && orient == VERTICAL ? -1 : 1) * (repositionHead - repositionTail);
      });

      // STEP 2:
      // for inner labels: avoid collision with outer labels
      tickValues.forEach(function (d, i) {
        if (i == 0 || i == tickValues.length - 1) return;

        // compute the influence of the head-side outer label
        var repositionHead =
        // take the distance between head and the tick at hand
        Math.abs(scale(d) - scale(tickValues[tickValues.length - 1]))

        // substract the shift of the head TODO: THE SIGN CHOICE HERE MIGHT BE WRONG. NEED TO TEST ALL CASES
        - (dimension == "y") * (orient == HORIZONTAL ? -1 : 1) * result[tickValues[tickValues.length - 1]][dimension] - (dimension == "x") * (orient == HORIZONTAL ? 1 : -1) * result[tickValues[tickValues.length - 1]][dimension]

        // substract half-length of the overlapping labels
        - (dimension == "x") * options.widthOfOneDigit / 2 * options.formatter(d).length - (dimension == "x") * options.widthOfOneDigit / 2 * options.formatter(tickValues[tickValues.length - 1]).length - (dimension == "y") * options.heightOfOneDigit * 0.7 //TODO remove magic constant - relation of actual font height to BBox-measured height

        // we may consider or not the label margins to give them a bit of spacing from the edges
        - (dimension == "x") * parseInt(options.cssMargin.left) - (dimension == "y") * parseInt(options.cssMargin.bottom);

        // compute the influence of the tail-side outer label
        var repositionTail =
        // take the distance between tail and the tick at hand
        Math.abs(scale(d) - scale(tickValues[0]))

        // substract the shift of the tail TODO: THE SIGN CHOICE HERE MIGHT BE WRONG. NEED TO TEST ALL CASES
        - (dimension == "y") * (orient == VERTICAL ? -1 : 1) * result[tickValues[0]][dimension] - (dimension == "x") * (orient == VERTICAL ? 1 : -1) * result[tickValues[0]][dimension]

        // substract half-length of the overlapping labels
        - (dimension == "x") * options.widthOfOneDigit / 2 * options.formatter(d).length - (dimension == "x") * options.widthOfOneDigit / 2 * options.formatter(tickValues[0]).length - (dimension == "y") * options.heightOfOneDigit * 0.7 //TODO remove magic constant - relation of actual font height to BBox-measured height

        // we may consider or not the label margins to give them a bit of spacing from the edges
        - (dimension == "x") * parseInt(options.cssMargin.left) - (dimension == "y") * parseInt(options.cssMargin.bottom);

        // apply limits in order to cancel repositioning of labels that are good
        if (repositionHead > 0) repositionHead = 0;
        if (repositionTail > 0) repositionTail = 0;

        // add them up with appropriate signs, save to the axis
        result[d] = { x: 0, y: 0 };
        result[d][dimension] = (dimension == "y" && orient == VERTICAL ? -1 : 1) * (repositionHead - repositionTail);
      });

      return result;
    } // function repositionLabelsThatStickOut()


    axis.copy = function () {
      return d3_axis_smart(d3["axis" + utils.capitalize(_orient)]());
    };

    axis.orient = function () {
      if (!arguments.length) return _orient;
      return axis;
    };

    return d3.rebind(axis, _super, "scale", "ticks", "tickArguments", "tickValues", "tickFormat", "tickSize", "tickSizeInner", "tickSizeOuter", "tickPadding");

    function meow() {
      var _console;

      if (!axis.labelerOptions().isDevMode) return;
      (_console = console).log.apply(_console, arguments);
    }
  }(d3["axis" + utils.capitalize(_orient)]());
}

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _dataconnected = __webpack_require__(61);

var _dataconnected2 = _interopRequireDefault(_dataconnected);

var _events = __webpack_require__(46);

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*!
 * HOOK MODEL
 */

var Hook = _dataconnected2.default.extend({

  //some hooks can be important. like axis x and y
  //that means, if X or Y doesn't have data at some point, we can't show markers
  _important: false,

  objectLeafs: ["autogenerate"],
  dataConnectedChildren: ["use", "which"],

  getClassDefaults: function getClassDefaults() {
    var defaults = {
      data: "data",
      which: null
    };
    return utils.deepExtend(this._super(), defaults);
  },
  buildScale: function buildScale() {
    //overloaded by specific hook models, like axis and color
  },


  /**
   * After complete model tree is created, this allows models to listen to eachother.
   */
  setInterModelListeners: function setInterModelListeners() {
    var _this2 = this;

    var spaceRefs = this._parent.getSpace(this);

    //check what we want to hook this model to
    utils.forEach(spaceRefs, function (name) {
      //hook with the closest prefix to this model
      _this2._space[name] = _this2.getClosestModel(name);
      //if hooks change, this should load again
      _this2._space[name].on("dataConnectedChange", _this2.handleDataConnectedChange.bind(_this2));
    });
    this.getClosestModel("locale").on("dataConnectedChange", this.handleDataConnectedChange.bind(this));
  },
  onSuccessfullLoad: function onSuccessfullLoad() {
    this.buildScale();
    this._super();
  },
  setWhich: function setWhich(newValue) {

    var obj = { which: newValue.concept };

    if (newValue.dataSource) obj.data = newValue.dataSource;
    var newDataSource = this.getClosestModel(obj.data || this.data);
    var conceptProps = newDataSource.getConceptprops(newValue.concept);

    if (newValue.which === "_default") {
      obj.use = "constant";
    } else {
      if (conceptProps.use) obj.use = conceptProps.use;
    }

    if (conceptProps.scales) {
      obj.scaleType = conceptProps.scales[0];
    }

    if (this.getType() === "axis" || this.getType() === "size") {
      obj.domainMin = null;
      obj.domainMax = null;
      obj.zoomedMin = null;
      obj.zoomedMax = null;
    }

    this.set(obj);
  },
  setScaleType: function setScaleType(newValue) {
    this.buildScale(newValue);
  },
  preloadData: function preloadData() {
    this.dataSource = this.getClosestModel(this.data);
    return this._super();
  },
  afterPreload: function afterPreload() {
    this.autoGenerateModel();
  },
  autoGenerateModel: function autoGenerateModel() {
    if (this.which == null && this.autogenerate) {
      this.which = this.dataSource.getConceptByIndex(this.autogenerate.conceptIndex, this.autogenerate.conceptType).concept;
    }
  },


  /**
   * Hooks loads data, models ask children to load data
   * Basically, this method:
   * loads is theres something to be loaded:
   * does not load if there's nothing to be loaded
   * @param {Object} options (includes splashScreen)
   * @returns defer
   */
  loadData: function loadData() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};


    // then start loading data

    if (!this.which) return Promise.resolve();

    this.trigger("hook_change");

    // TODO: should be set on data source switch, but load happens before change events
    this.dataSource = this.getClosestModel(this.data);

    var query = this.getQuery(opts.splashScreen);

    if (query === true) return Promise.resolve();

    //useful to check if in the middle of a load call
    this._loadCall = true;

    this.setReady(false);

    utils.timeStamp("Vizabi Model: Loading Data: " + this._id);

    var parsers = this._getAllParsers();
    var dataPromise = this.dataSource.load(query, parsers);

    dataPromise.then(this.afterLoad.bind(this), function (err) {
      return utils.warn("Problem with query: ", err, JSON.stringify(query));
    });

    return dataPromise;
  },
  handleDataConnectedChange: function handleDataConnectedChange(evt) {
    var _this3 = this;

    //defer is necessary because other events might be queued.
    //load right after such events
    utils.defer(function () {
      _this3.startLoading().catch(utils.warn);
    });
  },
  _isLoading: function _isLoading() {
    return !this._loadedOnce || this._loadCall;
  },


  /**
   * executes after data has actually been loaded
   */
  afterLoad: function afterLoad(dataId) {
    this._dataId = dataId;
    utils.timeStamp("Vizabi Model: Data loaded: " + this._id);
  },


  /**
   * gets query that this model/hook needs to get data
   * @returns {Array} query
   */
  getQuery: function getQuery(splashScreen) {
    var filters = void 0;

    //error if there's nothing to hook to
    if (Object.keys(this._space).length < 1) {
      utils.error("Error:", this._id, "can't find the space");
      return true;
    }

    var prop = this.use === "property" || this.use === "constant";
    var exceptions = prop ? { exceptType: "time" } : {};

    // select
    // we remove this.which from values if it duplicates a dimension
    var allDimensions = utils.unique(this._getAllDimensions(exceptions));
    var dimensions = prop && allDimensions.length > 1 ? [this.spaceRef ? this._space[this.spaceRef].dim : this.which] : allDimensions;

    dimensions = dimensions.filter(function (f) {
      return f !== "_default";
    }); // && f!==null);
    if (!dimensions || !dimensions.length) {
      utils.warn("getQuery() produced no query because no keys are available");
      return true;
    }

    var select = {
      key: dimensions,
      value: dimensions.indexOf(this.which) != -1 || this.use === "constant" ? [] : [this.which]
    };

    // animatable
    var animatable = this._getFirstDimension({ type: "time" });

    // from
    var from = prop ? "entities" : "datapoints";

    // where
    filters = this._getAllFilters(exceptions, splashScreen);
    if (prop && allDimensions.length > 1) {
      var f = {};
      if (filters[dimensions]) f[dimensions] = filters[dimensions];
      filters = f;
    }

    // make root $and explicit
    var explicitAndFilters = {};
    if (Object.keys(filters).length > 0) {
      explicitAndFilters["$and"] = [];
      for (var filterKey in filters) {
        var filter = {};
        filter[filterKey] = filters[filterKey];
        explicitAndFilters["$and"].push(filter);
      }
    }

    // join
    var join = this._getAllJoins(exceptions, splashScreen);
    if (prop && allDimensions.length > 1) {
      var j = {};
      if (join["$" + dimensions]) j["$" + dimensions] = join["$" + dimensions];
      join = j;
    }

    //return query
    return {
      "language": this.getClosestModel("locale").id,
      "from": from,
      "animatable": animatable,
      "select": select,
      "where": explicitAndFilters,
      "join": join,
      "order_by": prop ? ["rank"] : [this._space.time.dim]
    };
  },


  /**
   * gets all hook dimensions
   * @param {Object} opts options with exceptType or onlyType
   * @returns {Array} all unique dimensions
   */
  _getAllDimensions: function _getAllDimensions(opts) {

    // hook dimensions = marker dimensions. Later, hooks might have extra dimensions : )
    return this._parent._getAllDimensions(opts);
  },


  /**
   * gets first dimension that matches type
   * @param {Object} options
   * @returns {Array} all unique dimensions
   */
  _getFirstDimension: function _getFirstDimension(opts) {

    // hook dimensions = marker dimensions. Later, hooks might have extra dimensions : )
    return this._parent._getFirstDimension(opts);
  },


  /**
   * gets all hook filters
   * @param {Boolean} splashScreen get filters for first screen only
   * @returns {Object} filters
   */
  _getAllFilters: function _getAllFilters(opts, splashScreen) {
    opts = opts || {};
    var filters = {};
    var _this = this;
    utils.forEach(this._space, function (h) {
      if (opts.exceptType && h.getType() === opts.exceptType) {
        return true;
      }
      if (opts.onlyType && h.getType() !== opts.onlyType) {
        return true;
      }
      if (h.skipFilter) return;
      // if query's dimensions are the same as the hook's, no join
      if (utils.arrayEquals(_this._getAllDimensions(opts), [h.getDimension()])) {
        filters = utils.extend(filters, h.getFilter(splashScreen));
      } else {
        var joinFilter = h.getFilter(splashScreen);
        if (joinFilter != null && !utils.isEmpty(joinFilter)) {
          var filter = {};
          filter[h.getDimension()] = "$" + h.getDimension();
          filters = utils.extend(filters, filter);
        }
      }
    });
    return filters;
  },
  _getAllJoins: function _getAllJoins(opts, splashScreen) {
    var joins = {};
    var _this = this;
    utils.forEach(this._space, function (h) {
      if (opts.exceptType && h.getType() === opts.exceptType) {
        return true;
      }
      if (opts.onlyType && h.getType() !== opts.onlyType) {
        return true;
      }
      if (utils.arrayEquals(_this._getAllDimensions(opts), [h.getDimension()])) {
        return true;
      }
      if (h.skipFilter) return;

      var filter = h.getFilter(splashScreen);
      if (filter != null && !utils.isEmpty(filter)) {
        joins["$" + h.getDimension()] = {
          key: h.getDimension(),
          where: h.getFilter(splashScreen)
        };
      }
    });
    return joins;
  },


  /**
   * gets all hook filters
   * @returns {Object} filters
   */
  _getAllParsers: function _getAllParsers() {

    var parsers = {};

    function addParser(model) {
      // get parsers from model
      var parser = model.getParser();
      var column = model.getDimensionOrWhich();
      if (parser && column) {
        parsers[column] = parser;
      }
    }

    // loop through all models which can have filters
    utils.forEach(this._space, function (h) {
      addParser(h);
    });
    addParser(this);

    return parsers;
  },


  /**
   * Gets tick values for this hook
   * @returns {Function} That returns the value for this tick
   */
  getTickFormatter: function getTickFormatter() {

    var _this = this;
    var SHARE = "share";
    var PERCENT = "percent";

    // percentageMode works like rounded if set to SHARE, but multiplies by 100 and suffixes with "%"
    // percentageMode works like rounded if set to PERCENT, but suffixes with "%"

    return function (x, index, group, removePrefix, percentageMode) {

      percentageMode = _this.getConceptprops().format;
      if (percentageMode === SHARE) x *= 100;

      // Format time values
      // Assumption: a hook has always time in its space
      if (utils.isDate(x)) return _this._space.time.formatDate(x);

      // Dealing with values that are supposed to be time
      if (_this.scaleType === "time" && !utils.isDate(x)) {
        return _this._space.time.formatDate(new Date(x));
      }

      // Strings, null, NaN and undefined are bypassing any formatter
      if (utils.isString(x) || !x && x !== 0) return x;

      if (Math.abs(x) < 0.00000000000001) return "0";

      var format = "r"; //rounded format. use "f" for fixed
      var prec = 3; //round to so many significant digits

      var prefix = "";
      if (removePrefix) return d3.format("." + prec + format)(x);

      //---------------------
      // BEAUTIFIERS GO HOME!
      // don't break formatting please
      //---------------------
      // the tiny constant compensates epsilon-error when doing logsrithms
      /* eslint-disable */
      switch (Math.floor(Math.log(Math.abs(x)) / Math.LN10 + 0.00000000000001)) {
        case -13:
          x *= 1000000000000;prefix = "p";break; //0.1p
        case -10:
          x *= 1000000000;prefix = "n";break; //0.1n
        case -7:
          x *= 1000000;prefix = "µ";break; //0.1µ
        case -6:
          x *= 1000000;prefix = "µ";break; //1µ
        case -5:
          x *= 1000000;prefix = "µ";break; //10µ
        case -4:
          break; //0.0001
        case -3:
          break; //0.001
        case -2:
          break; //0.01
        case -1:
          break; //0.1
        case 0:
          break; //1
        case 1:
          break; //10
        case 2:
          break; //100
        case 3:
          break; //1000
        case 4:
          x /= 1000;prefix = "k";break; //10k
        case 5:
          x /= 1000;prefix = "k";break; //100k
        case 6:
          x /= 1000000;prefix = "M";break; //1M
        case 7:
          x /= 1000000;prefix = "M";break; //10M
        case 8:
          x /= 1000000;prefix = "M";break; //100M
        case 9:
          x /= 1000000000;prefix = "B";break; //1B
        case 10:
          x /= 1000000000;prefix = "B";break; //10B
        case 11:
          x /= 1000000000;prefix = "B";break; //100B
        case 12:
          x /= 1000000000000;prefix = "TR";break; //1TR
        case 13:
          x /= 1000000000000;prefix = "TR";break; //10TR
        case 14:
          x /= 1000000000000;prefix = "TR";break; //100TR
        //use the D3 SI formatting for the extreme cases
        default:
          return d3.format("." + prec + "s")(x).replace("G", "B");
      }
      /* eslint-enable */

      var formatted = d3.format("." + prec + format)(x);
      //remove trailing zeros if dot exists to avoid numbers like 1.0M, 3.0B, 1.500, 0.9700, 0.0
      if (formatted.indexOf(".") > -1) formatted = formatted.replace(/0+$/, "").replace(/\.$/, "");

      // use manual formatting for the cases above
      return formatted + prefix + (percentageMode === PERCENT || percentageMode === SHARE ? "%" : "");
    };
  },


  /**
   * Gets the d3 scale for this hook. if no scale then builds it
   * @returns {Array} domain
   */
  getScale: function getScale() {
    if (this.scale == null) console.warn("scale is null");
    return this.scale;
  },


  /**
  * Gets unique values in a column
  * @param {String|Array} attr parameter
  * @returns {Array} unique values
  */
  getUnique: function getUnique(attr) {
    if (!this.isHook()) return;
    if (!attr) attr = this._getFirstDimension({ type: "time" });
    return this.dataSource.getData(this._dataId, "unique", attr);
  },
  getData: function getData() {
    return this.dataSource.getData(this._dataId);
  },


  /**
  * gets dataset without null or nan values with respect to this hook's which
  * @returns {Object} filtered items object
  */
  getValidItems: function getValidItems() {
    return this.dataSource.getData(this._dataId, "valid", this.which);
  },


  /**
   * gets nested dataset
   * @param {Array} keys define how to nest the set
   * @returns {Object} hash-map of key-value pairs
   */
  getNestedItems: function getNestedItems(keys) {
    if (!keys) return utils.warn("No keys provided to getNestedItems(<keys>)");
    return this.dataSource.getData(this._dataId, "nested", keys);
  },
  getHaveNoDataPointsPerKey: function getHaveNoDataPointsPerKey() {
    return this.dataSource.getData(this._dataId, "haveNoDataPointsPerKey", this.which);
  },


  /**
   * Gets limits
   * @param {String} attr parameter
   * @returns {Object} limits (min and max)
   */
  getLimits: function getLimits(attr) {
    return this.dataSource.getData(this._dataId, "limits", attr);
  },
  getFrame: function getFrame(steps, forceFrame, selected) {
    return this.dataSource.getFrame(this._dataId, steps, forceFrame, selected);
  },
  getFrames: function getFrames(steps, selected) {
    return this.dataSource.getFrames(this._dataId, steps, selected);
  },


  /**
   * gets hook values according dimension values
   */
  getItems: function getItems() {
    var _this = this;
    var dim = this.spaceRef && this._space[this.spaceRef] ? this._space[this.spaceRef].dim : _this._getFirstDimension({ exceptType: "time" });
    var items = {};
    this.getValidItems().forEach(function (d) {
      items[d[dim]] = d[_this.which];
    });
    return items;
  },
  getLimitsByDimensions: function getLimitsByDimensions(dims) {
    var filtered = this.dataSource.getData(this._dataId, "nested", dims);
    var values = {};
    var limitsDim = {};
    var attr = this.which;

    var countLimits = function countLimits(items, limitsDim, id) {

      var filtered = items.reduce(function (filtered, d) {

        // check for dates
        var f = utils.isDate(d[attr]) ? d[attr] : parseFloat(d[attr]);

        // if it is a number
        if (!isNaN(f)) {
          filtered.push(f);
        }

        //filter
        return filtered;
      }, []);

      // get min/max for the filtered rows
      var min = void 0;
      var max = void 0;
      var limits = {};
      for (var i = 0; i < filtered.length; i += 1) {
        var c = filtered[i];
        if (typeof min === "undefined" || c < min) {
          min = c;
        }
        if (typeof max === "undefined" || c > max) {
          max = c;
        }
      }
      limits.min = min || 0;
      limits.max = max || 100;
      limitsDim[id] = limits;
    };

    var iterateGroupKeys = function iterateGroupKeys(data, deep, result, cb) {
      deep--;
      utils.forEach(data, function (d, id) {
        if (deep) {
          result[id] = {};
          iterateGroupKeys(d, deep, result[id], cb);
        } else {
          cb(d, result, id);
        }
      });
    };

    iterateGroupKeys(filtered, dims.length, limitsDim, countLimits);

    return limitsDim;
  },


  /**
   * Gets the concept properties of the hook's "which"
   * @returns {Object} concept properties
   */
  getConceptprops: function getConceptprops() {
    return this.use !== "constant" && this.dataSource ? this.dataSource.getConceptprops(this.which) : {};
  },


  /**
   * Find if a current model is discrete
   * @returns {boolean} true if it's a discrete model, false if continious
   */
  isDiscrete: function isDiscrete() {
    return this.scaleType === "ordinal";
  },
  validate: function validate() {
    this._super();

    var allowedScales = this.getConceptprops().scales;
    if (allowedScales && allowedScales.length > 0 && !allowedScales.includes(this.scaleType)) {
      this.set({ scaleType: allowedScales[0] === "nominal" ? "ordinal" : allowedScales[0] }, null, false);
    }
  },
  getEntity: function getEntity() {
    return this._space[this.spaceRef ? this.spaceRef : this._parent.getSpace()[0]];
  }
});

exports.default = Hook;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

var META     = __webpack_require__(58)('meta')
  , isObject = __webpack_require__(6)
  , has      = __webpack_require__(14)
  , setDesc  = __webpack_require__(9).f
  , id       = 0;
var isExtensible = Object.isExtensible || function(){
  return true;
};
var FREEZE = !__webpack_require__(5)(function(){
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function(it){
  setDesc(it, META, {value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  }});
};
var fastKey = function(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add metadata
    if(!create)return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function(it, create){
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return true;
    // not necessary to add metadata
    if(!create)return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function(it){
  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY:      META,
  NEED:     false,
  fastKey:  fastKey,
  getWeak:  getWeak,
  onFreeze: onFreeze
};

/***/ }),
/* 44 */
/***/ (function(module, exports) {

module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};

/***/ }),
/* 45 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChangeEvent = exports.DefaultEvent = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _class = __webpack_require__(16);

var _class2 = _interopRequireDefault(_class);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var _freezeAllEvents = false;
var _frozenEventInstances = [];
var _freezeAllExceptions = {};

var DefaultEvent = exports.DefaultEvent = _class2.default.extend({

  source: "",
  type: "default",

  init: function init(source, type) {
    this.source = source;
    if (type) this.type = type;
  }
});

var ChangeEvent = exports.ChangeEvent = DefaultEvent.extend("change", {

  type: "change",

  init: function init(source) {
    this._super(source);
  }
});

var EventSource = _class2.default.extend({

  /**
   * Initializes the event class
   */
  init: function init() {
    this._id = this._id || utils.uniqueId("e");
    this._events = {};
    //freezing events
    this._freeze = false;
    this._freezer = [];
    this._freezeExceptions = {};
  },


  /**
   * Binds a callback function to an event: part 1: split grouped parameters in seperate calls
   * @param {String} type type of event
   * @param {String|Array} target path to object the event should be bound to or array of target paths
   * @param {Function|Array} func function to be bound with event or array with functions
   */
  on: function on(type, path, func) {

    // if parameters had to be split up in seperate calls, don't continue with this call
    if (this.splitEventParameters(type, path, func, this.on)) return;

    // get the target model
    var target = this.traversePath(path);
    if (!target) return;

    // register the event to this object
    target._events[type] = target._events[type] || [];
    if (typeof func === "function") {
      target._events[type].push(func);
    } else {
      utils.warn("Can't bind event '" + type + "'. It must be a function.");
    }
  },


  /**
   * Unbinds all events associated with a name or a specific one
   * @param {String|Array} name name of event or array with names
   */
  off: function off(type, path, func) {

    // if no arguments, unbind all
    if (arguments.length == 0) {
      this._events = {};
      return;
    }

    // if parameters had to be split up in seperate calls, don't continue with this call
    if (this.splitEventParameters(type, path, func, this.off)) return;

    // get target model
    var target = this.traversePath(path);
    if (!target) return;

    // unbind events
    if (target._events.hasOwnProperty(type)) {
      // if function not given, remove all events of type
      if (typeof func === "undefined") {
        target._events[type] = [];
        return;
      }
      var index = target._events[type].indexOf(func);
      if (index > -1) {
        target._events[type].splice(index, 1);
      } else {
        utils.warn("Could not unbind function " + func.name + ". Function not in bound function list.");
      }
    }
  },


  /**
   * Split grouped event parameters to seperate calls to given funtion
   * @param {String|Object|Array} type type of event
   * @param {String|Array} target path to object the event should be bound to or array of target paths
   * @param {Function|Array} func function to be bound with event or array with functions
   * @param {Function} eventFunc function to further process the split up parameters
   * @return {Boolean} true if the parameters where split up, false if nothing was split up
   * eventFunc is mostly arguments.callee but this is deprecated in ECMAscript 5: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/callee
   */
  splitEventParameters: function splitEventParameters(type, path, func, eventFunc) {
    var i = void 0;
    var calls = [];

    // multiple at a time, array format: [{type: function}, {'type:path': function}, ... ]
    // seems redundant but used so that binding-sets won't be turned into models (which happens when it's a pure object). Used e.g. in Tool.init();
    if (utils.isArray(type)) {
      for (i = 0; i < type.length; i += 1) {
        eventFunc.call(this, type[i], func);
      }
      return true;
    }

    //multiple at a time, object format: {type: function, 'type:path': function, ... }
    if (utils.isObject(type)) {
      for (i in type) {
        eventFunc.call(this, i, type[i]);
      }
      return true;
    }

    // type and path are both in type: on('type:path', function)
    // or
    // path undefined: on('type', function)
    if (typeof path === "function") {
      func = path; // put callback function in func variable
      // on('type:path', func)
      if (type.indexOf(":") !== -1) {
        var split = type.split(":");
        type = split[0];
        path = split[1];
      }
      // on(type, func)
      else {
          path = undefined;
        }
      eventFunc.call(this, type, path, func);
      return true;
    }

    // bind multiple paths at a time to one function: on(type, [path1, path2], function)
    if (utils.isArray(path)) {
      for (i = 0; i < path.length; i += 1) {
        eventFunc.call(this, type, path[i], func);
      }
      return true;
    }

    //bind multiple functions at the same time to one path: on(type, path, [function1, function2])
    if (func && utils.isArray(func)) {
      for (i = 0; i < func.length; i += 1) {
        eventFunc.call(this, type, path, func[i]);
      }
      return true;
    }
    return false;
  },


  /**
   * // TODO: if events will not be strictly model-bound, this might have to move to model.
   * Traverse path down the model tree
   * @param {String|Array} target path to object that should be returned. Either in string or array form
   */
  traversePath: function traversePath(path) {

    // if there's no path to traverse
    if (typeof path === "undefined" || utils.isArray(path) && path.length == 0) {
      return this;
    }

    // prepare path to array
    if (typeof path === "string") {
      path = path.split(".");
    }

    // check if path is an array
    if (!utils.isArray(path)) {
      utils.error("Path is wrong type. Path should be a string or array but is " + (typeof path === "undefined" ? "undefined" : _typeof(path)) + ".");
      return null;
    }

    // descent to next child to find target object
    var currentTarget = path.shift();
    if (this[currentTarget] === undefined) utils.warn('Can\'t find child "' + currentTarget + '" of the model ' + this._name + ".");else return this.getModelObject(currentTarget).traversePath(path);
  },
  createEventFromType: function createEventFromType(evtType) {
    if (evtType instanceof DefaultEvent) {
      return evtType;
    }

    var eventClass = DefaultEvent.get(evtType, true); // silent
    if (eventClass) {
      return new eventClass(this);
    }

    return new DefaultEvent(this, evtType);
  },


  /**
   * Triggers an event, adding it to the buffer
   * @param {String|Array} name name of event or array with names
   * @param args Optional arguments (values to be passed)
   */
  trigger: function trigger(evtType, args) {
    var _this2 = this;

    var i = void 0;
    var size = void 0;

    // split up eventType-paremeter for multiple event-triggers
    if (utils.isArray(evtType)) {
      for (i = 0, size = evtType.length; i < size; i += 1) {
        this.trigger(evtType[i], args);
      }
      return;
    }

    // create an event-object if necessary
    var evt = this.createEventFromType(evtType);

    // if this eventType has no events registered
    if (!this._events.hasOwnProperty(evt.type)) {
      return;
    }

    // for each function registered to this eventType on this object
    var _this = this;
    utils.forEach(this._events[evt.type], function (func) {

      // prepare execution
      var execute = function execute() {
        var msg = "Vizabi Event: " + evt.type; // + ' - ' + eventPath;
        utils.timeStamp(msg);
        func.apply(_this, [evt, args]);
      };

      //TODO: improve readability of freezer code
      //only execute if not frozen and exception doesnt exist
      if (_this2.allowExecution(evt)) {
        execute();
      } else {
        _this2._freezer.push(execute);
        if (_freezeAllEvents && !_frozenEventInstances[_this2._id]) {
          _this2.freeze();
          _frozenEventInstances[_this2._id] = _this2;
        }
      }
    });
  },
  allowExecution: function allowExecution(evt) {
    return !this._freeze && !_freezeAllEvents || // nothing frozen
    _freezeAllEvents && _freezeAllExceptions.hasOwnProperty(evt.type) || // freeze all but exception
    !_freezeAllEvents && this._freeze && this._freezeExceptions.hasOwnProperty(evt.type); // freeze but exception
  },


  /**
   * Prevents all events from being triggered, buffering them
   */
  freeze: function freeze(exceptions) {
    this._freeze = true;
    if (!exceptions) {
      return;
    }
    if (!utils.isArray(exceptions)) {
      exceptions = [exceptions];
    }
    for (var i = 0; i < exceptions.length; i += 1) {
      this._freezeExceptions[exceptions[i]] = true;
    }
  },


  /**
   * triggers all frozen events
   */
  unfreeze: function unfreeze() {
    this._freeze = false;
    this._freezeExceptions = {};
    //execute old frozen events
    while (this._freezer.length) {
      var execute = this._freezer.shift();
      execute();
    }
  },


  /**
   * clears all frozen events
   */
  clearFrozen: function clearFrozen() {
    this._freeze = false;
    this._freezeExceptions = {};
    this._freezer = [];
  }
});

EventSource.freezeAll = freezeAll;
EventSource.unfreezeAll = unfreezeAll;

//generic event functions
/**
 * freezes all events
 */
function freezeAll(exceptions) {
  _freezeAllEvents = true;
  if (!exceptions) {
    return;
  }
  if (!utils.isArray(exceptions)) {
    exceptions = [exceptions];
  }
  utils.forEach(exceptions, function (e) {
    _freezeAllExceptions[e] = true;
  });
}

/**
 * triggers all frozen events form all instances
 */
function unfreezeAll() {
  _freezeAllEvents = false;
  _freezeAllExceptions = {};
  //unfreeze all instances
  var keys = Object.keys(_frozenEventInstances);
  for (var i = 0; i < keys.length; i++) {
    var instance = _frozenEventInstances[keys[i]];
    if (!instance) {
      continue;
    }
    instance.unfreeze();
  }
  _frozenEventInstances = {};
}

exports.default = EventSource;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _events = __webpack_require__(46);

var _events2 = _interopRequireDefault(_events);

var _intervals = __webpack_require__(208);

var _intervals2 = _interopRequireDefault(_intervals);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var ModelLeaf = _events2.default.extend({

  _name: "",
  _parent: null,
  _persistent: true,

  init: function init(name, value, parent, binds, persistent) {

    // getter and setter for the value
    Object.defineProperty(this, "value", {
      get: this.get,
      set: this.set
    });
    Object.defineProperty(this, "persistent", {
      get: function get() {
        return this._persistent;
      }
    });

    this._super();

    this._name = name;
    this._parent = parent;
    this._root = parent._root;
    this.set(value, false, persistent);
    this.on(binds); // after super so there is an .events object
  },


  // if they want a persistent value and the current value is not persistent, return the last persistent value
  get: function get(persistent) {
    return persistent && !this._persistent ? this._persistentVal : this._val;
  },
  set: function set(val, force, persistent) {
    if (this.isSetAllowed(val, force)) {
      // persistent defaults to true
      persistent = typeof persistent !== "undefined" ? persistent : true;

      // set leaf properties
      if (persistent) this._persistentVal = val; // set persistent value if change is persistent.
      this._previousVal = utils.deepClone(this._val);
      this._val = val;
      this._persistent = persistent;

      // trigger change event
      this.trigger(new _events.ChangeEvent(this), this._name);

      return true;
    }
    return false;
  },
  isSetAllowed: function isSetAllowed(val, force) {
    return force || this._val !== val && JSON.stringify(this._val) !== JSON.stringify(val);
  },


  // duplicate from Model. Should be in a shared parent class.
  setTreeFreezer: function setTreeFreezer(freezerStatus) {
    if (freezerStatus) {
      this.freeze(["hook_change"]);
    } else {
      this.unfreeze();
    }
  }
});

var Model = _events2.default.extend({

  getClassDefaults: function getClassDefaults() {
    return {};
  },

  /**
   * A leaf model which has an object as value.
   * Needed when parsing plain JS objects. Enables distinction between models and leafs with object values.
   **/
  objectLeafs: [],

  /**
   * Initializes the model.
   * @param {Object} values The initial values of this model
   * @param {Object} parent reference to parent
   * @param {Object} bind Initial events to bind
   * @param {Boolean} freeze block events from being dispatched
   */
  init: function init(name, values, parent, bind) {
    this._type = this._type || "model";
    this._id = this._id || utils.uniqueId("m");
    this._data = {};
    //holds attributes of this model
    this._parent = parent;
    this._root = parent ? parent._root : this;
    this._name = name;
    this._ready = false;
    this._readyOnce = false;
    //has this model ever been ready?
    this._loadedOnce = false;
    //array of processes that are loading
    this._intervals = getIntervals(this);

    //will the model be hooked to data?
    this._space = {};

    this._dataId = false;
    this._limits = {};
    //stores limit values
    this._super();

    // initial values
    // add defaults to initialValues
    var initialValues = utils.deepExtend({}, this.getClassDefaults(), values);
    this.set(initialValues);

    // bind initial events
    // bind after setting, so no events are fired by setting initial values
    if (bind) {
      this.on(bind);
    }
  },


  /* ==========================
   * Getters and Setters
   * ==========================
   */

  /**
   * Gets an attribute from this model or all fields.
   * @param attribute Optional attribute
   * @returns attr value or all values if attr is undefined
   */
  get: function get(attribute) {
    if (attribute) {
      var model = this._data[attribute];

      return Model.isModel(model) ? model : model.value;
    }

    return this._data;
  },


  /**
   * Sets an attribute or multiple for this model (inspired by Backbone)
   * @param attr property name
   * @param val property value (object or value)
   * @param {Boolean} force force setting of property to value and triggers set event
   * @param {Boolean} persistent true if the change is a persistent change
   * @returns defer defer that will be resolved when set is done
   */
  set: function set(attr, val, force, persistent) {
    var setting = this._setting;
    var attrs = void 0;
    var freezeCall = false; // boolean, indicates if this .set()-call froze the modelTree

    //expect object as default
    if (!utils.isPlainObject(attr)) {
      (attrs = {})[attr] = val;
    } else {
      // move all arguments one place
      attrs = attr;
      persistent = force;
      force = val;
    }

    //do nothing if setting an empty object
    if (Object.keys(attrs).length === 0) return;

    //we are currently setting the model
    this._setting = true;

    // Freeze the whole model tree if not frozen yet, so no events are fired while setting
    if (!this._freeze) {
      freezeCall = true;
      this.setTreeFreezer(true);
    }

    // init/set all given values
    var changes = [];
    for (var attribute in attrs) {
      val = attrs[attribute];

      var bothModel = utils.isPlainObject(val) && this._data[attribute] instanceof Model;
      var bothModelLeaf = (!utils.isPlainObject(val) || this.isObjectLeaf(attribute)) && this._data[attribute] instanceof ModelLeaf;

      if (this._data[attribute] && (bothModel || bothModelLeaf)) {
        // data type does not change (model or leaf and can be set through set-function)
        var setSuccess = this._data[attribute].set(val, force, persistent);
        if (bothModelLeaf && setSuccess) {
          changes.push(attribute);
        }
      } else {
        // data type has changed or is new, so initializing the model/leaf
        this._data[attribute] = initSubmodel(attribute, val, this, persistent);
        bindSetterGetter(this, attribute);
      }
    }

    if (!setting) {
      this.checkDataChanges(changes);
      if (this.validate) {
        this.validate();
      }
    }

    if (!setting || force) {
      this._setting = false;
      if (freezeCall && (!this.isHook() || !this.isLoading())) {
        this.setTreeFreezer(false);
      }
      if (!this.isHook() && !this.isLoading()) {
        this.setReady();
      }
    }

    // if this set()-call was the one freezing the tree, now the tree can be unfrozen (i.e. all setting is done)
  },


  // standard model doesn't do anything with data
  // overloaded by hook/entities
  checkDataChanges: function checkDataChanges() {},
  setTreeFreezer: function setTreeFreezer(freezerStatus) {
    // first traverse down
    // this ensures deepest events are triggered first
    utils.forEach(this._data, function (submodel) {
      submodel.setTreeFreezer(freezerStatus);
    });

    // then freeze/unfreeze
    if (freezerStatus) {
      this.freeze(["hook_change"]);
    } else {
      this.unfreeze();
    }
  },


  /**
   * Gets the type of this model
   * @returns {String} type of the model
   */
  getType: function getType() {
    return this._type;
  },


  /**
   * Gets all submodels of the current model
   * @param {Object} object [object=false] Should it return an object?
   * @param {Function} validationFunction Validation function
   * @returns {Array} submodels
   */
  getSubmodels: function getSubmodels() {
    var object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var validationFunction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
      return true;
    };

    var submodels = object ? {} : [];
    utils.forEach(this._data, function (subModel, name) {
      if (subModel && typeof subModel._id !== "undefined" && Model.isModel(subModel) && validationFunction(subModel)) {
        if (object) {
          submodels[name] = subModel;
        } else {
          submodels.push(subModel);
        }
      }
    });
    return submodels;
  },


  /**
   * Gets the current model and submodel values as a JS object
   * @returns {Object} All model as JS object, leafs will return their values
   */
  getPlainObject: function getPlainObject(persistent) {
    var obj = {};
    var _this = this;
    utils.forEach(this._data, function (dataItem, i) {
      // if it's a submodel
      if (dataItem instanceof Model) {
        obj[i] = dataItem.getPlainObject(persistent);
      }
      // if it's a modelLeaf
      else {
          //if asked for persistent then add value to result only if modelLeaf state is
          //persistent
          if (!persistent || dataItem.persistent) {
            var leafValue = dataItem.get(persistent);
            if (utils.isDate(leafValue)) leafValue = _this.formatDate(leafValue);
            obj[i] = leafValue;
          }
        }
    });
    return obj;
  },
  formatDate: function formatDate(dateObject) {
    return dateObject.toString();
  },


  /**
   * Gets the requested object, including the leaf-object, not the value
   * @returns {Object} Model or ModelLeaf object.
   */
  getModelObject: function getModelObject(name) {
    return name ? this._data[name] : this;
  },


  /**
   * Clears this model, submodels, data and events
   */
  clear: function clear() {
    var submodels = this.getSubmodels();
    for (var i in submodels) {
      submodels[i].clear();
    }
    this.setReady(false);
    this.off();
    this._intervals.clearAllIntervals();
    this._data = {};
  },


  /**
   * Validates data.
   * Interface for the validation function implemented by a model
   * @returns Promise or nothing
   */
  validate: function validate() {},


  /* ==========================
   * Model loading
   * ==========================
   */

  // normal model is never loading
  _isLoading: function _isLoading() {
    return false;
  },


  /**
   * checks whether this model is loading anything
   * @param {String} optional process id (to check only one)
   * @returns {Boolean} is it loading?
   */
  isLoading: function isLoading() {
    if (this._isLoading()) return true;

    //if not loading anything, check submodels
    var submodels = this.getSubmodels();
    var i = void 0;
    for (i = 0; i < submodels.length; i += 1) {
      if (submodels[i].isLoading()) {
        return true;
      }
    }

    return false;
  },


  /**
   * Sets the model as ready or not depending on its loading status
   */
  setReady: function setReady(value) {
    if (value === false) {
      this._ready = false;
      if (this._parent && this._parent.setReady) {
        this._parent.setReady(false);
      }
      return;
    }
    //only ready if nothing is loading at all
    var prev_ready = this._ready;
    this._ready = !this.isLoading() && !this._setting;
    // if now ready and wasn't ready yet
    if (this._ready && prev_ready !== this._ready) {
      if (!this._readyOnce) {
        this._readyOnce = true;
        this.trigger("readyOnce");
      }
      this.trigger("ready");
    }
  },
  setInterModelListeners: function setInterModelListeners() {
    utils.forEach(this.getSubmodels(), function (subModel) {
      return subModel.setInterModelListeners();
    });
  },
  startPreload: function startPreload() {

    var promises = [];
    promises.push(this.preloadData());

    utils.forEach(this.getSubmodels(), function (subModel) {
      return promises.push(subModel.startPreload());
    });

    return Promise.all(promises);
  },
  preloadData: function preloadData() {
    return Promise.resolve();
  },


  /**
   * loads data (if hook)
   * Hooks loads data, models ask children to load data
   * Basically, this method:
   * loads is theres something to be loaded:
   * does not load if there's nothing to be loaded
   * @param {Object} options (includes splashScreen)
   * @returns defer
   */
  startLoading: function startLoading(opts) {
    var _this2 = this;

    var promises = [];
    promises.push(this.loadData(opts));

    utils.forEach(this.getSubmodels(), function (subModel) {
      return promises.push(subModel.startLoading(opts));
    });

    return Promise.all(promises).then(this.onSuccessfullLoad.bind(this)).catch(function (error) {
      var translator = _this2.getClosestModel("locale").getTFunction();
      _this2.triggerLoadError([translator("crash/error"), window.navigator.userAgent, error].join("<br>"));
    });
  },
  loadData: function loadData(opts) {
    if (this.isHook()) utils.warn("Hook " + this._name + " is not loading because it's not extending Hook prototype.");
    return Promise.resolve();
  },
  loadSubmodels: function loadSubmodels(options) {
    var promises = [];
    var subModels = this.getSubmodels();
    utils.forEach(subModels, function (subModel) {
      promises.push(subModel.startLoading(options));
    });
    return promises.length > 0 ? Promise.all(promises) : Promise.resolve();
  },
  onSuccessfullLoad: function onSuccessfullLoad() {
    var _this3 = this;

    this.validate();
    utils.timeStamp("Vizabi Model: Model loaded: " + this._name + "(" + this._id + ")");
    //end this load call
    this._loadedOnce = true;

    this._loadCall = false;
    this.setTreeFreezer(false);

    //we need to defer to make sure all other submodels
    //have a chance to call loading for the second time
    utils.defer(function () {
      return _this3.setReady();
    });
  },
  triggerLoadError: function triggerLoadError(error) {
    utils.error(error);
    this.trigger("load_error", error);
  },


  /**
   * executes after preloading processing is done
   */
  afterPreload: function afterPreload() {
    var submodels = this.getSubmodels();
    utils.forEach(submodels, function (s) {
      s.afterPreload();
    });
  },


  /* ===============================
   * Hooking model to external data
   * ===============================
   */

  /**
   * is this model hooked to data?
   */
  isHook: function isHook() {
    return Boolean(this.use);
  },


  /**
   * Gets all submodels of the current model that are hooks
   * @param object [object=false] Should it return an object?
   * @returns {Array|Object} hooks array or object
   */
  getSubhooks: function getSubhooks(object) {
    return this.getSubmodels(object, function (s) {
      return s.isHook();
    });
  },


  /**
   * gets all sub values for a certain hook
   * only hooks have the "hook" attribute.
   * @param {String} type specific type to lookup
   * @returns {Array} all unique values with specific hook use
   */
  getHookWhich: function getHookWhich(type) {
    var values = [];
    if (this.use && this.use === type) {
      values.push(this.which);
    }
    //repeat for each submodel
    utils.forEach(this.getSubmodels(), function (s) {
      values = utils.unique(values.concat(s.getHookWhich(type)));
    });
    //now we have an array with all values in a type of hook for hooks.
    return values;
  },


  /**
   * gets all sub values for indicators in this model
   * @returns {Array} all unique values of indicator hooks
   */
  getIndicators: function getIndicators() {
    return this.getHookWhich("indicator");
  },


  /**
   * gets all sub values for indicators in this model
   * @returns {Array} all unique values of property hooks
   */
  getProperties: function getProperties() {
    return this.getHookWhich("property");
  },


  /**
   * Gets the dimension of this model if it has one
   * @returns {String|Boolean} dimension
   */
  getDimension: function getDimension() {
    return this.dim || false; //defaults to dim if it exists
  },


  /**
   * Gets the dimension (if entity) or which (if hook) of this model
   * @returns {String|Boolean} dimension
   */
  getDimensionOrWhich: function getDimensionOrWhich() {
    return this.dim || (this.use != "constant" ? this.which : false); //defaults to dim or which if it exists
  },


  /**
   * Gets the filter for this model if it has one
   * @returns {Object} filters
   */
  getFilter: function getFilter() {
    return {}; //defaults to no filter
  },


  /**
   * maps the value to this hook's specifications
   * @param value Original value
   * @returns hooked value
   */
  mapValue: function mapValue(value) {
    return value;
  },


  /**
   * Gets formatter for this model
   * @returns {Function|Boolean} formatter function
   */
  getParser: function getParser() {
    //TODO: default formatter is moved to utils. need to return it to hook prototype class, but retest #1212 #1230 #1253
    return null;
  },


  /**
   * @return {Object} defaults of this model, and when available overwritten by submodel defaults
   */
  getDefaults: function getDefaults() {
    return utils.deepExtend({}, this.getClassDefaults(), this.getSubmodelDefaults());
  },


  /**
   * @return {Object} All defaults coming from submodels
   */
  getSubmodelDefaults: function getSubmodelDefaults() {
    var d = {};
    utils.forEach(this.getSubmodels(true), function (model, name) {
      d[name] = model.getDefaults();
    });
    return d;
  },


  /**
   * @param  {name} name of the child to check
   * @return {Boolean} if the child is a leaf with a plain object as value
   */
  isObjectLeaf: function isObjectLeaf(name) {
    return this.objectLeafs.indexOf(name) !== -1;
  },


  /**
   * gets closest prefix model moving up the model tree
   * @param {String} prefix
   * @returns {Object} submodel
   */
  getClosestModel: function getClosestModel(name) {
    var model = this.findSubmodel(name);
    if (model) {
      return model;
    } else if (this._parent) {
      return this._parent.getClosestModel(name);
    }
    return null;
  },


  /**
   * find submodel with name that starts with prefix
   * @param {String} prefix
   * @returns {Object} submodel or false if nothing is found
   */
  findSubmodel: function findSubmodel(name) {
    for (var i in this._data) {
      //found submodel
      if (i === name && Model.isModel(this._data[i])) {
        return this._data[i];
      }
    }
    return null;
  }
});

/* ===============================
 * Private Helper Functions
 * ===============================
 */

/**
 * Checks whether an object is a model or not
 * if includeLeaf is true, a leaf is also seen as a model
 */
Model.isModel = function (model, includeLeaf) {
  return model && (model.hasOwnProperty("_data") || includeLeaf && model.hasOwnProperty("_val"));
};

function bindSetterGetter(model, prop) {
  Object.defineProperty(model, prop, {
    configurable: true,
    //allow reconfiguration
    get: function (p) {
      return function () {
        return model.get(p);
      };
    }(prop),
    set: function (p) {
      return function (value) {
        return model.set(p, value);
      };
    }(prop)
  });
}

/**
 * Loads a submodel, when necessaary
 * @param {String} attr Name of submodel
 * @param {Object} val Initial values
 * @param {Object} ctx context / parent model
 * @param {Boolean} persistent true if the change is a persistent change
 * @returns {Object} model new submodel
 */
function initSubmodel(attr, val, ctx, persistent) {

  var submodel = void 0;

  // if value is a value -> leaf
  if (!utils.isPlainObject(val) || utils.isArray(val) || ctx.isObjectLeaf(attr)) {

    var binds = {
      //the submodel has changed (multiple times)
      "change": onChange
    };
    submodel = new ModelLeaf(attr, val, ctx, binds, persistent);
  }

  // if value is an object -> model
  else {

      var _binds = {
        //the submodel has changed (multiple times)
        "change": onChange,
        //loading has started in this submodel (multiple times)
        "hook_change": onHookChange,
        // error triggered in loading
        "load_error": function load_error() {
          return ctx.trigger.apply(ctx, arguments);
        },
        //loading has ended in this submodel (multiple times)
        "ready": onReady
      };

      // if the value is an already instantiated submodel (Model or ModelLeaf)
      // this is the case for example when a new componentmodel is made (in Component._modelMapping)
      // it takes the submodels from the toolmodel and creates a new model for the component which refers
      // to the instantiated submodels (by passing them as model values, and thus they reach here)
      if (Model.isModel(val, true)) {
        submodel = val;
        submodel.on(_binds);
      }
      // if it's just a plain object, create a new model
      else {
          // construct model
          var modelType = attr.split("_")[0];

          var Modl = Model.get(modelType, true);
          if (!Modl) {
            try {
              Modl = __webpack_require__(476)("./" + modelType).default;
            } catch (err) {
              Modl = Model;
            }
          }

          submodel = new Modl(attr, val, ctx, _binds);
          // model is still frozen but will be unfrozen at end of original .set()
        }
    }

  return submodel;

  // Default event handlers for models
  function onChange(evt, path) {
    if (!ctx._ready) return; //block change propagation if model isnt ready
    path = ctx._name + "." + path;
    ctx.trigger(evt, path);
  }
  function onHookChange(evt, vals) {
    ctx.trigger(evt, vals);
  }
  function onReady(evt, vals) {
    //trigger only for submodel
    ctx.setReady(false);
    //wait to make sure it's not set false again in the next execution loop
    utils.defer(function () {
      ctx.setReady();
    });
    //ctx.trigger(evt, vals);
  }
}

/**
 * gets closest interval from this model or parent
 * @returns {Object} Intervals object
 */
function getIntervals(ctx) {
  return ctx._intervals || (ctx._parent ? getIntervals(ctx._parent) : new _intervals2.default());
}

exports.default = Model;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _iconset = __webpack_require__(10);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*!
 * VIZABI INDICATOR PICKER
 * Reusable indicator picker component
 */

var IndPicker = _component2.default.extend({

  /**
   * Initializes the Indicator Picker.
   * Executed once before any template is rendered.
   * @param config The options passed to the component
   * @param context The component's parent
   */
  init: function init(config, context) {

    this.name = "gapminder-indicatorpicker";
    this.template = '<span class="vzb-ip-holder"><span class="vzb-ip-select"></span><span class="vzb-ip-info"></span></span>';

    var _this = this;

    this.model_expects = [{
      name: "time",
      type: "time"
    }, {
      name: "entities",
      type: "entities"
    }, {
      name: "marker",
      type: "model"
    }, {
      name: "locale",
      type: "locale"
    }];

    this.markerID = config.markerID;
    this.showHoverValues = config.showHoverValues || false;
    if (!config.markerID) utils.warn("indicatorpicker.js complains on 'markerID' property: " + config.markerID);

    this.model_binds = {
      "translate:locale": function translateLocale(evt) {
        _this.updateView();
      },
      "ready": function ready(evt) {
        _this.updateView();
      }
    };

    if (this.markerID) {
      this.model_binds["change:marker." + this.markerID + ".which"] = function (evt) {
        _this.updateView();
      };
    }

    if (this.showHoverValues) {
      this.model_binds["change:marker.highlight"] = function (evt, values) {
        var mdl = _this.model.marker[_this.markerID];
        if (!_this.showHoverValues || mdl.use == "constant") return;
        var _highlightedEntity = _this.model.marker.getHighlighted();
        if (_highlightedEntity.length > 1) return;

        if (_highlightedEntity.length) {
          _this.model.marker.getFrame(_this.model.time.value, function (frame) {
            if (_this._highlighted || !frame) return;

            // should be replaced by dimension of entity set for this hook (if use == property)
            var dimension = _this.model.entities.getDimension();
            var _highlightedEntity = _this.model.marker.getHighlighted(dimension);
            if (_highlightedEntity.length) {

              var value = frame[_this.markerID][_highlightedEntity[0]];

              // resolve strings via the color legend model
              if (value && mdl._type === "color" && mdl.isDiscrete()) {
                var clModel = mdl.getColorlegendMarker();
                if (clModel.label.getItems()[value]) value = clModel.label.getItems()[value];
              }

              _this._highlightedValue = value;

              _this._highlighted = !_this._highlightedValue && _this._highlightedValue !== 0 || mdl.use !== "constant";
              _this.updateView();
            }
          });
        } else {
          if (values !== null && values !== "highlight") {
            if (values) {
              _this._highlightedValue = values[_this.markerID];
              _this._highlighted = !_this._highlightedValue && _this._highlightedValue !== 0 || mdl.use !== "constant";
            }
          } else {
            _this._highlighted = false;
          }
          _this.updateView();
        }
      };
    }

    //contructor is the same as any component
    this._super(config, context);
  },
  ready: function ready() {
    this.updateView();
  },
  readyOnce: function readyOnce() {
    var _this = this;

    this.el_select = d3.select(this.element).select(".vzb-ip-select");

    this.el_select.on("click", function () {
      var rect = _this.el_select.node().getBoundingClientRect();
      var rootEl = _this.root.element instanceof Array ? _this.root.element : d3.select(_this.root.element);
      var rootRect = rootEl.node().getBoundingClientRect();
      var treemenuComp = _this.root.findChildByName("gapminder-treemenu");
      var treemenuColWidth = treemenuComp.activeProfile.col_width;
      var treemenuPaddLeft = parseInt(treemenuComp.wrapper.style("padding-left"), 10) || 0;
      var treemenuPaddRight = parseInt(treemenuComp.wrapper.style("padding-right"), 10) || 0;
      var topPos = rect.bottom - rootRect.top;
      var leftPos = rect.left - rootRect.left - (treemenuPaddLeft + treemenuPaddRight + treemenuColWidth - rect.width) * 0.5;

      treemenuComp.markerID(_this.markerID).alignX("left").alignY("top").top(topPos).left(leftPos).updateView().toggle();
    });

    this.infoEl = d3.select(this.element).select(".vzb-ip-info");
    utils.setIcon(this.infoEl, _iconset.question).select("svg").attr("width", "0px").attr("height", "0px");

    this.infoEl.on("click", function () {
      _this.root.findChildByName("gapminder-datanotes").pin();
    });
    this.infoEl.on("mouseover", function () {
      var rect = _this.el_select.node().getBoundingClientRect();
      var rootRect = _this.root.element.getBoundingClientRect();
      var topPos = rect.bottom - rootRect.top;
      var leftPos = rect.left - rootRect.left + rect.width;

      _this.root.findChildByName("gapminder-datanotes").setHook(_this.markerID).show().setPos(leftPos, topPos);
    });
    this.infoEl.on("mouseout", function () {
      _this.root.findChildByName("gapminder-datanotes").hide();
    });
  },
  updateView: function updateView() {
    if (!this._readyOnce) return;

    var _this = this;
    var translator = this.model.locale.getTFunction();

    var which = this.model.marker[this.markerID].which;
    var type = this.model.marker[this.markerID]._type;
    var concept = this.model.marker[this.markerID].getConceptprops();

    var selectText = void 0;

    if (this.showHoverValues && this._highlighted) {
      var unit = !concept.unit ? "" : " " + concept.unit;
      var formatter = _this.model.marker[this.markerID].getTickFormatter();

      selectText = this._highlightedValue || this._highlightedValue === 0 ? formatter(this._highlightedValue) + unit : translator("hints/nodata");
    } else {
      //Let the indicator "_default" in tree menu be translated differnetly for every hook type
      selectText = which === "_default" ? translator("indicator/_default/" + type) : concept.name;
    }

    this.el_select.text(selectText);

    // hide info el if no data is available for it to make sense
    var hideInfoEl = !concept.description && !concept.sourceName && !concept.sourceLink;
    this.infoEl.classed("vzb-hidden", hideInfoEl);
  }
});

exports.default = IndPicker;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SteppedSlider = _component2.default.extend({
  init: function init(config, context) {
    var _this = this;

    this.name = "steppedSlider";
    this.template = __webpack_require__(455);

    this.config = Object.assign({
      triangleWidth: 10,
      triangleHeight: 10,
      height: 31,
      lineWidth: 10,
      domain: [1, 2, 3, 4, 5, 6],
      range: [1200, 900, 450, 200, 150, 100]
    }, config);

    this.config.height -= this.config.triangleHeight / 2;

    this.model_expects = [{
      name: "time",
      type: "time"
    }, {
      name: "locale",
      type: "locale"
    }];

    this.model_binds = {
      "change:time.delay": function changeTimeDelay() {
        _this.redraw();
      }
    };

    this.setDelay = (0, _utils.throttle)(this.setDelay, 50);

    this._super(config, context);
  },
  readyOnce: function readyOnce() {
    var _config = this.config,
        domain = _config.domain,
        range = _config.range,
        height = _config.height;


    this.element = d3.select(this.element);
    this.svg = this.element.select("svg");

    this.axisScale = d3.scale.log().domain(d3.extent(domain)).range([height, 0]);

    this.delayScale = d3.scale.linear().domain(domain).range(range);

    this.initTriangle();
    this.initAxis();

    this.redraw();
  },
  initAxis: function initAxis() {
    var _this2 = this;

    var _config2 = this.config,
        lineWidth = _config2.lineWidth,
        triangleWidth = _config2.triangleWidth,
        triangleHeight = _config2.triangleHeight,
        height = _config2.height;


    var axis = d3.axisLeft().scale(this.axisScale).tickFormat(function () {
      return "";
    }).tickSizeInner(lineWidth).tickSizeOuter(0);

    var tx = triangleWidth + lineWidth / 2;
    var ty = triangleHeight / 2;
    this.svg.on("mousedown", function () {
      var offsetY = d3.event.offsetY;

      var y = Math.max(0, Math.min(offsetY - ty, height));

      _this2.setDelay(Math.round(_this2.delayScale(_this2.axisScale.invert(y))), true, true);
    }).select(".vzb-stepped-speed-slider-axis").attr("transform", "translate(" + tx + ", " + ty + ")").call(axis);

    this.drag = d3.drag().on("drag", function () {
      var dy = d3.event.dy;

      var _transform = (0, _utils.transform)(_this2.slide.node()),
          translateY = _transform.translateY;

      var y = Math.max(0, Math.min(dy + translateY, height));

      _this2.setDelay(Math.round(_this2.delayScale(_this2.axisScale.invert(y))));
      _this2.redraw(y);
    }).on("end", function () {
      _this2.setDelay(_this2.model.time.delay, true, true);
    });

    this.svg.call(this.drag);
  },
  initTriangle: function initTriangle() {
    var _config3 = this.config,
        triangleWidth = _config3.triangleWidth,
        triangleHeight = _config3.triangleHeight,
        lineWidth = _config3.lineWidth;


    this.slide = this.svg.select(".vzb-stepped-speed-slider-triangle");

    this.slide.append("g").append("path").attr("d", this.getTrianglePath());
  },
  getTrianglePath: function getTrianglePath() {
    var _config4 = this.config,
        triangleHeight = _config4.triangleHeight,
        triangleWidth = _config4.triangleWidth;


    return "M " + triangleWidth + "," + triangleHeight / 2 + " 0," + triangleHeight + " 0,0 z";
  },
  setDelay: function setDelay(value) {
    var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var persistent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    this.model.time.set("delay", value, force, persistent);
  },
  redraw: function redraw() {
    var y = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.axisScale(this.delayScale.invert(this.model.time.delay));

    this.slide.attr("transform", "translate(0, " + y + ")");
  }
});

exports.default = SteppedSlider;

/***/ }),
/* 50 */
/***/ (function(module, exports) {

module.exports = function(it, Constructor, name, forbiddenField){
  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

/***/ }),
/* 51 */
/***/ (function(module, exports) {

module.exports = false;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject    = __webpack_require__(3)
  , dPs         = __webpack_require__(167)
  , enumBugKeys = __webpack_require__(94)
  , IE_PROTO    = __webpack_require__(106)('IE_PROTO')
  , Empty       = function(){ /* empty */ }
  , PROTOTYPE   = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(93)('iframe')
    , i      = enumBugKeys.length
    , lt     = '<'
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(96).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties){
  var result;
  if(O !== null){
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty;
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys      = __webpack_require__(169)
  , hiddenKeys = __webpack_require__(94).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
  return $keys(O, hiddenKeys);
};

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys       = __webpack_require__(169)
  , enumBugKeys = __webpack_require__(94);

module.exports = Object.keys || function keys(O){
  return $keys(O, enumBugKeys);
};

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__(19);
module.exports = function(target, src, safe){
  for(var key in src)redefine(target, key, src[key], safe);
  return target;
};

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global      = __webpack_require__(4)
  , dP          = __webpack_require__(9)
  , DESCRIPTORS = __webpack_require__(8)
  , SPECIES     = __webpack_require__(7)('species');

module.exports = function(KEY){
  var C = global[KEY];
  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
    configurable: true,
    get: function(){ return this; }
  });
};

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(45)
  , max       = Math.max
  , min       = Math.min;
module.exports = function(index, length){
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

/***/ }),
/* 58 */
/***/ (function(module, exports) {

var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _component2.default.extend({
  init: function init(config, context) {
    this.template = '<span class="vzb-sc-holder vzb-dialog-checkbox"><input type="checkbox"><label></label></span>';
    var _this = this;
    this.name = "gapminder-simplecheckbox";

    this.checkbox = config.checkbox;
    this.submodel = config.submodel;

    this.model_expects = [{
      name: "mdl"
      //TODO: learn how to expect model "axis" or "size" or "color"
    }, {
      name: "locale",
      type: "locale"
    }];

    this.model_binds = {
      "change:mdl": function changeMdl(evt) {
        _this.updateView();
      },
      "translate:locale": function translateLocale(evt) {
        _this.updateView();
      }
    };

    var submodel = this.submodel ? this.submodel + ":" : "";
    this.model_binds["change:mdl." + submodel + this.checkbox] = function () {
      _this.updateView();
    };

    //contructor is the same as any component
    this._super(config, context);
  },
  ready: function ready() {
    this.parentModel = this.submodel ? this.model.mdl[this.submodel] : this.model.mdl;
    this.updateView();
  },
  readyOnce: function readyOnce() {
    var _this = this;
    this.element = d3.select(this.element);
    var id = "-check-" + _this._id;
    this.labelEl = this.element.select("label").attr("for", id);
    this.checkEl = this.element.select("input").attr("id", id).on("change", function () {
      _this._setModel(d3.select(this).property("checked"));
    });
  },
  updateView: function updateView() {
    this.translator = this.model.locale.getTFunction();
    this.labelEl.text(this.translator("check/" + this.checkbox));
    this.checkEl.property("checked", !!this.parentModel[this.checkbox]);
  },
  _setModel: function _setModel(value) {
    this.parentModel[this.checkbox] = value;
  }
});

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }(); //d3.svg.dynamicBackground


var _class = __webpack_require__(16);

var _class2 = _interopRequireDefault(_class);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _class2.default.extend({
  init: function init(context, conditions) {
    this.context = context;
    this.context.classed('vzb-dynamic-background', true);

    this.width = 0;
    this.height = 0;
    this.topOffset = 0;
    this.leftOffset = 0;
    this.bottomOffset = 0;
    this.rightOffset = 0;
    this.textWidth = 0;
    this.textHeight = 0;
    this.widthRatio = 0.9;
    this.heightRatio = 0.9;
    this.xAlign = "center";
    this.yAlign = "center";
    this.element = this.context.append("text").style("font-size", "20px");

    if (conditions) {
      this.setConditions(conditions);
    }
  },
  setConditions: function setConditions(conditions) {
    if (!isNaN(parseFloat(conditions.rightOffset)) && isFinite(conditions.rightOffset)) {
      this.rightOffset = conditions.rightOffset;
    }
    if (!isNaN(parseFloat(conditions.leftOffset)) && isFinite(conditions.leftOffset)) {
      this.leftOffset = conditions.leftOffset;
    }
    if (!isNaN(parseFloat(conditions.topOffset)) && isFinite(conditions.topOffset)) {
      this.topOffset = conditions.topOffset;
    }
    if (!isNaN(parseFloat(conditions.bottomOffset)) && isFinite(conditions.bottomOffset)) {
      this.bottomOffset = conditions.bottomOffset;
    }
    if (conditions.xAlign) {
      this.xAlign = conditions.xAlign;
    }
    if (conditions.yAlign) {
      this.yAlign = conditions.yAlign;
    }
    if (!isNaN(parseFloat(conditions.widthRatio)) && conditions.widthRatio > 0 && conditions.widthRatio <= 1) {
      this.widthRatio = conditions.widthRatio;
    }
    if (!isNaN(parseFloat(conditions.heightRatio)) && conditions.heightRatio > 0 && conditions.heightRatio <= 1) {
      this.heightRatio = conditions.heightRatio;
    }
    return this;
  },
  resize: function resize(width, height, topOffset, leftOffset) {
    var _map = [width, height].map(function (v) {
      return Number(String(v).replace("px", ""));
    });

    var _map2 = _slicedToArray(_map, 2);

    this.width = _map2[0];
    this.height = _map2[1];


    if (topOffset) {
      this.topOffset = topOffset;
    }
    if (leftOffset) {
      this.leftOffset = leftOffset;
    }

    this._resizeText();
  },
  setText: function setText(text, delay) {
    var _this = this;

    setTimeout(function () {
      _this.element.text(text);
      _this._resizeText();
    }, delay);

    return this;
  },
  _resizeText: function _resizeText() {

    var bbox = this.element.node().getBBox();

    if (!bbox.width || !bbox.height || !this.width || !this.height) return this;

    // method from http://stackoverflow.com/a/22580176
    var widthTransform = this.width * this.widthRatio / bbox.width;
    var heightTransform = this.height * this.heightRatio / bbox.height;
    this.scalar = widthTransform < heightTransform ? widthTransform : heightTransform;
    this.element.attr("transform", "scale(" + this.scalar + ")");

    this.textHeight = bbox.height * this.scalar;
    this.textWidth = bbox.width * this.scalar;

    switch (this.yAlign) {
      case "bottom":
        this.context.select("text").attr("dy", ".325em");break;
      case "center":
        this.context.select("text").attr("dy", ".325em");break;
      case "top":
        this.context.select("text").attr("dy", "0");break;
    }

    this.context.attr("transform", "translate(" + this._getLeftOffset() + "," + this._getTopOffset() + ")");

    return this;
  },
  _getLeftOffset: function _getLeftOffset() {
    switch (this.xAlign) {
      case "right":
        return this.width - this.textWidth / 2 - this.rightOffset;
      case "left":
        return this.textWidth / 2 + this.leftOffset;
      default:
        return this.width / 2;
    }
  },
  _getTopOffset: function _getTopOffset() {
    switch (this.yAlign) {
      case "top":
        return this.textHeight / 2 + this.topOffset;
      case "bottom":
        return this.height - this.textHeight / 2 - this.bottomOffset;
      default:
        return this.height / 2;
    }
  }
});

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _model = __webpack_require__(47);

var _model2 = _interopRequireDefault(_model);

var _events = __webpack_require__(46);

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*!
 * DATACONNECTED MODEL
 *
 * Any model which may trigger a reload of data is here. Dimensions, Time, Hooks and Locales are DataConnected
 */

var DataConnected = _model2.default.extend({

  dataConnectedChildren: [],

  checkDataChanges: function checkDataChanges(changedChildren) {
    var _this = this;

    if (!changedChildren || !this.dataConnectedChildren) return;

    if (!utils.isArray(changedChildren) && utils.isObject(changedChildren)) changedChildren = Object.keys(changedChildren);

    if (changedChildren.length == 0 || this.dataConnectedChildren.length == 0) return;

    var dataConnectedChangedChildren = changedChildren.filter(function (child) {
      return _this.dataConnectedChildren.indexOf(child) !== -1;
    });

    if (dataConnectedChangedChildren.length > 0) {
      this.trigger("dataConnectedChange");
      this.startLoading();
    }
  }
});

exports.default = DataConnected;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__(7)('unscopables')
  , ArrayProto  = Array.prototype;
if(ArrayProto[UNSCOPABLES] == undefined)__webpack_require__(18)(ArrayProto, UNSCOPABLES, {});
module.exports = function(key){
  ArrayProto[UNSCOPABLES][key] = true;
};

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

var ctx         = __webpack_require__(37)
  , call        = __webpack_require__(163)
  , isArrayIter = __webpack_require__(98)
  , anObject    = __webpack_require__(3)
  , toLength    = __webpack_require__(12)
  , getIterFn   = __webpack_require__(115)
  , BREAK       = {}
  , RETURN      = {};
var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
    , f      = ctx(fn, that, entries ? 2 : 1)
    , index  = 0
    , length, step, iterator, result;
  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if(result === BREAK || result === RETURN)return result;
  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
    result = call(iterator, f, step.value, entries);
    if(result === BREAK || result === RETURN)return result;
  }
};
exports.BREAK  = BREAK;
exports.RETURN = RETURN;

/***/ }),
/* 64 */
/***/ (function(module, exports) {

module.exports = {};

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(9).f
  , has = __webpack_require__(14)
  , TAG = __webpack_require__(7)('toStringTag');

module.exports = function(it, tag, stat){
  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
};

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0)
  , defined = __webpack_require__(29)
  , fails   = __webpack_require__(5)
  , spaces  = __webpack_require__(111)
  , space   = '[' + spaces + ']'
  , non     = '\u200b\u0085'
  , ltrim   = RegExp('^' + space + space + '*')
  , rtrim   = RegExp(space + space + '*$');

var exporter = function(KEY, exec, ALIAS){
  var exp   = {};
  var FORCE = fails(function(){
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if(ALIAS)exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function(string, TYPE){
  string = String(defined(string));
  if(TYPE & 1)string = string.replace(ltrim, '');
  if(TYPE & 2)string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*!
 * VIZABI GENERIC SLIDER CONTROL
 * Reusable SLIDER
 */

var SimpleSlider = _component2.default.extend({
  init: function init(config, context) {
    this.template = '<div class="vzb-ss-holder"><input type="range" class="vzb-ss-slider vzb-ss-slider-normal" step="1"></div>';

    this.model_expects = [{
      name: "submodel"
    }];

    var _this = this;
    this.name = "gapminder-simpleSlider";

    this.arg = config.arg;
    this.thumb_size = config.thumb_size;
    this.slider_properties = config.properties;

    this.model_binds = {};
    this.model_binds["change:submodel." + this.arg] = function (evt) {
      _this.updateView();
    };

    //contructor is the same as any component
    this._super(config, context);

    this._setModel = utils.throttle(this._setModel, 50);
  },


  /**
   * Executes after the template is loaded and rendered.
   * Ideally, it contains HTML instantiations related to template
   * At this point, this.element and this.placeholder are available as a d3 object
   */
  readyOnce: function readyOnce() {

    //default values
    var min = 0;
    var max = 1;
    var step = 0.1;
    var value = min;

    //selecting elements
    var _this = this;
    this.element = d3.select(this.element);
    this.slider = this.element.selectAll(".vzb-ss-slider");

    this.elementSize = this.element.node().getBoundingClientRect();
    this.sliderSize = this.slider.node().getBoundingClientRect();
    this.slider.style("left", this.elementSize.left - this.sliderSize.left + "px");

    //TODO: replace this with utils.extend
    if (this.slider_properties) {
      if (this.slider_properties.min != null) min = this.slider_properties.min;
      if (this.slider_properties.max != null) max = this.slider_properties.max;
      if (this.slider_properties.step != null) step = this.slider_properties.step;

      if (this.slider_properties.scale) {
        value = this.slider_properties.scale(min);
      }
    }

    //step also defines the rounding of values that willbe sent to model: 0.1 --> 1 digit, 0.01 --> 2, 1 and up --> 0
    this.roundTo = step > 1 ? 0 : Math.round(Math.abs(Math.log(step) / Math.LN10));

    //check and change the slider's thumb size
    if (this.thumb_size) {
      this.slider.classed("vzb-ss-slider-normal", false);
      this.slider.classed("vzb-ss-slider-" + this.thumb_size, true);
    }

    this.slider.attr("min", min).attr("max", max).attr("step", step).attr("value", value).on("input", function () {
      var value = +d3.event.target.value;
      _this._setModel(value, false, false); // on drag - non-persistent changes while dragging
    }).on("change", function () {
      var value = +d3.event.target.value;
      _this._setModel(value, true); // on drag end - value is probably same as last 'input'-event, so force change
    }).on("touchstart", function () {
      _this.scrollAncestor = utils.findScrollableAncestor(d3.event.target);
      d3.select(_this.scrollAncestor).style("pointer-events", "none");
    }).on("touchend touchcancel", function () {
      d3.select(_this.scrollAncestor).style("pointer-events", null);
    });

    this.updateView();
  },
  updateView: function updateView() {
    var value = this.model.submodel[this.arg];
    var slider_properties = this.slider_properties;
    var scale = void 0;

    if (slider_properties) {
      scale = slider_properties.scale;
    }
    if (scale) {
      value = scale.invert(value);
    }

    //this.slider.attr('value', value);
    this.slider.node().value = value;
  },
  _setModel: function _setModel(value, force, persistent) {
    // rescale value if scale is supplied in slider_properties
    if (this.slider_properties && this.slider_properties.scale) value = this.slider_properties.scale(value);

    this.model.submodel.getModelObject(this.arg).set(value.toFixed(this.roundTo), force, persistent);
  }
});

exports.default = SimpleSlider;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(28)
  , TAG = __webpack_require__(7)('toStringTag')
  // ES3 wrong here
  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function(it, key){
  try {
    return it[key];
  } catch(e){ /* empty */ }
};

module.exports = function(it){
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(28);
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};

/***/ }),
/* 70 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var getDepth = function getDepth(key) {
  return key.match(/\//g).length;
};

var requireAll = function requireAll(_require, depth) {
  var keys = _require.keys();

  if (depth) {
    keys = keys.filter(typeof depth === "function" ? function (key) {
      return depth(getDepth(key));
    } : function (key) {
      return getDepth(key) === depth + 1;
    });
  }

  return keys.reduce(function (result, key) {
    var name = /([^/]+)\..+$/.exec(key)[1];

    try {
      var required = _require(key);
      result[name] = required.default || required;
    } catch (err) {
      console.warn("Import error", key, err);
    }

    return result;
  }, {});
};

exports.default = requireAll;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _class = __webpack_require__(16);

var _class2 = _interopRequireDefault(_class);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Initializes the reader.
 * @param {Object} reader_info Information about the reader
 */
var Reader = _class2.default.extend({

  QUERY_FROM_CONCEPTS: "concepts",
  QUERY_FROM_DATAPOINTS: "datapoints",
  QUERY_FROM_ENTITIES: "entities",

  CONDITION_CALLBACKS: {
    $gt: function $gt(configValue, rowValue) {
      return rowValue > configValue;
    },
    $gte: function $gte(configValue, rowValue) {
      return rowValue >= configValue;
    },
    $lt: function $lt(configValue, rowValue) {
      return rowValue < configValue;
    },
    $lte: function $lte(configValue, rowValue) {
      return rowValue <= configValue;
    },
    $in: function $in(configValue, rowValue) {
      return configValue.includes(rowValue);
    }
  },

  ERRORS: {
    GENERIC_ERROR: "reader/error/generic"
  },

  _name: "reader",

  load: function load() {
    return Promise.resolve({
      data: [],
      columns: []
    });
  },
  read: function read(query) {
    var _this = this;

    var parsers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    query = this._normalizeQuery(query, parsers);

    var _query2 = query,
        select = _query2.select,
        from = _query2.from,
        _query2$order_by = _query2.order_by,
        order_by = _query2$order_by === undefined ? [] : _query2$order_by;

    var _order_by = _slicedToArray(order_by, 1),
        orderBy = _order_by[0];

    return this.load().then(function (result) {
      var data = result.data,
          columns = result.columns;

      _this.ensureDataIsCorrect(result, parsers);

      switch (true) {
        case from === _this.QUERY_FROM_CONCEPTS:
          return _this._getConcepts(columns, data.map(_this._getRowMapper(query, parsers)));

        case _this._isDataQuery(from) && select.key.length > 0:
          return data.reduce(_this._applyQuery(query, parsers), []).sort(function (prev, next) {
            return prev[orderBy] - next[orderBy];
          });

        default:
          return [];
      }
    }).catch(function (error) {
      throw {}.toString.call(error) === "[object Error]" ? _this.error(_this.ERRORS.GENERIC_ERROR, error) : error;
    });
  },
  ensureDataIsCorrect: function ensureDataIsCorrect() {},
  _normalizeQuery: function _normalizeQuery(_query, parsers) {
    var query = Object.assign({}, _query);
    var where = query.where,
        join = query.join;


    if (where.$and) {
      where.$and = where.$and.reduce(function (whereResult, condition) {
        Object.keys(condition).forEach(function (rowKey) {
          var conditionValue = condition[rowKey];

          if (typeof conditionValue === "string" && conditionValue.startsWith("$")) {
            var joinWhere = join[conditionValue].where;

            Object.keys(joinWhere).forEach(function (joinRowKey) {
              var value = joinWhere[joinRowKey];
              var parser = parsers[joinRowKey];

              whereResult[joinRowKey] = parser ? (typeof value === "undefined" ? "undefined" : _typeof(value)) === "object" ? Object.keys(value).reduce(function (callbackConditions, callbackKey) {
                callbackConditions[callbackKey] = parser(value[callbackKey]);
                return callbackConditions;
              }, {}) : parser(value) : value;
            });
          } else {
            var parser = parsers[rowKey];
            whereResult[rowKey] = parser ? parser(conditionValue) : conditionValue;
          }
        });

        return whereResult;
      }, {});
    }

    return query;
  },
  _getConcepts: function _getConcepts(columns, data) {
    var _this2 = this;

    return columns.map(function (concept, index) {
      var result = { concept: concept };

      if (index < _this2.keySize) {
        result.concept_type = "entity_domain";
      } else if (index === _this2.keySize) {
        //the column after is expected to have time
        result.concept_type = "time";
      } else {
        result.concept_type = "measure";

        for (var i = data.length - 1; i >= 0; i--) {
          if (utils.isString(data[i][concept]) && data[i][concept] !== "") {
            result.concept_type = "entity_set";

            var _columns = _slicedToArray(columns, 1);

            result.domain = _columns[0];

            break;
          }
        }
      }

      return result;
    });
  },
  _isDataQuery: function _isDataQuery(from) {
    return [this.QUERY_FROM_DATAPOINTS, this.QUERY_FROM_ENTITIES].includes(from);
  },
  _getRowMapper: function _getRowMapper(query, parsers) {
    var select = query.select;


    return function (row) {
      var correct = true;

      var result = Object.keys(row).reduce(function (result, key) {
        if (correct) {
          var value = row[key];
          var parser = parsers[key];
          var resultValue = void 0;

          if (parser) {
            resultValue = parser(value);
          } else {
            var numeric = parseFloat(value);
            resultValue = !isNaN(numeric) && isFinite(numeric) ? parseFloat(value.replace(",", ".")) : value;
          }

          if (!resultValue && resultValue !== 0) {
            if (select.key.includes(key)) {
              correct = false;
            }
          } else {
            result[key] = resultValue;
          }
        }

        return result;
      }, {});

      return correct && result;
    };
  },
  _applyQuery: function _applyQuery(query, parsers) {
    var _this3 = this;

    var select = query.select,
        from = query.from;

    var _select$key = _slicedToArray(select.key, 1),
        uniqueKey = _select$key[0];

    var uniqueValues = [];
    var mapRow = this._getRowMapper(query, parsers);

    return function (result, row) {
      row = mapRow(row);

      if (row) {
        var unique = row[uniqueKey];
        var isUnique = from !== _this3.QUERY_FROM_ENTITIES || !uniqueValues.includes(unique);
        var isSuitable = _this3._isSuitableRow(query, row);

        if (isSuitable && isUnique) {
          if (from === _this3.QUERY_FROM_ENTITIES) {
            uniqueValues.push(unique);
          }

          var rowFilteredByKeys = Object.keys(row).reduce(function (resultRow, rowKey) {
            if (select.key.includes(rowKey) || select.value.includes(rowKey)) {
              resultRow[rowKey] = row[rowKey];
            }

            return resultRow;
          }, {});

          result.push(rowFilteredByKeys);
        }
      }

      return result;
    };
  },
  _isSuitableRow: function _isSuitableRow(query, row) {
    var _this4 = this;

    var where = query.where;


    return !where.$and || Object.keys(where.$and).every(function (conditionKey) {
      var condition = where.$and[conditionKey];
      var rowValue = row[conditionKey];

      // if the column is missing, then don't apply filter
      return rowValue === undefined || ((typeof condition === "undefined" ? "undefined" : _typeof(condition)) !== "object" ? rowValue === condition
      //resolve booleans via strings
      || condition === true && utils.isString(rowValue) && rowValue.toLowerCase().trim() === "true" || condition === false && utils.isString(rowValue) && rowValue.toLowerCase().trim() === "false" : Object.keys(condition).every(function (callbackKey) {
        return _this4.CONDITION_CALLBACKS[callbackKey](condition[callbackKey], rowValue);
      }));
    });
  },
  error: function error(code, message, payload) {
    return {
      code: code,
      message: message,
      payload: payload
    };
  }
});

exports.default = Reader;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _class = __webpack_require__(16);

var _class2 = _interopRequireDefault(_class);

var _iconset = __webpack_require__(10);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var label = function label(context) {

  return function d3_label() {

    var _this = context;

    var _cssPrefix = void 0;
    label.setCssPrefix = function (cssPrefix) {
      _cssPrefix = cssPrefix;
      return label;
    };

    var labelDragger = d3.drag().on("start", function (d, i) {
      d3.event.sourceEvent.stopPropagation();
      var KEY = _this.KEY;
    }).on("drag", function (d, i) {
      var KEY = _this.KEY;
      if (!_this.model.ui.chart.labels.dragging) return;
      if (!this.druging) _this.druging = d[KEY];
      var cache = _this.cached[d[KEY]];
      cache.labelFixed = true;

      var viewWidth = _this.context.width;
      var viewHeight = _this.context.height;

      cache.labelX_ += d3.event.dx / viewWidth;
      cache.labelY_ += d3.event.dy / viewHeight;

      var resolvedX = _this.xScale(cache.labelX0) + cache.labelX_ * viewWidth;
      var resolvedY = _this.yScale(cache.labelY0) + cache.labelY_ * viewHeight;

      var resolvedX0 = _this.xScale(cache.labelX0);
      var resolvedY0 = _this.yScale(cache.labelY0);

      var lineGroup = _this.entityLines.filter(function (f) {
        return f[KEY] == d[KEY];
      });

      label._repositionLabels(d, i, this, resolvedX, resolvedY, resolvedX0, resolvedY0, 0, null, lineGroup);
    }).on("end", function (d, i) {
      var KEY = _this.KEY;
      if (_this.druging) {
        var cache = _this.cached[d[KEY]];
        _this.druging = null;
        cache.labelOffset[0] = cache.labelX_;
        cache.labelOffset[1] = cache.labelY_;
        _this.model.marker.setLabelOffset(d, [cache.labelX_, cache.labelY_]);
      }
    });

    function label(container) {
      container.call(labelDragger).each(function (d, index) {
        var view = d3.select(this);

        // Ola: Clicking bubble label should not zoom to countries boundary #811
        // It's too easy to accidentally zoom
        // This feature will be activated later, by making the label into a "context menu" where users can click Split, or zoom,.. hide others etc....

        view.append("rect").attr("class", "vzb-label-glow").attr("filter", "url(" + location.pathname + "#vzb-glow-filter)");
        view.append("rect").attr("class", "vzb-label-fill vzb-tooltip-border");
        //          .on("click", function(d, i) {
        //            //default prevented is needed to distinguish click from drag
        //            if(d3.event.defaultPrevented) return;
        //
        //            var maxmin = _this.cached[d[KEY]].maxMinValues;
        //            var radius = utils.areaToRadius(_this.sScale(maxmin.valueSmax));
        //            _this._panZoom._zoomOnRectangle(_this.element,
        //              _this.xScale(maxmin.valueXmin) - radius,
        //              _this.yScale(maxmin.valueYmin) + radius,
        //              _this.xScale(maxmin.valueXmax) + radius,
        //              _this.yScale(maxmin.valueYmax) - radius,
        //              false, 500);
        //          });

        view.append("text").attr("class", _cssPrefix + "-label-content " + _cssPrefix + "-label-shadow vzb-noexport");

        view.append("text").attr("class", _cssPrefix + "-label-content");

        var cross = view.append("g").attr("class", _cssPrefix + "-label-x vzb-transparent");
        utils.setIcon(cross, _iconset.close);

        cross.insert("circle", "svg");

        cross.select("svg").attr("class", _cssPrefix + "-label-x-icon").attr("width", "0px").attr("height", "0px");

        cross.on("click", function () {
          //default prevented is needed to distinguish click from drag
          if (d3.event.defaultPrevented) return;
          d3.event.stopPropagation();
          _this.model.marker.clearHighlighted();
          _this.model.marker.selectMarker(d);
        });
      }).on("mouseover", function (d) {
        if (utils.isTouchDevice()) return;
        _this.model.marker.highlightMarker(d);
        var KEY = _this.KEY || _this.model.entities.getDimension();
        // hovered label should be on top of other labels: if "a" is not the hovered element "d", send "a" to the back
        _this.entityLabels.sort(function (a, b) {
          return a[KEY] != d[KEY] ? -1 : 1;
        });
        d3.select(this).selectAll("." + _cssPrefix + "-label-x").classed("vzb-transparent", false);
      }).on("mouseout", function (d) {
        if (utils.isTouchDevice()) return;
        _this.model.marker.clearHighlighted();
        d3.select(this).selectAll("." + _cssPrefix + "-label-x").classed("vzb-transparent", true);
      }).on("click", function (d) {
        if (!utils.isTouchDevice()) return;
        var cross = d3.select(this).selectAll("." + _cssPrefix + "-label-x");
        var KEY = _this.KEY || _this.model.entities.getDimension();
        var hidden = cross.classed("vzb-transparent");
        if (hidden) {
          // hovered label should be on top of other labels: if "a" is not the hovered element "d", send "a" to the back
          _this.entityLabels.sort(function (a, b) {
            return a[KEY] != d[KEY] ? -1 : 1;
          });
          _this.showCloseCross(null, false);
        }
        cross.classed("vzb-transparent", !hidden);
        if (!_this.options.SUPPRESS_HIGHLIGHT_DURING_PLAY || !_this.model.time.playing) {
          if (hidden) {
            _this.model.marker.setHighlight(d);
          } else {
            _this.model.marker.clearHighlighted();
          }
        }
      });

      return label;
    }

    label.line = function (container) {
      container.append("line").attr("class", _cssPrefix + "-label-line");
    };

    label._repositionLabels = _repositionLabels;
    function _repositionLabels(d, i, labelContext, _X, _Y, _X0, _Y0, duration, showhide, lineGroup) {

      var cache = _this.cached[d[_this.KEY]];

      var labelGroup = d3.select(labelContext);

      //protect label and line from the broken data
      var brokenInputs = !_X && _X !== 0 || !_Y && _Y !== 0 || !_X0 && _X0 !== 0 || !_Y0 && _Y0 !== 0;
      if (brokenInputs) {
        labelGroup.classed("vzb-invisible", brokenInputs);
        lineGroup.classed("vzb-invisible", brokenInputs);
        return;
      }

      var viewWidth = _this.context.width;
      var viewHeight = _this.context.height;
      var rectBBox = cache.rectBBox;
      var width = rectBBox.width;
      var height = rectBBox.height;

      //apply limits so that the label doesn't stick out of the visible field
      if (_X - width <= 0) {
        //check left
        _X = width;
        cache.labelX_ = (_X - _this.xScale(cache.labelX0)) / viewWidth;
      } else if (_X + 5 > viewWidth) {
        //check right
        _X = viewWidth - 5;
        cache.labelX_ = (_X - _this.xScale(cache.labelX0)) / viewWidth;
      }
      if (_Y - height * 0.75 <= 0) {
        // check top
        _Y = height * 0.75;
        cache.labelY_ = (_Y - _this.yScale(cache.labelY0)) / viewHeight;
      } else if (_Y + height * 0.35 > viewHeight) {
        //check bottom
        _Y = viewHeight - height * 0.35;
        cache.labelY_ = (_Y - _this.yScale(cache.labelY0)) / viewHeight;
      }

      if (duration == null) duration = _this.context.duration;
      if (cache._new) {
        duration = 0;
        delete cache._new;
      }
      if (duration) {
        if (showhide && !d.hidden) {
          //if need to show label

          labelGroup.classed("vzb-invisible", d.hidden);
          labelGroup.attr("transform", "translate(" + _X + "," + _Y + ")").style("opacity", 0).transition().duration(duration).ease(d3.easeExp).style("opacity", 1)
          //i would like to set opactiy to null in the end of transition.
          //but then fade in animation is not working for some reason
          .on("interrupt", function () {
            labelGroup.style("opacity", 1);
          });
          lineGroup.classed("vzb-invisible", d.hidden);
          lineGroup.attr("transform", "translate(" + _X + "," + _Y + ")").style("opacity", 0).transition().duration(duration).ease(d3.easeExp).style("opacity", 1)
          //i would like to set opactiy to null in the end of transition.
          //but then fade in animation is not working for some reason
          .on("interrupt", function () {
            lineGroup.style("opacity", 1);
          });
        } else if (showhide && d.hidden) {
          //if need to hide label

          labelGroup.style("opacity", 1).transition().duration(duration).ease(d3.easeExp).style("opacity", 0).on("end", function () {
            labelGroup.style("opacity", 1) //i would like to set it to null. but then fade in animation is not working for some reason
            .classed("vzb-invisible", d.hidden);
          });
          lineGroup.style("opacity", 1).transition().duration(duration).ease(d3.easeExp).style("opacity", 0).on("end", function () {
            lineGroup.style("opacity", 1) //i would like to set it to null. but then fade in animation is not working for some reason
            .classed("vzb-invisible", d.hidden);
          });
        } else {
          // just update the position

          labelGroup.transition().duration(duration).ease(d3.easeLinear).attr("transform", "translate(" + _X + "," + _Y + ")");
          lineGroup.transition().duration(duration).ease(d3.easeLinear).attr("transform", "translate(" + _X + "," + _Y + ")");
        }
      } else {
        labelGroup.interrupt().attr("transform", "translate(" + _X + "," + _Y + ")").transition();
        lineGroup.interrupt().attr("transform", "translate(" + _X + "," + _Y + ")").transition();
        if (showhide) labelGroup.classed("vzb-invisible", d.hidden);
        if (showhide) lineGroup.classed("vzb-invisible", d.hidden);
      }

      var diffX1 = _X0 - _X;
      var diffY1 = _Y0 - _Y;
      var textBBox = labelGroup.select("text").node().getBBox();
      var diffX2 = -textBBox.width * 0.5;
      var diffY2 = -height * 0.2;
      var labels = _this.model.ui.chart.labels;

      var bBox = labels.removeLabelBox ? textBBox : rectBBox;

      var FAR_COEFF = _this.activeProfile.labelLeashCoeff || 0;

      var lineHidden = circleRectIntersects({ x: diffX1, y: diffY1, r: cache.scaledS0 }, { x: diffX2, y: diffY2, width: bBox.height * 2 * FAR_COEFF + bBox.width, height: bBox.height * (2 * FAR_COEFF + 1) });
      lineGroup.select("line").classed("vzb-invisible", lineHidden);
      if (lineHidden) return;

      if (labels.removeLabelBox) {
        var angle = Math.atan2(diffX1 - diffX2, diffY1 - diffY2) * 180 / Math.PI;
        var deltaDiffX2 = angle >= 0 && angle <= 180 ? bBox.width * 0.5 : -bBox.width * 0.5;
        var deltaDiffY2 = Math.abs(angle) <= 90 ? bBox.height * 0.55 : -bBox.height * 0.45;
        diffX2 += Math.abs(diffX1 - diffX2) > textBBox.width * 0.5 ? deltaDiffX2 : 0;
        diffY2 += Math.abs(diffY1 - diffY2) > textBBox.height * 0.5 ? deltaDiffY2 : textBBox.height * 0.05;
      }

      var longerSideCoeff = Math.abs(diffX1) > Math.abs(diffY1) ? Math.abs(diffX1) : Math.abs(diffY1);
      lineGroup.select("line").style("stroke-dasharray", "0 " + cache.scaledS0 + " " + ~~longerSideCoeff * 2);

      lineGroup.selectAll("line").attr("x1", diffX1).attr("y1", diffY1).attr("x2", diffX2).attr("y2", diffY2);
    }

    /*
    * Adapted from
    * http://stackoverflow.com/questions/401847/circle-rectangle-collision-detection-intersection
    *
    * circle {
    *  x: center X
    *  y: center Y
    *  r: radius
    * }
    *
    * rect {
    *  x: center X
    *  y: center Y
    *  width: width
    *  height: height
    * }
    */
    function circleRectIntersects(circle, rect) {
      var circleDistanceX = Math.abs(circle.x - rect.x);
      var circleDistanceY = Math.abs(circle.y - rect.y);
      var halfRectWidth = rect.width * 0.5;
      var halfRectHeight = rect.height * 0.5;

      if (circleDistanceX > halfRectWidth + circle.r) {
        return false;
      }
      if (circleDistanceY > halfRectHeight + circle.r) {
        return false;
      }

      if (circleDistanceX <= halfRectWidth) {
        return true;
      }
      if (circleDistanceY <= halfRectHeight) {
        return true;
      }

      var cornerDistance_sq = Math.pow(circleDistanceX - halfRectWidth, 2) + Math.pow(circleDistanceY - halfRectHeight, 2);

      return cornerDistance_sq <= Math.pow(circle.r, 2);
    }

    return label;
  }();
};

var OPTIONS = {
  LABELS_CONTAINER_CLASS: "",
  LINES_CONTAINER_CLASS: "",
  LINES_CONTAINER_SELECTOR: "",
  CSS_PREFIX: "",
  SUPPRESS_HIGHLIGHT_DURING_PLAY: true
};

var Labels = _class2.default.extend({
  init: function init(context, conditions) {
    var _this = this;
    this.context = context;

    this.options = utils.extend({}, OPTIONS);
    this.label = label(this);
    this._xScale = null;
    this._yScale = null;
    this._closeCrossHeight = 0;
    this.labelSizeTextScale = null;
  },
  ready: function ready() {
    this.updateIndicators();
    this.updateLabelSizeLimits();
    //this.updateLabelsOnlyTextSize();
  },
  readyOnce: function readyOnce() {
    var _this = this;

    this.model = this.context.model;

    this.model.on("change:marker.select", function () {
      if (!_this.context._readyOnce) return;
      //console.log("EVENT change:entities:select");
      _this.selectDataPoints();
    });

    if (this.model.marker.size_label) this.model.on("change:marker.size_label.extent", function (evt, path) {
      //console.log("EVENT change:marker:size:max");
      if (!_this.context._readyOnce) return;
      _this.updateLabelSizeLimits();
      if (_this.model.time.splash) return;
      _this.updateLabelsOnlyTextSize();
    });

    if (this.model.ui.chart.labels.hasOwnProperty("removeLabelBox")) this.model.on("change:ui.chart.labels.removeLabelBox", function (evt, path) {
      //console.log("EVENT change:marker:size:max");
      if (!_this.context._readyOnce) return;
      _this.updateLabelsOnlyTextSize();
    });

    this.KEY = this.context.model.entities.getDimension();

    this.cached = {};

    this.label.setCssPrefix(this.options.CSS_PREFIX);

    this.rootEl = this.context.root.element instanceof Array ? this.context.root.element : d3.select(this.context.root.element);
    this.labelsContainer = this.rootEl.select("." + this.options.LABELS_CONTAINER_CLASS);
    this.linesContainer = this.rootEl.select("." + this.options.LINES_CONTAINER_CLASS);
    this.updateIndicators();
    this.updateSize();
    this.selectDataPoints();
  },
  config: function config(newOptions) {
    utils.extend(this.options, newOptions);
  },
  updateLabelSizeLimits: function updateLabelSizeLimits() {
    var _this = this;
    if (!this.model.marker.size_label) return;
    var extent = this.model.marker.size_label.extent || [0, 1];

    var minLabelTextSize = this.activeProfile.minLabelTextSize;
    var maxLabelTextSize = this.activeProfile.maxLabelTextSize;
    var minMaxDelta = maxLabelTextSize - minLabelTextSize;

    this.minLabelTextSize = Math.max(minLabelTextSize + minMaxDelta * extent[0], minLabelTextSize);
    this.maxLabelTextSize = Math.max(minLabelTextSize + minMaxDelta * extent[1], minLabelTextSize);

    if (this.model.marker.size_label.use == "constant") {
      // if(!this.model.marker.size_label.which) {
      //   this.maxLabelTextSize = this.activeProfile.defaultLabelTextSize;
      //   this.model.marker.size_label.set({'domainMax': (this.maxLabelTextSize - minLabelTextSize) / minMaxDelta, 'which': '_default'});
      //   return;
      // }
      this.minLabelTextSize = this.maxLabelTextSize;
    }

    if (this.model.marker.size_label.scaleType !== "ordinal" || this.model.marker.size_label.use == "constant") {
      this.labelSizeTextScale.range([_this.minLabelTextSize, _this.maxLabelTextSize]);
    } else {
      this.labelSizeTextScale.rangePoints([_this.minLabelTextSize, _this.maxLabelTextSize], 0).range();
    }
  },
  updateIndicators: function updateIndicators() {
    var _this = this;

    //scales
    if (this.model.marker.size_label) {
      this.labelSizeTextScale = this.model.marker.size_label.getScale();
    }
  },
  setScales: function setScales(xScale, yScale) {
    this._xScale = xScale;
    this._yScale = yScale;
  },
  setCloseCrossHeight: function setCloseCrossHeight(closeCrossHeight) {
    if (this._closeCrossHeight != closeCrossHeight) {
      this._closeCrossHeight = closeCrossHeight;
      this.updateLabelCloseGroupSize(this.entityLabels.selectAll("." + this.options.CSS_PREFIX + "-label-x"), this._closeCrossHeight);
    }
  },
  xScale: function xScale(x) {
    return this._xScale ? this._xScale(x) : x * this.context.width;
  },
  yScale: function yScale(y) {
    return this._yScale ? this._yScale(y) : y * this.context.height;
  },
  selectDataPoints: function selectDataPoints() {
    var _this = this;
    var KEY = this.KEY;
    var _cssPrefix = this.options.CSS_PREFIX;

    this.entityLabels = this.labelsContainer.selectAll("." + _cssPrefix + "-entity").data(_this.model.marker.select, function (d) {
      return d[KEY];
    });
    this.entityLines = this.linesContainer.selectAll("g.entity-line." + _cssPrefix + "-entity").data(_this.model.marker.select, function (d) {
      return d[KEY];
    });

    this.entityLabels.exit().each(function (d) {
      if (_this.cached[d[KEY]] != null) {
        _this.cached[d[KEY]] = void 0;
      }
    }).remove();
    this.entityLines.exit().remove();

    this.entityLines = this.entityLines.enter().insert("g", function (d) {
      return this.querySelector("." + _this.options.LINES_CONTAINER_SELECTOR_PREFIX + d[KEY]);
    }).attr("class", function (d, index) {
      return _cssPrefix + "-entity entity-line line-" + d[KEY];
    }).each(function (d, index) {
      _this.label.line(d3.select(this));
    }).merge(this.entityLines);

    this.entityLabels = this.entityLabels.enter().append("g").attr("class", function (d, index) {
      return _cssPrefix + "-entity label-" + d[KEY];
    }).each(function (d, index) {
      _this.cached[d[KEY]] = { _new: true };
      _this.label(d3.select(this));
    }).merge(this.entityLabels);
  },
  showCloseCross: function showCloseCross(d, show) {
    var KEY = this.KEY;
    //show the little cross on the selected label
    this.entityLabels.filter(function (f) {
      return d ? f[KEY] == d[KEY] : true;
    }).select("." + this.options.CSS_PREFIX + "-label-x").classed("vzb-transparent", !show);
  },
  highlight: function highlight(d, _highlight) {
    var KEY = this.KEY;
    var labels = this.entityLabels;
    if (d) {
      labels = labels.filter(function (f) {
        return d ? f[KEY] == d[KEY] : true;
      });
    }
    labels.classed("vzb-highlighted", _highlight);
  },
  updateLabel: function updateLabel(d, index, cache, valueX, valueY, valueS, valueC, valueL, valueLST, duration, showhide) {
    var _this = this;
    var KEY = this.KEY;
    if (d[KEY] == _this.druging) return;

    var _cssPrefix = this.options.CSS_PREFIX;

    // only for selected entities
    if (_this.model.marker.isSelected(d) && _this.entityLabels != null) {
      if (_this.cached[d[KEY]] == null) this.selectDataPoints();

      var cached = _this.cached[d[KEY]];
      if (cache) utils.extend(cached, cache);

      if (cached.scaledS0 == null || cached.labelX0 == null || cached.labelY0 == null) {
        //initialize label once
        if (valueS || valueS === 0) cached.scaledS0 = utils.areaToRadius(this.context.sScale(valueS));
        cached.labelX0 = valueX;
        cached.labelY0 = valueY;
        cached.valueLST = valueLST;
        cached.scaledC0 = valueC != null ? this.context.cScale(valueC) : this.context.COLOR_WHITEISH;
      }

      if (cached.labelX_ == null || cached.labelY_ == null) {
        var select = utils.find(_this.model.marker.select, function (f) {
          return f[KEY] == d[KEY];
        });
        cached.labelOffset = select.labelOffset || [0, 0];
      }

      var brokenInputs = !cached.labelX0 && cached.labelX0 !== 0 || !cached.labelY0 && cached.labelY0 !== 0 || !cached.scaledS0 && cached.scaledS0 !== 0;

      var lineGroup = _this.entityLines.filter(function (f) {
        return f[KEY] == d[KEY];
      });
      // reposition label
      _this.entityLabels.filter(function (f) {
        return f[KEY] == d[KEY];
      }).each(function (groupData) {

        var labelGroup = d3.select(this);

        if (brokenInputs) {
          labelGroup.classed("vzb-invisible", brokenInputs);
          lineGroup.classed("vzb-invisible", brokenInputs);
          return;
        }

        var text = labelGroup.selectAll("." + _cssPrefix + "-label-content").text(valueL);

        _this._updateLabelSize(d, index, labelGroup, valueLST, text);

        _this.positionLabel(d, index, this, duration, showhide, lineGroup);
      });
    }
  },
  _updateLabelSize: function _updateLabelSize(d, index, labelGroup, valueLST, text) {
    var _this = this;
    var KEY = this.KEY;
    var cached = _this.cached[d[KEY]];

    var _cssPrefix = this.options.CSS_PREFIX;

    var labels = _this.model.ui.chart.labels || {};
    labelGroup.classed("vzb-label-boxremoved", labels.removeLabelBox);

    var _text = text || labelGroup.selectAll("." + _cssPrefix + "-label-content");

    if (_this.labelSizeTextScale) {
      if (valueLST != null) {
        var range = _this.labelSizeTextScale.range();
        var fontSize = range[0] + Math.sqrt((_this.labelSizeTextScale(valueLST) - range[0]) * (range[1] - range[0]));
        _text.attr("font-size", fontSize + "px");
      } else {
        _text.attr("font-size", "");
      }
    }

    var contentBBox = _text.node().getBBox();

    var rect = labelGroup.selectAll("rect");

    if (!cached.textWidth || cached.textWidth != contentBBox.width) {
      cached.textWidth = contentBBox.width;

      var labelCloseHeight = _this._closeCrossHeight || contentBBox.height; //_this.activeProfile.infoElHeight * 1.2;//contentBBox.height;

      var isRTL = _this.model.locale.isRTL();
      var labelCloseGroup = labelGroup.select("." + _cssPrefix + "-label-x").attr("transform", "translate(" + (isRTL ? -contentBBox.width - 4 : 4) + "," + -contentBBox.height * 0.85 + ")");

      this.updateLabelCloseGroupSize(labelCloseGroup, labelCloseHeight);

      rect.attr("width", contentBBox.width + 8).attr("height", contentBBox.height * 1.2).attr("x", -contentBBox.width - 4).attr("y", -contentBBox.height * 0.85).attr("rx", contentBBox.height * 0.2).attr("ry", contentBBox.height * 0.2);

      //cache label bound rect for reposition
      cached.rectBBox = rect.node().getBBox();
      //cached.moveX = 5;
      //cached.moveY = contentBBox.height * .3;
    }

    var glowRect = labelGroup.select(".vzb-label-glow");
    if (glowRect.attr("stroke") !== cached.scaledC0) {
      glowRect.attr("stroke", cached.scaledC0);
    }
  },
  updateLabelCloseGroupSize: function updateLabelCloseGroupSize(labelCloseGroup, labelCloseHeight) {
    labelCloseGroup.select("circle").attr("cx", /*contentBBox.height * .0 + */0).attr("cy", 0).attr("r", labelCloseHeight * 0.5);

    labelCloseGroup.select("svg").attr("x", -labelCloseHeight * 0.5).attr("y", labelCloseHeight * -0.5).attr("width", labelCloseHeight).attr("height", labelCloseHeight);
  },
  updateLabelsOnlyTextSize: function updateLabelsOnlyTextSize() {
    var _this = this;
    var KEY = this.KEY;

    this.entityLabels.each(function (d, index) {
      var cached = _this.cached[d[KEY]];
      _this._updateLabelSize(d, index, d3.select(this), _this.context.frame.size_label[d[KEY]]);
      var lineGroup = _this.entityLines.filter(function (f) {
        return f[KEY] == d[KEY];
      });
      _this.positionLabel(d, index, this, 0, null, lineGroup);
    });
  },
  updateLabelOnlyPosition: function updateLabelOnlyPosition(d, index, cache) {
    var _this = this;
    var KEY = this.KEY;
    var cached = this.cached[d[KEY]];
    if (cache) utils.extend(cached, cache);

    var lineGroup = _this.entityLines.filter(function (f) {
      return f[KEY] == d[KEY];
    });

    this.entityLabels.filter(function (f) {
      return f[KEY] == d[KEY];
    }).each(function (groupData) {
      _this.positionLabel(d, index, this, 0, null, lineGroup);
    });
  },
  updateLabelOnlyColor: function updateLabelOnlyColor(d, index, cache) {
    var _this = this;
    var KEY = this.KEY;
    var cached = this.cached[d[KEY]];
    if (cache) utils.extend(cached, cache);

    var labelGroup = _this.entityLabels.filter(function (f) {
      return f[KEY] == d[KEY];
    });

    _this._updateLabelSize(d, index, labelGroup, null);
  },
  positionLabel: function positionLabel(d, index, context, duration, showhide, lineGroup) {
    var KEY = this.KEY;
    var cached = this.cached[d[KEY]];

    var viewWidth = this.context.width;
    var viewHeight = this.context.height;

    var resolvedX0 = this.xScale(cached.labelX0);
    var resolvedY0 = this.yScale(cached.labelY0);

    if (!cached.labelOffset) cached.labelOffset = [0, 0];
    cached.labelX_ = cached.labelOffset[0] || (-cached.scaledS0 * 0.75 - 5) / viewWidth;
    cached.labelY_ = cached.labelOffset[1] || (-cached.scaledS0 * 0.75 - 11) / viewHeight;

    //check default label position and switch to mirror position if position
    //does not bind to visible field

    var resolvedX = resolvedX0 + cached.labelX_ * viewWidth;
    if (cached.labelOffset[0] == 0) {
      if (resolvedX - cached.rectBBox.width <= 0) {
        //check left
        cached.labelX_ = (cached.scaledS0 * 0.75 + cached.rectBBox.width) / viewWidth;
        resolvedX = resolvedX0 + cached.labelX_ * viewWidth;
      } else if (resolvedX + 15 > viewWidth) {
        //check right
        cached.labelX_ = (viewWidth - 15 - resolvedX0) / viewWidth;
        resolvedX = resolvedX0 + cached.labelX_ * viewWidth;
      }
    }
    var resolvedY = resolvedY0 + cached.labelY_ * viewHeight;
    if (cached.labelOffset[1] == 0) {
      if (resolvedY - cached.rectBBox.height <= 0) {
        // check top
        cached.labelY_ = (cached.scaledS0 * 0.75 + cached.rectBBox.height) / viewHeight;
        resolvedY = resolvedY0 + cached.labelY_ * viewHeight;
      } else if (resolvedY + 10 > viewHeight) {
        //check bottom
        cached.labelY_ = (viewHeight - 10 - resolvedY0) / viewHeight;
        resolvedY = resolvedY0 + cached.labelY_ * viewHeight;
      }
    }
    this.label._repositionLabels(d, index, context, resolvedX, resolvedY, resolvedX0, resolvedY0, duration, showhide, lineGroup);
  },
  updateSize: function updateSize() {
    var profiles = {
      small: {
        minLabelTextSize: 7,
        maxLabelTextSize: 21,
        defaultLabelTextSize: 12,
        labelLeashCoeff: 0.4
      },
      medium: {
        minLabelTextSize: 7,
        maxLabelTextSize: 30,
        defaultLabelTextSize: 15,
        labelLeashCoeff: 0.3
      },
      large: {
        minLabelTextSize: 6,
        maxLabelTextSize: 48,
        defaultLabelTextSize: 20,
        labelLeashCoeff: 0.2
      }
    };

    var presentationProfiles = {
      medium: {
        minLabelTextSize: 15,
        maxLabelTextSize: 35,
        defaultLabelTextSize: 15,
        labelLeashCoeff: 0.3
      },
      large: {
        minLabelTextSize: 20,
        maxLabelTextSize: 55,
        defaultLabelTextSize: 20,
        labelLeashCoeff: 0.2
      }
    };

    this.activeProfile = this.context.getActiveProfile(profiles, presentationProfiles);
    this.updateLabelSizeLimits();
  }
});

exports.default = Labels;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(21)
  , toLength  = __webpack_require__(12)
  , toIndex   = __webpack_require__(57);
module.exports = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = toIObject($this)
      , length = toLength(O.length)
      , index  = toIndex(fromIndex, length)
      , value;
    // Array#includes uses SameValueZero equality algorithm
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    // Array#toIndex ignores holes, Array#includes - not
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global            = __webpack_require__(4)
  , $export           = __webpack_require__(0)
  , redefine          = __webpack_require__(19)
  , redefineAll       = __webpack_require__(55)
  , meta              = __webpack_require__(43)
  , forOf             = __webpack_require__(63)
  , anInstance        = __webpack_require__(50)
  , isObject          = __webpack_require__(6)
  , fails             = __webpack_require__(5)
  , $iterDetect       = __webpack_require__(80)
  , setToStringTag    = __webpack_require__(65)
  , inheritIfRequired = __webpack_require__(97);

module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
  var Base  = global[NAME]
    , C     = Base
    , ADDER = IS_MAP ? 'set' : 'add'
    , proto = C && C.prototype
    , O     = {};
  var fixMethod = function(KEY){
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function(a){
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a){
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a){
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a){ fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b){ fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if(typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
    new C().entries().next();
  }))){
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance             = new C
      // early implementations not supports chaining
      , HASNT_CHAINING       = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance
      // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
      , THROWS_ON_PRIMITIVES = fails(function(){ instance.has(1); })
      // most early implementations doesn't supports iterables, most modern - not close it correctly
      , ACCEPT_ITERABLES     = $iterDetect(function(iter){ new C(iter); }) // eslint-disable-line no-new
      // for early implementations -0 and +0 not the same
      , BUGGY_ZERO = !IS_WEAK && fails(function(){
        // V8 ~ Chromium 42- fails only with 5+ elements
        var $instance = new C()
          , index     = 5;
        while(index--)$instance[ADDER](index, index);
        return !$instance.has(-0);
      });
    if(!ACCEPT_ITERABLES){ 
      C = wrapper(function(target, iterable){
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base, target, C);
        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if(THROWS_ON_PRIMITIVES || BUGGY_ZERO){
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if(BUGGY_ZERO || HASNT_CHAINING)fixMethod(ADDER);
    // weak collections should not contains .clear method
    if(IS_WEAK && proto.clear)delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);

  return C;
};

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var hide     = __webpack_require__(18)
  , redefine = __webpack_require__(19)
  , fails    = __webpack_require__(5)
  , defined  = __webpack_require__(29)
  , wks      = __webpack_require__(7);

module.exports = function(KEY, length, exec){
  var SYMBOL   = wks(KEY)
    , fns      = exec(defined, SYMBOL, ''[KEY])
    , strfn    = fns[0]
    , rxfn     = fns[1];
  if(fails(function(){
    var O = {};
    O[SYMBOL] = function(){ return 7; };
    return ''[KEY](O) != 7;
  })){
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function(string, arg){ return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function(string){ return rxfn.call(string, this); }
    );
  }
};

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 21.2.5.3 get RegExp.prototype.flags
var anObject = __webpack_require__(3);
module.exports = function(){
  var that   = anObject(this)
    , result = '';
  if(that.global)     result += 'g';
  if(that.ignoreCase) result += 'i';
  if(that.multiline)  result += 'm';
  if(that.unicode)    result += 'u';
  if(that.sticky)     result += 'y';
  return result;
};

/***/ }),
/* 78 */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function(fn, args, that){
  var un = that === undefined;
  switch(args.length){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return              fn.apply(that, args);
};

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.8 IsRegExp(argument)
var isObject = __webpack_require__(6)
  , cof      = __webpack_require__(28)
  , MATCH    = __webpack_require__(7)('match');
module.exports = function(it){
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR     = __webpack_require__(7)('iterator')
  , SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function(){ SAFE_CLOSING = true; };
  Array.from(riter, function(){ throw 2; });
} catch(e){ /* empty */ }

module.exports = function(exec, skipClosing){
  if(!skipClosing && !SAFE_CLOSING)return false;
  var safe = false;
  try {
    var arr  = [7]
      , iter = arr[ITERATOR]();
    iter.next = function(){ return {done: safe = true}; };
    arr[ITERATOR] = function(){ return iter; };
    exec(arr);
  } catch(e){ /* empty */ }
  return safe;
};

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

// Forced replacement prototype accessors methods
module.exports = __webpack_require__(51)|| !__webpack_require__(5)(function(){
  var K = Math.random();
  // In FF throws only define methods
  __defineSetter__.call(null, K, function(){ /* empty */});
  delete __webpack_require__(4)[K];
});

/***/ }),
/* 82 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(4)
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(4)
  , hide   = __webpack_require__(18)
  , uid    = __webpack_require__(58)
  , TYPED  = uid('typed_array')
  , VIEW   = uid('view')
  , ABV    = !!(global.ArrayBuffer && global.DataView)
  , CONSTR = ABV
  , i = 0, l = 9, Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while(i < l){
  if(Typed = global[TypedArrayConstructors[i++]]){
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV:    ABV,
  CONSTR: CONSTR,
  TYPED:  TYPED,
  VIEW:   VIEW
};

/***/ }),
/* 85 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*!
 * VIZABI BUBBLE SIZE slider
 * Reusable bubble size slider
 */

var OPTIONS = {
  EXTENT_MIN: 0,
  EXTENT_MAX: 1,
  TEXT_PARAMS: { TOP: 11, LEFT: 10, MAX_WIDTH: 42, MAX_HEIGHT: 16 },
  BAR_WIDTH: 6,
  THUMB_RADIUS: 10,
  THUMB_STROKE_WIDTH: 4,
  INTRO_DURATION: 250
};

var profiles = {
  "small": {
    minRadius: 0.5,
    maxRadius: 40
  },
  "medium": {
    minRadius: 1,
    maxRadius: 55
  },
  "large": {
    minRadius: 1,
    maxRadius: 65
  }
};

var BubbleSize = _component2.default.extend({

  /**
   * Initializes the timeslider.
   * Executed once before any template is rendered.
   * @param config The options passed to the component
   * @param context The component's parent
   */
  init: function init(config, context) {

    this.name = "bubblesize";

    this.template = this.template || __webpack_require__(435);

    this.model_expects = [{
      name: "size",
      type: "size"
    }];

    var _this = this;
    this.model_binds = {
      "change:size.domainMin": changeMinMaxHandler,
      "change:size.domainMax": changeMinMaxHandler,
      "change:size.extent": changeMinMaxHandler,
      "ready": readyHandler
    };

    function changeMinMaxHandler(evt, path) {
      var extent = _this.model.size.extent || [OPTIONS.EXTENT_MIN, OPTIONS.EXTENT_MAX];
      _this._updateLabels(extent);
      _this._moveBrush(extent);
    }

    function readyHandler(evt) {
      _this.sizeScaleMinMax = _this.model.size.getScale().domain();
      _this._setLabelsText();
    }

    this._setModel = utils.throttle(this._setModel, 50);
    //contructor is the same as any component
    this._super(config, context);
  },


  /**
   * Executes after the template is loaded and rendered.
   * Ideally, it contains HTML instantiations related to template
   * At this point, this.element and this.placeholder are available as a d3 object
   */
  readyOnce: function readyOnce() {
    var _this = this;
    var extent = _this.model.size.extent || [OPTIONS.EXTENT_MIN, OPTIONS.EXTENT_MAX];
    this.showArcs = _this.model.size.showArcs !== false;

    this.element = d3.select(this.element);
    this.sliderSvg = this.element.select(".vzb-bs-svg");
    this.sliderWrap = this.sliderSvg.select(".vzb-bs-slider-wrap");
    this.sliderEl = this.sliderWrap.select(".vzb-bs-slider");

    var textMargin = { v: OPTIONS.TEXT_PARAMS.TOP, h: OPTIONS.TEXT_PARAMS.LEFT };
    var textMaxWidth = OPTIONS.TEXT_PARAMS.MAX_WIDTH;
    var textMaxHeight = OPTIONS.TEXT_PARAMS.MAX_HEIGHT;
    var barWidth = OPTIONS.BAR_WIDTH;
    var thumbRadius = OPTIONS.THUMB_RADIUS;
    var thumbStrokeWidth = OPTIONS.THUMB_STROKE_WIDTH;

    this.padding = {
      top: thumbStrokeWidth,
      left: textMargin.h + textMaxWidth,
      right: textMargin.h + textMaxWidth,
      bottom: barWidth + textMaxHeight
    };

    var minMaxBubbleRadius = this.getMinMaxBubbleRadius();

    this.xScale = d3.scale.linear().domain([OPTIONS.EXTENT_MIN, OPTIONS.EXTENT_MAX]).range([minMaxBubbleRadius.min * 2, minMaxBubbleRadius.max * 2]).clamp(true);

    this.brush = d3.brushX().extent([[0, 0], [minMaxBubbleRadius.max * 2, barWidth]]).handleSize(thumbRadius * 2 + barWidth * 2).on("start", function () {
      if (_this.nonBrushChange || !d3.event.sourceEvent) return;
      if (d3.event.selection && d3.event.selection[0] == d3.event.selection[1]) {
        var brushDatum = _this.sliderEl.node().__brush;
        brushDatum.selection[1][0] += 0.01;
      }
      _this._setFromExtent(false, false, false);
    }).on("brush", function () {
      if (_this.nonBrushChange || !d3.event.sourceEvent) return;
      if (d3.event.selection && d3.event.selection[0] == d3.event.selection[1]) {
        var brushDatum = _this.sliderEl.node().__brush;
        brushDatum.selection[1][0] += 0.01;
      }
      _this._setFromExtent(true, false, false); // non persistent change
    }).on("end", function () {
      if (_this.nonBrushChange || !d3.event.sourceEvent) return;
      _this._setFromExtent(true, true); // force a persistent change
    });

    this.sliderThumbs = this.sliderEl.selectAll(".handle").data([{ type: "w" }, { type: "e" }], function (d) {
      return d.type;
    }).enter().append("svg").attr("class", function (d) {
      return "handle handle--" + d.type;
    }).classed("vzb-bs-slider-thumb", true);

    this.sliderThumbs.append("g").attr("class", "vzb-bs-slider-thumb-badge").append("path").attr("d", "M" + (thumbRadius + barWidth) + " " + (thumbRadius + barWidth * 1.5) + "l" + -thumbRadius + " " + thumbRadius * 1.5 + "h" + thumbRadius * 2 + "Z");

    this.sliderEl.call(_this.brush);

    //For return to round thumbs
    //var thumbArc = d3.arc()
    //  .outerRadius(thumbRadius)
    //  .startAngle(0)
    //  .endAngle(2 * Math.PI)

    //For return to circles
    //.attr("d", "M0 0 l" + (thumbRadius * 2) + " " + (-thumbRadius) + "v" + (thumbRadius * 2) + "Z")

    //For return to round thumbs
    //.attr("d", thumbArc)

    if (_this.showArcs) {
      this.sliderEl.selectAll(".vzb-bs-slider-thumb-arc").data([0, 0]).enter().append("path").attr("class", "vzb-bs-slider-thumb-arc");
    }

    this.sliderArcsEl = this.sliderEl.selectAll(".vzb-bs-slider-thumb-arc");

    this.sliderEl.selectAll("text").data([0, 0]).enter().append("text").attr("class", "vzb-bs-slider-thumb-label").attr("text-anchor", function (d, i) {
      return i ? "start" : "end";
    }).attr("dy", function (d, i) {
      return i ? "-0.7em" : "1.4em";
    });

    this.sliderLabelsEl = this.sliderEl.selectAll("text.vzb-bs-slider-thumb-label");

    this.sliderEl.selectAll(".selection,.overlay").attr("height", barWidth).attr("rx", barWidth * 0.25).attr("ry", barWidth * 0.25).attr("transform", "translate(0," + -barWidth * 0.5 + ")");

    //For return to circles
    // var circleLabelTransform = function(d, i) {
    //    var dX = i ? textMargin.h + _this.xScale(d) : -textMargin.h,
    //        dY = -textMargin.v;
    //    return "translate(" + (dX) + "," + (dY) + ")";
    // }

    this.on("resize", function () {
      //console.log("EVENT: resize");
      var minMaxBubbleRadius = _this.getMinMaxBubbleRadius();
      _this.xScale.range([minMaxBubbleRadius.min * 2, minMaxBubbleRadius.max * 2]);
      _this._updateSize();
      _this.sliderEl.call(_this.brush.extent([[0, 0], [minMaxBubbleRadius.max * 2, barWidth]]));
      var extent = _this.model.size.extent || [OPTIONS.EXTENT_MIN, OPTIONS.EXTENT_MAX];
      _this._moveBrush(extent);
    });

    this._updateSize();
    this._moveBrush(extent);

    this.sizeScaleMinMax = this.model.size.getScale().domain();

    if (this.sizeScaleMinMax) {
      this._setLabelsText();
    }
  },
  getMinMaxBubbleRadius: function getMinMaxBubbleRadius() {
    return { min: profiles[this.getLayoutProfile()].minRadius, max: profiles[this.getLayoutProfile()].maxRadius };
  },
  _moveBrush: function _moveBrush(s) {
    var _s = s.map(this.xScale);
    this.nonBrushChange = true;
    this.sliderEl.call(this.brush.move, [_s[0], _s[1] + 0.01]);
    this.nonBrushChange = false;
    this._setFromExtent(false, false, false);
  },


  /*
   * RESIZE:
   * Executed whenever the container is resized
   */
  _updateSize: function _updateSize() {
    var maxBubbleRadius = this.showArcs ? this.getMinMaxBubbleRadius().max : OPTIONS.TEXT_PARAMS.TOP * 2;
    this.sliderSvg.attr("height", maxBubbleRadius + this.padding.top + this.padding.bottom).attr("width", this.getMinMaxBubbleRadius().max * 2 + this.padding.left + this.padding.right);
    this.sliderWrap.attr("transform", "translate(" + this.padding.left + "," + (maxBubbleRadius + this.padding.top) + ")");
  },
  _updateArcs: function _updateArcs(s) {
    if (!this.showArcs) return;
    var _this = this;
    var valueArc = d3.arc().outerRadius(function (d) {
      return _this.xScale(d) * 0.5;
    }).innerRadius(function (d) {
      return _this.xScale(d) * 0.5;
    }).startAngle(-Math.PI * 0.5).endAngle(Math.PI * 0.5);
    this.sliderArcsEl.data(s).attr("d", valueArc).attr("transform", function (d) {
      return "translate(" + _this.xScale(d) * 0.5 + ",0)";
    });
  },
  _updateLabels: function _updateLabels(s) {
    var _this = this;
    this.sliderLabelsEl.data(s).attr("transform", function (d, i) {
      var textMargin = { v: OPTIONS.TEXT_PARAMS.TOP, h: OPTIONS.TEXT_PARAMS.LEFT };
      var dX = textMargin.h * (i ? 0.5 : -1.0) + _this.xScale(d);
      var dY = 0;
      return "translate(" + dX + "," + dY + ")";
    });
  },
  _setLabelsText: function _setLabelsText() {
    var _this = this;
    _this.sliderLabelsEl.data([_this.model.size.getTickFormatter()(_this.sizeScaleMinMax[0]), _this.model.size.getTickFormatter()(_this.sizeScaleMinMax[1])]).text(function (d) {
      return d;
    });
  },


  /**
   * Prepares setting of the current model with the values from extent.
   * @param {boolean} set model
   * @param {boolean} force force firing the change event
   * @param {boolean} persistent sets the persistency of the change event
   */
  _setFromExtent: function _setFromExtent(setModel, force, persistent) {
    var s = d3.brushSelection(this.sliderEl.node());
    if (!s) return;
    s = [this.xScale.invert(s[0]), this.xScale.invert(+s[1].toFixed(1))];
    this._updateArcs(s);
    this._updateLabels(s);
    if (setModel) this._setModel(s, force, persistent);
  },


  /**
   * Sets the current value in model. avoid updating more than once in framerate
   * @param {number} value
   * @param {boolean} force force firing the change event
   * @param {boolean} persistent sets the persistency of the change event
   */
  _setModel: function _setModel(value, force, persistent) {
    value = [+value[0].toFixed(2), +value[1].toFixed(2)];
    this.model.size.set({ "extent": value }, force, persistent);
  }
});

exports.default = BubbleSize;

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _d = __webpack_require__(210);

var _d2 = _interopRequireDefault(_d);

var _d3 = __webpack_require__(41);

var _d4 = _interopRequireDefault(_d3);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*!
 * VIZABI BUBBLE COLOR LEGEND COMPONENT
 */

var ColorLegend = _component2.default.extend({
  init: function init(config, context) {
    var _this = this;
    this.template = '<div class="vzb-cl-outer"></div>';
    this.name = "colorlegend";

    this.model_expects = [{
      name: "time",
      type: "time"
    }, {
      name: "entities",
      type: "entities"
    }, {
      name: "marker",
      type: "model"
    }, {
      name: "locale",
      type: "locale"
    }];

    this.model_binds = {
      "change:marker.color.scaleType": function changeMarkerColorScaleType(evt, path) {
        if (!_this._readyOnce || _this.colorModel.isDiscrete()) return;
        _this.updateView();
      },
      "change:marker.color.palette": function changeMarkerColorPalette(evt, path) {
        if (!_this._readyOnce || _this.colorModel.isDiscrete() && !_this.frame) return;
        _this.updateView();
      },
      "change:marker.highlight": function changeMarkerHighlight(evt, values) {
        if (!_this.colorModel.isDiscrete()) return;

        _this.model.marker.getFrame(_this.model.time.value, function (frame) {
          if (frame) {
            var _hlEntities = _this.model.marker.getHighlighted(_this.KEY);
            _this.updateGroupsOpacity(_hlEntities.map(function (d) {
              return frame[_this.colorModel._name][d];
            }));
          } else {
            _this.updateGroupsOpacity();
          }
        });
      },
      "translate:locale": function translateLocale() {
        _this.colorPicker.translate(_this.model.locale.getTFunction());
      }
    };

    //contructor is the same as any component
    this._super(config, context);
  },
  readyOnce: function readyOnce() {
    var _this = this;
    this.element = d3.select(this.element);

    //make color in options scrollable
    d3.select(this.placeholder.parentNode).classed("vzb-dialog-scrollable", true);

    this.colorModel = this.model.marker.color;
    this.colorlegendMarker = this.colorModel.getColorlegendMarker();
    if (this.colorlegendMarker) {
      this.colorlegendMarker.on("ready", function () {
        _this.ready();
      });
    }
    this.listColorsEl = this.element.append("div").attr("class", "vzb-cl-holder").append("div").attr("class", "vzb-cl-colorlist");

    this.rainbowEl = this.listColorsEl.append("div").attr("class", "vzb-cl-rainbow");
    this.minimapEl = this.listColorsEl.append("div").attr("class", "vzb-cl-minimap");
    this.rainbowLegendEl = this.listColorsEl.append("div").attr("class", "vzb-cl-rainbow-legend");
    this.rainbowLegendSVG = this.rainbowLegendEl.append("svg");
    this.rainbowLegendG = this.rainbowLegendSVG.append("g");
    this.rainbowLegend = null;

    this.labelScaleEl = this.listColorsEl.append("div").attr("class", "vzb-cl-labelscale");
    this.labelScaleSVG = this.labelScaleEl.append("svg");
    this.labelScaleG = this.labelScaleSVG.append("g");
    this.unitDiv = this.listColorsEl.append("div").attr("class", "vzb-cl-unit");
    this.unitText = this.unitDiv.append("span").attr("class", "vzb-cl-unit-text");

    this.minimapSVG = this.minimapEl.append("svg");
    this.minimapG = this.minimapSVG.append("g");

    this.colorPicker = (0, _d2.default)();

    // append color picker to the tool DOM. need to check if element is already a d3 selection to not do it twice
    this.root.element instanceof Array ? this.root.element : d3.select(this.root.element).call(this.colorPicker);
    this.colorPicker.translate(this.model.locale.getTFunction());
  },
  ready: function ready() {
    var _this = this;

    this.KEY = this.model.entities.getDimension();
    this.colorlegendDim = this.KEY;
    this.canShowMap = false;

    if (this.colorModel.isDiscrete() && this.colorModel.use !== "constant" && this.colorlegendMarker) {
      if (!this.colorlegendMarker._ready) return;

      this.colorlegendDim = this.colorModel.getColorlegendEntities().getDimension();

      this.colorlegendMarker.getFrame(this.model.time.value, function (frame) {
        _this.frame = frame;
        _this.canShowMap = utils.keys((_this.frame || {}).hook_geoshape || {}).length;

        _this.colorlegendKeys = _this.colorlegendMarker.getKeys(_this.colorlegendDim);

        _this.colorlegendKeys.forEach(function (d) {
          if (!((_this.frame || {}).hook_geoshape || {})[d[_this.colorlegendDim]]) _this.canShowMap = false;
        });
        _this.updateView();
        _this.updateGroupsOpacity();
      });
      return;
    }

    _this.updateView();
    _this.updateGroupsOpacity();
  },
  updateView: function updateView() {
    var _this = this;
    var KEY = this.KEY;

    var palette = this.colorModel.getPalette();
    var canShowMap = this.canShowMap;

    var colorlegendKeys = this.colorlegendKeys || [];

    var colorOptions = this.listColorsEl.selectAll(".vzb-cl-option");

    //Hide and show elements of the color legend
    //Hide color legend entries if showing minimap or if color hook is a constant
    //or if using a discrete palette that would map to all entities on the chart and therefore will be too long
    //in the latter case we should show colors in the "find" list instead
    var hideColorOptions = canShowMap || this.colorModel.which == "_default" || this.colorlegendMarker && this.colorlegendDim == this.KEY && utils.comparePlainObjects(this.colorModel.getColorlegendEntities().getFilter(), this.model.entities.getFilter());

    colorOptions.classed("vzb-hidden", hideColorOptions);

    //Hide rainbow element if showing minimap or if color is discrete
    this.rainbowEl.classed("vzb-hidden", this.colorModel.isDiscrete());
    this.labelScaleEl.classed("vzb-hidden", this.colorModel.isDiscrete());
    this.rainbowLegendEl.classed("vzb-hidden", this.colorModel.isDiscrete());
    //Hide minimap if no data to draw it
    this.minimapEl.classed("vzb-hidden", !canShowMap || !this.colorModel.isDiscrete());

    this.unitDiv.classed("vzb-hidden", true);
    var cScale = this.colorModel.getScale();

    if (!this.colorModel.isDiscrete()) {

      var gradientWidth = this.rainbowEl.node().getBoundingClientRect().width;
      var paletteKeys = Object.keys(palette).map(parseFloat);

      var domain = void 0;
      var range = void 0;
      var formatter = this.colorModel.getTickFormatter();
      var fitIntoScale = null;

      var paletteLabels = this.colorModel.paletteLabels;

      if (paletteLabels) {

        fitIntoScale = "optimistic";

        domain = paletteLabels.map(function (val) {
          return parseFloat(val);
        });
        var paletteMax = d3.max(domain);
        range = domain.map(function (val) {
          return val / paletteMax * gradientWidth;
        });
      } else {

        domain = cScale.domain();
        var _paletteMax = d3.max(paletteKeys);
        range = paletteKeys.map(function (val) {
          return val / _paletteMax * gradientWidth;
        });
      }

      var labelScaletype = d3.min(domain) <= 0 && d3.max(domain) >= 0 && this.colorModel.scaleType === "log" ? "genericLog" : this.colorModel.scaleType;

      var labelScale = d3.scale[labelScaletype == "time" ? "linear" : labelScaletype]().domain(domain).range(range);

      var marginLeft = parseInt(this.rainbowEl.style("left"), 10) || 0;
      var marginRight = parseInt(this.rainbowEl.style("right"), 10) || marginLeft;

      this.labelScaleSVG.style("width", marginLeft + gradientWidth + marginRight + "px");
      this.labelScaleG.attr("transform", "translate(" + marginLeft + ",0)");
      this.rainbowLegendSVG.style("width", marginLeft + gradientWidth + marginRight + "px");
      this.rainbowLegendG.attr("transform", "translate(" + marginLeft + ", " + 7 + ")");
      var labelsAxis = (0, _d4.default)("bottom");
      labelsAxis.scale(labelScale)
      //.tickFormat(formatter)
      .tickSizeOuter(0).tickPadding(6).tickSizeMinor(3, 0).labelerOptions({
        scaleType: this.colorModel.scaleType,
        toolMargin: {
          right: marginRight,
          left: marginLeft
        },
        showOuter: true,
        //bump: this.activeProfile.maxRadius/2,
        //viewportLength: gradientWidth,
        formatter: formatter,
        bump: marginLeft,
        cssFontSize: "11px",
        fitIntoScale: fitIntoScale
      });

      this.labelScaleG.call(labelsAxis);

      var colorRange = cScale.range();

      var gIndicators = range.map(function (val, i) {
        return { val: val, color: colorRange[i], paletteKey: paletteKeys[i] };
      });
      this.rainbowLegend = this.rainbowLegendG.selectAll("circle").data(gIndicators);
      this.rainbowLegend.exit().remove();
      this.rainbowLegend = this.rainbowLegend.enter().append("circle").attr("r", "6px").attr("stroke", "#000").on("click", _this._interact().clickToChangeColor).merge(this.rainbowLegend);

      this.rainbowLegend.each(function (d, i) {
        d3.select(this).attr("fill", d.color);
        d3.select(this).attr("cx", d.val);
      });

      var gColors = paletteKeys.map(function (val, i) {
        return colorRange[i] + " " + d3.format("%")(val * 0.01);
      }).join(", ");

      this.rainbowEl.style("background", "linear-gradient(90deg," + gColors + ")");

      var unit = this.colorModel.getConceptprops().unit || "";

      this.unitDiv.classed("vzb-hidden", unit == "");
      this.unitText.text(unit);

      colorOptions.classed("vzb-hidden", true);
    } else {

      //Check if geoshape is provided
      if (!canShowMap) {

        if (this.colorModel.which == "_default") {
          colorOptions = colorOptions.data([]);
        } else {
          colorOptions = colorOptions.data(hideColorOptions ? [] : colorlegendKeys.length ? colorlegendKeys : Object.keys(this.colorModel.getPalette()).map(function (value) {
            var result = {};
            result[_this.colorlegendDim] = value;
            return result;
          }), function (d) {
            return d[_this.colorlegendDim];
          });
        }

        colorOptions.exit().remove();

        colorOptions.enter().append("div").attr("class", "vzb-cl-option").each(function () {
          d3.select(this).append("div").attr("class", "vzb-cl-color-sample").on("click", _this._interact().clickToShow);
          d3.select(this).append("div").attr("class", "vzb-cl-color-legend");
        }).on("mouseover", _this._interact().mouseover).on("mouseout", _this._interact().mouseout).on("click", _this._interact().clickToSelect);

        colorOptions.each(function (d, index) {
          d3.select(this).select(".vzb-cl-color-sample").style("background-color", cScale(d[_this.colorlegendDim])).style("border", "1px solid " + cScale(d[_this.colorlegendDim]));
          //Apply names to color legend entries if color is a property
          var label = _this.colorlegendMarker ? _this.frame.label[d[_this.colorlegendDim]] : null;
          if (!label && label !== 0) label = d[_this.colorlegendDim];
          d3.select(this).select(".vzb-cl-color-legend").text(label);
        });
      } else {

        //Drawing a minimap from the hook data

        var tempdivEl = this.minimapEl.append("div").attr("class", "vzb-temp");

        this.minimapSVG.attr("viewBox", null);
        this.minimapSVG.selectAll("g").remove();
        this.minimapG = this.minimapSVG.append("g");
        this.minimapG.selectAll("path").data(colorlegendKeys, function (d) {
          return d[_this.colorlegendDim];
        }).enter().append("path").on("mouseover", _this._interact().mouseover).on("mouseout", _this._interact().mouseout).on("click", _this._interact().clickToSelect).on("dblclick", _this._interact().clickToShow).each(function (d) {
          var shapeString = _this.frame.hook_geoshape[d[_this.colorlegendDim]].trim();

          //check if shape string starts with svg tag -- then it's a complete svg
          if (shapeString.slice(0, 4) == "<svg") {
            //append svg element from string to the temporary div
            tempdivEl.html(shapeString);
            //replace the shape string with just the path data from svg
            //TODO: this is not very resilient. potentially only the first path will be taken!
            shapeString = tempdivEl.select("svg").select("path").attr("d");
          }

          d3.select(this).attr("d", shapeString).style("fill", cScale(d[_this.colorlegendDim])).append("title").html(_this.frame.label[d[_this.colorlegendDim]]);

          tempdivEl.html("");
        });

        var gbbox = this.minimapG.node().getBBox();
        this.minimapSVG.attr("viewBox", "0 0 " + gbbox.width * 1.05 + " " + gbbox.height * 1.05);
        tempdivEl.remove();
      }
    }
  },
  _interact: function _interact() {
    var _this = this;
    var KEY = this.KEY;
    var colorlegendDim = this.colorlegendDim;

    return {
      mouseover: function mouseover(d, i) {
        //disable interaction if so stated in concept properties
        if (!_this.colorModel.isDiscrete()) return;

        var view = d3.select(this);
        var target = d[colorlegendDim];

        var highlight = _this.colorModel.getValidItems()
        //filter so that only countries of the correct target remain
        .filter(function (f) {
          return f[_this.colorModel.which] == target;
        })
        //fish out the "key" field, leave the rest behind
        .map(function (d) {
          return utils.clone(d, [KEY]);
        });

        _this.model.marker.setHighlight(highlight);
      },
      mouseout: function mouseout(d, i) {
        //disable interaction if so stated in concept properties
        if (!_this.colorModel.isDiscrete()) return;
        _this.model.marker.clearHighlighted();
      },
      clickToChangeColor: function clickToChangeColor(d, i) {
        //disable interaction if so stated in concept properties
        if (!_this.colorModel.isUserSelectable()) return;
        var palette = _this.colorModel.getPalette();
        var defaultPalette = _this.colorModel.getDefaultPalette();
        var view = d3.select(this);
        var target = !_this.colorModel.isDiscrete() ? d.paletteKey : d[colorlegendDim];
        _this.colorPicker.colorOld(palette[target]).colorDef(defaultPalette[target]).callback(function (value, permanent) {
          _this.colorModel.setColor(value, target);
        }).fitToScreen([d3.event.pageX, d3.event.pageY]).show(true);
      },
      clickToShow: function clickToShow(d, i) {
        //disable interaction if so stated in concept properties
        if (!_this.colorModel.isDiscrete()) return;

        var view = d3.select(this);
        var target = d[colorlegendDim];

        var oldShow = _this.model.entities.show[colorlegendDim] && _this.model.entities.show[colorlegendDim]["$in"] ? utils.clone(_this.model.entities.show[colorlegendDim]["$in"]) : [];

        var entityIndex = oldShow.indexOf(d[colorlegendDim]);
        if (entityIndex !== -1) {
          oldShow.splice(entityIndex, 1);
        } else {
          oldShow.push(d[colorlegendDim]);
        }

        var show = {};
        if (oldShow.length > 0) show[colorlegendDim] = { "$in": oldShow };

        _this.model.entities.set({ show: show });
      },
      clickToSelect: function clickToSelect(d, i) {
        //disable interaction if so stated in concept properties
        if (!_this.colorModel.isDiscrete()) return;

        var view = d3.select(this);
        var target = d[colorlegendDim];

        var select = _this.colorModel.getValidItems()
        //filter so that only countries of the correct target remain
        .filter(function (f) {
          return f[_this.colorModel.which] == target;
        })
        //fish out the "key" field, leave the rest behind
        .map(function (d) {
          return utils.clone(d, [KEY]);
        });

        if (select.filter(function (d) {
          return _this.model.marker.isSelected(d);
        }).length == select.length) {
          _this.model.marker.clearSelected();
        } else {
          _this.model.marker.setSelect(select);
        }
      }
    };
  },
  resize: function resize() {
    if (!this.colorModel.isDiscrete()) {
      this.updateView();
    }
    this.colorPicker.resize(d3.select(".vzb-colorpicker-svg"));
  },


  /**
   * Function updates the opacity of color legend elements
   * @param   {Array} value = [] array of highlighted elements
   */
  updateGroupsOpacity: function updateGroupsOpacity() {
    var highlight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    var _this = this;

    var clMarker = this.colorModel.getColorlegendMarker() || {};
    var OPACITY_REGULAR = clMarker.opacityRegular || 0.8;
    var OPACITY_DIM = clMarker.opacityHighlightDim || 0.5;
    var OPACITY_HIGHLIGHT = 1;

    var selection = _this.canShowMap ? ".vzb-cl-minimap path" : ".vzb-cl-option .vzb-cl-color-sample";

    this.listColorsEl.selectAll(selection).style("opacity", function (d) {
      if (!highlight.length) return OPACITY_REGULAR;
      return highlight.indexOf(d[_this.colorlegendDim]) > -1 ? OPACITY_HIGHLIGHT : OPACITY_DIM;
    });
  }
});

exports.default = ColorLegend;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*!
 * VIZABI MIN MAX INPUT FIELDS
 */

var DOMAINMIN = "domainMin";
var DOMAINMAX = "domainMax";
var ZOOMEDMIN = "zoomedMin";
var ZOOMEDMAX = "zoomedMax";

var MinMaxInputs = _component2.default.extend({

  /**
   * Initializes the Component.
   * Executed once before any template is rendered.
   * @param config The options passed to the component
   * @param context The component's parent
   */
  init: function init(config, context) {

    this.name = "gapminder-minmaxinputs";
    this.template = __webpack_require__(453);

    var _this = this;

    this.model_expects = [{
      name: "marker",
      type: "model"
    }, {
      name: "time",
      type: "time"
    }, {
      name: "locale",
      type: "locale"
    }];

    this.markerID = config.markerID;
    if (!config.markerID) utils.warn("minmaxinputs.js complains on 'markerID' property: " + config.markerID);

    this.model_binds = {};
    this.model_binds["translate:locale"] = function (evt) {
      _this.updateView();
    };
    this.model_binds["change:marker." + this.markerID] = function (evt) {
      _this.updateView();
    };
    this.model_binds["ready"] = function (evt) {
      _this.updateView();
    };

    //contructor is the same as any component
    this._super(config, context);

    // SPECIFIC COMPONENT UI! NOT TOOLMODEL UI!
    this.ui = utils.extend({
      selectDomainMinMax: false,
      selectZoomedMinMax: false
    }, this.ui.getPlainObject());
  },
  ready: function ready() {
    this.updateView();
  },
  readyOnce: function readyOnce() {
    var _this = this;

    this.element = d3.select(this.element);

    this.el_domain_labelMin = this.element.select(".vzb-mmi-domainmin-label");
    this.el_domain_labelMax = this.element.select(".vzb-mmi-domainmax-label");
    this.el_domain_fieldMin = this.element.select(".vzb-mmi-domainmin");
    this.el_domain_fieldMax = this.element.select(".vzb-mmi-domainmax");

    this.el_break = this.element.select(".vzb-mmi-break");

    this.el_zoomed_labelMin = this.element.select(".vzb-mmi-zoomedmin-label");
    this.el_zoomed_labelMax = this.element.select(".vzb-mmi-zoomedmax-label");
    this.el_zoomed_fieldMin = this.element.select(".vzb-mmi-zoomedmin");
    this.el_zoomed_fieldMax = this.element.select(".vzb-mmi-zoomedmax");

    _this.el_domain_fieldMin.on("change", function () {
      _this._setModel(DOMAINMIN, this.value);
    });
    _this.el_domain_fieldMax.on("change", function () {
      _this._setModel(DOMAINMAX, this.value);
    });

    _this.el_zoomed_fieldMin.on("change", function () {
      _this._setModel(ZOOMEDMIN, this.value);
    });
    _this.el_zoomed_fieldMax.on("change", function () {
      _this._setModel(ZOOMEDMAX, this.value);
    });

    this.element.selectAll("input").on("keypress", function (e) {
      if (d3.event.which == 13) document.activeElement.blur();
    });
  },
  updateView: function updateView() {
    var _this = this;
    this.translator = this.model.locale.getTFunction();

    this.el_domain_labelMin.text(this.translator("hints/min") + ":");
    this.el_domain_labelMax.text(this.translator("hints/max") + ":");
    this.el_zoomed_labelMin.text(this.translator("hints/min") + ":");
    this.el_zoomed_labelMax.text(this.translator("hints/max") + ":");

    this.el_domain_labelMin.classed("vzb-hidden", !this.ui.selectDomainMinMax);
    this.el_domain_labelMax.classed("vzb-hidden", !this.ui.selectDomainMinMax);
    this.el_domain_fieldMin.classed("vzb-hidden", !this.ui.selectDomainMinMax);
    this.el_domain_fieldMax.classed("vzb-hidden", !this.ui.selectDomainMinMax);

    this.el_break.classed("vzb-hidden", !(this.ui.selectDomainMinMax && this.ui.selectZoomedMinMax));

    this.el_zoomed_labelMin.classed("vzb-hidden", !this.ui.selectZoomedMinMax);
    this.el_zoomed_labelMax.classed("vzb-hidden", !this.ui.selectZoomedMinMax);
    this.el_zoomed_fieldMin.classed("vzb-hidden", !this.ui.selectZoomedMinMax);
    this.el_zoomed_fieldMax.classed("vzb-hidden", !this.ui.selectZoomedMinMax);

    var formatter = function formatter(n) {
      if (!n && n !== 0) return n;
      if (utils.isDate(n)) return _this.model.time.formatDate(n);
      return d3.format(".2r")(n);
    };

    this.el_domain_fieldMin.property("value", formatter(this.model.marker[this.markerID].getScale().domain()[0]));
    this.el_domain_fieldMax.property("value", formatter(this.model.marker[this.markerID].getScale().domain()[1]));
    this.el_zoomed_fieldMin.property("value", formatter(this.model.marker[this.markerID].zoomedMin));
    this.el_zoomed_fieldMax.property("value", formatter(this.model.marker[this.markerID].zoomedMax));
  },
  _setModel: function _setModel(what, value) {
    this.model.marker[this.markerID][what] = utils.strToFloat(value);
  }
});

exports.default = MinMaxInputs;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function () {
  d3.geoProject = function (object, projection) {
    var stream = projection.stream;
    if (!stream) throw new Error("not yet supported");
    return (object && d3_geo_projectObjectType.hasOwnProperty(object.type) ? d3_geo_projectObjectType[object.type] : d3_geo_projectGeometry)(object, stream);
  };
  function d3_geo_projectFeature(object, stream) {
    return {
      type: "Feature",
      id: object.id,
      properties: object.properties,
      geometry: d3_geo_projectGeometry(object.geometry, stream)
    };
  }
  function d3_geo_projectGeometry(geometry, stream) {
    if (!geometry) return null;
    if (geometry.type === "GeometryCollection") return {
      type: "GeometryCollection",
      geometries: object.geometries.map(function (geometry) {
        return d3_geo_projectGeometry(geometry, stream);
      })
    };
    if (!d3_geo_projectGeometryType.hasOwnProperty(geometry.type)) return null;
    var sink = d3_geo_projectGeometryType[geometry.type];
    d3.geoUstream(geometry, stream(sink));
    return sink.result();
  }
  var d3_geo_projectObjectType = {
    Feature: d3_geo_projectFeature,
    FeatureCollection: function FeatureCollection(object, stream) {
      return {
        type: "FeatureCollection",
        features: object.features.map(function (feature) {
          return d3_geo_projectFeature(feature, stream);
        })
      };
    }
  };
  var d3_geo_projectPoints = [],
      d3_geo_projectLines = [];
  var d3_geo_projectPoint = {
    point: function point(x, y) {
      d3_geo_projectPoints.push([x, y]);
    },
    result: function result() {
      var result = !d3_geo_projectPoints.length ? null : d3_geo_projectPoints.length < 2 ? {
        type: "Point",
        coordinates: d3_geo_projectPoints[0]
      } : {
        type: "MultiPoint",
        coordinates: d3_geo_projectPoints
      };
      d3_geo_projectPoints = [];
      return result;
    }
  };
  var d3_geo_projectLine = {
    lineStart: d3_geo_projectNoop,
    point: function point(x, y) {
      d3_geo_projectPoints.push([x, y]);
    },
    lineEnd: function lineEnd() {
      if (d3_geo_projectPoints.length) d3_geo_projectLines.push(d3_geo_projectPoints), d3_geo_projectPoints = [];
    },
    result: function result() {
      var result = !d3_geo_projectLines.length ? null : d3_geo_projectLines.length < 2 ? {
        type: "LineString",
        coordinates: d3_geo_projectLines[0]
      } : {
        type: "MultiLineString",
        coordinates: d3_geo_projectLines
      };
      d3_geo_projectLines = [];
      return result;
    }
  };
  var d3_geo_projectPolygon = {
    polygonStart: d3_geo_projectNoop,
    lineStart: d3_geo_projectNoop,
    point: function point(x, y) {
      d3_geo_projectPoints.push([x, y]);
    },
    lineEnd: function lineEnd() {
      var n = d3_geo_projectPoints.length;
      if (n) {
        do {
          d3_geo_projectPoints.push(d3_geo_projectPoints[0].slice());
        } while (++n < 4);
        d3_geo_projectLines.push(d3_geo_projectPoints), d3_geo_projectPoints = [];
      }
    },
    polygonEnd: d3_geo_projectNoop,
    result: function result() {
      if (!d3_geo_projectLines.length) return null;
      var polygons = [],
          holes = [];
      d3_geo_projectLines.forEach(function (ring) {
        if (d3_geo_projectClockwise(ring)) polygons.push([ring]);else holes.push(ring);
      });
      holes.forEach(function (hole) {
        var point = hole[0];
        polygons.some(function (polygon) {
          if (d3_geo_projectContains(polygon[0], point)) {
            polygon.push(hole);
            return true;
          }
          return false;
        }) || polygons.push([hole]);
      });
      d3_geo_projectLines = [];
      return !polygons.length ? null : polygons.length > 1 ? {
        type: "MultiPolygon",
        coordinates: polygons
      } : {
        type: "Polygon",
        coordinates: polygons[0]
      };
    }
  };
  var d3_geo_projectGeometryType = {
    Point: d3_geo_projectPoint,
    MultiPoint: d3_geo_projectPoint,
    LineString: d3_geo_projectLine,
    MultiLineString: d3_geo_projectLine,
    Polygon: d3_geo_projectPolygon,
    MultiPolygon: d3_geo_projectPolygon,
    Sphere: d3_geo_projectPolygon
  };
  function d3_geo_projectNoop() {}
  function d3_geo_projectClockwise(ring) {
    if ((n = ring.length) < 4) return false;
    var i = 0,
        n,
        area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
    while (++i < n) {
      area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
    }return area <= 0;
  }
  function d3_geo_projectContains(ring, point) {
    var x = point[0],
        y = point[1],
        contains = false;
    for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
      var pi = ring[i],
          xi = pi[0],
          yi = pi[1],
          pj = ring[j],
          xj = pj[0],
          yj = pj[1];
      if (yi > y ^ yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) contains = !contains;
    }
    return contains;
  }
  var ε = 1e-6,
      ε2 = ε * ε,
      π = Math.PI,
      halfπ = π / 2,
      sqrtπ = Math.sqrt(π),
      radians = π / 180,
      degrees = 180 / π;
  function sinci(x) {
    return x ? x / Math.sin(x) : 1;
  }
  function sgn(x) {
    return x > 0 ? 1 : x < 0 ? -1 : 0;
  }
  function asin(x) {
    return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
  }
  function acos(x) {
    return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
  }
  function asqrt(x) {
    return x > 0 ? Math.sqrt(x) : 0;
  }
  var projection = d3.geoProjection,
      projectionMutator = d3.geoProjectionMutator;
  d3.geoInterrupt = function (project) {
    var lobes = [[[[-π, 0], [0, halfπ], [π, 0]]], [[[-π, 0], [0, -halfπ], [π, 0]]]];
    var bounds;
    function forward(λ, φ) {
      var sign = φ < 0 ? -1 : +1,
          hemilobes = lobes[+(φ < 0)];
      for (var i = 0, n = hemilobes.length - 1; i < n && λ > hemilobes[i][2][0]; ++i) {}
      var coordinates = project(λ - hemilobes[i][1][0], φ);
      coordinates[0] += project(hemilobes[i][1][0], sign * φ > sign * hemilobes[i][0][1] ? hemilobes[i][0][1] : φ)[0];
      return coordinates;
    }
    function reset() {
      bounds = lobes.map(function (hemilobes) {
        return hemilobes.map(function (lobe) {
          var x0 = project(lobe[0][0], lobe[0][1])[0],
              x1 = project(lobe[2][0], lobe[2][1])[0],
              y0 = project(lobe[1][0], lobe[0][1])[1],
              y1 = project(lobe[1][0], lobe[1][1])[1],
              t;
          if (y0 > y1) t = y0, y0 = y1, y1 = t;
          return [[x0, y0], [x1, y1]];
        });
      });
    }
    if (project.invert) forward.invert = function (x, y) {
      var hemibounds = bounds[+(y < 0)],
          hemilobes = lobes[+(y < 0)];
      for (var i = 0, n = hemibounds.length; i < n; ++i) {
        var b = hemibounds[i];
        if (b[0][0] <= x && x < b[1][0] && b[0][1] <= y && y < b[1][1]) {
          var coordinates = project.invert(x - project(hemilobes[i][1][0], 0)[0], y);
          coordinates[0] += hemilobes[i][1][0];
          return pointEqual(forward(coordinates[0], coordinates[1]), [x, y]) ? coordinates : null;
        }
      }
    };
    var projection = d3.geoProjection(forward),
        stream_ = projection.stream;
    projection.stream = function (stream) {
      var rotate = projection.rotate(),
          rotateStream = stream_(stream),
          sphereStream = (projection.rotate([0, 0]), stream_(stream));
      projection.rotate(rotate);
      rotateStream.sphere = function () {
        d3.geoStream(sphere(), sphereStream);
      };
      return rotateStream;
    };
    projection.lobes = function (_) {
      if (!arguments.length) return lobes.map(function (lobes) {
        return lobes.map(function (lobe) {
          return [[lobe[0][0] * 180 / π, lobe[0][1] * 180 / π], [lobe[1][0] * 180 / π, lobe[1][1] * 180 / π], [lobe[2][0] * 180 / π, lobe[2][1] * 180 / π]];
        });
      });
      lobes = _.map(function (lobes) {
        return lobes.map(function (lobe) {
          return [[lobe[0][0] * π / 180, lobe[0][1] * π / 180], [lobe[1][0] * π / 180, lobe[1][1] * π / 180], [lobe[2][0] * π / 180, lobe[2][1] * π / 180]];
        });
      });
      reset();
      return projection;
    };
    function sphere() {
      var ε = 1e-6,
          coordinates = [];
      for (var i = 0, n = lobes[0].length; i < n; ++i) {
        var lobe = lobes[0][i],
            λ0 = lobe[0][0] * 180 / π,
            φ0 = lobe[0][1] * 180 / π,
            φ1 = lobe[1][1] * 180 / π,
            λ2 = lobe[2][0] * 180 / π,
            φ2 = lobe[2][1] * 180 / π;
        coordinates.push(resample([[λ0 + ε, φ0 + ε], [λ0 + ε, φ1 - ε], [λ2 - ε, φ1 - ε], [λ2 - ε, φ2 + ε]], 30));
      }
      for (var i = lobes[1].length - 1; i >= 0; --i) {
        var lobe = lobes[1][i],
            λ0 = lobe[0][0] * 180 / π,
            φ0 = lobe[0][1] * 180 / π,
            φ1 = lobe[1][1] * 180 / π,
            λ2 = lobe[2][0] * 180 / π,
            φ2 = lobe[2][1] * 180 / π;
        coordinates.push(resample([[λ2 - ε, φ2 - ε], [λ2 - ε, φ1 + ε], [λ0 + ε, φ1 + ε], [λ0 + ε, φ0 - ε]], 30));
      }
      return {
        type: "Polygon",
        coordinates: [d3.merge(coordinates)]
      };
    }
    function resample(coordinates, m) {
      var i = -1,
          n = coordinates.length,
          p0 = coordinates[0],
          p1,
          dx,
          dy,
          resampled = [];
      while (++i < n) {
        p1 = coordinates[i];
        dx = (p1[0] - p0[0]) / m;
        dy = (p1[1] - p0[1]) / m;
        for (var j = 0; j < m; ++j) {
          resampled.push([p0[0] + j * dx, p0[1] + j * dy]);
        }p0 = p1;
      }
      resampled.push(p1);
      return resampled;
    }
    function pointEqual(a, b) {
      return Math.abs(a[0] - b[0]) < ε && Math.abs(a[1] - b[1]) < ε;
    }
    return projection;
  };
  function airy(β) {
    var tanβ_2 = Math.tan(.5 * β),
        B = 2 * Math.log(Math.cos(.5 * β)) / (tanβ_2 * tanβ_2);
    function forward(λ, φ) {
      var cosλ = Math.cos(λ),
          cosφ = Math.cos(φ),
          sinφ = Math.sin(φ),
          cosz = cosφ * cosλ,
          K = -((1 - cosz ? Math.log(.5 * (1 + cosz)) / (1 - cosz) : -.5) + B / (1 + cosz));
      return [K * cosφ * Math.sin(λ), K * sinφ];
    }
    forward.invert = function (x, y) {
      var ρ = Math.sqrt(x * x + y * y),
          z = β * -.5,
          i = 50,
          δ;
      if (!ρ) return [0, 0];
      do {
        var z_2 = .5 * z,
            cosz_2 = Math.cos(z_2),
            sinz_2 = Math.sin(z_2),
            tanz_2 = Math.tan(z_2),
            lnsecz_2 = Math.log(1 / cosz_2);
        z -= δ = (2 / tanz_2 * lnsecz_2 - B * tanz_2 - ρ) / (-lnsecz_2 / (sinz_2 * sinz_2) + 1 - B / (2 * cosz_2 * cosz_2));
      } while (Math.abs(δ) > ε && --i > 0);
      var sinz = Math.sin(z);
      return [Math.atan2(x * sinz, ρ * Math.cos(z)), asin(y * sinz / ρ)];
    };
    return forward;
  }
  function airyProjection() {
    var β = halfπ,
        m = projectionMutator(airy),
        p = m(β);
    p.radius = function (_) {
      if (!arguments.length) return β / π * 180;
      return m(β = _ * π / 180);
    };
    return p;
  }
  (d3.geoAiry = airyProjection).raw = airy;
  function aitoff(λ, φ) {
    var cosφ = Math.cos(φ),
        sinciα = sinci(acos(cosφ * Math.cos(λ /= 2)));
    return [2 * cosφ * Math.sin(λ) * sinciα, Math.sin(φ) * sinciα];
  }
  aitoff.invert = function (x, y) {
    if (x * x + 4 * y * y > π * π + ε) return;
    var λ = x,
        φ = y,
        i = 25;
    do {
      var sinλ = Math.sin(λ),
          sinλ_2 = Math.sin(λ / 2),
          cosλ_2 = Math.cos(λ / 2),
          sinφ = Math.sin(φ),
          cosφ = Math.cos(φ),
          sin_2φ = Math.sin(2 * φ),
          sin2φ = sinφ * sinφ,
          cos2φ = cosφ * cosφ,
          sin2λ_2 = sinλ_2 * sinλ_2,
          C = 1 - cos2φ * cosλ_2 * cosλ_2,
          E = C ? acos(cosφ * cosλ_2) * Math.sqrt(F = 1 / C) : F = 0,
          F,
          fx = 2 * E * cosφ * sinλ_2 - x,
          fy = E * sinφ - y,
          δxδλ = F * (cos2φ * sin2λ_2 + E * cosφ * cosλ_2 * sin2φ),
          δxδφ = F * (.5 * sinλ * sin_2φ - E * 2 * sinφ * sinλ_2),
          δyδλ = F * .25 * (sin_2φ * sinλ_2 - E * sinφ * cos2φ * sinλ),
          δyδφ = F * (sin2φ * cosλ_2 + E * sin2λ_2 * cosφ),
          denominator = δxδφ * δyδλ - δyδφ * δxδλ;
      if (!denominator) break;
      var δλ = (fy * δxδφ - fx * δyδφ) / denominator,
          δφ = (fx * δyδλ - fy * δxδλ) / denominator;
      λ -= δλ, φ -= δφ;
    } while ((Math.abs(δλ) > ε || Math.abs(δφ) > ε) && --i > 0);
    return [λ, φ];
  };
  (d3.geoAitoff = function () {
    return projection(aitoff);
  }).raw = aitoff;
  function armadillo(φ0) {
    var sinφ0 = Math.sin(φ0),
        cosφ0 = Math.cos(φ0),
        sφ0 = φ0 > 0 ? 1 : -1,
        tanφ0 = Math.tan(sφ0 * φ0),
        k = (1 + sinφ0 - cosφ0) / 2;
    function forward(λ, φ) {
      var cosφ = Math.cos(φ),
          cosλ = Math.cos(λ /= 2);
      return [(1 + cosφ) * Math.sin(λ), (sφ0 * φ > -Math.atan2(cosλ, tanφ0) - .001 ? 0 : -sφ0 * 10) + k + Math.sin(φ) * cosφ0 - (1 + cosφ) * sinφ0 * cosλ];
    }
    forward.invert = function (x, y) {
      var λ = 0,
          φ = 0,
          i = 50;
      do {
        var cosλ = Math.cos(λ),
            sinλ = Math.sin(λ),
            cosφ = Math.cos(φ),
            sinφ = Math.sin(φ),
            A = 1 + cosφ,
            fx = A * sinλ - x,
            fy = k + sinφ * cosφ0 - A * sinφ0 * cosλ - y,
            δxδλ = .5 * A * cosλ,
            δxδφ = -sinλ * sinφ,
            δyδλ = .5 * sinφ0 * A * sinλ,
            δyδφ = cosφ0 * cosφ + sinφ0 * cosλ * sinφ,
            denominator = δxδφ * δyδλ - δyδφ * δxδλ,
            δλ = .5 * (fy * δxδφ - fx * δyδφ) / denominator,
            δφ = (fx * δyδλ - fy * δxδλ) / denominator;
        λ -= δλ, φ -= δφ;
      } while ((Math.abs(δλ) > ε || Math.abs(δφ) > ε) && --i > 0);
      return sφ0 * φ > -Math.atan2(Math.cos(λ), tanφ0) - .001 ? [λ * 2, φ] : null;
    };
    return forward;
  }
  function armadilloProjection() {
    var φ0 = π / 9,
        sφ0 = φ0 > 0 ? 1 : -1,
        tanφ0 = Math.tan(sφ0 * φ0),
        m = projectionMutator(armadillo),
        p = m(φ0),
        stream_ = p.stream;
    p.parallel = function (_) {
      if (!arguments.length) return φ0 / π * 180;
      tanφ0 = Math.tan((sφ0 = (φ0 = _ * π / 180) > 0 ? 1 : -1) * φ0);
      return m(φ0);
    };
    p.stream = function (stream) {
      var rotate = p.rotate(),
          rotateStream = stream_(stream),
          sphereStream = (p.rotate([0, 0]), stream_(stream));
      p.rotate(rotate);
      rotateStream.sphere = function () {
        sphereStream.polygonStart(), sphereStream.lineStart();
        for (var λ = sφ0 * -180; sφ0 * λ < 180; λ += sφ0 * 90) {
          sphereStream.point(λ, sφ0 * 90);
        }while (sφ0 * (λ -= φ0) >= -180) {
          sphereStream.point(λ, sφ0 * -Math.atan2(Math.cos(λ * radians / 2), tanφ0) * degrees);
        }
        sphereStream.lineEnd(), sphereStream.polygonEnd();
      };
      return rotateStream;
    };
    return p;
  }
  (d3.geoArmadillo = armadilloProjection).raw = armadillo;
  function tanh(x) {
    x = Math.exp(2 * x);
    return (x - 1) / (x + 1);
  }
  function sinh(x) {
    return .5 * (Math.exp(x) - Math.exp(-x));
  }
  function cosh(x) {
    return .5 * (Math.exp(x) + Math.exp(-x));
  }
  function arsinh(x) {
    return Math.log(x + asqrt(x * x + 1));
  }
  function arcosh(x) {
    return Math.log(x + asqrt(x * x - 1));
  }
  function august(λ, φ) {
    var tanφ = Math.tan(φ / 2),
        k = asqrt(1 - tanφ * tanφ),
        c = 1 + k * Math.cos(λ /= 2),
        x = Math.sin(λ) * k / c,
        y = tanφ / c,
        x2 = x * x,
        y2 = y * y;
    return [4 / 3 * x * (3 + x2 - 3 * y2), 4 / 3 * y * (3 + 3 * x2 - y2)];
  }
  august.invert = function (x, y) {
    x *= 3 / 8, y *= 3 / 8;
    if (!x && Math.abs(y) > 1) return null;
    var x2 = x * x,
        y2 = y * y,
        s = 1 + x2 + y2,
        sin3η = Math.sqrt(.5 * (s - Math.sqrt(s * s - 4 * y * y))),
        η = asin(sin3η) / 3,
        ξ = sin3η ? arcosh(Math.abs(y / sin3η)) / 3 : arsinh(Math.abs(x)) / 3,
        cosη = Math.cos(η),
        coshξ = cosh(ξ),
        d = coshξ * coshξ - cosη * cosη;
    return [sgn(x) * 2 * Math.atan2(sinh(ξ) * cosη, .25 - d), sgn(y) * 2 * Math.atan2(coshξ * Math.sin(η), .25 + d)];
  };
  (d3.geoAugust = function () {
    return projection(august);
  }).raw = august;
  var bakerφ = Math.log(1 + Math.SQRT2);
  function baker(λ, φ) {
    var φ0 = Math.abs(φ);
    return φ0 < π / 4 ? [λ, Math.log(Math.tan(π / 4 + φ / 2))] : [λ * Math.cos(φ0) * (2 * Math.SQRT2 - 1 / Math.sin(φ0)), sgn(φ) * (2 * Math.SQRT2 * (φ0 - π / 4) - Math.log(Math.tan(φ0 / 2)))];
  }
  baker.invert = function (x, y) {
    if ((y0 = Math.abs(y)) < bakerφ) return [x, 2 * Math.atan(Math.exp(y)) - halfπ];
    var sqrt8 = Math.sqrt(8),
        φ = π / 4,
        i = 25,
        δ,
        y0;
    do {
      var cosφ_2 = Math.cos(φ / 2),
          tanφ_2 = Math.tan(φ / 2);
      φ -= δ = (sqrt8 * (φ - π / 4) - Math.log(tanφ_2) - y0) / (sqrt8 - .5 * cosφ_2 * cosφ_2 / tanφ_2);
    } while (Math.abs(δ) > ε2 && --i > 0);
    return [x / (Math.cos(φ) * (sqrt8 - 1 / Math.sin(φ))), sgn(y) * φ];
  };
  (d3.geoBaker = function () {
    return projection(baker);
  }).raw = baker;
  var berghausAzimuthalEquidistant = d3.geoAzimuthalEquidistant.raw;
  function berghaus(n) {
    var k = 2 * π / n;
    function forward(λ, φ) {
      var p = berghausAzimuthalEquidistant(λ, φ);
      if (Math.abs(λ) > halfπ) {
        var θ = Math.atan2(p[1], p[0]),
            r = Math.sqrt(p[0] * p[0] + p[1] * p[1]),
            θ0 = k * Math.round((θ - halfπ) / k) + halfπ,
            α = Math.atan2(Math.sin(θ -= θ0), 2 - Math.cos(θ));
        θ = θ0 + asin(π / r * Math.sin(α)) - α;
        p[0] = r * Math.cos(θ);
        p[1] = r * Math.sin(θ);
      }
      return p;
    }
    forward.invert = function (x, y) {
      var r = Math.sqrt(x * x + y * y);
      if (r > halfπ) {
        var θ = Math.atan2(y, x),
            θ0 = k * Math.round((θ - halfπ) / k) + halfπ,
            s = θ > θ0 ? -1 : 1,
            A = r * Math.cos(θ0 - θ),
            cotα = 1 / Math.tan(s * Math.acos((A - π) / Math.sqrt(π * (π - 2 * A) + r * r)));
        θ = θ0 + 2 * Math.atan((cotα + s * Math.sqrt(cotα * cotα - 3)) / 3);
        x = r * Math.cos(θ), y = r * Math.sin(θ);
      }
      return berghausAzimuthalEquidistant.invert(x, y);
    };
    return forward;
  }
  function berghausProjection() {
    var n = 5,
        m = projectionMutator(berghaus),
        p = m(n),
        stream_ = p.stream,
        ε = .01,
        cr = -Math.cos(ε * radians),
        sr = Math.sin(ε * radians);
    p.lobes = function (_) {
      if (!arguments.length) return n;
      return m(n = +_);
    };
    p.stream = function (stream) {
      var rotate = p.rotate(),
          rotateStream = stream_(stream),
          sphereStream = (p.rotate([0, 0]), stream_(stream));
      p.rotate(rotate);
      rotateStream.sphere = function () {
        sphereStream.polygonStart(), sphereStream.lineStart();
        for (var i = 0, δ = 360 / n, δ0 = 2 * π / n, φ = 90 - 180 / n, φ0 = halfπ; i < n; ++i, φ -= δ, φ0 -= δ0) {
          sphereStream.point(Math.atan2(sr * Math.cos(φ0), cr) * degrees, asin(sr * Math.sin(φ0)) * degrees);
          if (φ < -90) {
            sphereStream.point(-90, -180 - φ - ε);
            sphereStream.point(-90, -180 - φ + ε);
          } else {
            sphereStream.point(90, φ + ε);
            sphereStream.point(90, φ - ε);
          }
        }
        sphereStream.lineEnd(), sphereStream.polygonEnd();
      };
      return rotateStream;
    };
    return p;
  }
  (d3.geoBerghaus = berghausProjection).raw = berghaus;
  function mollweideBromleyθ(Cp) {
    return function (θ) {
      var Cpsinθ = Cp * Math.sin(θ),
          i = 30,
          δ;
      do {
        θ -= δ = (θ + Math.sin(θ) - Cpsinθ) / (1 + Math.cos(θ));
      } while (Math.abs(δ) > ε && --i > 0);
      return θ / 2;
    };
  }
  function mollweideBromley(Cx, Cy, Cp) {
    var θ = mollweideBromleyθ(Cp);
    function forward(λ, φ) {
      return [Cx * λ * Math.cos(φ = θ(φ)), Cy * Math.sin(φ)];
    }
    forward.invert = function (x, y) {
      var θ = asin(y / Cy);
      return [x / (Cx * Math.cos(θ)), asin((2 * θ + Math.sin(2 * θ)) / Cp)];
    };
    return forward;
  }
  var mollweideθ = mollweideBromleyθ(π),
      mollweide = mollweideBromley(Math.SQRT2 / halfπ, Math.SQRT2, π);
  (d3.geoMollweide = function () {
    return projection(mollweide);
  }).raw = mollweide;
  function boggs(λ, φ) {
    var k = 2.00276,
        θ = mollweideθ(φ);
    return [k * λ / (1 / Math.cos(φ) + 1.11072 / Math.cos(θ)), (φ + Math.SQRT2 * Math.sin(θ)) / k];
  }
  boggs.invert = function (x, y) {
    var k = 2.00276,
        ky = k * y,
        θ = y < 0 ? -π / 4 : π / 4,
        i = 25,
        δ,
        φ;
    do {
      φ = ky - Math.SQRT2 * Math.sin(θ);
      θ -= δ = (Math.sin(2 * θ) + 2 * θ - π * Math.sin(φ)) / (2 * Math.cos(2 * θ) + 2 + π * Math.cos(φ) * Math.SQRT2 * Math.cos(θ));
    } while (Math.abs(δ) > ε && --i > 0);
    φ = ky - Math.SQRT2 * Math.sin(θ);
    return [x * (1 / Math.cos(φ) + 1.11072 / Math.cos(θ)) / k, φ];
  };
  (d3.geoBoggs = function () {
    return projection(boggs);
  }).raw = boggs;
  function parallel1Projection(projectAt) {
    var φ0 = 0,
        m = projectionMutator(projectAt),
        p = m(φ0);
    p.parallel = function (_) {
      if (!arguments.length) return φ0 / π * 180;
      return m(φ0 = _ * π / 180);
    };
    return p;
  }
  function sinusoidal(λ, φ) {
    return [λ * Math.cos(φ), φ];
  }
  sinusoidal.invert = function (x, y) {
    return [x / Math.cos(y), y];
  };
  (d3.geoSinusoidal = function () {
    return projection(sinusoidal);
  }).raw = sinusoidal;
  function bonne(φ0) {
    if (!φ0) return sinusoidal;
    var cotφ0 = 1 / Math.tan(φ0);
    function forward(λ, φ) {
      var ρ = cotφ0 + φ0 - φ,
          E = ρ ? λ * Math.cos(φ) / ρ : ρ;
      return [ρ * Math.sin(E), cotφ0 - ρ * Math.cos(E)];
    }
    forward.invert = function (x, y) {
      var ρ = Math.sqrt(x * x + (y = cotφ0 - y) * y),
          φ = cotφ0 + φ0 - ρ;
      return [ρ / Math.cos(φ) * Math.atan2(x, y), φ];
    };
    return forward;
  }
  (d3.geoBonne = function () {
    return parallel1Projection(bonne).parallel(45);
  }).raw = bonne;
  var bromley = mollweideBromley(1, 4 / π, π);
  (d3.geoBromley = function () {
    return projection(bromley);
  }).raw = bromley;
  function chamberlin(points) {
    points = points.map(function (p) {
      return [p[0], p[1], Math.sin(p[1]), Math.cos(p[1])];
    });
    for (var a = points[2], b, i = 0; i < 3; ++i, a = b) {
      b = points[i];
      a.v = chamberlinDistanceAzimuth(b[1] - a[1], a[3], a[2], b[3], b[2], b[0] - a[0]);
      a.point = [0, 0];
    }
    var β0 = chamberlinAngle(points[0].v[0], points[2].v[0], points[1].v[0]),
        β1 = chamberlinAngle(points[0].v[0], points[1].v[0], points[2].v[0]),
        β2 = π - β0;
    points[2].point[1] = 0;
    points[0].point[0] = -(points[1].point[0] = .5 * points[0].v[0]);
    var mean = [points[2].point[0] = points[0].point[0] + points[2].v[0] * Math.cos(β0), 2 * (points[0].point[1] = points[1].point[1] = points[2].v[0] * Math.sin(β0))];
    function forward(λ, φ) {
      var sinφ = Math.sin(φ),
          cosφ = Math.cos(φ),
          v = new Array(3);
      for (var i = 0; i < 3; ++i) {
        var p = points[i];
        v[i] = chamberlinDistanceAzimuth(φ - p[1], p[3], p[2], cosφ, sinφ, λ - p[0]);
        if (!v[i][0]) return p.point;
        v[i][1] = chamberlinLongitude(v[i][1] - p.v[1]);
      }
      var point = mean.slice();
      for (var i = 0; i < 3; ++i) {
        var j = i == 2 ? 0 : i + 1;
        var a = chamberlinAngle(points[i].v[0], v[i][0], v[j][0]);
        if (v[i][1] < 0) a = -a;
        if (!i) {
          point[0] += v[i][0] * Math.cos(a);
          point[1] -= v[i][0] * Math.sin(a);
        } else if (i == 1) {
          a = β1 - a;
          point[0] -= v[i][0] * Math.cos(a);
          point[1] -= v[i][0] * Math.sin(a);
        } else {
          a = β2 - a;
          point[0] += v[i][0] * Math.cos(a);
          point[1] += v[i][0] * Math.sin(a);
        }
      }
      point[0] /= 3, point[1] /= 3;
      return point;
    }
    return forward;
  }
  function chamberlinProjection() {
    var points = [[0, 0], [0, 0], [0, 0]],
        m = projectionMutator(chamberlin),
        p = m(points),
        rotate = p.rotate;
    delete p.rotate;
    p.points = function (_) {
      if (!arguments.length) return points;
      points = _;
      var origin = d3.geoCentroid({
        type: "MultiPoint",
        coordinates: points
      }),
          r = [-origin[0], -origin[1]];
      rotate.call(p, r);
      return m(points.map(d3.geoRotation(r)).map(chamberlinRadians));
    };
    return p.points([[-150, 55], [-35, 55], [-92.5, 10]]);
  }
  function chamberlinDistanceAzimuth(dφ, c1, s1, c2, s2, dλ) {
    var cosdλ = Math.cos(dλ),
        r;
    if (Math.abs(dφ) > 1 || Math.abs(dλ) > 1) {
      r = acos(s1 * s2 + c1 * c2 * cosdλ);
    } else {
      var sindφ = Math.sin(.5 * dφ),
          sindλ = Math.sin(.5 * dλ);
      r = 2 * asin(Math.sqrt(sindφ * sindφ + c1 * c2 * sindλ * sindλ));
    }
    if (Math.abs(r) > ε) {
      return [r, Math.atan2(c2 * Math.sin(dλ), c1 * s2 - s1 * c2 * cosdλ)];
    }
    return [0, 0];
  }
  function chamberlinAngle(b, c, a) {
    return acos(.5 * (b * b + c * c - a * a) / (b * c));
  }
  function chamberlinLongitude(λ) {
    return λ - 2 * π * Math.floor((λ + π) / (2 * π));
  }
  function chamberlinRadians(point) {
    return [point[0] * radians, point[1] * radians];
  }
  (d3.geoChamberlin = chamberlinProjection).raw = chamberlin;
  function collignon(λ, φ) {
    var α = asqrt(1 - Math.sin(φ));
    return [2 / sqrtπ * λ * α, sqrtπ * (1 - α)];
  }
  collignon.invert = function (x, y) {
    var λ = (λ = y / sqrtπ - 1) * λ;
    return [λ > 0 ? x * Math.sqrt(π / λ) / 2 : 0, asin(1 - λ)];
  };
  (d3.geoCollignon = function () {
    return projection(collignon);
  }).raw = collignon;
  function craig(φ0) {
    var tanφ0 = Math.tan(φ0);
    function forward(λ, φ) {
      return [λ, (λ ? λ / Math.sin(λ) : 1) * (Math.sin(φ) * Math.cos(λ) - tanφ0 * Math.cos(φ))];
    }
    forward.invert = tanφ0 ? function (x, y) {
      if (x) y *= Math.sin(x) / x;
      var cosλ = Math.cos(x);
      return [x, 2 * Math.atan2(Math.sqrt(cosλ * cosλ + tanφ0 * tanφ0 - y * y) - cosλ, tanφ0 - y)];
    } : function (x, y) {
      return [x, asin(x ? y * Math.tan(x) / x : y)];
    };
    return forward;
  }
  (d3.geoCraig = function () {
    return parallel1Projection(craig);
  }).raw = craig;
  function craster(λ, φ) {
    var sqrt3 = Math.sqrt(3);
    return [sqrt3 * λ * (2 * Math.cos(2 * φ / 3) - 1) / sqrtπ, sqrt3 * sqrtπ * Math.sin(φ / 3)];
  }
  craster.invert = function (x, y) {
    var sqrt3 = Math.sqrt(3),
        φ = 3 * asin(y / (sqrt3 * sqrtπ));
    return [sqrtπ * x / (sqrt3 * (2 * Math.cos(2 * φ / 3) - 1)), φ];
  };
  (d3.geoCraster = function () {
    return projection(craster);
  }).raw = craster;
  function cylindricalEqualArea(φ0) {
    var cosφ0 = Math.cos(φ0);
    function forward(λ, φ) {
      return [λ * cosφ0, Math.sin(φ) / cosφ0];
    }
    forward.invert = function (x, y) {
      return [x / cosφ0, asin(y * cosφ0)];
    };
    return forward;
  }
  (d3.geoCylindricalEqualArea = function () {
    return parallel1Projection(cylindricalEqualArea);
  }).raw = cylindricalEqualArea;
  function cylindricalStereographic(φ0) {
    var cosφ0 = Math.cos(φ0);
    function forward(λ, φ) {
      return [λ * cosφ0, (1 + cosφ0) * Math.tan(φ * .5)];
    }
    forward.invert = function (x, y) {
      return [x / cosφ0, Math.atan(y / (1 + cosφ0)) * 2];
    };
    return forward;
  }
  (d3.geoCylindricalStereographic = function () {
    return parallel1Projection(cylindricalStereographic);
  }).raw = cylindricalStereographic;
  function eckert1(λ, φ) {
    var α = Math.sqrt(8 / (3 * π));
    return [α * λ * (1 - Math.abs(φ) / π), α * φ];
  }
  eckert1.invert = function (x, y) {
    var α = Math.sqrt(8 / (3 * π)),
        φ = y / α;
    return [x / (α * (1 - Math.abs(φ) / π)), φ];
  };
  (d3.geoEckert1 = function () {
    return projection(eckert1);
  }).raw = eckert1;
  function eckert2(λ, φ) {
    var α = Math.sqrt(4 - 3 * Math.sin(Math.abs(φ)));
    return [2 / Math.sqrt(6 * π) * λ * α, sgn(φ) * Math.sqrt(2 * π / 3) * (2 - α)];
  }
  eckert2.invert = function (x, y) {
    var α = 2 - Math.abs(y) / Math.sqrt(2 * π / 3);
    return [x * Math.sqrt(6 * π) / (2 * α), sgn(y) * asin((4 - α * α) / 3)];
  };
  (d3.geoEckert2 = function () {
    return projection(eckert2);
  }).raw = eckert2;
  function eckert3(λ, φ) {
    var k = Math.sqrt(π * (4 + π));
    return [2 / k * λ * (1 + Math.sqrt(1 - 4 * φ * φ / (π * π))), 4 / k * φ];
  }
  eckert3.invert = function (x, y) {
    var k = Math.sqrt(π * (4 + π)) / 2;
    return [x * k / (1 + asqrt(1 - y * y * (4 + π) / (4 * π))), y * k / 2];
  };
  (d3.geoEckert3 = function () {
    return projection(eckert3);
  }).raw = eckert3;
  function eckert4(λ, φ) {
    var k = (2 + halfπ) * Math.sin(φ);
    φ /= 2;
    for (var i = 0, δ = Infinity; i < 10 && Math.abs(δ) > ε; i++) {
      var cosφ = Math.cos(φ);
      φ -= δ = (φ + Math.sin(φ) * (cosφ + 2) - k) / (2 * cosφ * (1 + cosφ));
    }
    return [2 / Math.sqrt(π * (4 + π)) * λ * (1 + Math.cos(φ)), 2 * Math.sqrt(π / (4 + π)) * Math.sin(φ)];
  }
  eckert4.invert = function (x, y) {
    var A = .5 * y * Math.sqrt((4 + π) / π),
        k = asin(A),
        c = Math.cos(k);
    return [x / (2 / Math.sqrt(π * (4 + π)) * (1 + c)), asin((k + A * (c + 2)) / (2 + halfπ))];
  };
  (d3.geoEckert4 = function () {
    return projection(eckert4);
  }).raw = eckert4;
  function eckert5(λ, φ) {
    return [λ * (1 + Math.cos(φ)) / Math.sqrt(2 + π), 2 * φ / Math.sqrt(2 + π)];
  }
  eckert5.invert = function (x, y) {
    var k = Math.sqrt(2 + π),
        φ = y * k / 2;
    return [k * x / (1 + Math.cos(φ)), φ];
  };
  (d3.geoEckert5 = function () {
    return projection(eckert5);
  }).raw = eckert5;
  function eckert6(λ, φ) {
    var k = (1 + halfπ) * Math.sin(φ);
    for (var i = 0, δ = Infinity; i < 10 && Math.abs(δ) > ε; i++) {
      φ -= δ = (φ + Math.sin(φ) - k) / (1 + Math.cos(φ));
    }
    k = Math.sqrt(2 + π);
    return [λ * (1 + Math.cos(φ)) / k, 2 * φ / k];
  }
  eckert6.invert = function (x, y) {
    var j = 1 + halfπ,
        k = Math.sqrt(j / 2);
    return [x * 2 * k / (1 + Math.cos(y *= k)), asin((y + Math.sin(y)) / j)];
  };
  (d3.geoEckert6 = function () {
    return projection(eckert6);
  }).raw = eckert6;
  function eisenlohr(λ, φ) {
    var s0 = Math.sin(λ /= 2),
        c0 = Math.cos(λ),
        k = Math.sqrt(Math.cos(φ)),
        c1 = Math.cos(φ /= 2),
        t = Math.sin(φ) / (c1 + Math.SQRT2 * c0 * k),
        c = Math.sqrt(2 / (1 + t * t)),
        v = Math.sqrt((Math.SQRT2 * c1 + (c0 + s0) * k) / (Math.SQRT2 * c1 + (c0 - s0) * k));
    return [eisenlohrK * (c * (v - 1 / v) - 2 * Math.log(v)), eisenlohrK * (c * t * (v + 1 / v) - 2 * Math.atan(t))];
  }
  eisenlohr.invert = function (x, y) {
    var p = d3.geoAugust.raw.invert(x / 1.2, y * 1.065);
    if (!p) return null;
    var λ = p[0],
        φ = p[1],
        i = 20;
    x /= eisenlohrK, y /= eisenlohrK;
    do {
      var _0 = λ / 2,
          _1 = φ / 2,
          s0 = Math.sin(_0),
          c0 = Math.cos(_0),
          s1 = Math.sin(_1),
          c1 = Math.cos(_1),
          cos1 = Math.cos(φ),
          k = Math.sqrt(cos1),
          t = s1 / (c1 + Math.SQRT2 * c0 * k),
          t2 = t * t,
          c = Math.sqrt(2 / (1 + t2)),
          v0 = Math.SQRT2 * c1 + (c0 + s0) * k,
          v1 = Math.SQRT2 * c1 + (c0 - s0) * k,
          v2 = v0 / v1,
          v = Math.sqrt(v2),
          vm1v = v - 1 / v,
          vp1v = v + 1 / v,
          fx = c * vm1v - 2 * Math.log(v) - x,
          fy = c * t * vp1v - 2 * Math.atan(t) - y,
          δtδλ = s1 && Math.SQRT1_2 * k * s0 * t2 / s1,
          δtδφ = (Math.SQRT2 * c0 * c1 + k) / (2 * (c1 + Math.SQRT2 * c0 * k) * (c1 + Math.SQRT2 * c0 * k) * k),
          δcδt = -.5 * t * c * c * c,
          δcδλ = δcδt * δtδλ,
          δcδφ = δcδt * δtδφ,
          A = (A = 2 * c1 + Math.SQRT2 * k * (c0 - s0)) * A * v,
          δvδλ = (Math.SQRT2 * c0 * c1 * k + cos1) / A,
          δvδφ = -(Math.SQRT2 * s0 * s1) / (k * A),
          δxδλ = vm1v * δcδλ - 2 * δvδλ / v + c * (δvδλ + δvδλ / v2),
          δxδφ = vm1v * δcδφ - 2 * δvδφ / v + c * (δvδφ + δvδφ / v2),
          δyδλ = t * vp1v * δcδλ - 2 * δtδλ / (1 + t2) + c * vp1v * δtδλ + c * t * (δvδλ - δvδλ / v2),
          δyδφ = t * vp1v * δcδφ - 2 * δtδφ / (1 + t2) + c * vp1v * δtδφ + c * t * (δvδφ - δvδφ / v2),
          denominator = δxδφ * δyδλ - δyδφ * δxδλ;
      if (!denominator) break;
      var δλ = (fy * δxδφ - fx * δyδφ) / denominator,
          δφ = (fx * δyδλ - fy * δxδλ) / denominator;
      λ -= δλ;
      φ = Math.max(-halfπ, Math.min(halfπ, φ - δφ));
    } while ((Math.abs(δλ) > ε || Math.abs(δφ) > ε) && --i > 0);
    return Math.abs(Math.abs(φ) - halfπ) < ε ? [0, φ] : i && [λ, φ];
  };
  var eisenlohrK = 3 + 2 * Math.SQRT2;
  (d3.geoEisenlohr = function () {
    return projection(eisenlohr);
  }).raw = eisenlohr;
  function fahey(λ, φ) {
    var t = Math.tan(φ / 2);
    return [λ * faheyK * asqrt(1 - t * t), (1 + faheyK) * t];
  }
  fahey.invert = function (x, y) {
    var t = y / (1 + faheyK);
    return [x ? x / (faheyK * asqrt(1 - t * t)) : 0, 2 * Math.atan(t)];
  };
  var faheyK = Math.cos(35 * radians);
  (d3.geoFahey = function () {
    return projection(fahey);
  }).raw = fahey;
  function foucaut(λ, φ) {
    var k = φ / 2,
        cosk = Math.cos(k);
    return [2 * λ / sqrtπ * Math.cos(φ) * cosk * cosk, sqrtπ * Math.tan(k)];
  }
  foucaut.invert = function (x, y) {
    var k = Math.atan(y / sqrtπ),
        cosk = Math.cos(k),
        φ = 2 * k;
    return [x * sqrtπ * .5 / (Math.cos(φ) * cosk * cosk), φ];
  };
  (d3.geoFoucaut = function () {
    return projection(foucaut);
  }).raw = foucaut;
  d3.geoGilbert = function (projection) {
    var e = d3.geoEquirectangular().scale(degrees).translate([0, 0]);
    function gilbert(coordinates) {
      return projection([coordinates[0] * .5, asin(Math.tan(coordinates[1] * .5 * radians)) * degrees]);
    }
    if (projection.invert) gilbert.invert = function (coordinates) {
      coordinates = projection.invert(coordinates);
      coordinates[0] *= 2;
      coordinates[1] = 2 * Math.atan(Math.sin(coordinates[1] * radians)) * degrees;
      return coordinates;
    };
    gilbert.stream = function (stream) {
      stream = projection.stream(stream);
      var s = e.stream({
        point: function point(λ, φ) {
          stream.point(λ * .5, asin(Math.tan(-φ * .5 * radians)) * degrees);
        },
        lineStart: function lineStart() {
          stream.lineStart();
        },
        lineEnd: function lineEnd() {
          stream.lineEnd();
        },
        polygonStart: function polygonStart() {
          stream.polygonStart();
        },
        polygonEnd: function polygonEnd() {
          stream.polygonEnd();
        }
      });
      s.sphere = function () {
        stream.sphere();
      };
      s.valid = false;
      return s;
    };
    return gilbert;
  };
  var gingeryAzimuthalEquidistant = d3.geoAzimuthalEquidistant.raw;
  function gingery(ρ, n) {
    var k = 2 * π / n,
        ρ2 = ρ * ρ;
    function forward(λ, φ) {
      var p = gingeryAzimuthalEquidistant(λ, φ),
          x = p[0],
          y = p[1],
          r2 = x * x + y * y;
      if (r2 > ρ2) {
        var r = Math.sqrt(r2),
            θ = Math.atan2(y, x),
            θ0 = k * Math.round(θ / k),
            α = θ - θ0,
            ρcosα = ρ * Math.cos(α),
            k_ = (ρ * Math.sin(α) - α * Math.sin(ρcosα)) / (halfπ - ρcosα),
            s_ = arcLength_(α, k_),
            e = (π - ρ) / gingeryIntegrate(s_, ρcosα, π);
        x = r;
        var i = 50,
            δ;
        do {
          x -= δ = (ρ + gingeryIntegrate(s_, ρcosα, x) * e - r) / (s_(x) * e);
        } while (Math.abs(δ) > ε && --i > 0);
        y = α * Math.sin(x);
        if (x < halfπ) y -= k_ * (x - halfπ);
        var s = Math.sin(θ0),
            c = Math.cos(θ0);
        p[0] = x * c - y * s;
        p[1] = x * s + y * c;
      }
      return p;
    }
    forward.invert = function (x, y) {
      var r2 = x * x + y * y;
      if (r2 > ρ2) {
        var r = Math.sqrt(r2),
            θ = Math.atan2(y, x),
            θ0 = k * Math.round(θ / k),
            dθ = θ - θ0,
            x = r * Math.cos(dθ);
        y = r * Math.sin(dθ);
        var x_halfπ = x - halfπ,
            sinx = Math.sin(x),
            α = y / sinx,
            δ = x < halfπ ? Infinity : 0,
            i = 10;
        while (true) {
          var ρsinα = ρ * Math.sin(α),
              ρcosα = ρ * Math.cos(α),
              sinρcosα = Math.sin(ρcosα),
              halfπ_ρcosα = halfπ - ρcosα,
              k_ = (ρsinα - α * sinρcosα) / halfπ_ρcosα,
              s_ = arcLength_(α, k_);
          if (Math.abs(δ) < ε2 || ! --i) break;
          α -= δ = (α * sinx - k_ * x_halfπ - y) / (sinx - x_halfπ * 2 * (halfπ_ρcosα * (ρcosα + α * ρsinα * Math.cos(ρcosα) - sinρcosα) - ρsinα * (ρsinα - α * sinρcosα)) / (halfπ_ρcosα * halfπ_ρcosα));
        }
        r = ρ + gingeryIntegrate(s_, ρcosα, x) * (π - ρ) / gingeryIntegrate(s_, ρcosα, π);
        θ = θ0 + α;
        x = r * Math.cos(θ);
        y = r * Math.sin(θ);
      }
      return gingeryAzimuthalEquidistant.invert(x, y);
    };
    return forward;
  }
  function arcLength_(α, k) {
    return function (x) {
      var y_ = α * Math.cos(x);
      if (x < halfπ) y_ -= k;
      return Math.sqrt(1 + y_ * y_);
    };
  }
  function gingeryProjection() {
    var n = 6,
        ρ = 30 * radians,
        cρ = Math.cos(ρ),
        sρ = Math.sin(ρ),
        m = projectionMutator(gingery),
        p = m(ρ, n),
        stream_ = p.stream,
        ε = .01,
        cr = -Math.cos(ε * radians),
        sr = Math.sin(ε * radians);
    p.radius = function (_) {
      if (!arguments.length) return ρ * degrees;
      cρ = Math.cos(ρ = _ * radians);
      sρ = Math.sin(ρ);
      return m(ρ, n);
    };
    p.lobes = function (_) {
      if (!arguments.length) return n;
      return m(ρ, n = +_);
    };
    p.stream = function (stream) {
      var rotate = p.rotate(),
          rotateStream = stream_(stream),
          sphereStream = (p.rotate([0, 0]), stream_(stream));
      p.rotate(rotate);
      rotateStream.sphere = function () {
        sphereStream.polygonStart(), sphereStream.lineStart();
        for (var i = 0, δ = 2 * π / n, φ = 0; i < n; ++i, φ -= δ) {
          sphereStream.point(Math.atan2(sr * Math.cos(φ), cr) * degrees, Math.asin(sr * Math.sin(φ)) * degrees);
          sphereStream.point(Math.atan2(sρ * Math.cos(φ - δ / 2), cρ) * degrees, Math.asin(sρ * Math.sin(φ - δ / 2)) * degrees);
        }
        sphereStream.lineEnd(), sphereStream.polygonEnd();
      };
      return rotateStream;
    };
    return p;
  }
  function gingeryIntegrate(f, a, b) {
    var n = 50,
        h = (b - a) / n,
        s = f(a) + f(b);
    for (var i = 1, x = a; i < n; ++i) {
      s += 2 * f(x += h);
    }return s * .5 * h;
  }
  (d3.geoGingery = gingeryProjection).raw = gingery;
  function ginzburgPolyconic(a, b, c, d, e, f, g, h) {
    if (arguments.length < 8) h = 0;
    function forward(λ, φ) {
      if (!φ) return [a * λ / π, 0];
      var φ2 = φ * φ,
          xB = a + φ2 * (b + φ2 * (c + φ2 * d)),
          yB = φ * (e - 1 + φ2 * (f - h + φ2 * g)),
          m = (xB * xB + yB * yB) / (2 * yB),
          α = λ * Math.asin(xB / m) / π;
      return [m * Math.sin(α), φ * (1 + φ2 * h) + m * (1 - Math.cos(α))];
    }
    forward.invert = function (x, y) {
      var λ = π * x / a,
          φ = y,
          δλ,
          δφ,
          i = 50;
      do {
        var φ2 = φ * φ,
            xB = a + φ2 * (b + φ2 * (c + φ2 * d)),
            yB = φ * (e - 1 + φ2 * (f - h + φ2 * g)),
            p = xB * xB + yB * yB,
            q = 2 * yB,
            m = p / q,
            m2 = m * m,
            dαdλ = Math.asin(xB / m) / π,
            α = λ * dαdλ;
        xB2 = xB * xB, dxBdφ = (2 * b + φ2 * (4 * c + φ2 * 6 * d)) * φ, dyBdφ = e + φ2 * (3 * f + φ2 * 5 * g), dpdφ = 2 * (xB * dxBdφ + yB * (dyBdφ - 1)), dqdφ = 2 * (dyBdφ - 1), dmdφ = (dpdφ * q - p * dqdφ) / (q * q), cosα = Math.cos(α), sinα = Math.sin(α), mcosα = m * cosα, msinα = m * sinα, dαdφ = λ / π * (1 / asqrt(1 - xB2 / m2)) * (dxBdφ * m - xB * dmdφ) / m2, fx = msinα - x, fy = φ * (1 + φ2 * h) + m - mcosα - y, δxδφ = dmdφ * sinα + mcosα * dαdφ, δxδλ = mcosα * dαdλ, δyδφ = 1 + dmdφ - (dmdφ * cosα - msinα * dαdφ), δyδλ = msinα * dαdλ, denominator = δxδφ * δyδλ - δyδφ * δxδλ;
        if (!denominator) break;
        λ -= δλ = (fy * δxδφ - fx * δyδφ) / denominator;
        φ -= δφ = (fx * δyδλ - fy * δxδλ) / denominator;
      } while ((Math.abs(δλ) > ε || Math.abs(δφ) > ε) && --i > 0);
      return [λ, φ];
    };
    return forward;
  }
  var ginzburg4 = ginzburgPolyconic(2.8284, -1.6988, .75432, -.18071, 1.76003, -.38914, .042555);
  (d3.geoGinzburg4 = function () {
    return projection(ginzburg4);
  }).raw = ginzburg4;
  var ginzburg5 = ginzburgPolyconic(2.583819, -.835827, .170354, -.038094, 1.543313, -.411435, .082742);
  (d3.geoGinzburg5 = function () {
    return projection(ginzburg5);
  }).raw = ginzburg5;
  var ginzburg6 = ginzburgPolyconic(5 / 6 * π, -.62636, -.0344, 0, 1.3493, -.05524, 0, .045);
  (d3.geoGinzburg6 = function () {
    return projection(ginzburg6);
  }).raw = ginzburg6;
  function ginzburg8(λ, φ) {
    var λ2 = λ * λ,
        φ2 = φ * φ;
    return [λ * (1 - .162388 * φ2) * (.87 - 952426e-9 * λ2 * λ2), φ * (1 + φ2 / 12)];
  }
  ginzburg8.invert = function (x, y) {
    var λ = x,
        φ = y,
        i = 50,
        δ;
    do {
      var φ2 = φ * φ;
      φ -= δ = (φ * (1 + φ2 / 12) - y) / (1 + φ2 / 4);
    } while (Math.abs(δ) > ε && --i > 0);
    i = 50;
    x /= 1 - .162388 * φ2;
    do {
      var λ4 = (λ4 = λ * λ) * λ4;
      λ -= δ = (λ * (.87 - 952426e-9 * λ4) - x) / (.87 - .00476213 * λ4);
    } while (Math.abs(δ) > ε && --i > 0);
    return [λ, φ];
  };
  (d3.geoGinzburg8 = function () {
    return projection(ginzburg8);
  }).raw = ginzburg8;
  var ginzburg9 = ginzburgPolyconic(2.6516, -.76534, .19123, -.047094, 1.36289, -.13965, .031762);
  (d3.geoGinzburg9 = function () {
    return projection(ginzburg9);
  }).raw = ginzburg9;
  function quincuncialProjection(projectHemisphere) {
    var dx = projectHemisphere(halfπ, 0)[0] - projectHemisphere(-halfπ, 0)[0];
    function projection() {
      var quincuncial = false,
          m = projectionMutator(projectAt),
          p = m(quincuncial);
      p.quincuncial = function (_) {
        if (!arguments.length) return quincuncial;
        return m(quincuncial = !!_);
      };
      return p;
    }
    function projectAt(quincuncial) {
      var forward = quincuncial ? function (λ, φ) {
        var t = Math.abs(λ) < halfπ,
            p = projectHemisphere(t ? λ : λ > 0 ? λ - π : λ + π, φ);
        var x = (p[0] - p[1]) * Math.SQRT1_2,
            y = (p[0] + p[1]) * Math.SQRT1_2;
        if (t) return [x, y];
        var d = dx * Math.SQRT1_2,
            s = x > 0 ^ y > 0 ? -1 : 1;
        return [s * x - sgn(y) * d, s * y - sgn(x) * d];
      } : function (λ, φ) {
        var s = λ > 0 ? -.5 : .5,
            point = projectHemisphere(λ + s * π, φ);
        point[0] -= s * dx;
        return point;
      };
      if (projectHemisphere.invert) forward.invert = quincuncial ? function (x0, y0) {
        var x = (x0 + y0) * Math.SQRT1_2,
            y = (y0 - x0) * Math.SQRT1_2,
            t = Math.abs(x) < .5 * dx && Math.abs(y) < .5 * dx;
        if (!t) {
          var d = dx * Math.SQRT1_2,
              s = x > 0 ^ y > 0 ? -1 : 1,
              x1 = -s * (x0 + (y > 0 ? 1 : -1) * d),
              y1 = -s * (y0 + (x > 0 ? 1 : -1) * d);
          x = (-x1 - y1) * Math.SQRT1_2;
          y = (x1 - y1) * Math.SQRT1_2;
        }
        var p = projectHemisphere.invert(x, y);
        if (!t) p[0] += x > 0 ? π : -π;
        return p;
      } : function (x, y) {
        var s = x > 0 ? -.5 : .5,
            location = projectHemisphere.invert(x + s * dx, y),
            λ = location[0] - s * π;
        if (λ < -π) λ += 2 * π;else if (λ > π) λ -= 2 * π;
        location[0] = λ;
        return location;
      };
      return forward;
    }
    projection.raw = projectAt;
    return projection;
  }
  function gringorten(λ, φ) {
    var sλ = sgn(λ),
        sφ = sgn(φ),
        cosφ = Math.cos(φ),
        x = Math.cos(λ) * cosφ,
        y = Math.sin(λ) * cosφ,
        z = Math.sin(sφ * φ);
    λ = Math.abs(Math.atan2(y, z));
    φ = asin(x);
    if (Math.abs(λ - halfπ) > ε) λ %= halfπ;
    var point = gringortenHexadecant(λ > π / 4 ? halfπ - λ : λ, φ);
    if (λ > π / 4) z = point[0], point[0] = -point[1], point[1] = -z;
    return point[0] *= sλ, point[1] *= -sφ, point;
  }
  gringorten.invert = function (x, y) {
    var sx = sgn(x),
        sy = sgn(y),
        x0 = -sx * x,
        y0 = -sy * y,
        t = y0 / x0 < 1,
        p = gringortenHexadecantInvert(t ? y0 : x0, t ? x0 : y0),
        λ = p[0],
        φ = p[1];
    if (t) λ = -halfπ - λ;
    var cosφ = Math.cos(φ),
        x = Math.cos(λ) * cosφ,
        y = Math.sin(λ) * cosφ,
        z = Math.sin(φ);
    return [sx * (Math.atan2(y, -z) + π), sy * asin(x)];
  };
  function gringortenHexadecant(λ, φ) {
    if (φ === halfπ) return [0, 0];
    var sinφ = Math.sin(φ),
        r = sinφ * sinφ,
        r2 = r * r,
        j = 1 + r2,
        k = 1 + 3 * r2,
        q = 1 - r2,
        z = asin(1 / Math.sqrt(j)),
        v = q + r * j * z,
        p2 = (1 - sinφ) / v,
        p = Math.sqrt(p2),
        a2 = p2 * j,
        a = Math.sqrt(a2),
        h = p * q;
    if (λ === 0) return [0, -(h + r * a)];
    var cosφ = Math.cos(φ),
        secφ = 1 / cosφ,
        drdφ = 2 * sinφ * cosφ,
        dvdφ = (-3 * r + z * k) * drdφ,
        dp2dφ = (-v * cosφ - (1 - sinφ) * dvdφ) / (v * v),
        dpdφ = .5 * dp2dφ / p,
        dhdφ = q * dpdφ - 2 * r * p * drdφ,
        dra2dφ = r * j * dp2dφ + p2 * k * drdφ,
        μ = -secφ * drdφ,
        ν = -secφ * dra2dφ,
        ζ = -2 * secφ * dhdφ,
        Λ = 4 * λ / π;
    if (λ > .222 * π || φ < π / 4 && λ > .175 * π) {
      var x = (h + r * asqrt(a2 * (1 + r2) - h * h)) / (1 + r2);
      if (λ > π / 4) return [x, x];
      var x1 = x,
          x0 = .5 * x,
          i = 50;
      x = .5 * (x0 + x1);
      do {
        var g = Math.sqrt(a2 - x * x),
            f = x * (ζ + μ * g) + ν * asin(x / a) - Λ;
        if (!f) break;
        if (f < 0) x0 = x;else x1 = x;
        x = .5 * (x0 + x1);
      } while (Math.abs(x1 - x0) > ε && --i > 0);
    } else {
      var x = ε,
          i = 25,
          δ;
      do {
        var x2 = x * x,
            g = asqrt(a2 - x2),
            ζμg = ζ + μ * g,
            f = x * ζμg + ν * asin(x / a) - Λ,
            df = ζμg + (ν - μ * x2) / g;
        x -= δ = g ? f / df : 0;
      } while (Math.abs(δ) > ε && --i > 0);
    }
    return [x, -h - r * asqrt(a2 - x * x)];
  }
  function gringortenHexadecantInvert(x, y) {
    var x0 = 0,
        x1 = 1,
        r = .5,
        i = 50;
    while (true) {
      var r2 = r * r,
          sinφ = Math.sqrt(r),
          z = Math.asin(1 / Math.sqrt(1 + r2)),
          v = 1 - r2 + r * (1 + r2) * z,
          p2 = (1 - sinφ) / v,
          p = Math.sqrt(p2),
          a2 = p2 * (1 + r2),
          h = p * (1 - r2),
          g2 = a2 - x * x,
          g = Math.sqrt(g2),
          y0 = y + h + r * g;
      if (Math.abs(x1 - x0) < ε2 || --i === 0 || y0 === 0) break;
      if (y0 > 0) x0 = r;else x1 = r;
      r = .5 * (x0 + x1);
    }
    if (!i) return null;
    var φ = Math.asin(sinφ),
        cosφ = Math.cos(φ),
        secφ = 1 / cosφ,
        drdφ = 2 * sinφ * cosφ,
        dvdφ = (-3 * r + z * (1 + 3 * r2)) * drdφ,
        dp2dφ = (-v * cosφ - (1 - sinφ) * dvdφ) / (v * v),
        dpdφ = .5 * dp2dφ / p,
        dhdφ = (1 - r2) * dpdφ - 2 * r * p * drdφ,
        ζ = -2 * secφ * dhdφ,
        μ = -secφ * drdφ,
        ν = -secφ * (r * (1 + r2) * dp2dφ + p2 * (1 + 3 * r2) * drdφ);
    return [π / 4 * (x * (ζ + μ * g) + ν * Math.asin(x / Math.sqrt(a2))), φ];
  }
  d3.geoGringorten = quincuncialProjection(gringorten);
  function ellipticJi(u, v, m) {
    if (!u) {
      var b = ellipticJ(v, 1 - m);
      return [[0, b[0] / b[1]], [1 / b[1], 0], [b[2] / b[1], 0]];
    }
    var a = ellipticJ(u, m);
    if (!v) return [[a[0], 0], [a[1], 0], [a[2], 0]];
    var b = ellipticJ(v, 1 - m),
        denominator = b[1] * b[1] + m * a[0] * a[0] * b[0] * b[0];
    return [[a[0] * b[2] / denominator, a[1] * a[2] * b[0] * b[1] / denominator], [a[1] * b[1] / denominator, -a[0] * a[2] * b[0] * b[2] / denominator], [a[2] * b[1] * b[2] / denominator, -m * a[0] * a[1] * b[0] / denominator]];
  }
  function ellipticJ(u, m) {
    var ai, b, φ, t, twon;
    if (m < ε) {
      t = Math.sin(u);
      b = Math.cos(u);
      ai = .25 * m * (u - t * b);
      return [t - ai * b, b + ai * t, 1 - .5 * m * t * t, u - ai];
    }
    if (m >= 1 - ε) {
      ai = .25 * (1 - m);
      b = cosh(u);
      t = tanh(u);
      φ = 1 / b;
      twon = b * sinh(u);
      return [t + ai * (twon - u) / (b * b), φ - ai * t * φ * (twon - u), φ + ai * t * φ * (twon + u), 2 * Math.atan(Math.exp(u)) - halfπ + ai * (twon - u) / b];
    }
    var a = [1, 0, 0, 0, 0, 0, 0, 0, 0],
        c = [Math.sqrt(m), 0, 0, 0, 0, 0, 0, 0, 0],
        i = 0;
    b = Math.sqrt(1 - m);
    twon = 1;
    while (Math.abs(c[i] / a[i]) > ε && i < 8) {
      ai = a[i++];
      c[i] = .5 * (ai - b);
      a[i] = .5 * (ai + b);
      b = asqrt(ai * b);
      twon *= 2;
    }
    φ = twon * a[i] * u;
    do {
      t = c[i] * Math.sin(b = φ) / a[i];
      φ = .5 * (asin(t) + φ);
    } while (--i);
    return [Math.sin(φ), t = Math.cos(φ), t / Math.cos(φ - b), φ];
  }
  function ellipticFi(φ, ψ, m) {
    var r = Math.abs(φ),
        i = Math.abs(ψ),
        sinhψ = sinh(i);
    if (r) {
      var cscφ = 1 / Math.sin(r),
          cotφ2 = 1 / (Math.tan(r) * Math.tan(r)),
          b = -(cotφ2 + m * sinhψ * sinhψ * cscφ * cscφ - 1 + m),
          c = (m - 1) * cotφ2,
          cotλ2 = .5 * (-b + Math.sqrt(b * b - 4 * c));
      return [ellipticF(Math.atan(1 / Math.sqrt(cotλ2)), m) * sgn(φ), ellipticF(Math.atan(asqrt((cotλ2 / cotφ2 - 1) / m)), 1 - m) * sgn(ψ)];
    }
    return [0, ellipticF(Math.atan(sinhψ), 1 - m) * sgn(ψ)];
  }
  function ellipticF(φ, m) {
    if (!m) return φ;
    if (m === 1) return Math.log(Math.tan(φ / 2 + π / 4));
    var a = 1,
        b = Math.sqrt(1 - m),
        c = Math.sqrt(m);
    for (var i = 0; Math.abs(c) > ε; i++) {
      if (φ % π) {
        var dφ = Math.atan(b * Math.tan(φ) / a);
        if (dφ < 0) dφ += π;
        φ += dφ + ~~(φ / π) * π;
      } else φ += φ;
      c = (a + b) / 2;
      b = Math.sqrt(a * b);
      c = ((a = c) - b) / 2;
    }
    return φ / (Math.pow(2, i) * a);
  }
  function guyou(λ, φ) {
    var k_ = (Math.SQRT2 - 1) / (Math.SQRT2 + 1),
        k = Math.sqrt(1 - k_ * k_),
        K = ellipticF(halfπ, k * k),
        f = -1;
    var ψ = Math.log(Math.tan(π / 4 + Math.abs(φ) / 2)),
        r = Math.exp(f * ψ) / Math.sqrt(k_),
        at = guyouComplexAtan(r * Math.cos(f * λ), r * Math.sin(f * λ)),
        t = ellipticFi(at[0], at[1], k * k);
    return [-t[1], (φ >= 0 ? 1 : -1) * (.5 * K - t[0])];
  }
  function guyouComplexAtan(x, y) {
    var x2 = x * x,
        y_1 = y + 1,
        t = 1 - x2 - y * y;
    return [.5 * ((x >= 0 ? halfπ : -halfπ) - Math.atan2(t, 2 * x)), -.25 * Math.log(t * t + 4 * x2) + .5 * Math.log(y_1 * y_1 + x2)];
  }
  function guyouComplexDivide(a, b) {
    var denominator = b[0] * b[0] + b[1] * b[1];
    return [(a[0] * b[0] + a[1] * b[1]) / denominator, (a[1] * b[0] - a[0] * b[1]) / denominator];
  }
  guyou.invert = function (x, y) {
    var k_ = (Math.SQRT2 - 1) / (Math.SQRT2 + 1),
        k = Math.sqrt(1 - k_ * k_),
        K = ellipticF(halfπ, k * k),
        f = -1;
    var j = ellipticJi(.5 * K - y, -x, k * k),
        tn = guyouComplexDivide(j[0], j[1]),
        λ = Math.atan2(tn[1], tn[0]) / f;
    return [λ, 2 * Math.atan(Math.exp(.5 / f * Math.log(k_ * tn[0] * tn[0] + k_ * tn[1] * tn[1]))) - halfπ];
  };
  d3.geoGuyou = quincuncialProjection(guyou);
  function hammerRetroazimuthal(φ0) {
    var sinφ0 = Math.sin(φ0),
        cosφ0 = Math.cos(φ0),
        rotate = hammerRetroazimuthalRotation(φ0);
    rotate.invert = hammerRetroazimuthalRotation(-φ0);
    function forward(λ, φ) {
      var p = rotate(λ, φ);
      λ = p[0], φ = p[1];
      var sinφ = Math.sin(φ),
          cosφ = Math.cos(φ),
          cosλ = Math.cos(λ),
          z = acos(sinφ0 * sinφ + cosφ0 * cosφ * cosλ),
          sinz = Math.sin(z),
          K = Math.abs(sinz) > ε ? z / sinz : 1;
      return [K * cosφ0 * Math.sin(λ), (Math.abs(λ) > halfπ ? K : -K) * (sinφ0 * cosφ - cosφ0 * sinφ * cosλ)];
    }
    forward.invert = function (x, y) {
      var ρ = Math.sqrt(x * x + y * y),
          sinz = -Math.sin(ρ),
          cosz = Math.cos(ρ),
          a = ρ * cosz,
          b = -y * sinz,
          c = ρ * sinφ0,
          d = asqrt(a * a + b * b - c * c),
          φ = Math.atan2(a * c + b * d, b * c - a * d),
          λ = (ρ > halfπ ? -1 : 1) * Math.atan2(x * sinz, ρ * Math.cos(φ) * cosz + y * Math.sin(φ) * sinz);
      return rotate.invert(λ, φ);
    };
    return forward;
  }
  function hammerRetroazimuthalRotation(φ0) {
    var sinφ0 = Math.sin(φ0),
        cosφ0 = Math.cos(φ0);
    return function (λ, φ) {
      var cosφ = Math.cos(φ),
          x = Math.cos(λ) * cosφ,
          y = Math.sin(λ) * cosφ,
          z = Math.sin(φ);
      return [Math.atan2(y, x * cosφ0 - z * sinφ0), asin(z * cosφ0 + x * sinφ0)];
    };
  }
  function hammerRetroazimuthalProjection() {
    var φ0 = 0,
        m = projectionMutator(hammerRetroazimuthal),
        p = m(φ0),
        rotate_ = p.rotate,
        stream_ = p.stream,
        circle = d3.geoCircle();
    p.parallel = function (_) {
      if (!arguments.length) return φ0 / π * 180;
      var r = p.rotate();
      return m(φ0 = _ * π / 180).rotate(r);
    };
    p.rotate = function (_) {
      if (!arguments.length) return _ = rotate_.call(p), _[1] += φ0 / π * 180, _;
      rotate_.call(p, [_[0], _[1] - φ0 / π * 180]);
      circle.center([-_[0], -_[1]]);
      return p;
    };
    p.stream = function (stream) {
      stream = stream_(stream);
      stream.sphere = function () {
        stream.polygonStart();
        var ε = .01,
            ring = circle.radius(90 - ε)().coordinates[0],
            n = ring.length - 1,
            i = -1,
            p;
        stream.lineStart();
        while (++i < n) {
          stream.point((p = ring[i])[0], p[1]);
        }stream.lineEnd();
        ring = circle.radius(90 + ε)().coordinates[0];
        n = ring.length - 1;
        stream.lineStart();
        while (--i >= 0) {
          stream.point((p = ring[i])[0], p[1]);
        }stream.lineEnd();
        stream.polygonEnd();
      };
      return stream;
    };
    return p;
  }
  (d3.geoHammerRetroazimuthal = hammerRetroazimuthalProjection).raw = hammerRetroazimuthal;
  var hammerAzimuthalEqualArea = d3.geoAzimuthalEqualArea.raw;
  function hammer(A, B) {
    if (arguments.length < 2) B = A;
    if (B === 1) return hammerAzimuthalEqualArea;
    if (B === Infinity) return hammerQuarticAuthalic;
    function forward(λ, φ) {
      var coordinates = hammerAzimuthalEqualArea(λ / B, φ);
      coordinates[0] *= A;
      return coordinates;
    }
    forward.invert = function (x, y) {
      var coordinates = hammerAzimuthalEqualArea.invert(x / A, y);
      coordinates[0] *= B;
      return coordinates;
    };
    return forward;
  }
  function hammerProjection() {
    var B = 2,
        m = projectionMutator(hammer),
        p = m(B);
    p.coefficient = function (_) {
      if (!arguments.length) return B;
      return m(B = +_);
    };
    return p;
  }
  function hammerQuarticAuthalic(λ, φ) {
    return [λ * Math.cos(φ) / Math.cos(φ /= 2), 2 * Math.sin(φ)];
  }
  hammerQuarticAuthalic.invert = function (x, y) {
    var φ = 2 * asin(y / 2);
    return [x * Math.cos(φ / 2) / Math.cos(φ), φ];
  };
  (d3.geoHammer = hammerProjection).raw = hammer;
  function hatano(λ, φ) {
    var c = Math.sin(φ) * (φ < 0 ? 2.43763 : 2.67595);
    for (var i = 0, δ; i < 20; i++) {
      φ -= δ = (φ + Math.sin(φ) - c) / (1 + Math.cos(φ));
      if (Math.abs(δ) < ε) break;
    }
    return [.85 * λ * Math.cos(φ *= .5), Math.sin(φ) * (φ < 0 ? 1.93052 : 1.75859)];
  }
  hatano.invert = function (x, y) {
    var θ = Math.abs(θ = y * (y < 0 ? .5179951515653813 : .5686373742600607)) > 1 - ε ? θ > 0 ? halfπ : -halfπ : asin(θ);
    return [1.1764705882352942 * x / Math.cos(θ), Math.abs(θ = ((θ += θ) + Math.sin(θ)) * (y < 0 ? .4102345310814193 : .3736990601468637)) > 1 - ε ? θ > 0 ? halfπ : -halfπ : asin(θ)];
  };
  (d3.geoHatano = function () {
    return projection(hatano);
  }).raw = hatano;
  var healpixParallel = 41 + 48 / 36 + 37 / 3600;
  function healpix(h) {
    var lambert = d3.geoCylindricalEqualArea.raw(0),
        φ0 = healpixParallel * π / 180,
        dx0 = 2 * π,
        dx1 = d3.geoCollignon.raw(π, φ0)[0] - d3.geoCollignon.raw(-π, φ0)[0],
        y0 = lambert(0, φ0)[1],
        y1 = d3.geoCollignon.raw(0, φ0)[1],
        dy1 = d3.geoCollignon.raw(0, halfπ)[1] - y1,
        k = 2 * π / h;
    function forward(λ, φ) {
      var point,
          φ2 = Math.abs(φ);
      if (φ2 > φ0) {
        var i = Math.min(h - 1, Math.max(0, Math.floor((λ + π) / k)));
        λ += π * (h - 1) / h - i * k;
        point = d3.geoCollignon.raw(λ, φ2);
        point[0] = point[0] * dx0 / dx1 - dx0 * (h - 1) / (2 * h) + i * dx0 / h;
        point[1] = y0 + (point[1] - y1) * 4 * dy1 / dx0;
        if (φ < 0) point[1] = -point[1];
      } else {
        point = lambert(λ, φ);
      }
      point[0] /= 2;
      return point;
    }
    forward.invert = function (x, y) {
      x *= 2;
      var y2 = Math.abs(y);
      if (y2 > y0) {
        var i = Math.min(h - 1, Math.max(0, Math.floor((x + π) / k)));
        x = (x + π * (h - 1) / h - i * k) * dx1 / dx0;
        var point = d3.geoCollignon.raw.invert(x, .25 * (y2 - y0) * dx0 / dy1 + y1);
        point[0] -= π * (h - 1) / h - i * k;
        if (y < 0) point[1] = -point[1];
        return point;
      }
      return lambert.invert(x, y);
    };
    return forward;
  }
  function healpixProjection() {
    var n = 2,
        m = projectionMutator(healpix),
        p = m(n),
        stream_ = p.stream;
    p.lobes = function (_) {
      if (!arguments.length) return n;
      return m(n = +_);
    };
    p.stream = function (stream) {
      var rotate = p.rotate(),
          rotateStream = stream_(stream),
          sphereStream = (p.rotate([0, 0]), stream_(stream));
      p.rotate(rotate);
      rotateStream.sphere = function () {
        d3.geoStream(sphere(), sphereStream);
      };
      return rotateStream;
    };
    function sphere() {
      var step = 180 / n;
      return {
        type: "Polygon",
        coordinates: [d3.range(-180, 180 + step / 2, step).map(function (x, i) {
          return [x, i & 1 ? 90 - 1e-6 : healpixParallel];
        }).concat(d3.range(180, -180 - step / 2, -step).map(function (x, i) {
          return [x, i & 1 ? -90 + 1e-6 : -healpixParallel];
        }))]
      };
    }
    return p;
  }
  (d3.geoHealpix = healpixProjection).raw = healpix;
  function hill(K) {
    var L = 1 + K,
        sinβ = Math.sin(1 / L),
        β = asin(sinβ),
        A = 2 * Math.sqrt(π / (B = π + 4 * β * L)),
        B,
        ρ0 = .5 * A * (L + Math.sqrt(K * (2 + K))),
        K2 = K * K,
        L2 = L * L;
    function forward(λ, φ) {
      var t = 1 - Math.sin(φ),
          ρ,
          ω;
      if (t && t < 2) {
        var θ = halfπ - φ,
            i = 25,
            δ;
        do {
          var sinθ = Math.sin(θ),
              cosθ = Math.cos(θ),
              β_β1 = β + Math.atan2(sinθ, L - cosθ),
              C = 1 + L2 - 2 * L * cosθ;
          θ -= δ = (θ - K2 * β - L * sinθ + C * β_β1 - .5 * t * B) / (2 * L * sinθ * β_β1);
        } while (Math.abs(δ) > ε2 && --i > 0);
        ρ = A * Math.sqrt(C);
        ω = λ * β_β1 / π;
      } else {
        ρ = A * (K + t);
        ω = λ * β / π;
      }
      return [ρ * Math.sin(ω), ρ0 - ρ * Math.cos(ω)];
    }
    forward.invert = function (x, y) {
      var ρ2 = x * x + (y -= ρ0) * y,
          cosθ = (1 + L2 - ρ2 / (A * A)) / (2 * L),
          θ = acos(cosθ),
          sinθ = Math.sin(θ),
          β_β1 = β + Math.atan2(sinθ, L - cosθ);
      return [asin(x / Math.sqrt(ρ2)) * π / β_β1, asin(1 - 2 * (θ - K2 * β - L * sinθ + (1 + L2 - 2 * L * cosθ) * β_β1) / B)];
    };
    return forward;
  }
  function hillProjection() {
    var K = 1,
        m = projectionMutator(hill),
        p = m(K);
    p.ratio = function (_) {
      if (!arguments.length) return K;
      return m(K = +_);
    };
    return p;
  }
  (d3.geoHill = hillProjection).raw = hill;
  var sinuMollweideφ = .7109889596207567,
      sinuMollweideY = .0528035274542;
  function sinuMollweide(λ, φ) {
    return φ > -sinuMollweideφ ? (λ = mollweide(λ, φ), λ[1] += sinuMollweideY, λ) : sinusoidal(λ, φ);
  }
  sinuMollweide.invert = function (x, y) {
    return y > -sinuMollweideφ ? mollweide.invert(x, y - sinuMollweideY) : sinusoidal.invert(x, y);
  };
  (d3.geoSinuMollweide = function () {
    return projection(sinuMollweide).rotate([-20, -55]);
  }).raw = sinuMollweide;
  function homolosine(λ, φ) {
    return Math.abs(φ) > sinuMollweideφ ? (λ = mollweide(λ, φ), λ[1] -= φ > 0 ? sinuMollweideY : -sinuMollweideY, λ) : sinusoidal(λ, φ);
  }
  homolosine.invert = function (x, y) {
    return Math.abs(y) > sinuMollweideφ ? mollweide.invert(x, y + (y > 0 ? sinuMollweideY : -sinuMollweideY)) : sinusoidal.invert(x, y);
  };
  (d3.geoHomolosine = function () {
    return projection(homolosine);
  }).raw = homolosine;
  function kavrayskiy7(λ, φ) {
    return [3 * λ / (2 * π) * Math.sqrt(π * π / 3 - φ * φ), φ];
  }
  kavrayskiy7.invert = function (x, y) {
    return [2 / 3 * π * x / Math.sqrt(π * π / 3 - y * y), y];
  };
  (d3.geoKavrayskiy7 = function () {
    return projection(kavrayskiy7);
  }).raw = kavrayskiy7;
  function lagrange(n) {
    function forward(λ, φ) {
      if (Math.abs(Math.abs(φ) - halfπ) < ε) return [0, φ < 0 ? -2 : 2];
      var sinφ = Math.sin(φ),
          v = Math.pow((1 + sinφ) / (1 - sinφ), n / 2),
          c = .5 * (v + 1 / v) + Math.cos(λ *= n);
      return [2 * Math.sin(λ) / c, (v - 1 / v) / c];
    }
    forward.invert = function (x, y) {
      var y0 = Math.abs(y);
      if (Math.abs(y0 - 2) < ε) return x ? null : [0, sgn(y) * halfπ];
      if (y0 > 2) return null;
      x /= 2, y /= 2;
      var x2 = x * x,
          y2 = y * y,
          t = 2 * y / (1 + x2 + y2);
      t = Math.pow((1 + t) / (1 - t), 1 / n);
      return [Math.atan2(2 * x, 1 - x2 - y2) / n, asin((t - 1) / (t + 1))];
    };
    return forward;
  }
  function lagrangeProjection() {
    var n = .5,
        m = projectionMutator(lagrange),
        p = m(n);
    p.spacing = function (_) {
      if (!arguments.length) return n;
      return m(n = +_);
    };
    return p;
  }
  (d3.geoLagrange = lagrangeProjection).raw = lagrange;
  function larrivee(λ, φ) {
    return [λ * (1 + Math.sqrt(Math.cos(φ))) / 2, φ / (Math.cos(φ / 2) * Math.cos(λ / 6))];
  }
  larrivee.invert = function (x, y) {
    var x0 = Math.abs(x),
        y0 = Math.abs(y),
        π_sqrt2 = π / Math.SQRT2,
        λ = ε,
        φ = halfπ;
    if (y0 < π_sqrt2) φ *= y0 / π_sqrt2;else λ += 6 * acos(π_sqrt2 / y0);
    for (var i = 0; i < 25; i++) {
      var sinφ = Math.sin(φ),
          sqrtcosφ = asqrt(Math.cos(φ)),
          sinφ_2 = Math.sin(φ / 2),
          cosφ_2 = Math.cos(φ / 2),
          sinλ_6 = Math.sin(λ / 6),
          cosλ_6 = Math.cos(λ / 6),
          f0 = .5 * λ * (1 + sqrtcosφ) - x0,
          f1 = φ / (cosφ_2 * cosλ_6) - y0,
          df0dφ = sqrtcosφ ? -.25 * λ * sinφ / sqrtcosφ : 0,
          df0dλ = .5 * (1 + sqrtcosφ),
          df1dφ = (1 + .5 * φ * sinφ_2 / cosφ_2) / (cosφ_2 * cosλ_6),
          df1dλ = φ / cosφ_2 * (sinλ_6 / 6) / (cosλ_6 * cosλ_6),
          denom = df0dφ * df1dλ - df1dφ * df0dλ,
          dφ = (f0 * df1dλ - f1 * df0dλ) / denom,
          dλ = (f1 * df0dφ - f0 * df1dφ) / denom;
      φ -= dφ;
      λ -= dλ;
      if (Math.abs(dφ) < ε && Math.abs(dλ) < ε) break;
    }
    return [x < 0 ? -λ : λ, y < 0 ? -φ : φ];
  };
  (d3.geoLarrivee = function () {
    return projection(larrivee);
  }).raw = larrivee;
  function laskowski(λ, φ) {
    var λ2 = λ * λ,
        φ2 = φ * φ;
    return [λ * (.975534 + φ2 * (-.119161 + λ2 * -.0143059 + φ2 * -.0547009)), φ * (1.00384 + λ2 * (.0802894 + φ2 * -.02855 + λ2 * 199025e-9) + φ2 * (.0998909 + φ2 * -.0491032))];
  }
  laskowski.invert = function (x, y) {
    var λ = sgn(x) * π,
        φ = y / 2,
        i = 50;
    do {
      var λ2 = λ * λ,
          φ2 = φ * φ,
          λφ = λ * φ,
          fx = λ * (.975534 + φ2 * (-.119161 + λ2 * -.0143059 + φ2 * -.0547009)) - x,
          fy = φ * (1.00384 + λ2 * (.0802894 + φ2 * -.02855 + λ2 * 199025e-9) + φ2 * (.0998909 + φ2 * -.0491032)) - y,
          δxδλ = .975534 - φ2 * (.119161 + 3 * λ2 * .0143059 + φ2 * .0547009),
          δxδφ = -λφ * (2 * .119161 + 4 * .0547009 * φ2 + 2 * .0143059 * λ2),
          δyδλ = λφ * (2 * .0802894 + 4 * 199025e-9 * λ2 + 2 * -.02855 * φ2),
          δyδφ = 1.00384 + λ2 * (.0802894 + 199025e-9 * λ2) + φ2 * (3 * (.0998909 - .02855 * λ2) - 5 * .0491032 * φ2),
          denominator = δxδφ * δyδλ - δyδφ * δxδλ,
          δλ = (fy * δxδφ - fx * δyδφ) / denominator,
          δφ = (fx * δyδλ - fy * δxδλ) / denominator;
      λ -= δλ, φ -= δφ;
    } while ((Math.abs(δλ) > ε || Math.abs(δφ) > ε) && --i > 0);
    return i && [λ, φ];
  };
  (d3.geoLaskowski = function () {
    return projection(laskowski);
  }).raw = laskowski;
  function littrow(λ, φ) {
    return [Math.sin(λ) / Math.cos(φ), Math.tan(φ) * Math.cos(λ)];
  }
  littrow.invert = function (x, y) {
    var x2 = x * x,
        y2 = y * y,
        y2_1 = y2 + 1,
        cosφ = x ? Math.SQRT1_2 * Math.sqrt((y2_1 - Math.sqrt(x2 * x2 + 2 * x2 * (y2 - 1) + y2_1 * y2_1)) / x2 + 1) : 1 / Math.sqrt(y2_1);
    return [asin(x * cosφ), sgn(y) * acos(cosφ)];
  };
  (d3.geoLittrow = function () {
    return projection(littrow);
  }).raw = littrow;
  function loximuthal(φ0) {
    var cosφ0 = Math.cos(φ0),
        tanφ0 = Math.tan(π / 4 + φ0 / 2);
    function forward(λ, φ) {
      var y = φ - φ0,
          x = Math.abs(y) < ε ? λ * cosφ0 : Math.abs(x = π / 4 + φ / 2) < ε || Math.abs(Math.abs(x) - halfπ) < ε ? 0 : λ * y / Math.log(Math.tan(x) / tanφ0);
      return [x, y];
    }
    forward.invert = function (x, y) {
      var λ,
          φ = y + φ0;
      return [Math.abs(y) < ε ? x / cosφ0 : Math.abs(λ = π / 4 + φ / 2) < ε || Math.abs(Math.abs(λ) - halfπ) < ε ? 0 : x * Math.log(Math.tan(λ) / tanφ0) / y, φ];
    };
    return forward;
  }
  (d3.geoLoximuthal = function () {
    return parallel1Projection(loximuthal).parallel(40);
  }).raw = loximuthal;
  function miller(λ, φ) {
    return [λ, 1.25 * Math.log(Math.tan(π / 4 + .4 * φ))];
  }
  miller.invert = function (x, y) {
    return [x, 2.5 * Math.atan(Math.exp(.8 * y)) - .625 * π];
  };
  (d3.geoMiller = function () {
    return projection(miller);
  }).raw = miller;
  function modifiedStereographic(C) {
    var m = C.length - 1;
    function forward(λ, φ) {
      var cosφ = Math.cos(φ),
          k = 2 / (1 + cosφ * Math.cos(λ)),
          zr = k * cosφ * Math.sin(λ),
          zi = k * Math.sin(φ),
          i = m,
          w = C[i],
          ar = w[0],
          ai = w[1],
          t;
      while (--i >= 0) {
        w = C[i];
        ar = w[0] + zr * (t = ar) - zi * ai;
        ai = w[1] + zr * ai + zi * t;
      }
      ar = zr * (t = ar) - zi * ai;
      ai = zr * ai + zi * t;
      return [ar, ai];
    }
    forward.invert = function (x, y) {
      var i = 20,
          zr = x,
          zi = y;
      do {
        var j = m,
            w = C[j],
            ar = w[0],
            ai = w[1],
            br = 0,
            bi = 0,
            t;
        while (--j >= 0) {
          w = C[j];
          br = ar + zr * (t = br) - zi * bi;
          bi = ai + zr * bi + zi * t;
          ar = w[0] + zr * (t = ar) - zi * ai;
          ai = w[1] + zr * ai + zi * t;
        }
        br = ar + zr * (t = br) - zi * bi;
        bi = ai + zr * bi + zi * t;
        ar = zr * (t = ar) - zi * ai - x;
        ai = zr * ai + zi * t - y;
        var denominator = br * br + bi * bi,
            δr,
            δi;
        zr -= δr = (ar * br + ai * bi) / denominator;
        zi -= δi = (ai * br - ar * bi) / denominator;
      } while (Math.abs(δr) + Math.abs(δi) > ε * ε && --i > 0);
      if (i) {
        var ρ = Math.sqrt(zr * zr + zi * zi),
            c = 2 * Math.atan(ρ * .5),
            sinc = Math.sin(c);
        return [Math.atan2(zr * sinc, ρ * Math.cos(c)), ρ ? asin(zi * sinc / ρ) : 0];
      }
    };
    return forward;
  }
  var modifiedStereographicCoefficients = {
    alaska: [[.9972523, 0], [.0052513, -.0041175], [.0074606, .0048125], [-.0153783, -.1968253], [.0636871, -.1408027], [.3660976, -.2937382]],
    gs48: [[.98879, 0], [0, 0], [-.050909, 0], [0, 0], [.075528, 0]],
    gs50: [[.984299, 0], [.0211642, .0037608], [-.1036018, -.0575102], [-.0329095, -.0320119], [.0499471, .1223335], [.026046, .0899805], [7388e-7, -.1435792], [.0075848, -.1334108], [-.0216473, .0776645], [-.0225161, .0853673]],
    miller: [[.9245, 0], [0, 0], [.01943, 0]],
    lee: [[.721316, 0], [0, 0], [-.00881625, -.00617325]]
  };
  function modifiedStereographicProjection() {
    var coefficients = modifiedStereographicCoefficients.miller,
        m = projectionMutator(modifiedStereographic),
        p = m(coefficients);
    p.coefficients = function (_) {
      if (!arguments.length) return coefficients;
      return m(coefficients = typeof _ === "string" ? modifiedStereographicCoefficients[_] : _);
    };
    return p;
  }
  (d3.geoModifiedStereographic = modifiedStereographicProjection).raw = modifiedStereographic;
  function mtFlatPolarParabolic(λ, φ) {
    var sqrt6 = Math.sqrt(6),
        sqrt7 = Math.sqrt(7),
        θ = Math.asin(7 * Math.sin(φ) / (3 * sqrt6));
    return [sqrt6 * λ * (2 * Math.cos(2 * θ / 3) - 1) / sqrt7, 9 * Math.sin(θ / 3) / sqrt7];
  }
  mtFlatPolarParabolic.invert = function (x, y) {
    var sqrt6 = Math.sqrt(6),
        sqrt7 = Math.sqrt(7),
        θ = 3 * asin(y * sqrt7 / 9);
    return [x * sqrt7 / (sqrt6 * (2 * Math.cos(2 * θ / 3) - 1)), asin(Math.sin(θ) * 3 * sqrt6 / 7)];
  };
  (d3.geoMtFlatPolarParabolic = function () {
    return projection(mtFlatPolarParabolic);
  }).raw = mtFlatPolarParabolic;
  function mtFlatPolarQuartic(λ, φ) {
    var k = (1 + Math.SQRT1_2) * Math.sin(φ),
        θ = φ;
    for (var i = 0, δ; i < 25; i++) {
      θ -= δ = (Math.sin(θ / 2) + Math.sin(θ) - k) / (.5 * Math.cos(θ / 2) + Math.cos(θ));
      if (Math.abs(δ) < ε) break;
    }
    return [λ * (1 + 2 * Math.cos(θ) / Math.cos(θ / 2)) / (3 * Math.SQRT2), 2 * Math.sqrt(3) * Math.sin(θ / 2) / Math.sqrt(2 + Math.SQRT2)];
  }
  mtFlatPolarQuartic.invert = function (x, y) {
    var sinθ_2 = y * Math.sqrt(2 + Math.SQRT2) / (2 * Math.sqrt(3)),
        θ = 2 * asin(sinθ_2);
    return [3 * Math.SQRT2 * x / (1 + 2 * Math.cos(θ) / Math.cos(θ / 2)), asin((sinθ_2 + Math.sin(θ)) / (1 + Math.SQRT1_2))];
  };
  (d3.geoMtFlatPolarQuartic = function () {
    return projection(mtFlatPolarQuartic);
  }).raw = mtFlatPolarQuartic;
  function mtFlatPolarSinusoidal(λ, φ) {
    var A = Math.sqrt(6 / (4 + π)),
        k = (1 + π / 4) * Math.sin(φ),
        θ = φ / 2;
    for (var i = 0, δ; i < 25; i++) {
      θ -= δ = (θ / 2 + Math.sin(θ) - k) / (.5 + Math.cos(θ));
      if (Math.abs(δ) < ε) break;
    }
    return [A * (.5 + Math.cos(θ)) * λ / 1.5, A * θ];
  }
  mtFlatPolarSinusoidal.invert = function (x, y) {
    var A = Math.sqrt(6 / (4 + π)),
        θ = y / A;
    if (Math.abs(Math.abs(θ) - halfπ) < ε) θ = θ < 0 ? -halfπ : halfπ;
    return [1.5 * x / (A * (.5 + Math.cos(θ))), asin((θ / 2 + Math.sin(θ)) / (1 + π / 4))];
  };
  (d3.geoMtFlatPolarSinusoidal = function () {
    return projection(mtFlatPolarSinusoidal);
  }).raw = mtFlatPolarSinusoidal;
  function naturalEarth(λ, φ) {
    var φ2 = φ * φ,
        φ4 = φ2 * φ2;
    return [λ * (.8707 - .131979 * φ2 + φ4 * (-.013791 + φ4 * (.003971 * φ2 - .001529 * φ4))), φ * (1.007226 + φ2 * (.015085 + φ4 * (-.044475 + .028874 * φ2 - .005916 * φ4)))];
  }
  naturalEarth.invert = function (x, y) {
    var φ = y,
        i = 25,
        δ;
    do {
      var φ2 = φ * φ,
          φ4 = φ2 * φ2;
      φ -= δ = (φ * (1.007226 + φ2 * (.015085 + φ4 * (-.044475 + .028874 * φ2 - .005916 * φ4))) - y) / (1.007226 + φ2 * (.015085 * 3 + φ4 * (-.044475 * 7 + .028874 * 9 * φ2 - .005916 * 11 * φ4)));
    } while (Math.abs(δ) > ε && --i > 0);
    return [x / (.8707 + (φ2 = φ * φ) * (-.131979 + φ2 * (-.013791 + φ2 * φ2 * φ2 * (.003971 - .001529 * φ2)))), φ];
  };
  (d3.geoNaturalEarth = function () {
    return projection(naturalEarth);
  }).raw = naturalEarth;
  function nellHammer(λ, φ) {
    return [λ * (1 + Math.cos(φ)) / 2, 2 * (φ - Math.tan(φ / 2))];
  }
  nellHammer.invert = function (x, y) {
    var p = y / 2;
    for (var i = 0, δ = Infinity; i < 10 && Math.abs(δ) > ε; i++) {
      var c = Math.cos(y / 2);
      y -= δ = (y - Math.tan(y / 2) - p) / (1 - .5 / (c * c));
    }
    return [2 * x / (1 + Math.cos(y)), y];
  };
  (d3.geoNellHammer = function () {
    return projection(nellHammer);
  }).raw = nellHammer;
  var pattersonK1 = 1.0148,
      pattersonK2 = .23185,
      pattersonK3 = -.14499,
      pattersonK4 = .02406,
      pattersonC1 = pattersonK1,
      pattersonC2 = 5 * pattersonK2,
      pattersonC3 = 7 * pattersonK3,
      pattersonC4 = 9 * pattersonK4,
      pattersonYmax = 1.790857183;
  function patterson(λ, φ) {
    var φ2 = φ * φ;
    return [λ, φ * (pattersonK1 + φ2 * φ2 * (pattersonK2 + φ2 * (pattersonK3 + pattersonK4 * φ2)))];
  }
  patterson.invert = function (x, y) {
    if (y > pattersonYmax) y = pattersonYmax;else if (y < -pattersonYmax) y = -pattersonYmax;
    var yc = y,
        δ;
    do {
      var y2 = yc * yc;
      yc -= δ = (yc * (pattersonK1 + y2 * y2 * (pattersonK2 + y2 * (pattersonK3 + pattersonK4 * y2))) - y) / (pattersonC1 + y2 * y2 * (pattersonC2 + y2 * (pattersonC3 + pattersonC4 * y2)));
    } while (Math.abs(δ) > ε);
    return [x, yc];
  };
  (d3.geoPatterson = function () {
    return projection(patterson);
  }).raw = patterson;
  var peirceQuincuncialProjection = quincuncialProjection(guyou);
  (d3.geoPeirceQuincuncial = function () {
    return peirceQuincuncialProjection().quincuncial(true).rotate([-90, -90, 45]).clipAngle(180 - 1e-6);
  }).raw = peirceQuincuncialProjection.raw;
  function polyconic(λ, φ) {
    if (Math.abs(φ) < ε) return [λ, 0];
    var tanφ = Math.tan(φ),
        k = λ * Math.sin(φ);
    return [Math.sin(k) / tanφ, φ + (1 - Math.cos(k)) / tanφ];
  }
  polyconic.invert = function (x, y) {
    if (Math.abs(y) < ε) return [x, 0];
    var k = x * x + y * y,
        φ = y * .5,
        i = 10,
        δ;
    do {
      var tanφ = Math.tan(φ),
          secφ = 1 / Math.cos(φ),
          j = k - 2 * y * φ + φ * φ;
      φ -= δ = (tanφ * j + 2 * (φ - y)) / (2 + j * secφ * secφ + 2 * (φ - y) * tanφ);
    } while (Math.abs(δ) > ε && --i > 0);
    tanφ = Math.tan(φ);
    return [(Math.abs(y) < Math.abs(φ + 1 / tanφ) ? asin(x * tanφ) : sgn(x) * (acos(Math.abs(x * tanφ)) + halfπ)) / Math.sin(φ), φ];
  };
  (d3.geoPolyconic = function () {
    return projection(polyconic);
  }).raw = polyconic;
  function rectangularPolyconic(φ0) {
    var sinφ0 = Math.sin(φ0);
    function forward(λ, φ) {
      var A = sinφ0 ? Math.tan(λ * sinφ0 / 2) / sinφ0 : λ / 2;
      if (!φ) return [2 * A, -φ0];
      var E = 2 * Math.atan(A * Math.sin(φ)),
          cotφ = 1 / Math.tan(φ);
      return [Math.sin(E) * cotφ, φ + (1 - Math.cos(E)) * cotφ - φ0];
    }
    forward.invert = function (x, y) {
      if (Math.abs(y += φ0) < ε) return [sinφ0 ? 2 * Math.atan(sinφ0 * x / 2) / sinφ0 : x, 0];
      var k = x * x + y * y,
          φ = 0,
          i = 10,
          δ;
      do {
        var tanφ = Math.tan(φ),
            secφ = 1 / Math.cos(φ),
            j = k - 2 * y * φ + φ * φ;
        φ -= δ = (tanφ * j + 2 * (φ - y)) / (2 + j * secφ * secφ + 2 * (φ - y) * tanφ);
      } while (Math.abs(δ) > ε && --i > 0);
      var E = x * (tanφ = Math.tan(φ)),
          A = Math.tan(Math.abs(y) < Math.abs(φ + 1 / tanφ) ? asin(E) * .5 : acos(E) * .5 + π / 4) / Math.sin(φ);
      return [sinφ0 ? 2 * Math.atan(sinφ0 * A) / sinφ0 : 2 * A, φ];
    };
    return forward;
  }
  (d3.geoRectangularPolyconic = function () {
    return parallel1Projection(rectangularPolyconic);
  }).raw = rectangularPolyconic;
  var robinsonConstants = [[.9986, -.062], [1, 0], [.9986, .062], [.9954, .124], [.99, .186], [.9822, .248], [.973, .31], [.96, .372], [.9427, .434], [.9216, .4958], [.8962, .5571], [.8679, .6176], [.835, .6769], [.7986, .7346], [.7597, .7903], [.7186, .8435], [.6732, .8936], [.6213, .9394], [.5722, .9761], [.5322, 1]];
  robinsonConstants.forEach(function (d) {
    d[1] *= 1.0144;
  });
  function robinson(λ, φ) {
    var i = Math.min(18, Math.abs(φ) * 36 / π),
        i0 = Math.floor(i),
        di = i - i0,
        ax = (k = robinsonConstants[i0])[0],
        ay = k[1],
        bx = (k = robinsonConstants[++i0])[0],
        by = k[1],
        cx = (k = robinsonConstants[Math.min(19, ++i0)])[0],
        cy = k[1],
        k;
    return [λ * (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2), (φ > 0 ? halfπ : -halfπ) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2)];
  }
  robinson.invert = function (x, y) {
    var yy = y / halfπ,
        φ = yy * 90,
        i = Math.min(18, Math.abs(φ / 5)),
        i0 = Math.max(0, Math.floor(i));
    do {
      var ay = robinsonConstants[i0][1],
          by = robinsonConstants[i0 + 1][1],
          cy = robinsonConstants[Math.min(19, i0 + 2)][1],
          u = cy - ay,
          v = cy - 2 * by + ay,
          t = 2 * (Math.abs(yy) - by) / u,
          c = v / u,
          di = t * (1 - c * t * (1 - 2 * c * t));
      if (di >= 0 || i0 === 1) {
        φ = (y >= 0 ? 5 : -5) * (di + i);
        var j = 50,
            δ;
        do {
          i = Math.min(18, Math.abs(φ) / 5);
          i0 = Math.floor(i);
          di = i - i0;
          ay = robinsonConstants[i0][1];
          by = robinsonConstants[i0 + 1][1];
          cy = robinsonConstants[Math.min(19, i0 + 2)][1];
          φ -= (δ = (y >= 0 ? halfπ : -halfπ) * (by + di * (cy - ay) / 2 + di * di * (cy - 2 * by + ay) / 2) - y) * degrees;
        } while (Math.abs(δ) > ε2 && --j > 0);
        break;
      }
    } while (--i0 >= 0);
    var ax = robinsonConstants[i0][0],
        bx = robinsonConstants[i0 + 1][0],
        cx = robinsonConstants[Math.min(19, i0 + 2)][0];
    return [x / (bx + di * (cx - ax) / 2 + di * di * (cx - 2 * bx + ax) / 2), φ * radians];
  };
  (d3.geoRobinson = function () {
    return projection(robinson);
  }).raw = robinson;
  function satelliteVertical(P) {
    function forward(λ, φ) {
      var cosφ = Math.cos(φ),
          k = (P - 1) / (P - cosφ * Math.cos(λ));
      return [k * cosφ * Math.sin(λ), k * Math.sin(φ)];
    }
    forward.invert = function (x, y) {
      var ρ2 = x * x + y * y,
          ρ = Math.sqrt(ρ2),
          sinc = (P - Math.sqrt(1 - ρ2 * (P + 1) / (P - 1))) / ((P - 1) / ρ + ρ / (P - 1));
      return [Math.atan2(x * sinc, ρ * Math.sqrt(1 - sinc * sinc)), ρ ? asin(y * sinc / ρ) : 0];
    };
    return forward;
  }
  function satellite(P, ω) {
    var vertical = satelliteVertical(P);
    if (!ω) return vertical;
    var cosω = Math.cos(ω),
        sinω = Math.sin(ω);
    function forward(λ, φ) {
      var coordinates = vertical(λ, φ),
          y = coordinates[1],
          A = y * sinω / (P - 1) + cosω;
      return [coordinates[0] * cosω / A, y / A];
    }
    forward.invert = function (x, y) {
      var k = (P - 1) / (P - 1 - y * sinω);
      return vertical.invert(k * x, k * y * cosω);
    };
    return forward;
  }
  function satelliteProjection() {
    var P = 1.4,
        ω = 0,
        m = projectionMutator(satellite),
        p = m(P, ω);
    p.distance = function (_) {
      if (!arguments.length) return P;
      return m(P = +_, ω);
    };
    p.tilt = function (_) {
      if (!arguments.length) return ω * 180 / π;
      return m(P, ω = _ * π / 180);
    };
    return p;
  }
  (d3.geoSatellite = satelliteProjection).raw = satellite;
  function times(λ, φ) {
    var t = Math.tan(φ / 2),
        s = Math.sin(π / 4 * t);
    return [λ * (.74482 - .34588 * s * s), 1.70711 * t];
  }
  times.invert = function (x, y) {
    var t = y / 1.70711,
        s = Math.sin(π / 4 * t);
    return [x / (.74482 - .34588 * s * s), 2 * Math.atan(t)];
  };
  (d3.geoTimes = function () {
    return projection(times);
  }).raw = times;
  function twoPointEquidistant(z0) {
    if (!z0) return d3.geoAzimuthalEquidistant.raw;
    var λa = -z0 / 2,
        λb = -λa,
        z02 = z0 * z0,
        tanλ0 = Math.tan(λb),
        S = .5 / Math.sin(λb);
    function forward(λ, φ) {
      var za = acos(Math.cos(φ) * Math.cos(λ - λa)),
          zb = acos(Math.cos(φ) * Math.cos(λ - λb)),
          ys = φ < 0 ? -1 : 1;
      za *= za, zb *= zb;
      return [(za - zb) / (2 * z0), ys * asqrt(4 * z02 * zb - (z02 - za + zb) * (z02 - za + zb)) / (2 * z0)];
    }
    forward.invert = function (x, y) {
      var y2 = y * y,
          cosza = Math.cos(Math.sqrt(y2 + (t = x + λa) * t)),
          coszb = Math.cos(Math.sqrt(y2 + (t = x + λb) * t)),
          t,
          d;
      return [Math.atan2(d = cosza - coszb, t = (cosza + coszb) * tanλ0), (y < 0 ? -1 : 1) * acos(Math.sqrt(t * t + d * d) * S)];
    };
    return forward;
  }
  function twoPointEquidistantProjection() {
    var points = [[0, 0], [0, 0]],
        m = projectionMutator(twoPointEquidistant),
        p = m(0),
        rotate = p.rotate;
    delete p.rotate;
    p.points = function (_) {
      if (!arguments.length) return points;
      points = _;
      var interpolate = d3.geoInterpolate(_[0], _[1]),
          origin = interpolate(.5),
          p = d3.geoRotation([-origin[0], -origin[1]])(_[0]),
          b = interpolate.distance * .5,
          γ = -asin(Math.sin(p[1] * radians) / Math.sin(b));
      if (p[0] > 0) γ = π - γ;
      rotate.call(p, [-origin[0], -origin[1], -γ * degrees]);
      return m(b * 2);
    };
    return p;
  }
  (d3.geoTwoPointEquidistant = twoPointEquidistantProjection).raw = twoPointEquidistant;
  function twoPointAzimuthal(d) {
    var cosd = Math.cos(d);
    function forward(λ, φ) {
      var coordinates = d3.geoGnomonic.raw(λ, φ);
      coordinates[0] *= cosd;
      return coordinates;
    }
    forward.invert = function (x, y) {
      return d3.geoGnomonic.raw.invert(x / cosd, y);
    };
    return forward;
  }
  function twoPointAzimuthalProjection() {
    var points = [[0, 0], [0, 0]],
        m = projectionMutator(twoPointAzimuthal),
        p = m(0),
        rotate = p.rotate;
    delete p.rotate;
    p.points = function (_) {
      if (!arguments.length) return points;
      points = _;
      var interpolate = d3.geoInterpolate(_[0], _[1]),
          origin = interpolate(.5),
          p = d3.geoRotation([-origin[0], -origin[1]])(_[0]),
          b = interpolate.distance * .5,
          γ = -asin(Math.sin(p[1] * radians) / Math.sin(b));
      if (p[0] > 0) γ = π - γ;
      rotate.call(p, [-origin[0], -origin[1], -γ * degrees]);
      return m(b);
    };
    return p;
  }
  (d3.geoTwoPointAzimuthal = twoPointAzimuthalProjection).raw = twoPointAzimuthal;
  function vanDerGrinten(λ, φ) {
    if (Math.abs(φ) < ε) return [λ, 0];
    var sinθ = Math.abs(φ / halfπ),
        θ = asin(sinθ);
    if (Math.abs(λ) < ε || Math.abs(Math.abs(φ) - halfπ) < ε) return [0, sgn(φ) * π * Math.tan(θ / 2)];
    var cosθ = Math.cos(θ),
        A = Math.abs(π / λ - λ / π) / 2,
        A2 = A * A,
        G = cosθ / (sinθ + cosθ - 1),
        P = G * (2 / sinθ - 1),
        P2 = P * P,
        P2_A2 = P2 + A2,
        G_P2 = G - P2,
        Q = A2 + G;
    return [sgn(λ) * π * (A * G_P2 + Math.sqrt(A2 * G_P2 * G_P2 - P2_A2 * (G * G - P2))) / P2_A2, sgn(φ) * π * (P * Q - A * Math.sqrt((A2 + 1) * P2_A2 - Q * Q)) / P2_A2];
  }
  vanDerGrinten.invert = function (x, y) {
    if (Math.abs(y) < ε) return [x, 0];
    if (Math.abs(x) < ε) return [0, halfπ * Math.sin(2 * Math.atan(y / π))];
    var x2 = (x /= π) * x,
        y2 = (y /= π) * y,
        x2_y2 = x2 + y2,
        z = x2_y2 * x2_y2,
        c1 = -Math.abs(y) * (1 + x2_y2),
        c2 = c1 - 2 * y2 + x2,
        c3 = -2 * c1 + 1 + 2 * y2 + z,
        d = y2 / c3 + (2 * c2 * c2 * c2 / (c3 * c3 * c3) - 9 * c1 * c2 / (c3 * c3)) / 27,
        a1 = (c1 - c2 * c2 / (3 * c3)) / c3,
        m1 = 2 * Math.sqrt(-a1 / 3),
        θ1 = acos(3 * d / (a1 * m1)) / 3;
    return [π * (x2_y2 - 1 + Math.sqrt(1 + 2 * (x2 - y2) + z)) / (2 * x), sgn(y) * π * (-m1 * Math.cos(θ1 + π / 3) - c2 / (3 * c3))];
  };
  (d3.geoVanDerGrinten = function () {
    return projection(vanDerGrinten);
  }).raw = vanDerGrinten;
  function vanDerGrinten2(λ, φ) {
    if (Math.abs(φ) < ε) return [λ, 0];
    var sinθ = Math.abs(φ / halfπ),
        θ = asin(sinθ);
    if (Math.abs(λ) < ε || Math.abs(Math.abs(φ) - halfπ) < ε) return [0, sgn(φ) * π * Math.tan(θ / 2)];
    var cosθ = Math.cos(θ),
        A = Math.abs(π / λ - λ / π) / 2,
        A2 = A * A,
        x1 = cosθ * (Math.sqrt(1 + A2) - A * cosθ) / (1 + A2 * sinθ * sinθ);
    return [sgn(λ) * π * x1, sgn(φ) * π * asqrt(1 - x1 * (2 * A + x1))];
  }
  vanDerGrinten2.invert = function (x, y) {
    if (!x) return [0, halfπ * Math.sin(2 * Math.atan(y / π))];
    var x1 = Math.abs(x / π),
        A = (1 - x1 * x1 - (y /= π) * y) / (2 * x1),
        A2 = A * A,
        B = Math.sqrt(A2 + 1);
    return [sgn(x) * π * (B - A), sgn(y) * halfπ * Math.sin(2 * Math.atan2(Math.sqrt((1 - 2 * A * x1) * (A + B) - x1), Math.sqrt(B + A + x1)))];
  };
  (d3.geoVanDerGrinten2 = function () {
    return projection(vanDerGrinten2);
  }).raw = vanDerGrinten2;
  function vanDerGrinten3(λ, φ) {
    if (Math.abs(φ) < ε) return [λ, 0];
    var sinθ = φ / halfπ,
        θ = asin(sinθ);
    if (Math.abs(λ) < ε || Math.abs(Math.abs(φ) - halfπ) < ε) return [0, π * Math.tan(θ / 2)];
    var A = (π / λ - λ / π) / 2,
        y1 = sinθ / (1 + Math.cos(θ));
    return [π * (sgn(λ) * asqrt(A * A + 1 - y1 * y1) - A), π * y1];
  }
  vanDerGrinten3.invert = function (x, y) {
    if (!y) return [x, 0];
    var y1 = y / π,
        A = (π * π * (1 - y1 * y1) - x * x) / (2 * π * x);
    return [x ? π * (sgn(x) * Math.sqrt(A * A + 1) - A) : 0, halfπ * Math.sin(2 * Math.atan(y1))];
  };
  (d3.geoVanDerGrinten3 = function () {
    return projection(vanDerGrinten3);
  }).raw = vanDerGrinten3;
  function vanDerGrinten4(λ, φ) {
    if (!φ) return [λ, 0];
    var φ0 = Math.abs(φ);
    if (!λ || φ0 === halfπ) return [0, φ];
    var B = φ0 / halfπ,
        B2 = B * B,
        C = (8 * B - B2 * (B2 + 2) - 5) / (2 * B2 * (B - 1)),
        C2 = C * C,
        BC = B * C,
        B_C2 = B2 + C2 + 2 * BC,
        B_3C = B + 3 * C,
        λ0 = λ / halfπ,
        λ1 = λ0 + 1 / λ0,
        D = sgn(Math.abs(λ) - halfπ) * Math.sqrt(λ1 * λ1 - 4),
        D2 = D * D,
        F = B_C2 * (B2 + C2 * D2 - 1) + (1 - B2) * (B2 * (B_3C * B_3C + 4 * C2) + 12 * BC * C2 + 4 * C2 * C2),
        x1 = (D * (B_C2 + C2 - 1) + 2 * asqrt(F)) / (4 * B_C2 + D2);
    return [sgn(λ) * halfπ * x1, sgn(φ) * halfπ * asqrt(1 + D * Math.abs(x1) - x1 * x1)];
  }
  vanDerGrinten4.invert = function (x, y) {
    if (!x || !y) return [x, y];
    y /= π;
    var x1 = sgn(x) * x / halfπ,
        D = (x1 * x1 - 1 + 4 * y * y) / Math.abs(x1),
        D2 = D * D,
        B = 2 * y,
        i = 50;
    do {
      var B2 = B * B,
          C = (8 * B - B2 * (B2 + 2) - 5) / (2 * B2 * (B - 1)),
          C_ = (3 * B - B2 * B - 10) / (2 * B2 * B),
          C2 = C * C,
          BC = B * C,
          B_C = B + C,
          B_C2 = B_C * B_C,
          B_3C = B + 3 * C,
          F = B_C2 * (B2 + C2 * D2 - 1) + (1 - B2) * (B2 * (B_3C * B_3C + 4 * C2) + C2 * (12 * BC + 4 * C2)),
          F_ = -2 * B_C * (4 * BC * C2 + (1 - 4 * B2 + 3 * B2 * B2) * (1 + C_) + C2 * (-6 + 14 * B2 - D2 + (-8 + 8 * B2 - 2 * D2) * C_) + BC * (-8 + 12 * B2 + (-10 + 10 * B2 - D2) * C_)),
          sqrtF = Math.sqrt(F),
          f = D * (B_C2 + C2 - 1) + 2 * sqrtF - x1 * (4 * B_C2 + D2),
          f_ = D * (2 * C * C_ + 2 * B_C * (1 + C_)) + F_ / sqrtF - 8 * B_C * (D * (-1 + C2 + B_C2) + 2 * sqrtF) * (1 + C_) / (D2 + 4 * B_C2);
      B -= δ = f / f_;
    } while (δ > ε && --i > 0);
    return [sgn(x) * (Math.sqrt(D * D + 4) + D) * π / 4, halfπ * B];
  };
  (d3.geoVanDerGrinten4 = function () {
    return projection(vanDerGrinten4);
  }).raw = vanDerGrinten4;
  var wagner4 = function () {
    var A = 4 * π + 3 * Math.sqrt(3),
        B = 2 * Math.sqrt(2 * π * Math.sqrt(3) / A);
    return mollweideBromley(B * Math.sqrt(3) / π, B, A / 6);
  }();
  (d3.geoWagner4 = function () {
    return projection(wagner4);
  }).raw = wagner4;
  function wagner6(λ, φ) {
    return [λ * Math.sqrt(1 - 3 * φ * φ / (π * π)), φ];
  }
  wagner6.invert = function (x, y) {
    return [x / Math.sqrt(1 - 3 * y * y / (π * π)), y];
  };
  (d3.geoWagner6 = function () {
    return projection(wagner6);
  }).raw = wagner6;
  function wagner7(λ, φ) {
    var s = .90631 * Math.sin(φ),
        c0 = Math.sqrt(1 - s * s),
        c1 = Math.sqrt(2 / (1 + c0 * Math.cos(λ /= 3)));
    return [2.66723 * c0 * c1 * Math.sin(λ), 1.24104 * s * c1];
  }
  wagner7.invert = function (x, y) {
    var t1 = x / 2.66723,
        t2 = y / 1.24104,
        p = Math.sqrt(t1 * t1 + t2 * t2),
        c = 2 * asin(p / 2);
    return [3 * Math.atan2(x * Math.tan(c), 2.66723 * p), p && asin(y * Math.sin(c) / (1.24104 * .90631 * p))];
  };
  (d3.geoWagner7 = function () {
    return projection(wagner7);
  }).raw = wagner7;
  function wiechel(λ, φ) {
    var cosφ = Math.cos(φ),
        sinφ = Math.cos(λ) * cosφ,
        sin1_φ = 1 - sinφ,
        cosλ = Math.cos(λ = Math.atan2(Math.sin(λ) * cosφ, -Math.sin(φ))),
        sinλ = Math.sin(λ);
    cosφ = asqrt(1 - sinφ * sinφ);
    return [sinλ * cosφ - cosλ * sin1_φ, -cosλ * cosφ - sinλ * sin1_φ];
  }
  wiechel.invert = function (x, y) {
    var w = -.5 * (x * x + y * y),
        k = Math.sqrt(-w * (2 + w)),
        b = y * w + x * k,
        a = x * w - y * k,
        D = Math.sqrt(a * a + b * b);
    return [Math.atan2(k * b, D * (1 + w)), D ? -asin(k * a / D) : 0];
  };
  (d3.geoWiechel = function () {
    return projection(wiechel);
  }).raw = wiechel;
  function winkel3(λ, φ) {
    var coordinates = aitoff(λ, φ);
    return [(coordinates[0] + λ / halfπ) / 2, (coordinates[1] + φ) / 2];
  }
  winkel3.invert = function (x, y) {
    var λ = x,
        φ = y,
        i = 25;
    do {
      var cosφ = Math.cos(φ),
          sinφ = Math.sin(φ),
          sin_2φ = Math.sin(2 * φ),
          sin2φ = sinφ * sinφ,
          cos2φ = cosφ * cosφ,
          sinλ = Math.sin(λ),
          cosλ_2 = Math.cos(λ / 2),
          sinλ_2 = Math.sin(λ / 2),
          sin2λ_2 = sinλ_2 * sinλ_2,
          C = 1 - cos2φ * cosλ_2 * cosλ_2,
          E = C ? acos(cosφ * cosλ_2) * Math.sqrt(F = 1 / C) : F = 0,
          F,
          fx = .5 * (2 * E * cosφ * sinλ_2 + λ / halfπ) - x,
          fy = .5 * (E * sinφ + φ) - y,
          δxδλ = .5 * F * (cos2φ * sin2λ_2 + E * cosφ * cosλ_2 * sin2φ) + .5 / halfπ,
          δxδφ = F * (sinλ * sin_2φ / 4 - E * sinφ * sinλ_2),
          δyδλ = .125 * F * (sin_2φ * sinλ_2 - E * sinφ * cos2φ * sinλ),
          δyδφ = .5 * F * (sin2φ * cosλ_2 + E * sin2λ_2 * cosφ) + .5,
          denominator = δxδφ * δyδλ - δyδφ * δxδλ,
          δλ = (fy * δxδφ - fx * δyδφ) / denominator,
          δφ = (fx * δyδλ - fy * δxδλ) / denominator;
      λ -= δλ, φ -= δφ;
    } while ((Math.abs(δλ) > ε || Math.abs(δφ) > ε) && --i > 0);
    return [λ, φ];
  };
  (d3.geoWinkel3 = function () {
    return projection(winkel3);
  }).raw = winkel3;
};

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _hook = __webpack_require__(42);

var _hook2 = _interopRequireDefault(_hook);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*!
 * VIZABI Axis Model (hook)
 */

var AxisModel = _hook2.default.extend({

  //some hooks can be important. like axis x and y
  //that means, if X or Y doesn't have data at some point, we can't show markers
  _important: true,

  /**
   * Default values for this model
   */
  getClassDefaults: function getClassDefaults() {
    var defaults = {
      use: null,
      which: null,
      domainMin: null,
      domainMax: null,
      zoomedMin: null,
      zoomedMax: null,
      scaleType: "linear",
      allow: {
        scales: ["linear", "log", "genericLog", "time", "pow"]
      }
    };
    return utils.deepExtend(this._super(), defaults);
  },
  autoGenerateModel: function autoGenerateModel() {
    if (this.which == null && this.autogenerate) {

      var concept = this.dataSource.getConceptByIndex(this.autogenerate.conceptIndex, this.autogenerate.conceptType);

      if (!concept) {
        concept = this.dataSource.getConceptByIndex(0, "time");
      }

      this.which = concept.concept;
    }
  },


  _type: "axis",

  /**
   * Validates a color hook
   */
  validate: function validate() {
    this._super();

    //restore the correct object type for time values
    if (this.scale && this.scaleType == "time") {
      var obj = {};
      if (this.zoomedMin != null && !utils.isDate(this.zoomedMin)) obj.zoomedMin = this._space.time.parse(this.zoomedMin.toString());
      if (this.zoomedMax != null && !utils.isDate(this.zoomedMax)) obj.zoomedMax = this._space.time.parse(this.zoomedMax.toString());
      this.set(obj);
    }
  },


  /**
   * Gets the domain for this hook
   * @returns {Array} domain
   */
  buildScale: function buildScale() {
    var scaleType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.scaleType;

    var domain = void 0;

    if (scaleType == "time") {

      var timeMdl = this._space.time;
      var limits = timeMdl.splash ? { min: timeMdl.parse(timeMdl.startOrigin), max: timeMdl.parse(timeMdl.endOrigin) } : { min: timeMdl.start, max: timeMdl.end };

      domain = [limits.min, limits.max];
      this.scale = d3.time.scale.utc().domain(domain);
    } else {

      if (!this.isDiscrete()) {
        var _limits = this.getLimits(this.which);
        //default domain is based on limits
        domain = [_limits.min, _limits.max];
        //min and max can override the domain if defined
        domain[0] = this.domainMin != null ? +this.domainMin : domain[0];
        domain[1] = this.domainMax != null ? +this.domainMax : domain[1];
      } else {
        domain = this.use === "constant" ? [this.which] : this.getUnique(this.which);
      }

      scaleType = d3.min(domain) <= 0 && d3.max(domain) >= 0 && scaleType === "log" ? "genericLog" : scaleType;
      this.scale = d3.scale[scaleType || "linear"]().domain(domain);
    }

    this.scaleType = scaleType;
  },


  /**
   * Formats date according to time in this hook's space
   * @param {Date} date object to format
   * @returns {String} formatted date
   */
  formatDate: function formatDate(dateObject) {
    // improvement would be to check concept type of each space-dimension if it's time.
    // Below code works as long we have one time model: time.
    return this._space.time.formatDate(dateObject);
  }
});

exports.default = AxisModel;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)

var toObject = __webpack_require__(13)
  , toIndex  = __webpack_require__(57)
  , toLength = __webpack_require__(12);
module.exports = function fill(value /*, start = 0, end = @length */){
  var O      = toObject(this)
    , length = toLength(O.length)
    , aLen   = arguments.length
    , index  = toIndex(aLen > 1 ? arguments[1] : undefined, length)
    , end    = aLen > 2 ? arguments[2] : undefined
    , endPos = end === undefined ? length : toIndex(end, length);
  while(endPos > index)O[index++] = value;
  return O;
};

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $defineProperty = __webpack_require__(9)
  , createDesc      = __webpack_require__(44);

module.exports = function(object, index, value){
  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(6)
  , document = __webpack_require__(4).document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};

/***/ }),
/* 94 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

var MATCH = __webpack_require__(7)('match');
module.exports = function(KEY){
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch(e){
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch(f){ /* empty */ }
  } return true;
};

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(4).document && document.documentElement;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

var isObject       = __webpack_require__(6)
  , setPrototypeOf = __webpack_require__(105).set;
module.exports = function(that, target, C){
  var P, S = target.constructor;
  if(S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf){
    setPrototypeOf(that, P);
  } return that;
};

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators  = __webpack_require__(64)
  , ITERATOR   = __webpack_require__(7)('iterator')
  , ArrayProto = Array.prototype;

module.exports = function(it){
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(28);
module.exports = Array.isArray || function isArray(arg){
  return cof(arg) == 'Array';
};

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create         = __webpack_require__(52)
  , descriptor     = __webpack_require__(44)
  , setToStringTag = __webpack_require__(65)
  , IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(18)(IteratorPrototype, __webpack_require__(7)('iterator'), function(){ return this; });

module.exports = function(Constructor, NAME, next){
  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
};

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY        = __webpack_require__(51)
  , $export        = __webpack_require__(0)
  , redefine       = __webpack_require__(19)
  , hide           = __webpack_require__(18)
  , has            = __webpack_require__(14)
  , Iterators      = __webpack_require__(64)
  , $iterCreate    = __webpack_require__(100)
  , setToStringTag = __webpack_require__(65)
  , getPrototypeOf = __webpack_require__(25)
  , ITERATOR       = __webpack_require__(7)('iterator')
  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
  , FF_ITERATOR    = '@@iterator'
  , KEYS           = 'keys'
  , VALUES         = 'values';

var returnThis = function(){ return this; };

module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
  $iterCreate(Constructor, NAME, next);
  var getMethod = function(kind){
    if(!BUGGY && kind in proto)return proto[kind];
    switch(kind){
      case KEYS: return function keys(){ return new Constructor(this, kind); };
      case VALUES: return function values(){ return new Constructor(this, kind); };
    } return function entries(){ return new Constructor(this, kind); };
  };
  var TAG        = NAME + ' Iterator'
    , DEF_VALUES = DEFAULT == VALUES
    , VALUES_BUG = false
    , proto      = Base.prototype
    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , $default   = $native || getMethod(DEFAULT)
    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
    , methods, key, IteratorPrototype;
  // Fix native
  if($anyNative){
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
    if(IteratorPrototype !== Object.prototype){
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if(DEF_VALUES && $native && $native.name !== VALUES){
    VALUES_BUG = true;
    $default = function values(){ return $native.call(this); };
  }
  // Define iterator
  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG]  = returnThis;
  if(DEFAULT){
    methods = {
      values:  DEF_VALUES ? $default : getMethod(VALUES),
      keys:    IS_SET     ? $default : getMethod(KEYS),
      entries: $entries
    };
    if(FORCED)for(key in methods){
      if(!(key in proto))redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

/***/ }),
/* 102 */
/***/ (function(module, exports) {

// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x){
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;

/***/ }),
/* 103 */
/***/ (function(module, exports) {

// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x){
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

var global    = __webpack_require__(4)
  , macrotask = __webpack_require__(112).set
  , Observer  = global.MutationObserver || global.WebKitMutationObserver
  , process   = global.process
  , Promise   = global.Promise
  , isNode    = __webpack_require__(28)(process) == 'process';

module.exports = function(){
  var head, last, notify;

  var flush = function(){
    var parent, fn;
    if(isNode && (parent = process.domain))parent.exit();
    while(head){
      fn   = head.fn;
      head = head.next;
      try {
        fn();
      } catch(e){
        if(head)notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if(parent)parent.enter();
  };

  // Node.js
  if(isNode){
    notify = function(){
      process.nextTick(flush);
    };
  // browsers with MutationObserver
  } else if(Observer){
    var toggle = true
      , node   = document.createTextNode('');
    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
    notify = function(){
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if(Promise && Promise.resolve){
    var promise = Promise.resolve();
    notify = function(){
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function(){
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function(fn){
    var task = {fn: fn, next: undefined};
    if(last)last.next = task;
    if(!head){
      head = task;
      notify();
    } last = task;
  };
};

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(6)
  , anObject = __webpack_require__(3);
var check = function(O, proto){
  anObject(O);
  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function(test, buggy, set){
      try {
        set = __webpack_require__(37)(Function.call, __webpack_require__(24).f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch(e){ buggy = true; }
      return function setPrototypeOf(O, proto){
        check(O, proto);
        if(buggy)O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(83)('keys')
  , uid    = __webpack_require__(58);
module.exports = function(key){
  return shared[key] || (shared[key] = uid(key));
};

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject  = __webpack_require__(3)
  , aFunction = __webpack_require__(17)
  , SPECIES   = __webpack_require__(7)('species');
module.exports = function(O, D){
  var C = anObject(O).constructor, S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(45)
  , defined   = __webpack_require__(29);
// true  -> String#at
// false -> String#codePointAt
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String(defined(that))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

// helper for String#{startsWith, endsWith, includes}
var isRegExp = __webpack_require__(79)
  , defined  = __webpack_require__(29);

module.exports = function(that, searchString, NAME){
  if(isRegExp(searchString))throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toInteger = __webpack_require__(45)
  , defined   = __webpack_require__(29);

module.exports = function repeat(count){
  var str = String(defined(this))
    , res = ''
    , n   = toInteger(count);
  if(n < 0 || n == Infinity)throw RangeError("Count can't be negative");
  for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
  return res;
};

/***/ }),
/* 111 */
/***/ (function(module, exports) {

module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

var ctx                = __webpack_require__(37)
  , invoke             = __webpack_require__(78)
  , html               = __webpack_require__(96)
  , cel                = __webpack_require__(93)
  , global             = __webpack_require__(4)
  , process            = global.process
  , setTask            = global.setImmediate
  , clearTask          = global.clearImmediate
  , MessageChannel     = global.MessageChannel
  , counter            = 0
  , queue              = {}
  , ONREADYSTATECHANGE = 'onreadystatechange'
  , defer, channel, port;
var run = function(){
  var id = +this;
  if(queue.hasOwnProperty(id)){
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function(event){
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if(!setTask || !clearTask){
  setTask = function setImmediate(fn){
    var args = [], i = 1;
    while(arguments.length > i)args.push(arguments[i++]);
    queue[++counter] = function(){
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id){
    delete queue[id];
  };
  // Node.js 0.8-
  if(__webpack_require__(28)(process) == 'process'){
    defer = function(id){
      process.nextTick(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if(MessageChannel){
    channel = new MessageChannel;
    port    = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
    defer = function(id){
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if(ONREADYSTATECHANGE in cel('script')){
    defer = function(id){
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function(id){
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set:   setTask,
  clear: clearTask
};

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global         = __webpack_require__(4)
  , DESCRIPTORS    = __webpack_require__(8)
  , LIBRARY        = __webpack_require__(51)
  , $typed         = __webpack_require__(84)
  , hide           = __webpack_require__(18)
  , redefineAll    = __webpack_require__(55)
  , fails          = __webpack_require__(5)
  , anInstance     = __webpack_require__(50)
  , toInteger      = __webpack_require__(45)
  , toLength       = __webpack_require__(12)
  , gOPN           = __webpack_require__(53).f
  , dP             = __webpack_require__(9).f
  , arrayFill      = __webpack_require__(91)
  , setToStringTag = __webpack_require__(65)
  , ARRAY_BUFFER   = 'ArrayBuffer'
  , DATA_VIEW      = 'DataView'
  , PROTOTYPE      = 'prototype'
  , WRONG_LENGTH   = 'Wrong length!'
  , WRONG_INDEX    = 'Wrong index!'
  , $ArrayBuffer   = global[ARRAY_BUFFER]
  , $DataView      = global[DATA_VIEW]
  , Math           = global.Math
  , RangeError     = global.RangeError
  , Infinity       = global.Infinity
  , BaseBuffer     = $ArrayBuffer
  , abs            = Math.abs
  , pow            = Math.pow
  , floor          = Math.floor
  , log            = Math.log
  , LN2            = Math.LN2
  , BUFFER         = 'buffer'
  , BYTE_LENGTH    = 'byteLength'
  , BYTE_OFFSET    = 'byteOffset'
  , $BUFFER        = DESCRIPTORS ? '_b' : BUFFER
  , $LENGTH        = DESCRIPTORS ? '_l' : BYTE_LENGTH
  , $OFFSET        = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
var packIEEE754 = function(value, mLen, nBytes){
  var buffer = Array(nBytes)
    , eLen   = nBytes * 8 - mLen - 1
    , eMax   = (1 << eLen) - 1
    , eBias  = eMax >> 1
    , rt     = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0
    , i      = 0
    , s      = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0
    , e, m, c;
  value = abs(value)
  if(value != value || value === Infinity){
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if(value * (c = pow(2, -e)) < 1){
      e--;
      c *= 2;
    }
    if(e + eBias >= 1){
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if(value * c >= 2){
      e++;
      c /= 2;
    }
    if(e + eBias >= eMax){
      m = 0;
      e = eMax;
    } else if(e + eBias >= 1){
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for(; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for(; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
};
var unpackIEEE754 = function(buffer, mLen, nBytes){
  var eLen  = nBytes * 8 - mLen - 1
    , eMax  = (1 << eLen) - 1
    , eBias = eMax >> 1
    , nBits = eLen - 7
    , i     = nBytes - 1
    , s     = buffer[i--]
    , e     = s & 127
    , m;
  s >>= 7;
  for(; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for(; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if(e === 0){
    e = 1 - eBias;
  } else if(e === eMax){
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
};

var unpackI32 = function(bytes){
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
};
var packI8 = function(it){
  return [it & 0xff];
};
var packI16 = function(it){
  return [it & 0xff, it >> 8 & 0xff];
};
var packI32 = function(it){
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
};
var packF64 = function(it){
  return packIEEE754(it, 52, 8);
};
var packF32 = function(it){
  return packIEEE754(it, 23, 4);
};

var addGetter = function(C, key, internal){
  dP(C[PROTOTYPE], key, {get: function(){ return this[internal]; }});
};

var get = function(view, bytes, index, isLittleEndian){
  var numIndex = +index
    , intIndex = toInteger(numIndex);
  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b
    , start = intIndex + view[$OFFSET]
    , pack  = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
};
var set = function(view, bytes, index, conversion, value, isLittleEndian){
  var numIndex = +index
    , intIndex = toInteger(numIndex);
  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b
    , start = intIndex + view[$OFFSET]
    , pack  = conversion(+value);
  for(var i = 0; i < bytes; i++)store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
};

var validateArrayBufferArguments = function(that, length){
  anInstance(that, $ArrayBuffer, ARRAY_BUFFER);
  var numberLength = +length
    , byteLength   = toLength(numberLength);
  if(numberLength != byteLength)throw RangeError(WRONG_LENGTH);
  return byteLength;
};

if(!$typed.ABV){
  $ArrayBuffer = function ArrayBuffer(length){
    var byteLength = validateArrayBufferArguments(this, length);
    this._b       = arrayFill.call(Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength){
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH]
      , offset       = toInteger(byteOffset);
    if(offset < 0 || offset > bufferLength)throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if(offset + byteLength > bufferLength)throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if(DESCRIPTORS){
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset){
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset){
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /*, littleEndian */){
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /*, littleEndian */){
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /*, littleEndian */){
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /*, littleEndian */){
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /*, littleEndian */){
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /*, littleEndian */){
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value){
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value){
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /*, littleEndian */){
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /*, littleEndian */){
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /*, littleEndian */){
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /*, littleEndian */){
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /*, littleEndian */){
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /*, littleEndian */){
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if(!fails(function(){
    new $ArrayBuffer;     // eslint-disable-line no-new
  }) || !fails(function(){
    new $ArrayBuffer(.5); // eslint-disable-line no-new
  })){
    $ArrayBuffer = function ArrayBuffer(length){
      return new BaseBuffer(validateArrayBufferArguments(this, length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for(var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j; ){
      if(!((key = keys[j++]) in $ArrayBuffer))hide($ArrayBuffer, key, BaseBuffer[key]);
    };
    if(!LIBRARY)ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2))
    , $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if(view.getInt8(0) || !view.getInt8(1))redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value){
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value){
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

var global         = __webpack_require__(4)
  , core           = __webpack_require__(36)
  , LIBRARY        = __webpack_require__(51)
  , wksExt         = __webpack_require__(176)
  , defineProperty = __webpack_require__(9).f;
module.exports = function(name){
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
};

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

var classof   = __webpack_require__(68)
  , ITERATOR  = __webpack_require__(7)('iterator')
  , Iterators = __webpack_require__(64);
module.exports = __webpack_require__(36).getIteratorMethod = function(it){
  if(it != undefined)return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(62)
  , step             = __webpack_require__(164)
  , Iterators        = __webpack_require__(64)
  , toIObject        = __webpack_require__(21);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(101)(Array, 'Array', function(iterated, kind){
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , kind  = this._k
    , index = this._i++;
  if(!O || index >= O.length){
    this._t = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _buttonlist = __webpack_require__(22);

var _buttonlist2 = _interopRequireDefault(_buttonlist);

var _iconset = __webpack_require__(10);

var iconset = _interopRequireWildcard(_iconset);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*!
 * VIZABI OPTIONSBUTTONLIST
 * Reusable optionsbuttonlist component
 */

//default existing buttons
var class_active = "vzb-active";
// var class_active_locked = "vzb-active-locked";
// var class_expand_dialog = "vzb-dialog-side";
// var class_hide_btn = "vzb-dialog-side-btn";
// var class_unavailable = "vzb-unavailable";
// var class_vzb_fullscreen = "vzb-force-fullscreen";
// var class_container_fullscreen = "vzb-container-fullscreen";

var OptionsButtonList = _buttonlist2.default.extend({

  /**
   * Initializes the buttonlist
   * @param config component configuration
   * @param context component context (parent)
   */
  init: function init(config, context) {

    //set properties
    var _this = this;
    this.name = "gapminder-optionsbuttonlist";

    this._super(config, context);
  },
  readyOnce: function readyOnce() {
    var _this = this;
    Object.keys(this._available_buttons).forEach(function (buttonId) {
      var button = _this._available_buttons[buttonId];
      button.required = !button.required;
    });

    this.buttonListComp = this.root.findChildByName("gapminder-buttonlist");

    this.buttonListComp.on("click", function (evt, button) {
      var btn = _this.element.selectAll(".vzb-buttonlist-btn[data-btn='" + button.id + "']");
      btn.classed(class_active, button.active);
    });

    this.buttonListComp.on("toggle", function (evt, params) {
      var btn = _this.element.selectAll(".vzb-buttonlist-btn");
      var visibleButton = 0;
      btn.each(function (d) {
        var button = d3.select(this);
        var isHidden = params.hiddenButtons.indexOf(d.id) == -1;
        button.style("display", isHidden ? "none" : "");
        if (!isHidden) visibleButton++;
      });
    });

    this._super();
  },
  proceedClick: function proceedClick(id) {
    var _this = this;
    this.buttonListComp.proceedClick(id);
    var btn_data = this.element.selectAll(".vzb-buttonlist-btn[data-btn='" + id + "']").datum();
    if (btn_data.func) {
      setTimeout(function () {
        _this.root.findChildByName("gapminder-dialogs").closeAllDialogs();
      }, 200);
    }
  },
  _toggleButtons: function _toggleButtons() {
    //
  }
});

exports.default = OptionsButtonList;

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _dialog = __webpack_require__(11);

var _dialog2 = _interopRequireDefault(_dialog);

var _globals = __webpack_require__(34);

var _globals2 = _interopRequireDefault(_globals);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * Size dialog
 */

var About = _dialog2.default.extend({

  /**
   * Initializes the dialog component
   * @param config component configuration
   * @param context component context (parent)
   */
  init: function init(config, parent) {
    this.name = "about";

    this._super(config, parent);
  },
  readyOnce: function readyOnce() {
    var version = _globals2.default.version;
    var updated = new Date(parseInt(_globals2.default.build));

    this.element = d3.select(this.element);
    this.element.select(".vzb-about-text0").html("This chart is made with Vizabi,");
    this.element.select(".vzb-about-text1").html("a project by <a href='http://gapminder.org'>Gapminder Foundation</a>");
    this.element.select(".vzb-about-version").html("<a href='https://github.com/Gapminder/vizabi/releases/tag/v" + version + "'>Version: " + version + " (alpha)</a>");
    this.element.select(".vzb-about-updated").html("Build: " + d3.time.format("%Y-%m-%d at %H:%M")(updated));
    this.element.select(".vzb-about-text2").html("Alpha version: don't expect too much!");
    this.element.select(".vzb-about-report").html("<a href='https://getsatisfaction.com/gapminder/'>Report a problem</a>");
    this.element.select(".vzb-about-credits").html("<a href='https://github.com/Gapminder/vizabi/graphs/contributors'>Contributors</a>");
  }
});

exports.default = About;

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _dialog = __webpack_require__(11);

var _dialog2 = _interopRequireDefault(_dialog);

var _indicatorpicker = __webpack_require__(48);

var _indicatorpicker2 = _interopRequireDefault(_indicatorpicker);

var _minmaxinputs = __webpack_require__(88);

var _minmaxinputs2 = _interopRequireDefault(_minmaxinputs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * Axes dialog
 */

var Axes = _dialog2.default.extend({

  /**
   * Initializes the dialog component
   * @param config component configuration
   * @param context component context (parent)
   */
  init: function init(config, parent) {
    this.name = "axes";
    var _this = this;

    this.components = [{
      component: _indicatorpicker2.default,
      placeholder: ".vzb-xaxis-selector",
      model: ["state.time", "state.entities", "state.marker", "locale"],
      markerID: "axis_x"
    }, {
      component: _minmaxinputs2.default,
      placeholder: ".vzb-xaxis-minmax",
      model: ["state.marker", "state.time", "locale"],
      markerID: "axis_x",
      ui: {
        selectDomainMinMax: false,
        selectZoomedMinMax: true
      }
    }, {
      component: _indicatorpicker2.default,
      placeholder: ".vzb-yaxis-selector",
      model: ["state.time", "state.entities", "state.marker", "locale"],
      markerID: "axis_y"
    }, {
      component: _minmaxinputs2.default,
      placeholder: ".vzb-yaxis-minmax",
      model: ["state.marker", "state.time", "locale"],
      markerID: "axis_y",
      ui: {
        selectDomainMinMax: false,
        selectZoomedMinMax: true
      }
    }];

    this._super(config, parent);
  }
});

exports.default = Axes;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _dialog = __webpack_require__(11);

var _dialog2 = _interopRequireDefault(_dialog);

var _minmaxinputs = __webpack_require__(88);

var _minmaxinputs2 = _interopRequireDefault(_minmaxinputs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * Axes dialog
 */

var Axes = _dialog2.default.extend({

  /**
   * Initializes the dialog component
   * @param config component configuration
   * @param context component context (parent)
   */
  init: function init(config, parent) {
    this.name = "axesmc";
    var _this = this;

    this.model_binds = {
      "change:ui.chart.xLogStops": function changeUiChartXLogStops() {
        _this.updateView();
      },
      "change:ui.chart.yMaxMethod": function changeUiChartYMaxMethod() {
        _this.updateView();
      }
    };

    this.components = [{
      component: _minmaxinputs2.default,
      placeholder: ".vzb-xlimits-container",
      model: ["state.marker", "state.time", "locale"],
      markerID: "axis_x",
      ui: {
        selectDomainMinMax: false,
        selectZoomedMinMax: true
      }
    }];

    this._super(config, parent);
  },
  readyOnce: function readyOnce() {
    this._super();

    var _this = this;

    this.yMaxRadio = this.element.select(".vzb-yaxis-container").selectAll("input").on("change", function () {
      _this.setModel("yMaxMethod", d3.select(this).node().value);
    });

    this.xLogStops = this.element.select(".vzb-xaxis-container").selectAll("input").on("change", function () {
      _this.setModel("xLogStops", d3.select(this).node().value);
    });

    this.probeCheck = this.element.select(".vzb-probe-check").on("change", function () {
      _this.setModel("showProbeX", d3.select(this).property("checked"));
    });

    this.probeFieldEl = this.element.select(".vzb-probe-field").on("change", function () {
      var result = parseFloat(this.value.replace(",", "."));
      if (!result || result <= _this.model.state.marker.axis_x.tailCutX) {
        this.value = _this.model.ui.chart.probeX;
        return;
      } else if (result > _this.model.state.marker.axis_x.domainMax) {
        result = _this.model.state.marker.axis_x.domainMax;
      }
      this.value = result;
      _this.setModel("probeX", result);
    });

    this.updateView();
  },
  updateView: function updateView() {
    var _this = this;

    this.yMaxRadio.property("checked", function () {
      return d3.select(this).node().value === _this.model.ui.chart.yMaxMethod;
    });
    this.xLogStops.property("checked", function () {
      return _this.model.ui.chart.xLogStops.indexOf(+d3.select(this).node().value) !== -1;
    });
    this.probeCheck.property("checked", this.model.ui.chart.showProbeX);
    this.probeFieldEl.property("value", this.model.ui.chart.probeX);
  },
  setModel: function setModel(what, value) {
    var result = void 0;

    if (what == "yMaxMethod") {
      result = value;
    }
    if (what == "xLogStops") {
      result = [];
      this.xLogStops.each(function () {
        if (d3.select(this).property("checked")) result.push(+d3.select(this).node().value);
      });
    }
    if (what == "probeX" || what == "showProbeX") {
      result = value;
    }

    this.model.ui.chart[what] = result;
  }
});

exports.default = Axes;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _dialog = __webpack_require__(11);

var _dialog2 = _interopRequireDefault(_dialog);

var _colorlegend = __webpack_require__(87);

var _colorlegend2 = _interopRequireDefault(_colorlegend);

var _indicatorpicker = __webpack_require__(48);

var _indicatorpicker2 = _interopRequireDefault(_indicatorpicker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*!
 * VIZABI COLOR DIALOG
 */

var Colors = _dialog2.default.extend({

  /**
   * Initializes the dialog component
   * @param config component configuration
   * @param context component context (parent)
   */
  init: function init(config, parent) {
    this.name = "colors";

    this.components = [{
      component: _indicatorpicker2.default,
      placeholder: ".vzb-caxis-selector",
      model: ["state.time", "state.entities", "state.marker", "locale"],
      markerID: "color",
      showHoverValues: true
    }, {
      component: _colorlegend2.default,
      placeholder: ".vzb-clegend-container",
      model: ["state.time", "state.entities", "state.marker", "locale"]
    }];

    this._super(config, parent);
  }
});

exports.default = Colors;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _dialog = __webpack_require__(11);

var _dialog2 = _interopRequireDefault(_dialog);

var _simpleslider = __webpack_require__(67);

var _simpleslider2 = _interopRequireDefault(_simpleslider);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*!
 * VIZABI FIND CONTROL
 * Reusable find dialog
 */

var Find = _dialog2.default.extend({
  init: function init(config, parent) {
    this.name = "find";
    var _this = this;

    this.components = [{
      component: _simpleslider2.default,
      placeholder: ".vzb-dialog-bubbleopacity",
      model: ["state.marker"],
      arg: "opacitySelectDim",
      properties: { step: 0.01 }
    }];

    this.model_binds = {
      "change:state.marker.select": function changeStateMarkerSelect(evt) {
        _this.selectDataPoints();
        _this.showHideDeselect();
      },
      "change:state.time.playing": function changeStateTimePlaying(evt) {
        if (!_this.model.state.time.playing) {
          _this.time = _this.model.state.time.value;

          _this.model.state.marker.getFrame(_this.time, function (values, time) {
            if (!values || _this.time - time) return;
            _this.redrawDataPoints(values);
          });
        }
      },
      "change:state.time.value": function changeStateTimeValue(evt) {
        // hide changes if the dialog is not visible
        if (!_this.placeholderEl.classed("vzb-active") && !_this.placeholderEl.classed("vzb-sidebar")) return;

        _this.time = _this.model.state.time.value;

        _this.model.state.marker.getFrame(_this.time, function (values) {
          if (!values) return;
          _this.redrawDataPoints(values);
        });
      },
      "translate:locale": function translateLocale() {
        _this.input_search.attr("placeholder", _this.translator("placeholder/search") + "...");
      }
    };

    this._super(config, parent);
  },


  /**
   * Grab the list div
   */
  readyOnce: function readyOnce() {
    this._super();

    this.list = this.element.select(".vzb-find-list");
    this.input_search = this.element.select(".vzb-find-search");
    this.deselect_all = this.element.select(".vzb-find-deselect");
    this.opacity_nonselected = this.element.select(".vzb-dialog-bubbleopacity");

    this.KEY = this.model.state.entities.getDimension();

    var _this = this;

    this.input_search.on("keyup", function () {
      var event = d3.event;
      if (event.keyCode == 13 && _this.input_search.node().value == "select all") {
        _this.input_search.node().value = "";
        //clear highlight so it doesn't get in the way when selecting an entity
        if (!utils.isTouchDevice()) _this.model.state.marker.clearHighlighted();
        _this.model.state.marker.selectAll();
      }
    });

    this.input_search.on("input", function () {
      _this.showHideSearch();
    });

    this.deselect_all.on("click", function () {
      _this.deselectMarkers();
    });

    this.translator = this.model.locale.getTFunction();
    this.input_search.attr("placeholder", this.translator("placeholder/search") + "...");

    //make sure it refreshes when all is reloaded
    this.root.on("ready", function () {
      _this.ready();
    });
  },
  open: function open() {
    var _this = this;
    this._super();

    this.input_search.node().value = "";
    this.showHideSearch();

    this.time = this.model.state.time.value;

    this.model.state.marker.getFrame(this.time, function (values) {
      if (!values) return;
      _this.redrawDataPoints(values);
    });
  },


  /**
   * Build the list everytime it updates
   */
  //TODO: split update in render and update methods
  ready: function ready() {
    this._super();

    var _this = this;
    var KEY = this.KEY;

    this.time = this.model.state.time.value;
    this.model.state.marker.getFrame(this.time, function (values) {
      if (!values) return;

      var data = _this.model.state.marker.getKeys().map(function (d) {
        var pointer = {};
        pointer[KEY] = d[KEY];
        pointer.brokenData = false;
        pointer.name = values.label[d[KEY]];

        return pointer;
      });

      //sort data alphabetically
      data.sort(function (a, b) {
        return a.name < b.name ? -1 : 1;
      });

      _this.list.html("");

      _this.items = _this.list.selectAll(".vzb-find-item").data(data).enter().append("div").attr("class", "vzb-find-item vzb-dialog-checkbox");

      _this.items.append("input").attr("type", "checkbox").attr("class", "vzb-find-item").attr("id", function (d) {
        return "-find-" + d[KEY] + "-" + _this._id;
      }).on("change", function (d) {
        //clear highlight so it doesn't get in the way when selecting an entity
        if (!utils.isTouchDevice()) _this.model.state.marker.clearHighlighted();
        _this.model.state.marker.selectMarker(d);
        //return to highlighted state
        if (!utils.isTouchDevice() && !d.brokenData) _this.model.state.marker.highlightMarker(d);
      });

      _this.items.append("label").attr("for", function (d) {
        return "-find-" + d[KEY] + "-" + _this._id;
      }).text(function (d) {
        return d.name;
      }).on("mouseover", function (d) {
        if (!utils.isTouchDevice() && !d.brokenData) _this.model.state.marker.highlightMarker(d);
      }).on("mouseout", function (d) {
        if (!utils.isTouchDevice()) _this.model.state.marker.clearHighlighted();
      });
      utils.preventAncestorScrolling(_this.element.select(".vzb-dialog-scrollable"));

      _this.redrawDataPoints(values);
      _this.selectDataPoints();
      _this.showHideSearch();
      _this.showHideDeselect();
    });
  },
  redrawDataPoints: function redrawDataPoints(values) {
    var _this = this;
    var KEY = this.KEY;

    _this.items.each(function (d) {
      var view = d3.select(this).select("label");

      d.brokenData = false;
      utils.forEach(values, function (hook, name) {
        //TODO: remove the hack with hardcoded hook names (see discussion in #1389)
        if (name !== "color" && name !== "size_label" && _this.model.state.marker[name].use !== "constant" && !hook[d[KEY]] && hook[d[KEY]] !== 0) {
          d.brokenData = true;
        }
      });

      view.classed("vzb-find-item-brokendata", d.brokenData).attr("title", d.brokenData ? _this.model.state.time.formatDate(_this.time) + ": " + _this.translator("hints/nodata") : "");
    });
  },
  selectDataPoints: function selectDataPoints() {
    var KEY = this.KEY;
    var selected = this.model.state.marker.getSelected(KEY);
    this.items.selectAll("input").property("checked", function (d) {
      return selected.indexOf(d[KEY]) !== -1;
    });
  },
  showHideSearch: function showHideSearch() {
    var search = this.input_search.node().value || "";
    search = search.toLowerCase();

    this.list.selectAll(".vzb-find-item").classed("vzb-hidden", function (d) {
      var lower = (d.name || "").toLowerCase();
      return lower.indexOf(search) === -1;
    });
  },
  showHideDeselect: function showHideDeselect() {
    var someSelected = !!this.model.state.marker.select.length;
    this.deselect_all.classed("vzb-hidden", !someSelected);
    this.opacity_nonselected.classed("vzb-hidden", !someSelected);
  },
  deselectMarkers: function deselectMarkers() {
    this.model.state.marker.clearSelected();
  },
  transitionEnd: function transitionEnd(event) {
    this._super(event);

    if (!utils.isTouchDevice()) this.input_search.node().focus();
  }
});

exports.default = Find;

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _dialog = __webpack_require__(11);

var _dialog2 = _interopRequireDefault(_dialog);

var _sizeslider = __webpack_require__(136);

var _sizeslider2 = _interopRequireDefault(_sizeslider);

var _indicatorpicker = __webpack_require__(48);

var _indicatorpicker2 = _interopRequireDefault(_indicatorpicker);

var _simplecheckbox = __webpack_require__(59);

var _simplecheckbox2 = _interopRequireDefault(_simplecheckbox);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * Label dialog
 */

var Label = _dialog2.default.extend({

  /**
   * Initializes the dialog component
   * @param config component configuration
   * @param context component context (parent)
   */
  init: function init(config, parent) {
    this.name = "label";

    // in dialog, this.model_expects = ["state", "data"];

    this.components = [{
      component: _sizeslider2.default,
      placeholder: ".vzb-dialog-sizeslider",
      model: ["state.marker.size_label", "locale"],
      propertyname: "LabelTextSize",
      ui: {
        constantUnit: "unit/pixels"
      }
    }, {
      component: _indicatorpicker2.default,
      placeholder: ".vzb-saxis-selector",
      model: ["state.time", "state.entities", "state.marker", "locale"],
      markerID: "size_label",
      showHoverValues: true
    }, {
      component: _simplecheckbox2.default,
      placeholder: ".vzb-removelabelbox-switch",
      model: ["ui.chart", "locale"],
      checkbox: "removeLabelBox",
      submodel: "labels"
    }];

    this._super(config, parent);
  }
});

exports.default = Label;

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _dialog = __webpack_require__(11);

var _dialog2 = _interopRequireDefault(_dialog);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * Axes dialog
 */

var Mapoptions = _dialog2.default.extend({

  /**
   * Initializes the dialog component
   * @param config component configuration
   * @param context component context (parent)
   */

  init: function init(config, context) {
    this.name = "mapoptions";
    this.selectedLayer = {};
    this.mapEngines = [{
      title: "Topojson",
      value: "topojson"
    }, {
      title: "Google",
      value: "google"
    }, {
      title: "Mapbox",
      value: "mapbox"
    }];

    this.mapLayers = {
      "google": [{
        title: "Land",
        value: "terrain"
      }, {
        title: "Satellite",
        value: "satellite"
      }],
      mapbox: [{
        title: "Land",
        value: "mapbox://styles/mapbox/streets-v9"
      }, {
        title: "Satellite",
        value: "mapbox://styles/mapbox/satellite-v9"
      }, {
        title: "Satellite Street",
        value: "mapbox://styles/mapbox/satellite-streets-v9"
      }]
    };

    this.components = [];

    this._super(config, context);
  },
  readyOnce: function readyOnce() {
    this._super();

    // save last used layer for map
    this.selectedLayer[this.model.ui.map.mapEngine] = this.model.ui.map.mapLayer;
    var _this = this;
    this.mapEngineForm = this.element.select(".vzb-dialog-paragraph.map-api").selectAll("input").data(_this.mapEngines);

    this.mapEngineForm.exit().remove();

    this.mapEngineForm.enter().append("label").attr("for", function (d, i) {
      return "a" + i;
    }).each(function (d, i) {
      d3.select(this).append("input").attr("id", "a" + i).attr("type", "radio").attr("name", "engine").attr("value", d.value).property("checked", d.value == _this.model.ui.map.mapEngine).on("change", function () {
        return _this.setModel("mapEngine", d.value);
      });
      d3.select(this).append("span").text(d.title);
    });
    this.updateView();
  },
  updateView: function updateView() {
    var _this = this;
    this.element.select(".vzb-dialog-paragraph.map-layer").selectAll("label").remove();
    var data = _this.mapLayers[_this.model.ui.map.mapEngine] ? _this.mapLayers[_this.model.ui.map.mapEngine] : [];
    this.mapLayerForm = this.element.select(".vzb-dialog-paragraph.map-layer").selectAll("label").data(data);

    this.mapLayerForm.enter().append("label").attr("for", function (d, i) {
      return "a" + i;
    }).each(function (d, i) {
      d3.select(this).append("input").attr("id", "a" + i).attr("type", "radio").attr("name", "layer").attr("value", d.value).property("checked", d.value == _this.selectedLayer[_this.model.ui.map.mapEngine]).on("change", function () {
        return _this.setModel("mapLayer", d.value);
      });
      d3.select(this).append("span").text(d.title);
    });
  },
  setModel: function setModel(what, value) {
    if (what == "mapEngine" && this.model.ui.map.mapEngine != value) {
      if (!this.selectedLayer[value]) this.selectedLayer[value] = this.mapLayers[value] ? this.mapLayers[value][0].value : null;
      this.model.ui.map.mapEngine = value;
      this.updateView();
      this.model.ui.map.mapLayer = this.selectedLayer[value];
    }
    if (what == "mapLayer") {
      this.selectedLayer[this.model.ui.map.mapEngine] = value;
      this.model.ui.map.mapLayer = value;
    }
  }
});

exports.default = Mapoptions;

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _dialog = __webpack_require__(11);

var _dialog2 = _interopRequireDefault(_dialog);

var _simpleslider = __webpack_require__(67);

var _simpleslider2 = _interopRequireDefault(_simpleslider);

var _bubblesize = __webpack_require__(86);

var _bubblesize2 = _interopRequireDefault(_bubblesize);

var _colorlegend = __webpack_require__(87);

var _colorlegend2 = _interopRequireDefault(_colorlegend);

var _indicatorpicker = __webpack_require__(48);

var _indicatorpicker2 = _interopRequireDefault(_indicatorpicker);

var _simplecheckbox = __webpack_require__(59);

var _simplecheckbox2 = _interopRequireDefault(_simplecheckbox);

var _optionsbuttonlist = __webpack_require__(117);

var _optionsbuttonlist2 = _interopRequireDefault(_optionsbuttonlist);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * More options dialog
 */

var MoreOptions = _dialog2.default.extend({

  /**
   * Initializes the dialog component
   * @param config component configuration
   * @param context component context (parent)
   */
  init: function init(config, parent) {
    this.name = "moreoptions";

    //specifying components
    this.components = [{
      component: _optionsbuttonlist2.default,
      placeholder: ".vzb-dialog-options-buttonlist",
      model: ["state", "ui", "locale"]
    }];

    this._super(config, parent);
  },
  readyOnce: function readyOnce() {
    this._super();

    var _this = this;
    this.accordionEl = this.contentEl.select(".vzb-accordion");

    this.on("dragend", function () {
      _this._setMaxHeight();
    });

    var dialog_popup = (this.model.ui.dialogs || {}).popup || [];
    var dialog_moreoptions = (this.model.ui.dialogs || {}).moreoptions || [];

    // if dialog_moreoptions has been passed in with boolean param or array must check and covert to array
    if (dialog_moreoptions === true) {
      dialog_moreoptions = dialog_popup;
      (this.model.ui.dialogs || {}).moreoptions = dialog_moreoptions;
    }

    this._addDialogs(dialog_moreoptions);

    //accordion
    if (this.accordionEl) {
      var titleEl = this.accordionEl.selectAll(".vzb-accordion-section").select(".vzb-dialog-title>span:first-child");
      titleEl.on("click", function (d) {
        var element = _this.components[d.component].element;
        var sectionEl = _this.components[d.component].placeholderEl;
        var activeEl = _this.accordionEl.select(".vzb-accordion-active");
        if (activeEl) {
          activeEl.classed("vzb-accordion-active", false);
        }
        if (sectionEl.node() !== activeEl.node()) {
          sectionEl.classed("vzb-accordion-active", true);
        }
      });
    }
  },
  _addDialogs: function _addDialogs(dialog_list) {
    this._components_config = [];
    var details_dlgs = [];
    if (!dialog_list.length) return;
    //add a component for each dialog
    for (var i = 0; i < dialog_list.length; i++) {

      //check moreoptions in dialog.moreoptions
      if (dialog_list[i] === "moreoptions") continue;

      var dlg = dialog_list[i];
      var dlg_config = utils.deepClone(this.parent._available_dialogs[dlg]);

      //if it's a dialog, add component
      if (dlg_config && dlg_config.dialog) {
        var comps = this._components_config;

        //add corresponding component
        comps.push({
          component: dlg_config.dialog,
          placeholder: '.vzb-dialogs-dialog[data-dlg="' + dlg + '"]',
          model: ["state", "ui", "locale"]
        });

        dlg_config.component = comps.length - 1;

        dlg_config.id = dlg;
        details_dlgs.push(dlg_config);
      }
    }

    this.accordionEl.selectAll("div").data(details_dlgs).enter().append("div").attr("class", function (d) {
      var cls = "vzb-dialogs-dialog vzb-moreoptions vzb-accordion-section";
      return cls;
    }).attr("data-dlg", function (d) {
      return d.id;
    });

    this.loadSubComponents();

    var _this = this;
    //render each subcomponent
    utils.forEach(this.components, function (subcomp) {
      subcomp.render();
      _this.on("resize", function () {
        subcomp.trigger("resize");
      });
    });
  }
});

exports.default = MoreOptions;

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _dialog = __webpack_require__(11);

var _dialog2 = _interopRequireDefault(_dialog);

var _simpleslider = __webpack_require__(67);

var _simpleslider2 = _interopRequireDefault(_simpleslider);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * Size dialog
 */

var Opacity = _dialog2.default.extend({

  /**
   * Initializes the dialog component
   * @param config component configuration
   * @param context component context (parent)
   */
  init: function init(config, parent) {
    this.name = "opacity";

    // in dialog, this.model_expects = ["state", "data"];

    this.components = [{
      component: _simpleslider2.default,
      placeholder: ".vzb-dialog-bubbleopacity-regular",
      model: ["state.marker"],
      arg: "opacityRegular",
      properties: { step: 0.01 }
    }, {
      component: _simpleslider2.default,
      placeholder: ".vzb-dialog-bubbleopacity-selectdim",
      model: ["state.marker"],
      arg: "opacitySelectDim",
      properties: { step: 0.01 }
    }];

    this._super(config, parent);
  }
});

exports.default = Opacity;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _dialog = __webpack_require__(11);

var _dialog2 = _interopRequireDefault(_dialog);

var _simplecheckbox = __webpack_require__(59);

var _simplecheckbox2 = _interopRequireDefault(_simplecheckbox);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * Size dialog
 */

var Presentation = _dialog2.default.extend({

  /**
   * Initializes the dialog component
   * @param config component configuration
   * @param context component context (parent)
   */
  init: function init(config, parent) {
    this.name = "presentation";

    // in dialog, this.model_expects = ["state", "data"];

    this.components = [{
      component: _simplecheckbox2.default,
      placeholder: ".vzb-presentationmode-switch",
      model: ["ui", "locale"],
      checkbox: "presentation"
    }];

    this._super(config, parent);
  }
});

exports.default = Presentation;

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _dialog = __webpack_require__(11);

var _dialog2 = _interopRequireDefault(_dialog);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*!
 * VIZABI SHOW CONTROL
 * Reusable show dialog
 */

var Show = _dialog2.default.extend({
  init: function init(config, parent) {
    this.name = "show";
    var _this = this;

    this.model_binds = {
      "change:state.entities.show": function changeStateEntitiesShow(evt) {
        _this.redraw();
      }
    };

    this._super(config, parent);
  },


  /**
   * Grab the list div
   */
  readyOnce: function readyOnce() {
    this._super();
    this.list = this.element.select(".vzb-show-list");
    this.input_search = this.element.select(".vzb-show-search");
    this.deselect_all = this.element.select(".vzb-show-deselect");

    this.KEY = this.model.state.entities.getDimension();
    this.TIMEDIM = this.model.state.time.getDimension();

    var _this = this;
    this.input_search.on("input", function () {
      _this.showHideSearch();
    });

    this.deselect_all.on("click", function () {
      _this.deselectEntities();
    });

    //make sure it refreshes when all is reloaded
    this.root.on("ready", function () {
      _this.redraw();
    });
  },
  open: function open() {
    this._super();

    this.input_search.node().value = "";
    this.showHideSearch();
  },
  ready: function ready() {
    this._super();
    this.redraw();
    utils.preventAncestorScrolling(this.element.select(".vzb-dialog-scrollable"));
  },
  redraw: function redraw() {

    var _this = this;
    this.translator = this.model.locale.getTFunction();

    this.model.state.marker_allpossible.getFrame(this.model.state.time.value, function (values) {
      if (!values) return;
      var data = utils.keys(values.label).map(function (d) {
        var result = {};
        result[_this.KEY] = d;
        result["label"] = values.label[d];
        return result;
      });

      //sort data alphabetically
      data.sort(function (a, b) {
        return a.label < b.label ? -1 : 1;
      });

      _this.list.html("");

      var items = _this.list.selectAll(".vzb-show-item").data(data).enter().append("div").attr("class", "vzb-show-item vzb-dialog-checkbox");

      items.append("input").attr("type", "checkbox").attr("class", "vzb-show-item").attr("id", function (d) {
        return "-show-" + d[_this.KEY] + "-" + _this._id;
      }).property("checked", function (d) {
        return _this.model.state.entities.isShown(d);
      }).on("change", function (d) {

        _this.model.state.marker.clearSelected();
        _this.model.state.entities.showEntity(d);
        _this.showHideDeselect();
      });

      items.append("label").attr("for", function (d) {
        return "-show-" + d[_this.KEY] + "-" + _this._id;
      }).text(function (d) {
        return d.label;
      });

      _this.input_search.attr("placeholder", _this.translator("placeholder/search") + "...");

      _this.showHideSearch();
      _this.showHideDeselect();
    });
  },
  showHideSearch: function showHideSearch() {

    var search = this.input_search.node().value || "";
    search = search.toLowerCase();

    this.list.selectAll(".vzb-show-item").classed("vzb-hidden", function (d) {
      var lower = d.label.toLowerCase();
      return lower.indexOf(search) === -1;
    });
  },
  showHideDeselect: function showHideDeselect() {
    var show = this.model.state.entities.show[this.KEY];
    this.deselect_all.classed("vzb-hidden", !show || show.length == 0);
  },
  deselectEntities: function deselectEntities() {
    this.model.state.entities.clearShow();
    this.showHideDeselect();
  },
  transitionEnd: function transitionEnd(event) {
    this._super(event);

    if (!utils.isTouchDevice()) this.input_search.node().focus();
  }
});

exports.default = Show;

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _dialog = __webpack_require__(11);

var _dialog2 = _interopRequireDefault(_dialog);

var _indicatorpicker = __webpack_require__(48);

var _indicatorpicker2 = _interopRequireDefault(_indicatorpicker);

var _simplecheckbox = __webpack_require__(59);

var _simplecheckbox2 = _interopRequireDefault(_simplecheckbox);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*!
 * VIZABI SIDE CONTROL
 * Reusable side dialog
 */

var Side = _dialog2.default.extend({
  init: function init(config, parent) {
    this.name = "side";
    var _this = this;

    this.model_binds = {
      "change:state.marker.side.which": function changeStateMarkerSideWhich(evt) {
        if (_this.model.state.entities_allpossibleside) {
          var sideDim = _this.model.state.marker.side.use == "constant" ? null : _this.model.state.marker.side.which;
          _this.model.state.entities_allpossibleside.set("dim", sideDim);
        }
      },
      "change:state.entities_side.show": function changeStateEntities_sideShow(evt) {
        if (!_this._readyOnce) return;
        _this.updateState();
        _this.redraw();
      },
      "change:ui.chart.flipSides": function changeUiChartFlipSides(evt) {
        if (!_this._readyOnce) return;
        _this.updateState();
        _this.redraw();
      }

    };

    this.components = [{
      component: _indicatorpicker2.default,
      placeholder: ".vzb-side-selector",
      model: ["state.time", "state.entities_side", "state.marker", "locale"],
      markerID: "side",
      showHoverValues: false
    }];

    this._super(config, parent);
  },


  /**
   * Grab the list div
   */
  readyOnce: function readyOnce() {
    this._super();
    this.listLeft = this.element.select(".vzb-side-list-left");
    this.listRight = this.element.select(".vzb-side-list-right");
    this.switchSides = this.element.select(".vzb-side-switch-sides");

    this.TIMEDIM = this.model.state.time.getDimension();
    this.state = {};
    var _this = this;

    this.switchSides.on("click", function () {
      _this.model.ui.chart.flipSides = !_this.model.ui.chart.flipSides;
    });

    //make sure it refreshes when all is reloaded
    this.root.on("ready", function () {
      _this.redraw();
    });
  },
  ready: function ready() {
    this._super();

    this.KEY = this.model.state.entities_side.getDimension();
    this.updateState();
    this.redraw();
    utils.preventAncestorScrolling(this.element.select(".vzb-dialog-scrollable"));
  },
  updateState: function updateState() {
    var _this = this;
    var sideDim = this.model.state.marker.side.getEntity().getDimension();
    var modelSide = this.model.state.marker.side;

    this.state["right"] = {};
    this.state["left"] = {};
    if (modelSide.state["left"][sideDim] && modelSide.state["right"][sideDim]) {
      this.state["left"][sideDim] = modelSide.state["left"][sideDim];
      this.state["right"][sideDim] = modelSide.state["right"][sideDim];
    } else {
      var sides = this.model.state.marker.getKeys(sideDim);
      var sideKeys = [];
      var sideFiltered = !!this.model.state.marker.side.getEntity().show[sideDim];
      sideKeys = sides.filter(function (f) {
        return !sideFiltered || _this.model.state.marker.side.getEntity().isShown(f);
      }).map(function (m) {
        return m[sideDim];
      });

      if (sideKeys.length > 2) sideKeys.length = 2;
      if (sideKeys.length > 1) {
        var sortFunc = this.ui.chart.flipSides ? d3.ascending : d3.descending;
        sideKeys.sort(sortFunc);
      }

      this.state["right"] = {};
      this.state["right"][sideDim] = sideKeys[0];
      this.state["left"] = {};
      this.state["left"][sideDim] = sideKeys[1] ? sideKeys[1] : sideKeys[0];
    }

    var hidden = this.model.state.marker.side.use == "constant";

    this.listLeft.classed("vzb-hidden", hidden);
    this.listRight.classed("vzb-hidden", hidden);
    this.switchSides.classed("vzb-hidden", hidden || this.state["left"][sideDim] == this.state["right"][sideDim]);
  },
  redraw: function redraw() {

    var _this = this;
    this.translator = this.model.locale.getTFunction();

    if (!_this.model.state.entities_allpossibleside.dim) return;
    this.model.state.marker_allpossibleside.getFrame(this.model.state.time.value, function (values) {
      if (!values) return;
      var data = utils.keys(values.label).map(function (d) {
        var result = {};
        result[_this.KEY] = d;
        result["label"] = values.label[d];
        return result;
      });

      //sort data alphabetically
      data.sort(function (a, b) {
        return a.label < b.label ? -1 : 1;
      });

      _this.listLeft.html("");
      _this.listRight.html("");
      _this.createList(_this.listLeft, "left", data);
      _this.createList(_this.listRight, "right", data);
    });
  },
  createList: function createList(listSel, name, data) {
    var _this = this;
    var sideDim = this.model.state.marker.side.getEntity().getDimension();

    var items = listSel.selectAll(".vzb-side-item").data(data).enter().append("div").attr("class", "vzb-side-item vzb-dialog-radio");

    items.append("input").attr("type", "radio").attr("name", name + "-" + _this._id).attr("class", "vzb-side-item").attr("id", function (d) {
      return "-side-" + name + "-" + d[sideDim] + "-" + _this._id;
    }).property("checked", function (d) {
      return _this.state[name][sideDim] === d[sideDim];
    }).on("change", function (d, i) {
      var sideEntities = _this.model.state.entities_side;
      var sideDim = sideEntities.getDimension();
      var otherSide = name == "left" ? "right" : "left";
      var modelSide = _this.model.state.marker.side;

      modelSide.state[name][sideDim] = d[sideDim];
      modelSide.state[otherSide][sideDim] = _this.state[otherSide][sideDim];

      var showArray = [];

      if (!sideEntities.isShown(d)) {
        showArray.push(d);
      }
      if (d[sideDim] !== _this.state[otherSide][sideDim] && !sideEntities.isShown(_this.state[otherSide])) {
        showArray.push(_this.state[otherSide]);
      }
      if (_this.state[name][sideDim] !== _this.state[otherSide][sideDim] && sideEntities.isShown(_this.state[name])) {
        showArray.push(_this.state[name]);
      }

      if (d[sideDim] !== _this.state[otherSide][sideDim]) {
        var sideKeys = [d[sideDim], _this.state[otherSide][sideDim]];
        var sortFunc = _this.ui.chart.flipSides ? d3.ascending : d3.descending;
        sideKeys.sort(sortFunc);
        if (sideKeys[name == "left" ? 0 : 1] == d[sideDim]) {
          _this.model.state.marker.side.switchSideState();
          _this.ui.chart.flipSides = !_this.ui.chart.flipSides;
        }
      }

      if (showArray.length) {
        sideEntities.showEntity(showArray);
      }
    });

    items.append("label").attr("for", function (d) {
      return "-side-" + name + "-" + d[_this.KEY] + "-" + _this._id;
    }).text(function (d) {
      return d.label;
    });
  }
});

exports.default = Side;

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _dialog = __webpack_require__(11);

var _dialog2 = _interopRequireDefault(_dialog);

var _bubblesize = __webpack_require__(86);

var _bubblesize2 = _interopRequireDefault(_bubblesize);

var _indicatorpicker = __webpack_require__(48);

var _indicatorpicker2 = _interopRequireDefault(_indicatorpicker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * Size dialog
 */

var Size = _dialog2.default.extend({

  /**
   * Initializes the dialog component
   * @param config component configuration
   * @param context component context (parent)
   */
  init: function init(config, parent) {
    this.name = "size";

    // in dialog, this.model_expects = ["state", "ui", "locale"];

    this.components = [{
      component: _indicatorpicker2.default,
      placeholder: ".vzb-saxis-selector",
      model: ["state.time", "state.entities", "state.marker", "locale"],
      markerID: "size",
      showHoverValues: true
    }];

    // config.ui is same as this.model.ui here but this.model.ui is not yet available because constructor hasn't been called.
    // can't call constructor earlier because this.components needs to be complete before calling constructor
    if (!config.ui.chart || config.ui.chart.sizeSelectorActive !== 0) {
      this.components.push({
        component: _bubblesize2.default,
        placeholder: ".vzb-dialog-bubblesize",
        model: ["state.marker.size"],
        ui: {
          show_button: false
        }
      });
    }

    this._super(config, parent);
  }
});

exports.default = Size;

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _dialog = __webpack_require__(11);

var _dialog2 = _interopRequireDefault(_dialog);

var _simpleslider = __webpack_require__(67);

var _simpleslider2 = _interopRequireDefault(_simpleslider);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * Size dialog
 */

var Speed = _dialog2.default.extend({

  /**
   * Initializes the dialog component
   * @param config component configuration
   * @param context component context (parent)
   */
  init: function init(config, parent) {
    this.name = "speed";

    // in dialog, this.model_expects = ["state", "data"];

    this.components = [{
      component: _simpleslider2.default,
      placeholder: ".vzb-dialog-placeholder",
      model: ["state.time"],
      arg: "delay",
      properties: { min: 1, max: 6, step: 0.1, scale: d3.scale.linear().domain([1, 2, 3, 4, 5, 6]).range([1200, 900, 450, 200, 150, 100])
      }
    }];

    this._super(config, parent);
  }
});

exports.default = Speed;

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _dialog = __webpack_require__(11);

var _dialog2 = _interopRequireDefault(_dialog);

var _draggablelist = __webpack_require__(135);

var _draggablelist2 = _interopRequireDefault(_draggablelist);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * stack dialog
 */

var Stack = _dialog2.default.extend({

  /**
   * Initializes the dialog component
   * @param config component configuration
   * @param context component context (parent)
   */
  init: function init(config, parent) {
    this.name = "stack";
    var _this = this;

    // in dialog, this.model_expects = ["state", "ui", "locale"];

    this.components = [{
      component: _draggablelist2.default,
      placeholder: ".vzb-dialog-draggablelist",
      model: ["state.marker.group", "state.marker.color", "locale", "ui.chart"],
      groupID: "manualSorting",
      isEnabled: "manualSortingEnabled",
      dataArrFn: _this.manualSorting.bind(_this),
      lang: ""
    }];

    this.model_binds = {
      "change:state.marker.group": function changeStateMarkerGroup(evt) {
        //console.log("group change " + evt);
        if (!_this._ready) return;
        _this.updateView();
      }
    };

    this._super(config, parent);
  },
  readyOnce: function readyOnce() {
    this._super();

    var _this = this;
    this.group = this.model.state.marker.group;
    this.stack = this.model.state.marker.stack;

    this.howToStackEl = this.element.select(".vzb-howtostack").selectAll("input").on("change", function () {
      _this.setModel("stack", d3.select(this).node().value);
    });
    this.howToMergeEl = this.element.select(".vzb-howtomerge").selectAll("input").on("change", function () {
      _this.setModel("merge", d3.select(this).node().value);
    });

    this.updateView();
  },
  ready: function ready() {
    this._super();
    if (!this.model.state.marker.color.isDiscrete()) {
      if (this.stack.use == "property") {
        this.setModel("stack", "none");
        return;
      } else if (this.group.merge) {
        this.setModel("merge", "none");
        return;
      }
    }
    this.updateView();
  },
  updateView: function updateView() {
    var _this = this;

    this.howToStackEl.property("checked", function () {
      if (d3.select(this).node().value === "none") return _this.stack.which === "none";
      if (d3.select(this).node().value === "bycolor") return _this.stack.which === _this.model.state.marker.color.which;
      if (d3.select(this).node().value === "all") return _this.stack.which === "all";
    }).attr("disabled", function () {
      if (d3.select(this).node().value === "none") return null; // always enabled
      if (d3.select(this).node().value === "all") return null; // always enabled
      if (d3.select(this).node().value === "bycolor") return _this.model.state.marker.color.use !== "property" ? true : null;
    });

    _this.model.ui.chart.manualSortingEnabled = _this.stack.which == "all";

    this.howToMergeEl.property("checked", function () {
      if (d3.select(this).node().value === "none") return !_this.group.merge && !_this.stack.merge;
      if (d3.select(this).node().value === "grouped") return _this.group.merge;
      if (d3.select(this).node().value === "stacked") return _this.stack.merge;
    }).attr("disabled", function () {
      if (d3.select(this).node().value === "none") return null; // always enabled
      if (d3.select(this).node().value === "grouped") return _this.stack.which === "none" || _this.model.state.marker.color.use !== "property" ? true : null;
      if (d3.select(this).node().value === "stacked") return _this.stack.which === "all" ? null : true;
    });
  },
  manualSorting: function manualSorting(value) {
    if (arguments.length === 0) return this.model.state.marker.group.manualSorting;
    this.model.state.marker.group.manualSorting = value;
  },
  setModel: function setModel(what, value) {

    var obj = { stack: {}, group: {} };

    if (what === "merge") {
      switch (value) {
        case "none":
          obj.group.merge = false;
          obj.stack.merge = false;
          break;
        case "grouped":
          obj.group.merge = true;
          obj.stack.merge = false;
          break;
        case "stacked":
          obj.group.merge = false;
          obj.stack.merge = true;
          break;
      }
    }
    if (what === "stack") {

      switch (value) {
        case "all":
          obj.stack.use = "constant";
          obj.stack.which = "all";
          break;
        case "none":
          obj.stack.use = "constant";
          obj.stack.which = "none";
          break;
        case "bycolor":
          obj.stack.use = "property";
          obj.stack.which = this.model.state.marker.color.which;
          break;
      }

      //validate possible merge values in group and stack hooks
      if (value === "none" && this.group.merge) obj.group.merge = false;
      if (value !== "all" && this.stack.merge) obj.stack.merge = false;
    }

    this.model.state.marker.set(obj);
  }
});

exports.default = Stack;

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _dialog = __webpack_require__(11);

var _dialog2 = _interopRequireDefault(_dialog);

var _d = __webpack_require__(60);

var _d2 = _interopRequireDefault(_d);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * Timedisplay dialog
 */
var TimeDisplay = _dialog2.default.extend({
  init: function init(config, parent) {
    var _this = this;

    this.name = "timedisplay";

    this.model_binds = {
      "change:state.time.value": function changeStateTimeValue() {
        _this.updateTime();
      }
    };

    this._super(config, parent);
  },
  ready: function ready() {
    this.updateTime();
  },
  readyOnce: function readyOnce() {
    this._super();
    this.timeLabel = new _d2.default(this.element.select(".vzb-timedisplay"));
    this.timeLabel.setConditions({ widthRatio: 1, heightRatio: 1 });
    this.timeLabel.resize(this.contentEl.style("width"), this.contentEl.style("height"));
  },
  updateTime: function updateTime() {
    var timeMdl = this.model.state.time;
    this.time_1 = this.time == null ? timeMdl.value : this.time;
    this.time = timeMdl.value;
    var duration = timeMdl.playing && this.time - this.time_1 > 0 ? timeMdl.delayAnimations : 0;
    this.timeLabel.setText(timeMdl.formatDate(this.time, "ui"), duration);
  }
});

exports.default = TimeDisplay;

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _dialog = __webpack_require__(11);

var _dialog2 = _interopRequireDefault(_dialog);

var _zoombuttonlist = __webpack_require__(137);

var _zoombuttonlist2 = _interopRequireDefault(_zoombuttonlist);

var _simplecheckbox = __webpack_require__(59);

var _simplecheckbox2 = _interopRequireDefault(_simplecheckbox);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * Zoom dialog
 */

var Zoom = _dialog2.default.extend({

  /**
   * Initializes the dialog component
   * @param config component configuration
   * @param context component context (parent)
   */
  init: function init(config, parent) {
    this.name = "zoom";

    // in dialog, this.model_expects = ["state", "data"];

    this.components = [{
      component: _zoombuttonlist2.default,
      placeholder: ".vzb-dialog-zoom-buttonlist",
      model: ["state", "ui", "locale"]
    }, {
      component: _simplecheckbox2.default,
      placeholder: ".vzb-panwitharrow-switch",
      model: ["ui", "locale"],
      checkbox: "panWithArrow"
    }, {
      component: _simplecheckbox2.default,
      placeholder: ".vzb-zoomonscrolling-switch",
      model: ["ui", "locale"],
      checkbox: "zoomOnScrolling"
    }, {
      component: _simplecheckbox2.default,
      placeholder: ".vzb-adaptminmaxzoom-switch",
      model: ["ui", "locale"],
      checkbox: "adaptMinMaxZoom"
    }];

    this._super(config, parent);
  }
});

exports.default = Zoom;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var DraggableList = _component2.default.extend({
  init: function init(config, context) {
    this.template = '<span class="vzb-dl-holder"><ul class="vzb-draggable list vzb-dialog-scrollable"></ul></span>';
    var _this = this;
    this.name = "draggableList";

    this.dataArrFn = config.dataArrFn;
    this.lang = config.lang;

    this.model_expects = [{
      name: "group",
      type: "model"
    }, {
      name: "color",
      type: "color"
    }, {
      name: "locale",
      type: "locale"
    }, {
      name: "chart",
      type: "model"
    }];

    this.groupID = config.groupID;
    this.isEnabled = config.isEnabled;
    this.draggable = true;

    if (!config.groupID) utils.warn("draggablelist.js complains on 'groupID' property: " + config.groupID);

    this.model_binds = {
      "translate:locale": function translateLocale(evt) {
        _this.updateView();
      },
      "change:group.which": function changeGroupWhich(evt) {
        _this.updateView();
      }
    };

    this.model_binds["change:group." + this.groupID] = function (evt) {
      _this.updateView();
    };
    this.model_binds["change:chart." + this.isEnabled] = function (evt) {
      _this.draggable = _this.model.chart[_this.isEnabled];
      _this.updateView();
    };

    this._super(config, context);

    this.updateData = utils.debounce(this.updateData, 1000);

    this.itemDragger = d3.drag().on("start", function (draggedData, i) {
      if (_this.dataUpdateFlag || !_this.draggable) return;
      d3.event.sourceEvent.stopPropagation();
      _this.parentBoundRect = _this.element.node().getBoundingClientRect();
      _this.element.selectAll("div").each(function (d, i) {
        var boundRect = this.getBoundingClientRect();
        d._y = boundRect.top;
        d._top = 0;
        if (draggedData.data === d.data) {
          d._height = boundRect.height;
          _this.selectedNode = this;
        }
      });
      d3.select(_this.selectedNode).classed("dragged", true);
    }).on("drag", function (draggedData, draggedIndex) {
      if (_this.dataUpdateFlag || !_this.draggable) return;
      draggedData._top += d3.event.dy;
      var newDraggedY = draggedData._y + draggedData._top;
      if (newDraggedY > _this.parentBoundRect.top && newDraggedY + draggedData._height < _this.parentBoundRect.top + _this.parentBoundRect.height) {
        _this.itemsEl.style("top", function (d, i) {
          var top = 0;

          if (i < draggedIndex && d._y + draggedData._height * 0.5 > newDraggedY) {
            top = draggedData._height;
          } else if (i > draggedIndex && d._y - draggedData._height * 0.5 < newDraggedY) {
            top = -draggedData._height;
          }

          if (i != draggedIndex) d._top = top;
          return d._top + "px";
        });
      }
    }).on("end", function (d, i) {
      if (_this.dataUpdateFlag || !_this.draggable) return;
      _this.getData();
    });
  },
  ready: function ready() {
    var _this = this;

    var labels = _this.model.color.getColorlegendMarker().label.getItems();
    this.dataArrFn(utils.keys(labels));

    this.updateView();

    this.itemsEl = this.element.selectAll("div");

    this.itemsEl.call(_this.itemDragger);

    var test = this.itemsEl.select("li").on("mouseover", function () {
      d3.select(this).classed("hover", true);
    }).on("mouseout", function () {
      d3.select(this).classed("hover", false);
    }).on("touchstart", function () {
      d3.event.preventDefault();
    });
  },
  updateView: function updateView() {
    var _this = this;

    this.items = this.element.selectAll("div").data(function () {
      return _this.dataArrFn().map(function (d) {
        return { data: d };
      });
    });
    this.items.exit().remove();
    this.items = this.items.enter().append("div").append("li").merge(this.items);

    var labels = _this.model.color.getColorlegendMarker().label.getItems();
    this.items.select("li").classed("hover", false).each(function (val, index) {
      d3.select(this).attr("data", val["data"]).text(labels[val["data"]]);
    });

    var draggable = _this.draggable ? true : null;
    this.element.selectAll("div").style("top", "").attr("draggable", draggable).classed("dragged", false);
    this.dataUpdateFlag = false;
  },
  getData: function getData() {
    var dataArr = [];
    var data = this.element.selectAll("div").data();

    dataArr = data.sort(function (a, b) {
      return a._y + a._top - (b._y + b._top);
    }).map(function (d) {
      return d.data;
    });
    if (utils.arrayEquals(this.dataArrFn(), dataArr)) {
      this.updateView();
    } else {
      this.dataUpdateFlag = true;
      this.updateData(dataArr);
    }
  },
  updateData: function updateData(dataArr) {
    this.dataArrFn(dataArr);
  },
  readyOnce: function readyOnce() {
    var _this = this;

    this.element = d3.select(this.element).select(".list");
  }
});

exports.default = DraggableList;

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*!
 * VIZABI BUBBLE SIZE slider
 * Reusable bubble size slider
 */

var OPTIONS = {
  EXTENT_MIN: 0,
  EXTENT_MAX: 1,
  TEXT_PARAMS: { TOP: 18, LEFT: 10, MAX_WIDTH: 42, MAX_HEIGHT: 16 },
  BAR_WIDTH: 6,
  THUMB_RADIUS: 10,
  THUMB_STROKE_WIDTH: 4,
  INTRO_DURATION: 250,
  MARGIN: { TOP: 2, LEFT: 5, RIGHT: 5 }
};

var profiles = {
  "small": {
    minLabelTextSize: 7,
    maxLabelTextSize: 21,
    defaultLabelTextSize: 12
  },
  "medium": {
    minLabelTextSize: 7,
    maxLabelTextSize: 30,
    defaultLabelTextSize: 15
  },
  "large": {
    minLabelTextSize: 6,
    maxLabelTextSize: 48,
    defaultLabelTextSize: 20
  }
};

var SizeSlider = _component2.default.extend({

  /**
   * Initializes the timeslider.
   * Executed once before any template is rendered.
   * @param config The options passed to the component
   * @param context The component's parent
   */
  init: function init(config, context) {

    this.name = "sizeslider";

    this.template = this.template || __webpack_require__(454);

    this.propertyName = config.propertyname;

    this.model_expects = [{
      name: "size",
      type: "size"
    }, {
      name: "locale",
      type: "locale"
    }];

    var _this = this;
    this.model_binds = {
      "change:size.domainMin": changeMinMaxHandler,
      "change:size.domainMax": changeMinMaxHandler,
      "change:size.extent": changeMinMaxHandler,
      "ready": function ready() {
        _this.modelReady();
      }
    };

    function changeMinMaxHandler(evt, path) {
      var extent = _this.model.size.extent || [OPTIONS.EXTENT_MIN, OPTIONS.EXTENT_MAX];
      _this._updateLabels(extent);
      _this._moveBrush(extent);
    }

    this._setModel = utils.throttle(this._setModel, 50);
    //contructor is the same as any component
    this._super(config, context);
  },
  modelReady: function modelReady() {
    var _this = this;
    _this.modelUse = _this.model.size.use;
    var extent = _this.model.size.extent || [OPTIONS.EXTENT_MIN, OPTIONS.EXTENT_MAX];
    if (_this.modelUse != "constant") {
      _this.sizeScaleMinMax = _this.model.size.getScale().domain();
      _this.sliderEl.selectAll(".w").classed("vzb-hidden", false);
      _this.sliderEl.select(".selection").classed("vzb-hidden", false);
      _this.sliderEl.select(".overlay").classed("vzb-pointerevents-none", false);
      _this._setLabelsText();
    } else {
      _this.sliderEl.selectAll(".w").classed("vzb-hidden", true);
      _this.sliderEl.select(".selection").classed("vzb-hidden", true);
      _this.sliderEl.select(".overlay").classed("vzb-pointerevents-none", true);
      if (!_this.model.size.which) {
        var p = _this.propertyActiveProfile;
        extent[1] = (p.default - p.min) / (p.max - p.min);
        _this.model.size.which = "_default";
      }
    }
    _this._moveBrush(extent);
  },


  /**
   * Executes after the template is loaded and rendered.
   * Ideally, it contains HTML instantiations related to template
   * At this point, this.element and this.placeholder are available as a d3 object
   */
  readyOnce: function readyOnce() {
    var _this = this;
    var extent = _this.model.size.extent || [OPTIONS.EXTENT_MIN, OPTIONS.EXTENT_MAX];
    this.element = d3.select(this.element);
    this.sliderSvg = this.element.select(".vzb-szs-svg");
    this.sliderWrap = this.sliderSvg.select(".vzb-szs-slider-wrap");
    this.sliderEl = this.sliderWrap.select(".vzb-szs-slider");

    var textMargin = { v: OPTIONS.TEXT_PARAMS.TOP, h: OPTIONS.TEXT_PARAMS.LEFT };
    var textMaxWidth = OPTIONS.TEXT_PARAMS.MAX_WIDTH;
    var textMaxHeight = OPTIONS.TEXT_PARAMS.MAX_HEIGHT;
    var barWidth = OPTIONS.BAR_WIDTH;
    var thumbRadius = OPTIONS.THUMB_RADIUS;
    var thumbStrokeWidth = OPTIONS.THUMB_STROKE_WIDTH;
    var padding = {
      top: OPTIONS.MARGIN.TOP + barWidth * 1.25,
      left: thumbRadius,
      right: thumbRadius,
      bottom: barWidth + textMaxHeight
    };

    var componentWidth = this.element.node().offsetWidth;

    this.padding = padding;

    this.propertyActiveProfile = this.getPropertyActiveProfile();
    this.translator = this.model.locale.getTFunction();

    this.propertyScale = d3.scale.linear().domain([OPTIONS.EXTENT_MIN, OPTIONS.EXTENT_MAX]).range([this.propertyActiveProfile.min, this.propertyActiveProfile.max]).clamp(true);

    this.xScale = d3.scale.linear().domain([OPTIONS.EXTENT_MIN, OPTIONS.EXTENT_MAX]).range([0, componentWidth - padding.left - padding.right]).clamp(true);

    this.brush = d3.brushX().extent([[0, 0], [componentWidth - padding.left - padding.right, barWidth]]).handleSize(thumbRadius * 2 + barWidth * 2).on("start", function () {
      if (_this.nonBrushChange || !d3.event.sourceEvent) return;
      if (d3.event.selection && d3.event.selection[0] == d3.event.selection[1]) {
        var brushDatum = _this.sliderEl.node().__brush;
        brushDatum.selection[1][0] += 0.01;
      }
      _this._setFromExtent(false, false, false);
    }).on("brush", function () {
      if (_this.nonBrushChange || !d3.event.sourceEvent) return;
      if (d3.event.selection && d3.event.selection[0] == d3.event.selection[1]) {
        var brushDatum = _this.sliderEl.node().__brush;
        brushDatum.selection[1][0] += 0.01;
      }
      _this._setFromExtent(true, false, false); // non persistent change
    }).on("end", function () {
      if (_this.nonBrushChange || !d3.event.sourceEvent) return;
      _this._setFromExtent(true, true); // force a persistent change
    });

    this.sliderThumbs = this.sliderEl.selectAll(".handle").data([{ type: "w" }, { type: "e" }], function (d) {
      return d.type;
    }).enter().append("svg").attr("class", function (d) {
      return "handle handle--" + d.type + " " + d.type;
    }).classed("vzb-szs-slider-thumb", true);

    this.sliderThumbs.append("g").attr("class", "vzb-szs-slider-thumb-badge").append("path").attr("d", "M" + (thumbRadius + barWidth) + " " + (thumbRadius + barWidth * 1.5) + "l" + -thumbRadius + " " + thumbRadius * 1.5 + "h" + thumbRadius * 2 + "Z");

    this.sliderEl.call(_this.brush);

    this.sliderEl.selectAll("text").data([0, 0]).enter().append("text").attr("class", function (d, i) {
      return "vzb-szs-slider-thumb-label " + (i ? "e" : "w");
    }).attr("dy", -barWidth * 1.25 + "px").attr("text-anchor", function (d, i) {
      return 1 - i ? "start" : "end";
    });

    this.sliderLabelsEl = this.sliderEl.selectAll("text.vzb-szs-slider-thumb-label");

    this.sliderEl.selectAll(".selection,.overlay").attr("height", barWidth).attr("rx", barWidth * 0.25).attr("ry", barWidth * 0.25).attr("transform", "translate(0," + -barWidth * 0.5 + ")");
    this.sliderEl.select(".extent").classed("vzb-szs-slider-extent", true);

    this.on("resize", function () {
      //console.log("EVENT: resize");
      _this.propertyActiveProfile = _this.getPropertyActiveProfile();
      _this.propertyScale.range([_this.propertyActiveProfile.min, _this.propertyActiveProfile.max]);

      var componentWidth = _this.element.node().offsetWidth;

      _this.xScale.range([0, componentWidth - _this.padding.left - _this.padding.right]);
      _this._updateSize();
      _this.sliderEl.call(_this.brush.extent([[0, 0], [componentWidth - padding.left - padding.right, barWidth]]));
      var extent = _this.model.size.extent || [OPTIONS.EXTENT_MIN, OPTIONS.EXTENT_MAX];
      _this._moveBrush(extent);
    });

    this._updateSize();
    this._moveBrush(extent);

    _this.sizeScaleMinMax = _this.model.size.getScale().domain();

    if (_this.sizeScaleMinMax) {
      _this._setLabelsText();
    }

    if (_this.model._ready) this.modelReady();
  },
  getPropertyActiveProfile: function getPropertyActiveProfile() {
    var profile = profiles[this.getLayoutProfile()];
    return { min: profile["min" + this.propertyName], max: profile["max" + this.propertyName], default: profile["default" + this.propertyName] };
  },
  _moveBrush: function _moveBrush(s) {
    var _s = s.map(this.xScale);
    this.nonBrushChange = true;
    this.sliderEl.call(this.brush.move, [_s[0], _s[1] + 0.01]);
    this.nonBrushChange = false;
    this._setFromExtent(false, false, false);
  },


  /*
   * RESIZE:
   * Executed whenever the container is resized
   */
  _updateSize: function _updateSize() {
    this.sliderSvg.attr("height", this.propertyActiveProfile.max + this.padding.top + this.padding.bottom).attr("width", "100%");
    this.sliderWrap.attr("transform", "translate(" + this.padding.left + "," + (this.propertyActiveProfile.max + this.padding.top) + ")");
  },
  _updateLabels: function _updateLabels(s) {
    var _this = this;
    this.sliderLabelsEl.data(s).attr("transform", function (d, i) {
      var dX = _this.xScale(i);
      var dY = 0; //i ? -textMargin.v : 0;
      return "translate(" + dX + "," + dY + ")";
    }).attr("font-size", function (d, i) {
      return _this.propertyScale(d);
    });
    if (_this.model.size.use === "constant") this.sliderLabelsEl.text(function (d) {
      return ~~_this.propertyScale(d) + (_this.translator(_this.ui.constantUnit) || "");
    });
  },
  _setLabelsText: function _setLabelsText() {
    var _this = this;
    _this.sliderLabelsEl.data([_this.model.size.getTickFormatter()(_this.sizeScaleMinMax[0]), _this.model.size.getTickFormatter()(_this.sizeScaleMinMax[1])]).text(function (d) {
      return d;
    });
  },


  /**
   * Prepares setting of the current model with the values from extent.
   * @param {boolean} set model
   * @param {boolean} force force firing the change event
   * @param {boolean} persistent sets the persistency of the change event
   */
  _setFromExtent: function _setFromExtent(setModel, force, persistent) {
    var s = d3.brushSelection(this.sliderEl.node());
    if (!s) return;
    s = [this.xScale.invert(s[0]), this.xScale.invert(+s[1].toFixed(1))];
    this._updateLabels(s);
    if (setModel) this._setModel(s, force, persistent);
  },


  /**
   * Sets the current value in model. avoid updating more than once in framerate
   * @param {number} value
   * @param {boolean} force force firing the change event
   * @param {boolean} persistent sets the persistency of the change event
   */
  _setModel: function _setModel(value, force, persistent) {
    value = [+value[0].toFixed(2), +value[1].toFixed(2)];
    this.model.size.set({ "extent": value }, force, persistent);
  }
});

exports.default = SizeSlider;

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _iconset = __webpack_require__(10);

var iconset = _interopRequireWildcard(_iconset);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*!
 * VIZABI OPTIONSBUTTONLIST
 * Reusable optionsbuttonlist component
 */

//default existing buttons
var class_active = "vzb-active";
// var class_active_locked = "vzb-active-locked";
// var class_expand_dialog = "vzb-dialog-side";
// var class_hide_btn = "vzb-dialog-side-btn";
// var class_unavailable = "vzb-unavailable";
// var class_vzb_fullscreen = "vzb-force-fullscreen";
// var class_container_fullscreen = "vzb-container-fullscreen";

var ZoomButtonList = _component2.default.extend({

  /**
   * Initializes the buttonlist
   * @param config component configuration
   * @param context component context (parent)
   */
  init: function init(config, context) {

    //set properties
    var _this = this;
    this.name = "gapminder-zoombuttonlist";

    this.model_expects = [{
      name: "state",
      type: "model"
    }, {
      name: "ui",
      type: "ui"
    }, {
      name: "locale",
      type: "locale"
    }];

    this._available_buttons = {
      "arrow": {
        title: "buttons/cursorarrow",
        icon: "cursorArrow",
        func: this.toggleCursorMode.bind(this),
        required: true,
        statebind: "ui.cursorMode",
        statebindfunc: this.setCursorMode.bind(this)
      },
      "plus": {
        title: "buttons/cursorplus",
        icon: "cursorPlus",
        func: this.toggleCursorMode.bind(this),
        required: true,
        statebind: "ui.cursorMode",
        statebindfunc: this.setCursorMode.bind(this)
      },
      "minus": {
        title: "buttons/cursorminus",
        icon: "cursorMinus",
        func: this.toggleCursorMode.bind(this),
        required: true,
        statebind: "ui.cursorMode",
        statebindfunc: this.setCursorMode.bind(this)
      },
      "hand": {
        title: "buttons/cursorhand",
        icon: "cursorHand",
        func: this.toggleCursorMode.bind(this),
        required: true,
        statebind: "ui.cursorMode",
        statebindfunc: this.setCursorMode.bind(this)
      },
      "hundredpercent": {
        title: "buttons/hundredpercent",
        icon: "hundredPercent",
        func: this.toggleHundredPercent.bind(this),
        required: true
        // ,
        // statebind: "ui.chart.trails",
        // statebindfunc: this.setBubbleTrails.bind(this)
      }
    };

    this.model_binds = {};

    Object.keys(this._available_buttons).forEach(function (buttonId) {
      var button = _this._available_buttons[buttonId];
      if (button && button.statebind) {
        _this.model_binds["change:" + button.statebind] = function (evt) {
          button.statebindfunc(buttonId, evt.source.value);
        };
      }
    });

    this._super(config, context);
  },
  readyOnce: function readyOnce() {
    var _this = this;

    this.element = d3.select(this.placeholder);
    this.element.selectAll("div").remove();

    this._addButtons(Object.keys(this._available_buttons), []);
    this.setCursorMode("arrow");
  },


  /*
   * adds buttons configuration to the components and template_data
   * @param {Array} button_list list of buttons to be added
   */
  _addButtons: function _addButtons(button_list, button_expand) {
    var _this = this;
    this._components_config = [];
    var details_btns = [];
    if (!button_list.length) return;
    //add a component for each button
    for (var i = 0; i < button_list.length; i++) {

      var btn = button_list[i];
      var btn_config = this._available_buttons[btn];

      //add template data
      var d = btn_config ? btn : "_default";
      var details_btn = utils.clone(this._available_buttons[d]);

      details_btn.id = btn;
      details_btn.icon = iconset[details_btn.icon];
      details_btns.push(details_btn);
    }

    var t = this.getTranslationFunction(true);

    this.element.selectAll("button").data(details_btns).enter().append("button").attr("class", function (d) {
      var cls = "vzb-buttonlist-btn";
      if (button_expand.length > 0) {
        if (button_expand.indexOf(d.id) > -1) {
          cls += " vzb-dialog-side-btn";
        }
      }

      return cls;
    }).attr("data-btn", function (d) {
      return d.id;
    }).html(function (btn) {
      return "<span class='vzb-buttonlist-btn-icon fa'>" + btn.icon + "</span><span class='vzb-buttonlist-btn-title'>" + t(btn.title) + "</span>";
    });

    var buttons = this.element.selectAll(".vzb-buttonlist-btn");

    //clicking the button
    buttons.on("click", function () {

      d3.event.preventDefault();
      d3.event.stopPropagation();

      var id = d3.select(this).attr("data-btn");
      _this.proceedClick(id);
    });
  },
  proceedClick: function proceedClick(id) {
    var _this = this;
    var btn = _this.element.selectAll(".vzb-buttonlist-btn[data-btn='" + id + "']");
    var classes = btn.attr("class");
    var btn_config = _this._available_buttons[id];

    if (btn_config && btn_config.func) {
      btn_config.func(id);
    } else {
      var btn_active = classes.indexOf(class_active) === -1;

      btn.classed(class_active, btn_active);
      var evt = {};
      evt["id"] = id;
      evt["active"] = btn_active;
      _this.trigger("click", evt);
    }
  },
  setButtonActive: function setButtonActive(id, boolActive) {
    var btn = this.element.selectAll(".vzb-buttonlist-btn[data-btn='" + id + "']");

    btn.classed(class_active, boolActive);
  },
  toggleCursorMode: function toggleCursorMode(id) {
    var value = id;
    this.model.ui.set("cursorMode", value, false, false);
  },
  setCursorMode: function setCursorMode(id) {
    var value = this.model.ui.cursorMode ? this.model.ui.cursorMode : "arrow";
    this.element.selectAll(".vzb-buttonlist-btn").classed(class_active, function (d) {
      return d.id == value;
    });
  },
  toggleHundredPercent: function toggleHundredPercent(id) {
    this.root.trigger("resetZoom");
  }
});

exports.default = ZoomButtonList;

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _class = __webpack_require__(16);

var _class2 = _interopRequireDefault(_class);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _prefix = "";
var _deleteClasses = [];
var SVGHEADER = '<?xml version="1.0" encoding="utf-8"?>';

exports.default = _class2.default.extend({

  init: function init(context) {
    this.context = context;
    this.shapes = [];
    this.groups = [];
    this.counter = 0;
    this.name = "";
    this.label = "";
  },

  reset: function reset() {
    this.container.remove();
    this.context.element.selectAll(".vzb-export-redball").remove();
    this.context.element.selectAll(".vzb-export-counter").remove();
    this.counter = 0;
  },

  prefix: function prefix(arg) {
    if (!arguments.length) return _prefix;
    _prefix = arg;
    return this;
  },
  deleteClasses: function deleteClasses(arg) {
    if (!arguments.length) return _deleteClasses;
    _deleteClasses = arg;
    return this;
  },

  open: function open(element, name) {
    var _this = this;

    //reset if some exports exists on opening
    if (this.svg) this.reset();

    if (!element) element = this.context.element;
    if (!name) name = this.context.name;
    this.name = name;

    var width = parseInt(element.style("width"), 10) || 0;
    var height = parseInt(element.style("height"), 10) || 0;

    this.container = element.append("div").attr("class", "vzb-svg-export");
    this.svg = this.container.node().appendChild(element.select("svg").node().cloneNode(true));
    this.svg = d3.select(this.svg);
    this.svg.attr("viewBox", "0 0 " + width + " " + height).attr("version", "1.1").attr("param1", "http://www.w3.org/2000/svg").attr("param2", "http://www.w3.org/1999/xlink").attr("x", "0px").attr("y", "0px").attr("style", "enable-background:new " + "0 0 " + width + " " + height).attr("xml:space", "preserve");

    this.redBall = element.append("div").attr("class", "vzb-export-redball").style("position", "absolute").style("top", "20px").style("right", "20px").style("width", "20px").style("height", "20px").style("background", "red").style("color", "white").style("text-align", "center").style("border-radius", "10px").style("font-size", "14px").style("line-height", "20px").style("opacity", .8).style("cursor", "pointer").on("mouseover", function () {
      d3.select(this).style("opacity", 1).text("▼");
      _this.counterEl.text("Download");
    }).on("mouseout", function () {
      d3.select(this).style("opacity", .8).text("");
      _this.counterEl.text(_this.label);
    }).on("click", function () {
      _this.close();
    });

    this.counterEl = element.append("div").attr("class", "vzb-export-counter").style("position", "absolute").style("top", "20px").style("right", "45px").style("color", "red").style("opacity", .8).style("line-height", "20px").style("font-size", "14px").style("text-align", "center");

    this.root = this.svg.select("." + _prefix + "graph");

    this.root.selectAll("g, text, svg, line, rect").filter(function () {
      var view = d3.select(this);
      var result = false;
      _deleteClasses.forEach(function (one) {
        result = result || view.classed(one);
      });
      return result;
    }).remove();

    this.svg.selectAll(".tick line").attr("fill", "none").attr("stroke", "#999");
    this.svg.selectAll("." + _prefix + "axis-x path").attr("fill", "none").attr("stroke", "#999");
    this.svg.selectAll("." + _prefix + "axis-y path").attr("fill", "none").attr("stroke", "#999");
  },

  write: function write(me) {
    var groupBy = "time";

    if (!this.root) this.open();

    //avoid writing the same thing again
    if (this.shapes.indexOf(me.id + "_" + me.time) > -1) return;

    this.shapes.push(me.id + "_" + me.time);

    // check if need to create a new group and do so
    if (this.groups.indexOf(me[groupBy]) == -1) {
      this.root.append("g").attr("id", "g_" + me[groupBy]);
      this.groups.push(me[groupBy]);
    }

    // put a marker into the group
    if (me.opacity == null) me.opacity = .5;
    if (me.fill == null) me.fill = "#ff80dd";

    var marker = this.root.select("#g_" + me[groupBy]).append(me.type).attr("id", me.id + "_" + me.time).style("fill", me.fill).style("opacity", me.opacity);

    switch (me.type) {
      case "path":
        marker.attr("d", me.d);
        break;

      case "circle":
        marker.attr("cx", me.cx).attr("cy", me.cy).attr("r", me.r);
        break;
    }

    this.counter++;
    this.redBall.style("opacity", this.counter % 10 / 12 + .2);
    this.label = me.type + " shapes: " + this.counter;
    this.counterEl.text(this.label);
  },

  close: function close() {

    var result = SVGHEADER + " " + this.container.node().innerHTML.replace("param1", "xmlns").replace("param2", "xmlns:xlink")
    //round all numbers in SVG code
    .replace(/\d+(\.\d+)/g, function (x) {
      return Math.round(+x * 100) / 100 + "";
    });

    if (result.length / 1024 / 1024 > 2) {

      alert("The file size is " + Math.round(result.length / 1024) + "kB, which is too large to download. Will try to print it in the console instead...");
      console.log(result);
    } else {

      var link = document.createElement('a');
      link.download = this.name + " " + this.counter + " shapes" + ".svg";
      link.href = 'data:,' + result;
      link.click();
    }
  }

});

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

// topojson
exports.default = function () {
  var topojson = {
    version: "1.6.19",
    mesh: function mesh(topology) {
      return object(topology, meshArcs.apply(this, arguments));
    },
    meshArcs: meshArcs,
    merge: function merge(topology) {
      return object(topology, mergeArcs.apply(this, arguments));
    },
    mergeArcs: mergeArcs,
    feature: featureOrCollection,
    neighbors: neighbors,
    presimplify: presimplify
  };

  function stitchArcs(topology, arcs) {
    var stitchedArcs = {},
        fragmentByStart = {},
        fragmentByEnd = {},
        fragments = [],
        emptyIndex = -1;

    // Stitch empty arcs first, since they may be subsumed by other arcs.
    arcs.forEach(function (i, j) {
      var arc = topology.arcs[i < 0 ? ~i : i],
          t;
      if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
        t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
      }
    });

    arcs.forEach(function (i) {
      var e = ends(i),
          start = e[0],
          end = e[1],
          f,
          g;

      if (f = fragmentByEnd[start]) {
        delete fragmentByEnd[f.end];
        f.push(i);
        f.end = end;
        if (g = fragmentByStart[end]) {
          delete fragmentByStart[g.start];
          var fg = g === f ? f : f.concat(g);
          fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
        } else {
          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
        }
      } else if (f = fragmentByStart[end]) {
        delete fragmentByStart[f.start];
        f.unshift(i);
        f.start = start;
        if (g = fragmentByEnd[start]) {
          delete fragmentByEnd[g.end];
          var gf = g === f ? f : g.concat(f);
          fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
        } else {
          fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
        }
      } else {
        f = [i];
        fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
      }
    });

    function ends(i) {
      var arc = topology.arcs[i < 0 ? ~i : i],
          p0 = arc[0],
          p1;
      if (topology.transform) p1 = [0, 0], arc.forEach(function (dp) {
        p1[0] += dp[0], p1[1] += dp[1];
      });else p1 = arc[arc.length - 1];
      return i < 0 ? [p1, p0] : [p0, p1];
    }

    function flush(fragmentByEnd, fragmentByStart) {
      for (var k in fragmentByEnd) {
        var f = fragmentByEnd[k];
        delete fragmentByStart[f.start];
        delete f.start;
        delete f.end;
        f.forEach(function (i) {
          stitchedArcs[i < 0 ? ~i : i] = 1;
        });
        fragments.push(f);
      }
    }

    flush(fragmentByEnd, fragmentByStart);
    flush(fragmentByStart, fragmentByEnd);
    arcs.forEach(function (i) {
      if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]);
    });

    return fragments;
  }

  function meshArcs(topology, o, filter) {
    var arcs = [];

    function arc(i) {
      var j = i < 0 ? ~i : i;
      (geomsByArc[j] || (geomsByArc[j] = [])).push({
        i: i,
        g: geom
      });
    }

    function line(arcs) {
      arcs.forEach(arc);
    }

    function polygon(arcs) {
      arcs.forEach(line);
    }

    function geometry(o) {
      if (o.type === "GeometryCollection") o.geometries.forEach(geometry);else if (o.type in geometryType) geom = o, geometryType[o.type](o.arcs);
    }

    if (arguments.length > 1) {
      var geomsByArc = [],
          geom;

      var geometryType = {
        LineString: line,
        MultiLineString: polygon,
        Polygon: polygon,
        MultiPolygon: function MultiPolygon(arcs) {
          arcs.forEach(polygon);
        }
      };

      geometry(o);

      geomsByArc.forEach(arguments.length < 3 ? function (geoms) {
        arcs.push(geoms[0].i);
      } : function (geoms) {
        if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i);
      });
    } else {
      for (var i = 0, n = topology.arcs.length; i < n; ++i) {
        arcs.push(i);
      }
    }

    return {
      type: "MultiLineString",
      arcs: stitchArcs(topology, arcs)
    };
  }

  function mergeArcs(topology, objects) {
    var polygonsByArc = {},
        polygons = [],
        components = [];

    objects.forEach(function (o) {
      if (o.type === "Polygon") register(o.arcs);else if (o.type === "MultiPolygon") o.arcs.forEach(register);
    });

    function register(polygon) {
      polygon.forEach(function (ring) {
        ring.forEach(function (arc) {
          (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
        });
      });
      polygons.push(polygon);
    }

    function exterior(ring) {
      return cartesianRingArea(object(topology, {
        type: "Polygon",
        arcs: [ring]
      }).coordinates[0]) > 0; // TODO allow spherical?
    }

    polygons.forEach(function (polygon) {
      if (!polygon._) {
        var component = [],
            neighbors = [polygon];
        polygon._ = 1;
        components.push(component);
        while (polygon = neighbors.pop()) {
          component.push(polygon);
          polygon.forEach(function (ring) {
            ring.forEach(function (arc) {
              polygonsByArc[arc < 0 ? ~arc : arc].forEach(function (polygon) {
                if (!polygon._) {
                  polygon._ = 1;
                  neighbors.push(polygon);
                }
              });
            });
          });
        }
      }
    });

    polygons.forEach(function (polygon) {
      delete polygon._;
    });

    return {
      type: "MultiPolygon",
      arcs: components.map(function (polygons) {
        var arcs = [];

        // Extract the exterior (unique) arcs.
        polygons.forEach(function (polygon) {
          polygon.forEach(function (ring) {
            ring.forEach(function (arc) {
              if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
                arcs.push(arc);
              }
            });
          });
        });

        // Stitch the arcs into one or more rings.
        arcs = stitchArcs(topology, arcs);

        // If more than one ring is returned,
        // at most one of these rings can be the exterior;
        // this exterior ring has the same winding order
        // as any exterior ring in the original polygons.
        if ((n = arcs.length) > 1) {
          var sgn = exterior(polygons[0][0]);
          for (var i = 0, t; i < n; ++i) {
            if (sgn === exterior(arcs[i])) {
              t = arcs[0], arcs[0] = arcs[i], arcs[i] = t;
              break;
            }
          }
        }

        return arcs;
      })
    };
  }

  function featureOrCollection(topology, o) {
    return o.type === "GeometryCollection" ? {
      type: "FeatureCollection",
      features: o.geometries.map(function (o) {
        return feature(topology, o);
      })
    } : feature(topology, o);
  }

  function feature(topology, o) {
    var f = {
      type: "Feature",
      id: o.id,
      properties: o.properties || {},
      geometry: object(topology, o)
    };
    if (o.id == null) delete f.id;
    return f;
  }

  function object(topology, o) {
    var absolute = transformAbsolute(topology.transform),
        arcs = topology.arcs;

    function arc(i, points) {
      if (points.length) points.pop();
      for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length, p; k < n; ++k) {
        points.push(p = a[k].slice());
        absolute(p, k);
      }
      if (i < 0) reverse(points, n);
    }

    function point(p) {
      p = p.slice();
      absolute(p, 0);
      return p;
    }

    function line(arcs) {
      var points = [];
      for (var i = 0, n = arcs.length; i < n; ++i) {
        arc(arcs[i], points);
      }if (points.length < 2) points.push(points[0].slice());
      return points;
    }

    function ring(arcs) {
      var points = line(arcs);
      while (points.length < 4) {
        points.push(points[0].slice());
      }return points;
    }

    function polygon(arcs) {
      return arcs.map(ring);
    }

    function geometry(o) {
      var t = o.type;
      return t === "GeometryCollection" ? {
        type: t,
        geometries: o.geometries.map(geometry)
      } : t in geometryType ? {
        type: t,
        coordinates: geometryType[t](o)
      } : null;
    }

    var geometryType = {
      Point: function Point(o) {
        return point(o.coordinates);
      },
      MultiPoint: function MultiPoint(o) {
        return o.coordinates.map(point);
      },
      LineString: function LineString(o) {
        return line(o.arcs);
      },
      MultiLineString: function MultiLineString(o) {
        return o.arcs.map(line);
      },
      Polygon: function Polygon(o) {
        return polygon(o.arcs);
      },
      MultiPolygon: function MultiPolygon(o) {
        return o.arcs.map(polygon);
      }
    };

    return geometry(o);
  }

  function reverse(array, n) {
    var t,
        j = array.length,
        i = j - n;
    while (i < --j) {
      t = array[i], array[i++] = array[j], array[j] = t;
    }
  }

  function bisect(a, x) {
    var lo = 0,
        hi = a.length;
    while (lo < hi) {
      var mid = lo + hi >>> 1;
      if (a[mid] < x) lo = mid + 1;else hi = mid;
    }
    return lo;
  }

  function neighbors(objects) {
    var indexesByArc = {},
        // arc index -> array of object indexes
    neighbors = objects.map(function () {
      return [];
    });

    function line(arcs, i) {
      arcs.forEach(function (a) {
        if (a < 0) a = ~a;
        var o = indexesByArc[a];
        if (o) o.push(i);else indexesByArc[a] = [i];
      });
    }

    function polygon(arcs, i) {
      arcs.forEach(function (arc) {
        line(arc, i);
      });
    }

    function geometry(o, i) {
      if (o.type === "GeometryCollection") o.geometries.forEach(function (o) {
        geometry(o, i);
      });else if (o.type in geometryType) geometryType[o.type](o.arcs, i);
    }

    var geometryType = {
      LineString: line,
      MultiLineString: polygon,
      Polygon: polygon,
      MultiPolygon: function MultiPolygon(arcs, i) {
        arcs.forEach(function (arc) {
          polygon(arc, i);
        });
      }
    };

    objects.forEach(geometry);

    for (var i in indexesByArc) {
      for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
        for (var k = j + 1; k < m; ++k) {
          var ij = indexes[j],
              ik = indexes[k],
              n;
          if ((n = neighbors[ij])[i = bisect(n, ik)] !== ik) n.splice(i, 0, ik);
          if ((n = neighbors[ik])[i = bisect(n, ij)] !== ij) n.splice(i, 0, ij);
        }
      }
    }

    return neighbors;
  }

  function presimplify(topology, triangleArea) {
    var absolute = transformAbsolute(topology.transform),
        relative = transformRelative(topology.transform),
        heap = minAreaHeap();

    if (!triangleArea) triangleArea = cartesianTriangleArea;

    topology.arcs.forEach(function (arc) {
      var triangles = [],
          maxArea = 0,
          triangle;

      // To store each point鈥檚 effective area, we create a new array rather than
      // extending the passed-in point to workaround a Chrome/V8 bug (getting
      // stuck in smi mode). For midpoints, the initial effective area of
      // Infinity will be computed in the next step.
      for (var i = 0, n = arc.length, p; i < n; ++i) {
        p = arc[i];
        absolute(arc[i] = [p[0], p[1], Infinity], i);
      }

      for (var i = 1, n = arc.length - 1; i < n; ++i) {
        triangle = arc.slice(i - 1, i + 2);
        triangle[1][2] = triangleArea(triangle);
        triangles.push(triangle);
        heap.push(triangle);
      }

      for (var i = 0, n = triangles.length; i < n; ++i) {
        triangle = triangles[i];
        triangle.previous = triangles[i - 1];
        triangle.next = triangles[i + 1];
      }

      while (triangle = heap.pop()) {
        var previous = triangle.previous,
            next = triangle.next;

        // If the area of the current point is less than that of the previous point
        // to be eliminated, use the latter's area instead. This ensures that the
        // current point cannot be eliminated without eliminating previously-
        // eliminated points.
        if (triangle[1][2] < maxArea) triangle[1][2] = maxArea;else maxArea = triangle[1][2];

        if (previous) {
          previous.next = next;
          previous[2] = triangle[2];
          update(previous);
        }

        if (next) {
          next.previous = previous;
          next[0] = triangle[0];
          update(next);
        }
      }

      arc.forEach(relative);
    });

    function update(triangle) {
      heap.remove(triangle);
      triangle[1][2] = triangleArea(triangle);
      heap.push(triangle);
    }

    return topology;
  }

  function cartesianRingArea(ring) {
    var i = -1,
        n = ring.length,
        a,
        b = ring[n - 1],
        area = 0;

    while (++i < n) {
      a = b;
      b = ring[i];
      area += a[0] * b[1] - a[1] * b[0];
    }

    return area * .5;
  }

  function cartesianTriangleArea(triangle) {
    var a = triangle[0],
        b = triangle[1],
        c = triangle[2];
    return Math.abs((a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]));
  }

  function compareArea(a, b) {
    return a[1][2] - b[1][2];
  }

  function minAreaHeap() {
    var heap = {},
        array = [],
        size = 0;

    heap.push = function (object) {
      up(array[object._ = size] = object, size++);
      return size;
    };

    heap.pop = function () {
      if (size <= 0) return;
      var removed = array[0],
          object;
      if (--size > 0) object = array[size], down(array[object._ = 0] = object, 0);
      return removed;
    };

    heap.remove = function (removed) {
      var i = removed._,
          object;
      if (array[i] !== removed) return; // invalid request
      if (i !== --size) object = array[size], (compareArea(object, removed) < 0 ? up : down)(array[object._ = i] = object, i);
      return i;
    };

    function up(object, i) {
      while (i > 0) {
        var j = (i + 1 >> 1) - 1,
            parent = array[j];
        if (compareArea(object, parent) >= 0) break;
        array[parent._ = i] = parent;
        array[object._ = i = j] = object;
      }
    }

    function down(object, i) {
      while (true) {
        var r = i + 1 << 1,
            l = r - 1,
            j = i,
            child = array[j];
        if (l < size && compareArea(array[l], child) < 0) child = array[j = l];
        if (r < size && compareArea(array[r], child) < 0) child = array[j = r];
        if (j === i) break;
        array[child._ = i] = child;
        array[object._ = i = j] = object;
      }
    }

    return heap;
  }

  function transformAbsolute(transform) {
    if (!transform) return noop;
    var x0,
        y0,
        kx = transform.scale[0],
        ky = transform.scale[1],
        dx = transform.translate[0],
        dy = transform.translate[1];
    return function (point, i) {
      if (!i) x0 = y0 = 0;
      point[0] = (x0 += point[0]) * kx + dx;
      point[1] = (y0 += point[1]) * ky + dy;
    };
  }

  function transformRelative(transform) {
    if (!transform) return noop;
    var x0,
        y0,
        kx = transform.scale[0],
        ky = transform.scale[1],
        dx = transform.translate[0],
        dy = transform.translate[1];
    return function (point, i) {
      if (!i) x0 = y0 = 0;
      var x1 = (point[0] - dx) / kx | 0,
          y1 = (point[1] - dy) / ky | 0;
      point[0] = x1 - x0;
      point[1] = y1 - y0;
      x0 = x1;
      y0 = y1;
    };
  }

  function noop() {}

  return topojson;
}();

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _hook = __webpack_require__(42);

var _hook2 = _interopRequireDefault(_hook);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*!
 * VIZABI Color Model (hook)
 */

var defaultPalettes = {
  "_continuous": {
    "_default": "#ffb600",
    "0": "#B4DE79",
    "50": "#E1CE00",
    "100": "#F77481"
  },
  "_discrete": {
    "_default": "#ffb600",
    "0": "#4cd843",
    "1": "#e83739",
    "2": "#ff7f00",
    "3": "#c027d4",
    "4": "#d66425",
    "5": "#0ab8d8",
    "6": "#bcfa83",
    "7": "#ff8684",
    "8": "#ffb04b",
    "9": "#f599f5",
    "10": "#f4f459",
    "11": "#7fb5ed"
  },
  "_default": {
    "_default": "#93daec"
  }
};

var ColorModel = _hook2.default.extend({

  /**
   * Default values for this model
   */
  getClassDefaults: function getClassDefaults() {
    var defaults = {
      use: null,
      which: null,
      scaleType: null,
      syncModels: [],
      palette: {},
      paletteLabels: null,
      allow: {
        //this is almost everything, but not "nominal", so no random strings like "name"
        scales: ["linear", "log", "genericLog", "time", "pow", "ordinal"]
      }
    };
    return utils.deepExtend(this._super(), defaults);
  },
  autoGenerateModel: function autoGenerateModel() {
    if (this.which == null) {
      var concept = void 0;
      if (this.autogenerate) {
        concept = this.dataSource.getConceptByIndex(this.autogenerate.conceptIndex, this.autogenerate.conceptType);

        if (concept) {
          this.which = concept.concept;
          this.use = "indicator";
          this.scaleType = "linear";
        }
      }
      if (!concept) {
        this.which = "_default";
        this.use = "constant";
        this.scaleType = "ordinal";
      }
    }
    if (this.scaleType == null) {
      this.scaleType = this.dataSource.getConceptprops(this.which).scales[0];
    }
  },


  /**
   * Initializes the color hook
   * @param {Object} values The initial values of this model
   * @param parent A reference to the parent model
   * @param {Object} bind Initial events to bind
   */
  init: function init(name, values, parent, bind) {
    var _this = this;
    this._type = "color";

    this._super(name, values, parent, bind);

    this._syncModelReferences = {};
    this._hasDefaultColor = false;

    this.on("hook_change", function () {
      if (_this._readyOnce) return;

      if (_this.palette && Object.keys(_this.palette._data).length !== 0) {
        var defaultPalette = _this.getDefaultPalette();
        var currentPalette = _this.getPalette(true);
        var palette = {};
        //extend partial current palette with default palette and
        //switch current palette elements which equals
        //default palette elments to nonpersistent state
        Object.keys(defaultPalette).forEach(function (key) {
          if (!currentPalette[key] || defaultPalette[key] == currentPalette[key]) palette[key] = defaultPalette[key];
        });
        _this.set("palette", palette, false, false);
      }
    });
  },
  setInterModelListeners: function setInterModelListeners() {
    this._super();
    this._setSyncModels();
  },


  // args: {colorID, shadeID}
  getColorShade: function getColorShade(args) {
    var palette = this.getPalette();

    if (!args) return utils.warn("getColorShade() is missing arguments");

    // if colorID is not given or not found in the palette, replace it with default color
    if (!args.colorID || !palette[args.colorID]) args.colorID = "_default";

    // if the resolved colr value is not an array (has only one shade) -- return it
    if (!utils.isArray(palette[args.colorID])) return palette[args.colorID];

    var conceptpropsColor = this.getConceptprops().color;
    var shade = args.shadeID && conceptpropsColor && conceptpropsColor.shades && conceptpropsColor.shades[args.shadeID] ? conceptpropsColor.shades[args.shadeID] : 0;

    return palette[args.colorID][shade];
  },


  /**
   * Get the above constants
   */
  isUserSelectable: function isUserSelectable() {
    var conceptpropsColor = this.getConceptprops().color;
    return conceptpropsColor == null || conceptpropsColor.selectable == null || conceptpropsColor.selectable;
  },
  setWhich: function setWhich(newValue) {
    this._super(newValue);
    if (this.palette) this.palette._data = {};
    this._setSyncModels();
  },
  _setSyncModels: function _setSyncModels() {
    var _this = this;
    this.syncModels.forEach(function (modelName) {
      //fetch the model to sync, it's marker and entities
      var model = _this.getClosestModel(modelName);
      var marker = model.isHook() ? model._parent : model;
      var entities = marker.getClosestModel(marker.space[0]);

      //save the references here locally
      _this._syncModelReferences[modelName] = { model: model, marker: marker, entities: entities };

      if (_this.isDiscrete()) _this._setSyncModel(model, marker, entities);
    });
  },
  _setSyncModel: function _setSyncModel(model, marker, entities) {
    if (model == marker) {
      var newFilter = {
        dim: this.which,
        show: {}
      };
      marker.setDataSourceForAllSubhooks(this.data);
      entities.set(newFilter, false, false);
    } else {
      if (model.isDiscrete() && model.use !== "constant") model.set({ which: this.which, data: this.data }, false, false);
    }
  },
  getColorlegendMarker: function getColorlegendMarker() {
    return (this._syncModelReferences["marker_colorlegend"] || {})["marker"];
  },
  getColorlegendEntities: function getColorlegendEntities() {
    return (this._syncModelReferences["marker_colorlegend"] || {})["entities"];
  },


  /**
   * set color
   */
  setColor: function setColor(value, pointer) {
    var temp = this.getPalette();
    temp[pointer] = value;
    this.scale.range(utils.values(temp));
    this.palette[pointer] = value;
  },


  /**
   * maps the value to this hook's specifications
   * @param value Original value
   * @returns hooked value
   */
  mapValue: function mapValue(value) {
    //if the property value does not exist, supply the _default
    // otherwise the missing value would be added to the domain
    if (this.scale != null && this.isDiscrete() && this._hasDefaultColor && this.scale.domain().indexOf(value) == -1) value = "_default";
    return this._super(value);
  },
  getDefaultPalette: function getDefaultPalette() {
    var conceptpropsColor = this.getConceptprops().color;
    var palette = void 0;

    this.discreteDefaultPalette = false;

    if (conceptpropsColor && conceptpropsColor.palette) {
      //specific color palette from hook concept properties
      palette = utils.clone(conceptpropsColor.palette);
    } else if (defaultPalettes[this.which]) {
      //color palette for this.which exists in palette defaults
      palette = utils.clone(defaultPalettes[this.which]);
    } else if (this.use === "constant") {
      //an explicit hex color constant #abc or #adcdef is provided
      if (/^#([0-9a-f]{3}|[0-9a-f]{6})$/.test(this.which)) {
        palette = { "_default": this.which };
      } else {
        palette = utils.clone(defaultPalettes["_default"]);
      }
    } else {
      palette = utils.clone(defaultPalettes[this.isDiscrete() ? "_discrete" : "_continuous"]);
      this.discreteDefaultPalette = true;
    }

    return palette;
  },
  _getPaletteLabels: function _getPaletteLabels() {
    var conceptpropsColor = this.getConceptprops().color;
    var paletteLabels = null;

    if (conceptpropsColor && conceptpropsColor.paletteLabels) {
      //specific color palette from hook concept properties
      paletteLabels = utils.clone(conceptpropsColor.paletteLabels);
    }
    return paletteLabels;
  },
  getPaletteLabels: function getPaletteLabels() {
    return this.paletteLabels.getPlainObject();
  },
  getPalette: function getPalette(includeDefault) {
    //rebuild palette if it's empty
    if (!this.palette || Object.keys(this.palette._data).length === 0) {
      var _palette = this.getDefaultPalette();
      this.set("palette", _palette, false, false);
      var paletteLabels = this._getPaletteLabels();
      this.set("paletteLabels", paletteLabels, false, false);
    }
    var palette = this.palette.getPlainObject();
    if (this.use === "indicator" && !includeDefault) {
      delete palette["_default"];
    }
    return palette;
  },


  /**
   * Gets the domain for this hook
   * @returns {Array} domain
   */
  buildScale: function buildScale() {
    var scaleType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.scaleType;

    var _this = this;

    var paletteObject = _this.getPalette();
    var domain = Object.keys(paletteObject);
    var range = utils.values(paletteObject);

    this._hasDefaultColor = domain.indexOf("_default") > -1;

    if (scaleType == "time") {

      var timeMdl = this._space.time;
      var limits = timeMdl.splash ? { min: timeMdl.parse(timeMdl.startOrigin), max: timeMdl.parse(timeMdl.endOrigin) } : { min: timeMdl.start, max: timeMdl.end };

      var singlePoint = limits.max - limits.min == 0;

      domain = domain.sort(function (a, b) {
        return a - b;
      });
      range = domain.map(function (m) {
        return singlePoint ? paletteObject[domain[0]] : paletteObject[m];
      });
      domain = domain.map(function (m) {
        return limits.min.valueOf() + m / 100 * (limits.max.valueOf() - limits.min.valueOf());
      });

      this.scale = d3.time.scale.utc().domain(domain).range(range).interpolate(d3.interpolateRgb);
    } else if (!this.isDiscrete()) {

      var _limits = this.getLimits(this.which);
      //default domain is based on limits
      _limits = [_limits.min, _limits.max];
      //domain from concept properties can override it if defined
      _limits = this.getConceptprops().domain ? this.getConceptprops().domain : _limits;

      var _singlePoint = _limits[1] - _limits[0] == 0;

      domain = domain.sort(function (a, b) {
        return a - b;
      });
      range = domain.map(function (m) {
        return _singlePoint ? paletteObject[domain[0]] : paletteObject[m];
      });
      domain = domain.map(function (m) {
        return _limits[0] + m / 100 * (_limits[1] - _limits[0]);
      });

      if (d3.min(domain) <= 0 && d3.max(domain) >= 0 && scaleType === "log") scaleType = "genericLog";

      if (scaleType == "log" || scaleType == "genericLog") {
        var s = d3.scale.genericLog().domain(_limits).range(_limits);
        domain = domain.map(function (d) {
          return s.invert(d);
        });
      }
      this.scale = d3.scale[scaleType]().domain(domain).range(range).interpolate(d3.interpolateRgb);
    } else {
      range = range.map(function (m) {
        return utils.isArray(m) ? m[0] : m;
      });

      scaleType = "ordinal";

      if (this.discreteDefaultPalette) domain = domain.concat(this.getUnique(this.which));
      this.scale = d3.scale[scaleType]().domain(domain).range(range);
    }

    this.scaleType = scaleType;
  }
});

exports.default = ColorModel;

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _model = __webpack_require__(47);

var _model2 = _interopRequireDefault(_model);

var _reader = __webpack_require__(72);

var _reader2 = _interopRequireDefault(_reader);

var _events = __webpack_require__(46);

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * VIZABI Data Model (model.data)
 */

var DataModel = _model2.default.extend({

  /**
   * Default values for this model
   */
  getClassDefaults: function getClassDefaults() {
    var defaults = {
      reader: "csv"
    };
    return utils.deepExtend(this._super(), defaults);
  },


  trackInstances: true,

  /**
   * Initializes the data model.
   * @param {Object} values The initial values of this model
   * @param parent A reference to the parent model
   * @param {Object} bind Initial events to bind
   */
  init: function init(name, values, parent, bind) {

    this._type = "data";

    this.queryQueue = {};
    this._collection = {};
    this._collectionPromises = {}; // stores promises, making sure we don't do one calulation twice

    //same constructor as parent, with same arguments
    this._super(name, values, parent, bind);

    this.readerObject = this.getReader();
  },


  /**
   * Loads concept properties when all other models are also starting to load data
   * @return {Promise} Promise which resolves when concepts are loaded
   */
  preloadData: function preloadData() {
    return this.loadConceptProps();
  },


  /**
   * Loads resource from reader or cache
   * @param {Array} query Array with queries to be loaded
   * @param {Object} parsers An object with concepts as key and parsers as value
   * @param {*} evts ?
   */
  load: function load(query) {
    var _this2 = this;

    var parsers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};


    // add waffle server specific query clauses if set
    if (this.dataset) query.dataset = this.dataset;
    if (this.version) query.version = this.version;

    var dataId = this.getDataId(query);

    if (dataId) {
      return Promise.resolve(dataId);
    }

    utils.timeStamp("Vizabi Data: Loading Data");
    _events2.default.freezeAll(["hook_change", "resize"]);

    return this.loadFromReader(query, parsers).then(function (dataId) {
      _events2.default.unfreezeAll();
      return dataId;
    }).catch(function (error) {
      return _this2.handleReaderError(error, query);
    });
  },


  /**
   * Loads resource from reader
   * @param {Array} query Array with queries to be loaded
   * @param {Object} parsers An object with concepts as key and parsers as value
   */
  loadFromReader: function loadFromReader(query, parsers) {
    var _this = this;

    var dataId = utils.hashCode([query]);
    var queryMergeId = utils.hashCode([query.select.key, query.where, query.join]);

    if (this.queryQueue[queryMergeId]) {

      // add select to base query and return the base query promise
      Array.prototype.push.apply(this.queryQueue[queryMergeId].query.select.value, query.select.value);
      utils.extend(this.queryQueue[queryMergeId].parsers, parsers);
      return this.queryQueue[queryMergeId].promise;
    }

    // set up base query
    var promise = new Promise(function (resolve, reject) {

      // wait one execution round for the queue to fill up
      utils.defer(function () {
        // now the query queue is filled with all queries from one execution round

        // remove double columns from select (resulting from merging)
        // no double columns in formatter because it's an object, extend would've overwritten doubles
        query.select.value = utils.unique(query.select.value);

        // execute the query with this reader
        _this.readerObject.read(query, parsers).then(function (response) {
          //success reading
          _this.checkQueryResponse(query, response);

          _this._collection[dataId] = {};
          _this._collectionPromises[dataId] = {};
          var col = _this._collection[dataId];
          col.data = response;
          col.valid = {};
          col.nested = {};
          col.unique = {};
          col.limits = {};
          col.frames = {};
          col.haveNoDataPointsPerKey = {};
          col.query = query;
          // col.sorted = {}; // TODO: implement this for sorted data-sets, or is this for the server/(or file reader) to handle?

          // remove query from queue
          _this.queryQueue[queryMergeId] = null;
          resolve(dataId);
        }).catch(function (err) {
          _this.queryQueue[queryMergeId] = null;
          reject(err);
        });
      });
    });

    this.queryQueue[queryMergeId] = {
      query: query,
      parsers: parsers,
      promise: promise
    };

    return this.queryQueue[queryMergeId].promise;
  },
  getReader: function getReader() {
    // Create a new reader for this query
    var readerClass = _reader2.default.get(this.reader);
    if (!readerClass) {
      throw new Error("Unknown reader: " + this.reader);
    }

    return new readerClass({
      path: this.path,
      delimiter: this.delimiter,
      keySize: this.keySize,
      data: this.data
    });
  },
  checkQueryResponse: function checkQueryResponse(query, response) {
    if (response.length == 0) utils.warn("Reader for data source '" + this._name + "' returned empty array for query:", JSON.stringify(query, null, 2));

    if (response.length > 0) {
      // search data for the entirely missing columns
      var columnsMissing = (query.select.key || []).concat(query.select.value || []);
      for (var i = response.length - 1; i >= 0; i--) {
        for (var c = columnsMissing.length - 1; c >= 0; c--) {
          // if found value for column c in row i then remove that column name from the list of missing columns
          if (response[i][columnsMissing[c]] || response[i][columnsMissing[c]] === 0) columnsMissing.splice(c, 1);
        }
        // all columns were found to have value in at least one of the rows then stop iterating
        if (!columnsMissing.length) break;
      }
      columnsMissing.forEach(function (d) {
        if (query.select.key.indexOf(d) == -1) {
          utils.warn('Reader result: Column "' + d + '" is missing from "' + query.from + '" data, but it might be ok');
        } else {
          utils.error('Reader result: Key column "' + d + '" is missing from "' + query.from + '" data for query:', JSON.stringify(query));
          console.log(response);
        }
      });
    }
  },


  /**
   * get data
   */
  getData: function getData(dataId, what, whatId, args) {
    // if not specified data from what query, return nothing
    if (!dataId) return utils.warn("Data.js 'get' method doesn't like the dataId you gave it: " + dataId);

    // if they want data, return the data
    if (!what || what == "data") {
      return this._collection[dataId]["data"];
    }

    // if they didn't give an instruction, give them the whole thing
    // it's probably old code which modifies the data outside this class
    // TODO: move these methods inside (e.g. model.getNestedItems())
    if (!whatId) {
      return this._collection[dataId][what];
    }

    // if they want a certain processing of the data, see if it's already in cache
    var id = typeof whatId == "string" ? whatId : JSON.stringify(whatId);
    if (this._collection[dataId][what][id]) {
      return this._collection[dataId][what][id];
    }

    // if it's not cached, process the data and then return it
    switch (what) {
      case "unique":
        this._collection[dataId][what][id] = this._getUnique(dataId, whatId);
        break;
      case "valid":
        this._collection[dataId][what][id] = this._getValid(dataId, whatId);
        break;
      case "limits":
        this._collection[dataId][what][id] = this._getLimits(dataId, whatId);
        break;
      case "nested":
        this._collection[dataId][what][id] = this._getNested(dataId, whatId);
        break;
      case "haveNoDataPointsPerKey":
        //do nothing. no caching is available for this option, served directly from collection
        break;
    }
    return this._collection[dataId][what][id];
  },
  loadConceptProps: function loadConceptProps() {
    var _this3 = this;

    var query = {
      select: {
        key: ["concept"],
        value: ["concept_type", "domain", "indicator_url", "color", "scales", "interpolation", "tags", "name", "unit", "description", "format"]
      },
      from: "concepts",
      where: {},
      language: this.getClosestModel("locale").id
    };

    return this.load(query).then(this.handleConceptPropsResponse.bind(this)).catch(function (error) {
      return _this3.handleReaderError(error, query);
    });
  },
  handleConceptPropsResponse: function handleConceptPropsResponse(dataId) {
    var _this4 = this;

    this.conceptDictionary = { _default: { concept_type: "string", use: "constant", scales: ["ordinal"], tags: "_root" } };
    this.conceptArray = [];

    this.getData(dataId).forEach(function (d) {
      var concept = {};

      if (d.concept_type) concept["use"] = d.concept_type == "measure" || d.concept_type == "time" ? "indicator" : "property";

      concept["concept_type"] = d.concept_type;
      concept["sourceLink"] = d.indicator_url;
      try {
        concept["color"] = d.color && d.color !== "" ? JSON.parse(d.color) : null;
      } catch (e) {
        concept["color"] = null;
      }
      try {
        concept["scales"] = d.scales ? JSON.parse(d.scales) : null;
      } catch (e) {
        concept["scales"] = null;
      }
      if (!concept.scales) {
        switch (d.concept_type) {
          case "measure":
            concept.scales = ["linear", "log"];break;
          case "string":
            concept.scales = ["nominal"];break;
          case "entity_domain":
            concept.scales = ["ordinal"];break;
          case "entity_set":
            concept.scales = ["ordinal"];break;
          case "time":
            concept.scales = ["time"];break;
        }
      }
      if (concept["scales"] == null) concept["scales"] = ["linear", "log"];
      if (d.interpolation) {
        concept["interpolation"] = d.interpolation;
      } else if (d.concept_type == "measure") {
        concept["interpolation"] = concept.scales && concept.scales[0] == "log" ? "exp" : "linear";
      } else if (d.concept_type == "time") {
        concept["interpolation"] = "linear";
      } else {
        concept["interpolation"] = "stepMiddle";
      }
      concept["concept"] = d.concept;
      concept["domain"] = d.domain;
      concept["tags"] = d.tags;
      concept["format"] = d.format;
      concept["name"] = d.name || d.concept || "";
      concept["unit"] = d.unit || "";
      concept["description"] = d.description;
      _this4.conceptDictionary[d.concept] = concept;
      _this4.conceptArray.push(concept);
    });
  },
  getConceptprops: function getConceptprops(which) {
    return which ? this.conceptDictionary[which] || utils.warn("The concept " + which + " is not found in the dictionary") : this.conceptDictionary;
  },
  getConceptByIndex: function getConceptByIndex(index, type) {
    //if(!concept && type == "measure") concept = this.conceptArray.filter(f => f.concept_type==="time")[0];
    return this.conceptArray.filter(function (f) {
      return !type || !f.concept_type || f.concept_type === type;
    })[index];
  },
  getDatasetName: function getDatasetName() {
    if (this.readerObject.getDatasetInfo) {
      var meta = this.readerObject.getDatasetInfo();
      return meta.name + (meta.version ? " " + meta.version : "");
    }
    return this._name;
  },
  _getCacheKey: function _getCacheKey(frames, keys) {
    var result = frames[0] + " - " + frames[frames.length - 1];
    if (keys) {
      result = result + "_" + keys.join();
    }
    return result;
  },
  getFrames: function getFrames(dataId, framesArray, keys) {
    var _this = this;
    var whatId = this._getCacheKey(framesArray, keys);
    if (!this._collectionPromises[dataId][whatId]) {
      this._collectionPromises[dataId][whatId] = {
        queue: this.framesQueue(framesArray, whatId),
        promise: null
      };
    }
    if (this._collectionPromises[dataId][whatId] && this._collectionPromises[dataId][whatId]["promise"] instanceof Promise) {
      return this._collectionPromises[dataId][whatId]["promise"];
    }

    this._collectionPromises[dataId][whatId]["promise"] = new Promise(function (resolve, reject) {
      if (!dataId) reject(utils.warn("Data.js 'get' method doesn't like the dataId you gave it: " + dataId));
      _this._getFrames(dataId, whatId, framesArray, keys).then(function (frames) {
        _this._collection[dataId]["frames"][whatId] = frames;
        resolve(_this._collection[dataId]["frames"][whatId]);
      });
    });

    return this._collectionPromises[dataId][whatId]["promise"];
  },
  getFrame: function getFrame(dataId, framesArray, neededFrame, keys) {
    //can only be called after getFrames()
    var _this = this;
    var whatId = this._getCacheKey(framesArray, keys);
    return new Promise(function (resolve, reject) {
      if (_this._collection[dataId]["frames"][whatId] && _this._collection[dataId]["frames"][whatId][neededFrame]) {
        resolve(_this._collection[dataId]["frames"][whatId]);
      } else {
        _this._collectionPromises[dataId][whatId]["queue"].forceFrame(neededFrame, function () {
          resolve(_this._collection[dataId]["frames"][whatId]);
        });
      }
    });
  },
  listenFrame: function listenFrame(dataId, framesArray, keys, cb) {
    var _this = this;
    var whatId = this._getCacheKey(framesArray, keys);
    this._collectionPromises[dataId][whatId]["queue"].defaultCallbacks.push(function (time) {
      cb(dataId, time);
    });
    if (this._collection[dataId]["frames"][whatId]) {
      utils.forEach(this._collection[dataId]["frames"][whatId], function (frame, key) {
        cb(dataId, new Date(key));
      });
    }
  },
  _muteAllQueues: function _muteAllQueues(except) {
    utils.forEach(this._collectionPromises, function (queries, dataId) {
      utils.forEach(queries, function (promise, whatId) {
        if (promise.queue.isActive == true && promise.queue.whatId != except) {
          promise.queue.mute();
        }
      });
    });
  },
  _checkForcedQueuesExists: function _checkForcedQueuesExists() {
    utils.forEach(this._collectionPromises, function (queries, dataId) {
      utils.forEach(queries, function (promise, whatId) {
        if (promise.queue.forcedQueue.length > 0) {
          promise.queue.unMute();
        }
      });
    });
  },
  _unmuteQueue: function _unmuteQueue() {
    utils.forEach(this._collectionPromises, function (queries, dataId) {
      utils.forEach(queries, function (promise, whatId) {
        if (promise.queue.isActive == false) {
          promise.queue.unMute();
        }
      });
    });
  },

  /**
   * set priority for generate each year frame
   * @param framesArray
   * @returns {*}
   */
  framesQueue: function framesQueue(framesArray, whatId) {
    var _context = this;
    return new function () {
      this.defaultCallbacks = [];
      this.callbacks = {};
      this.forcedQueue = [];
      this.isActive = true;
      this.delayedAction = null;
      this.whatId = whatId;
      this.queue = framesArray.slice(0); //clone array
      var queue = this;
      //put the last element to the start of the queue because we are likely to need it first
      this.queue.splice(0, 0, this.queue.splice(this.queue.length - 1, 1)[0]);
      this.key = 0;
      this.mute = function () {
        this.isActive = false;
        this.delayedAction = Promise.resolve.bind(Promise);
      };

      this.unMute = function () {
        this.isActive = true;
        if (typeof this.delayedAction == "function") {
          this.delayedAction();
        }
        this.delayedAction = null;
        if (this.forcedQueue.length == 0 && this.queue.length == 0) {
          _context._unmuteQueue();
        }
      };
      this.frameComplete = function (frameName) {
        //function called after build each frame with name of frame build
        var i = void 0;
        if (queue.defaultCallbacks.length > 0) {
          for (i = 0; i < queue.defaultCallbacks.length; i++) {
            queue.defaultCallbacks[i](frameName);
          }
        }
        if (queue.callbacks[frameName] && queue.callbacks[frameName].length > 0) {
          for (i = 0; i < queue.callbacks[frameName].length; i++) {
            queue.callbacks[frameName][i]();
          }
        }
      };
      this._waitingForActivation = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
          if (_this.isActive) {
            return resolve();
          }
          _this.delayedAction = resolve;
        });
      };

      this._getNextFrameName = function () {
        var frameName = null;
        if (this.forcedQueue.length > 0 || this.queue.length > 0) {
          if (this.forcedQueue.length > 0) {
            frameName = this.forcedQueue.shift();
          } else {
            if (this.forcedQueue.length == 0 && this.key >= this.queue.length - 1) {
              this.key = 0;
            }
            frameName = this.queue.splice(this.key, 1).pop();
          }
        } else {
          _context._unmuteQueue();
        }
        return frameName;
      };
      this.checkForcedFrames = function () {
        if (this.forcedQueue.length > 0) return;
        _context._checkForcedQueuesExists();
      };

      // returns the next frame in a queue
      this.getNext = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
          _this.checkForcedFrames();
          if (_this.isActive) {
            resolve(_this._getNextFrameName());
          } else {
            _this._waitingForActivation().then(function () {
              resolve(_this._getNextFrameName());
            });
          }
        });
      };

      // force the particular frame up the queue
      this.forceFrame = function (frameName, cb) {
        var objIndexOf = function objIndexOf(obj, need) {
          var search = need.toString();
          var index = -1;
          for (var i = 0, len = obj.length; i < len; i++) {
            if (obj[i].toString() == search) {
              index = i;
              break;
            }
          }
          return index;
        };
        if (this.callbacks[frameName]) {

          this.callbacks[frameName].push(cb);
        } else {
          var newKey = objIndexOf(this.queue, frameName); //this.queue.indexOf(frameName.toString());
          if (newKey !== -1) {
            this.forcedQueue.unshift(this.queue.splice(newKey, 1).pop());
            _context._muteAllQueues(this.whatId);
            this.unMute();
            if (typeof cb === "function") {
              if (_typeof(this.callbacks[frameName]) != "object") {
                this.callbacks[frameName] = [];
              }
              this.callbacks[frameName].push(cb);
            }
            this.key = newKey; //set key to next year after gorced element (preload if user click play)
          } else {
            if (_typeof(this.callbacks[frameName]) === "object") {
              this.callbacks[frameName].push(cb);
            } else {
              this.callbacks[frameName] = [cb];
            }
          }
        }
      };
    }();
  },


  /**
   * Get regularised dataset (where gaps are filled)
   * @param {Number} dataId hash code for query
   * @param {String} whatId hash code for cache
   * @param {Array} framesArray -- array of keyframes across animatable
   * @param {Array} keys -- array of keys
   * @returns {Object} regularised dataset, nested by [animatable, column, key]
   */
  _getFrames: function _getFrames(dataId, whatId, framesArray, keys) {
    var _this = this;

    if (!_this._collection[dataId]["frames"][whatId]) {
      _this._collection[dataId]["frames"][whatId] = {};
    }
    return new Promise(function (resolve, reject) {

      //TODO: thses should come from state or from outside somehow
      // FramesArray in the input contains the array of keyframes in animatable dimension.
      // Example: array of years like [1800, 1801 … 2100]
      // these will be the points where we need data
      // (some of which might already exist in the set. in regular datasets all the points would exist!)

      // Check if query.where clause is missing a time field

      var indicatorsDB = _this.getConceptprops();

      if (!indicatorsDB) utils.warn("_getFrames in data.js is missing indicatorsDB, it's needed for gap filling");
      if (!framesArray) utils.warn("_getFrames in data.js is missing framesArray, it's needed so much");

      var TIME = _this._collection[dataId].query.animatable;
      var KEY = _this._collection[dataId].query.select.key.slice(0);
      if (TIME && KEY.indexOf(TIME) != -1) KEY.splice(KEY.indexOf(TIME), 1);

      var filtered = {};
      var k = void 0,
          items = void 0,
          itemsIndex = void 0,
          oneFrame = void 0,
          method = void 0,
          use = void 0,
          next = void 0;

      var entitiesByKey = {};
      if (KEY.length > 1) {
        for (k = 1; k < KEY.length; k++) {
          var _nested = _this.getData(dataId, "nested", [KEY[k]].concat([TIME]));
          entitiesByKey[KEY[k]] = Object.keys(_nested);
        }
      }

      // We _nest_ the flat dataset in two levels: first by “key” (example: geo), then by “animatable” (example: year)
      // See the _getNested function for more details
      var nested = _this.getData(dataId, "nested", KEY.concat([TIME]));
      keys = keys ? keys : Object.keys(nested);
      entitiesByKey[KEY[0]] = keys;
      // Get the list of columns that are in the dataset, exclude key column and animatable column
      // Example: [“lex”, “gdp”, “u5mr"]
      var query = _this._collection[dataId].query;
      var columns = query.select.value.filter(function (f) {
        return f !== "_default";
      });

      var cLength = columns.length;
      var key = void 0,
          c = void 0;

      var lastIndex = KEY.length - 1;
      var createFiltered = function createFiltered(parent, index) {
        var keys = entitiesByKey[KEY[index]];
        for (var i = 0, j = keys.length; i < j; i++) {
          parent[keys[i]] = {};
          if (index == lastIndex) {
            for (c = 0; c < cLength; c++) {
              parent[keys[i]][columns[c]] = null;
            }
          } else {
            var nextIndex = index + 1;
            createFiltered(parent[keys[i]], nextIndex);
          }
        }
      };

      createFiltered(filtered, 0);

      for (c = 0; c < cLength; c++) {
        _this._collection[dataId].haveNoDataPointsPerKey[columns[c]] = {};
      }var buildFrame = function buildFrame(frameName, entitiesByKey, KEY, dataId, callback) {
        var frame = {};
        if (query.from !== "datapoints") {
          // we populate the regular set with a single value (unpack properties into constant time series)
          var dataset = _this._collection[dataId].data;
          for (c = 0; c < cLength; c++) {
            frame[columns[c]] = {};
          }for (var i = 0; i < dataset.length; i++) {
            var d = dataset[i];
            for (c = 0; c < cLength; c++) {
              frame[columns[c]][d[KEY[0]]] = d[columns[c]];
              //check data for properties with missed data. If founded then write key to haveNoDataPointsPerKey with
              //count of broken datapoints
              if (d[columns[c]] == null) {
                _this._collection[dataId].haveNoDataPointsPerKey[columns[c]][d[KEY[0]]] = dataset.length;
              }
            }
          }
        } else {
          var _mapValue = function _mapValue(column, firstKey, lastKey, firstKeyObject, lastKeyObject, nested, filtered) {

            //If there are some points in the array with valid numbers, then
            //interpolate the missing point and save it to the “clean regular set”
            method = indicatorsDB[column] ? indicatorsDB[column].interpolation : null;
            use = indicatorsDB[column] ? indicatorsDB[column].use : "indicator";

            if (firstKeyObject) {
              frame[column][firstKey] = firstKeyObject[firstKey];
            } else {
              lastKeyObject = frame[column];
            }

            // Inside of this 3-level loop is the following:
            if (nested && nested[frameName] && (nested[frameName][0][column] || nested[frameName][0][column] === 0)) {

              // Check if the piece of data for [this key][this frame][this column] exists
              // and is valid. If so, then save it into a “clean regular set”
              lastKeyObject[lastKey] = nested[frameName][0][column];
            } else if (method === "none") {

              // the piece of data is not available and the interpolation is set to "none"
              lastKeyObject[lastKey] = null;
            } else {
              // If the piece of data doesn’t exist or is invalid, then we need to inter- or extapolate it

              // Let’s take a slice of the nested set, corresponding to the current key nested[key]
              // As you remember it has the data nested further by frames.
              // At every frame the data in the current column might or might not exist.
              // Thus, let’s filter out all the frames which don’t have the data for the current column.
              // Let’s cache it because we will most likely encounter another gap in the same column for the same key
              items = filtered[column];
              if (items === null) {
                var givenFrames = Object.keys(nested);
                items = new Array(givenFrames.length);
                itemsIndex = 0;

                for (var z = 0, length = givenFrames.length; z < length; z++) {
                  oneFrame = nested[givenFrames[z]];
                  if (oneFrame[0][column] || oneFrame[0][column] === 0) items[itemsIndex++] = oneFrame[0];
                }

                //trim the length of the array
                items.length = itemsIndex;

                if (itemsIndex === 0) {
                  filtered[column] = [];
                } else {
                  filtered[column] = items;
                }

                if (items.length == 0) _this._collection[dataId].haveNoDataPointsPerKey[column][key] = items.length;
              }

              // Now we are left with a fewer frames in the filtered array. Let's check its length.
              //If the array is empty, then the entire column is missing for the key
              //So we let the key have missing values in this column for all frames
              if (items && items.length > 0) {
                next = null;
                lastKeyObject[lastKey] = utils.interpolatePoint(items, use, column, next, TIME, frameName, method);
              }
            }
          };

          // If there is a time field in query.where clause, then we are dealing with indicators in this request

          // Put together a template for cached filtered sets (see below what's needed)

          // Now we run a 3-level loop: across frames, then across keys, then and across data columns (lex, gdp)

          for (c = 0; c < cLength; c++) {
            frame[columns[c]] = {};
          }var iterateKeys = function iterateKeys(firstKeyObject, lastKeyObject, firstKey, nested, filtered, index) {
            var keys = entitiesByKey[KEY[index]];
            for (var _i = 0, j = keys.length; _i < j; _i++) {
              if (index == 0) {
                firstKey = keys[_i]; //root level
              }
              if (index == lastIndex) {
                for (c = 0; c < cLength; c++) {
                  _mapValue(columns[c], firstKey, keys[_i], firstKeyObject, lastKeyObject, nested[keys[_i]], filtered[keys[_i]]);
                }
              } else {
                if (index == 0) {
                  lastKeyObject = firstKeyObject = {};
                }
                var nextIndex = index + 1;
                lastKeyObject[keys[_i]] = {};
                iterateKeys(firstKeyObject, lastKeyObject[keys[_i]], firstKey, nested[keys[_i]], filtered[keys[_i]], nextIndex);
              }
            }
          };

          iterateKeys(null, null, null, nested, filtered, 0);
        }

        // save the calcualted frame to global datamanager cache
        _this._collection[dataId]["frames"][whatId][frameName] = frame;

        // fire the callback
        if (typeof callback === "function") {
          // runs the function frameComplete inside framesQueue.getNext()
          callback(frameName);
        }

        // recursively call the buildFrame again, this time for the next frame
        //QUESTION: FramesArray is probably not needed at this point. dataId and whatId is enough
        _this._collectionPromises[dataId][whatId]["queue"].getNext().then(function (nextFrame) {
          if (nextFrame) {
            utils.defer(function () {
              buildFrame(nextFrame, entitiesByKey, KEY, dataId, _this._collectionPromises[dataId][whatId]["queue"].frameComplete);
            });
          } else {
            //this goes to marker.js as a "response"
            resolve(_this._collection[dataId]["frames"][whatId]);
          }
        });
      };
      _this._collectionPromises[dataId][whatId]["queue"].getNext().then(function (nextFrame) {
        if (nextFrame) {
          buildFrame(nextFrame, entitiesByKey, KEY, dataId, _this._collectionPromises[dataId][whatId]["queue"].frameComplete);
        }
      });
    });
  },
  _getNested: function _getNested(dataId, order) {
    // Nests are objects of key-value pairs
    // Example:
    //
    // order = ["geo", "time"];
    //
    // original_data = [
    //   { geo: "afg", time: 1800, gdp: 23424, lex: 23}
    //   { geo: "afg", time: 1801, gdp: 23424, lex: null}
    //   { geo: "chn", time: 1800, gdp: 23587424, lex: 46}
    //   { geo: "chn", time: 1801, gdp: null, lex: null}
    // ];
    //
    // nested_data = {
    //   afg: {
    //     1800: {gdp: 23424, lex: 23},
    //     1801: {gdp: 23424, lex: null}
    //   }
    //   chn: {
    //     1800: {gdp: 23587424, lex: 46 },
    //     1801: {gdp: null, lex: null }
    //   }
    // };

    var nest = d3.nest();
    for (var i = 0; i < order.length; i++) {
      nest = nest.key(function (k) {
        return function (d) {
          return d[k];
        };
      }(order[i]));
    }

    return utils.nestArrayToObj(nest.entries(this._collection[dataId]["data"]));
  },
  _getUnique: function _getUnique(dataId, attr) {
    var uniq = void 0;
    var items = this._collection[dataId].data;
    // if it's an array, it will return a list of unique combinations.
    if (utils.isArray(attr)) {
      var values = items.map(function (d) {
        return utils.clone(d, attr);
      }); // pick attrs
      uniq = utils.unique(values, function (n) {
        return JSON.stringify(n);
      });
    } // if it's a string, it will return a list of values
    else {
        var _values = items.map(function (d) {
          return d[attr];
        });
        uniq = utils.unique(_values);
      }
    return uniq;
  },
  _getValid: function _getValid(dataId, column) {
    return this._collection[dataId].data.filter(function (f) {
      return f[column] || f[column] === 0;
    });
  },
  _getLimits: function _getLimits(dataId, attr) {

    var items = this._collection[dataId].data;
    // get only column attr and only rows with number or date
    var filtered = items.reduce(function (filtered, d) {

      // check for dates
      var f = utils.isDate(d[attr]) ? d[attr] : parseFloat(d[attr]);

      // if it is a number
      if (!isNaN(f)) {
        filtered.push(f);
      }

      //filter
      return filtered;
    }, []);

    // get min/max for the filtered rows
    var min = void 0;
    var max = void 0;
    var limits = {};
    for (var i = 0; i < filtered.length; i += 1) {
      var c = filtered[i];
      if (typeof min === "undefined" || c < min) {
        min = c;
      }
      if (typeof max === "undefined" || c > max) {
        max = c;
      }
    }
    limits.min = min || 0;
    limits.max = max || 100;
    return limits;
  },


  /**
   * checks whether this combination is cached or not
   */
  getDataId: function getDataId(query) {
    //encode in hashCode
    var q = utils.hashCode([query]);
    //simply check if we have this in internal data
    if (Object.keys(this._collection).indexOf(q) !== -1) {
      return q;
    }
    return false;
  },
  handleReaderError: function handleReaderError(error, query) {
    if (utils.isObject(error)) {
      var locale = this.getClosestModel("locale");
      var translation = locale.getTFunction()(error.code, error.payload) || "";
      error = (translation + " " + (error.message || "")).trim();
    }

    utils.warn("Problem with query: ", query);
    throw error;
  }
});

exports.default = DataModel;

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _dataconnected = __webpack_require__(61);

var _dataconnected2 = _interopRequireDefault(_dataconnected);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/*!
 * VIZABI Entities Model
 */

var EntitiesModel = _dataconnected2.default.extend({

  /**
   * Default values for this model
   */
  getClassDefaults: function getClassDefaults() {
    var defaults = {
      show: {},
      dim: null,
      skipFilter: false
    };
    return utils.deepExtend(this._super(), defaults);
  },


  objectLeafs: ["show", "autogenerate"],
  dataConnectedChildren: ["show", "dim"],

  /**
   * Initializes the entities model.
   * @param {Object} values The initial values of this model
   * @param parent A reference to the parent model
   * @param {Object} bind Initial events to bind
   */
  init: function init(name, values, parent, bind) {

    this._type = "entities";

    this._super(name, values, parent, bind);
  },
  afterPreload: function afterPreload() {
    if (this.dim == null && this.autogenerate) {
      var dataSource = this.getClosestModel(this.autogenerate.data);
      this.dim = dataSource.getConceptByIndex(this.autogenerate.conceptIndex).concept;
    }
  },


  /**
   * Gets the dimensions in this entities
   * @returns {String} String with dimension
   */
  getDimension: function getDimension() {
    return this.dim;
  },


  /**
   * Gets the filter in this entities
   * @returns {Array} Array of unique values
   */
  getFilter: function getFilter() {
    return this.skipFilter ? [] : this.show;
  },


  /**
   * Shows or unshows an entity from the set
   */
  showEntity: function showEntity(d) {
    var _this = this;

    //clear selected countries when showing something new
    var newShow = utils.deepClone(this.show);
    var dimension = this.getDimension();
    var _d = void 0;

    if (!utils.isArray(d)) {
      _d = [d];
    } else {
      _d = d;
    }

    var showArray = [];

    // get array from show
    if (this.show[dimension] && this.show[dimension]["$in"] && utils.isArray(this.show[dimension]["$in"])) showArray = this.show[dimension]["$in"];

    utils.forEach(_d, function (d) {
      var value = d[dimension];
      if (_this.isShown(d)) {
        showArray = showArray.filter(function (d) {
          return d !== value;
        });
      } else {
        showArray = showArray.concat(value);
      }
    });

    if (showArray.length === 0) delete newShow[dimension];else newShow[dimension] = { "$in": showArray };

    this.show = newShow;
  },


  /**
   * Selects an entity from the set
   * @returns {Boolean} whether the item is shown or not
   */
  isShown: function isShown(d) {
    var dimension = this.getDimension();
    return this.show[dimension] && this.show[dimension]["$in"] && this.show[dimension]["$in"].indexOf(d[dimension]) !== -1;
  },


  /**
   * Clears showing of items
   */
  clearShow: function clearShow() {
    var dimension = this.getDimension();
    var show = utils.deepClone(this.show);
    delete show[dimension];
    this.show = show;
  },
  getFilteredEntities: function getFilteredEntities() {
    var dimension = this.getDimension();

    var _ref = this.show[dimension] || {},
        _ref$$in = _ref.$in,
        $in = _ref$$in === undefined ? [] : _ref$$in;

    return $in.map(function (m) {
      return _defineProperty({}, dimension, m);
    });
  }
});

exports.default = EntitiesModel;

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _hook = __webpack_require__(42);

var _hook2 = _interopRequireDefault(_hook);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * VIZABI Group Model
 */

var GroupModel = _hook2.default.extend({

  /**
   * Default values for this model
   */
  getClassDefaults: function getClassDefaults() {
    var defaults = {
      use: null,
      which: null,
      merge: false,
      manualSorting: null
    };
    return utils.deepExtend(this._super(), defaults);
  },


  /**
   * Initializes the group hook
   * @param {Object} values The initial values of this model
   * @param parent A reference to the parent model
   * @param {Object} bind Initial events to bind
   */
  init: function init(name, values, parent, bind) {
    this._type = "model";

    this._super(name, values, parent, bind);
  },


  /**
   * Validates a color hook
   */
  validate: function validate() {
    //there must be no scale
    if (this.scale) this.scale = null;

    //use must be "property"
    if (this.use != "property") {
      utils.warn("group model: use must be 'property'. Resetting...");
      this.use = "property";
    }
  }
});

exports.default = GroupModel;

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _hook = __webpack_require__(42);

var _hook2 = _interopRequireDefault(_hook);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * VIZABI Data Model (options.data)
 */

var LabelModel = _hook2.default.extend({

  /**
   * Default values for this model
   */

  getClassDefaults: function getClassDefaults() {
    var defaults = {
      use: null,
      which: null
    };
    return utils.deepExtend(this._super(), defaults);
  },


  /**
   * Initializes the size hook
   * @param {Object} values The initial values of this model
   * @param parent A reference to the parent model
   * @param {Object} bind Initial events to bind
   */
  init: function init(name, values, parent, bind) {

    this._type = "label";

    this._super(name, values, parent, bind);
  }
});

exports.default = LabelModel;

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _dataconnected = __webpack_require__(61);

var _dataconnected2 = _interopRequireDefault(_dataconnected);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// this and many other locale information should at some point be stored in an external file with locale information (rtl, date formats etc)
var rtlLocales = ["ar", "ar-SA"];

var LocaleModel = _dataconnected2.default.extend({

  /**
   * Default values for this model
   */
  getClassDefaults: function getClassDefaults() {
    var defaults = {
      id: "en",
      filePath: "assets/translation/"
    };
    return utils.deepExtend(this._super(), defaults);
  },


  dataConnectedChildren: ["id"],
  strings: {},

  /**
   * Initializes the locale model.
   * @param {Object} values The initial values of this model
   * @param parent A reference to the parent model
   * @param {Object} bind Initial events to bind
   */
  init: function init(name, values, parent, bind) {
    this._type = "locale";

    //same constructor, with same arguments
    this._super(name, values, parent, bind);
  },
  _isLoading: function _isLoading() {
    return !this._loadedOnce || this._loadCall;
  },
  preloadData: function preloadData() {
    return this.loadData();
  },
  loadData: function loadData() {
    var _this = this;

    this.setReady(false);
    this._loadCall = true;

    // load new concept properties for each data source.
    // this should be done with listeners, but the load promise can't be returned
    // through the listeners

    var promises = [];
    utils.forEach(this._root._data, function (mdl) {
      if (mdl._type === "data") promises.push(mdl.loadConceptProps());
    });
    promises.push(new Promise(function (resolve, reject) {
      d3.json(_this.filePath + _this.id + ".json", function (error, strings) {
        if (error) reject(error);
        _this.handleNewStrings(strings);
        resolve();
      });
    }));

    return Promise.all(promises).then(function () {
      return _this.trigger("translate");
    });
  },
  handleNewStrings: function handleNewStrings(receivedStrings) {
    this.strings[this.id] = this.strings[this.id] ? utils.extend(this.strings[this.id], receivedStrings) : receivedStrings;
  },


  /**
   * Gets a certain UI string
   * @param {String} stringId string identifier
   * @returns {string} translated string
   */
  getUIString: function getUIString(stringId) {
    if (this.strings && this.strings[this.id] && (this.strings[this.id][stringId] || this.strings[this.id][stringId] === "")) {
      return this.strings[this.id][stringId];
    }
    if (!this.strings || !this.strings[this.id]) utils.warn("Strings are not loaded for the " + this.id + " locale. Check if translation JSON is valid");
    return stringId;
  },


  /**
   * Gets the translation function
   * @returns {string} translation function
   */
  getTFunction: function getTFunction() {
    var _this2 = this;

    return function (stringId) {
      var payload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return Object.keys(payload).reduce(function (result, key) {
        var regexp = new RegExp("{{" + key + "}}", "g");
        return result.replace(regexp, payload[key]);
      }, _this2.getUIString(stringId));
    };
  },
  isRTL: function isRTL() {
    return rtlLocales.indexOf(this.id) !== -1;
  }
});

exports.default = LocaleModel;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _model = __webpack_require__(47);

var _model2 = _interopRequireDefault(_model);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*!
 * HOOK MODEL
 */

var Marker = _model2.default.extend({
  getClassDefaults: function getClassDefaults() {
    var defaults = {
      select: [],
      highlight: [],
      opacityHighlightDim: 0.1,
      opacitySelectDim: 0.3,
      opacityRegular: 1,
      allowSelectMultiple: true
    };
    return utils.deepExtend(this._super(), defaults);
  },
  init: function init(name, value, parent, binds, persistent) {
    var _this = this;

    this._visible = [];

    this._super(name, value, parent, binds, persistent);
    this.on("ready", this.checkTimeLimits.bind(this));
    this.on("readyOnce", function () {
      var exceptions = { exceptType: "time" };
      var allDimensions = _this._getAllDimensions(exceptions);
      _this._multiDim = allDimensions.length > 1;
    });
  },
  setDataSourceForAllSubhooks: function setDataSourceForAllSubhooks(data) {
    var obj = {};
    this.getSubhooks().forEach(function (hook) {
      obj[hook._name] = { data: data };
    });
    this.set(obj, null, false);
  },


  /**
   * Validates the model
   */
  validate: function validate() {
    var _this = this;
    var dimension = this.getDimension();
    var visible_array = this._visible.map(function (d) {
      return d[dimension];
    });

    if (visible_array.length) {
      this.select = this.select.filter(function (f) {
        return visible_array.indexOf(f[dimension]) !== -1;
      });
      this.setHighlight(this.highlight.filter(function (f) {
        return visible_array.indexOf(f[dimension]) !== -1;
      }));
    }
  },


  /**
   * Sets the visible entities
   * @param {Array} arr
   */
  setVisible: function setVisible(arr) {
    this._visible = arr;
  },


  /**
   * Gets the visible entities
   * @returns {Array} visible
   */
  getVisible: function getVisible(arr) {
    return this._visible;
  },


  /**
   * Gets the selected items
   * @returns {Array} Array of unique selected values
   */
  getSelected: function getSelected(dim) {
    return dim ? this.select.map(function (d) {
      return d[dim];
    }) : this.select;
  },
  selectMarker: function selectMarker(d) {
    var _this = this;
    var value = this._createValue(d);
    if (this.isSelected(d)) {
      this.select = this.select.filter(function (d) {
        return JSON.stringify(_this._createValue(d)) !== JSON.stringify(value);
      });
    } else {
      this.select = this.allowSelectMultiple ? this.select.concat(value) : [value];
    }
  },


  /**
   * Select all entities
   */
  selectAll: function selectAll(timeDim, timeFormatter) {
    if (!this.allowSelectMultiple) return;

    var added = void 0;
    var dimension = this._getFirstDimension({ exceptType: "time" });

    this.select = this._visible.map(function (d) {
      added = {};
      added[dimension] = d[dimension];
      return added;
    });
  },
  isSelected: function isSelected(d) {
    var _this = this;
    var value = this._createValue(d);

    return this.select.map(function (d) {
      return JSON.stringify(_this._createValue(d)) === JSON.stringify(value);
    }).indexOf(true) !== -1;
  },
  _createValue: function _createValue(d) {
    var dims = this._getAllDimensions({ exceptType: "time" });
    return dims.reduce(function (value, key) {
      value[key] = d[key];
      return value;
    }, {});
  },


  /**
   * Gets the highlighted items
   * @returns {Array} Array of unique highlighted values
   */
  getHighlighted: function getHighlighted(dim) {
    return dim ? this.highlight.map(function (d) {
      return d[dim];
    }) : this.highlight;
  },
  setHighlight: function setHighlight(arg) {
    if (!utils.isArray(arg)) {
      this.setHighlight([].concat(arg));
      return;
    }
    this.getModelObject("highlight").set(arg, false, false); // highlights are always non persistent changes
  },
  setSelect: function setSelect(arg) {
    if (!utils.isArray(arg)) {
      this.setSelect([].concat(arg));
      return;
    }
    this.getModelObject("select").set(arg);
  },


  //TODO: join the following 3 methods with the previous 3

  /**
   * Highlights an entity from the set
   */
  highlightMarker: function highlightMarker(d) {
    var value = this._createValue(d);
    if (!this.isHighlighted(d)) {
      this.setHighlight(this.highlight.concat(value));
    }
  },


  /**
   * Unhighlights an entity from the set
   */
  unhighlightEntity: function unhighlightEntity(d) {
    var value = this._createValue(d);
    if (this.isHighlighted(d)) {
      this.setHighlight(this.highlight.filter(function (d) {
        return d[dimension] !== value;
      }));
    }
  },


  /**
   * Checks whether an entity is highlighted from the set
   * @returns {Boolean} whether the item is highlighted or not
   */
  isHighlighted: function isHighlighted(d) {
    var _this = this;
    var value = this._createValue(d);
    return this.highlight.map(function (d) {
      return JSON.stringify(_this._createValue(d)) === JSON.stringify(value);
    }).indexOf(true) !== -1;
  },


  /**
   * Clears selection of items
   */
  clearHighlighted: function clearHighlighted() {
    this.setHighlight([]);
  },
  clearSelected: function clearSelected() {
    this.select = [];
  },
  setLabelOffset: function setLabelOffset(d, xy) {
    if (xy[0] === 0 && xy[1] === 1) return;

    this.select.find(function (selectedMarker) {
      return utils.comparePlainObjects(selectedMarker, d);
    }).labelOffset = [Math.round(xy[0] * 1000) / 1000, Math.round(xy[1] * 1000) / 1000];

    //force the model to trigger events even if value is the same
    this.set("select", this.select, true);
  },
  checkTimeLimits: function checkTimeLimits() {

    var time = this._parent.time;

    if (!time) return;

    var tLimits = this.getTimeLimits();

    if (!tLimits) return;
    if (!utils.isDate(tLimits.min) || !utils.isDate(tLimits.max)) return utils.warn("checkTimeLimits(): min-max look wrong: " + tLimits.min + " " + tLimits.max + ". Expecting Date objects. Ensure that time is properly parsed in the data from reader");

    // change start and end (but keep startOrigin and endOrigin for furhter requests)
    var newTime = {};
    if (time.start - tLimits.min != 0 || !time.start && !this.startOrigin) newTime["start"] = d3.max([tLimits.min, time.parse(time.startOrigin)]);
    if (time.end - tLimits.max != 0 || !time.end && !this.endOrigin) newTime["end"] = d3.min([tLimits.max, time.parse(time.endOrigin)]);

    time.set(newTime, false, false);

    if (newTime.start || newTime.end) {
      utils.forEach(this.getSubhooks(), function (hook) {
        if (hook.which == "time") {
          hook.buildScale();
        }
      });
    }

    //force time validation because time.value might now fall outside of start-end
    time.validate();
  },


  /**
   * Gets the narrowest limits of the subhooks with respect to the provided data column
   * @param {String} attr parameter (data column)
   * @returns {Object} limits (min and max)
   * this function is only needed to route the "time" to some indicator,
   * to adjust time start and end to the max and min time available in data
   */
  getTimeLimits: function getTimeLimits() {
    var _this = this;
    var time = this._parent.time;
    var minArray = [],
        maxArray = [];
    var min = void 0,
        max = void 0,
        items = {};
    if (!this.cachedTimeLimits) this.cachedTimeLimits = {};
    utils.forEach(this.getSubhooks(), function (hook) {

      //only indicators depend on time and therefore influence the limits
      if (hook.use !== "indicator" || !hook._important) return;

      var cachedLimits = _this.cachedTimeLimits[hook._dataId + hook.which];

      if (cachedLimits) {
        //if already calculated the limits then no ned to do it again
        min = cachedLimits.min;
        max = cachedLimits.max;
      } else {
        //otherwise calculate own date limits (a costly operation)
        items = hook.getValidItems().map(function (m) {
          return m[time.getDimension()];
        });
        if (items.length == 0) utils.warn("getTimeLimits() was unable to work with an empty array of valid datapoints");
        min = d3.min(items);
        max = d3.max(items);
      }
      _this.cachedTimeLimits[hook._dataId + hook.which] = { min: min, max: max };
      minArray.push(min);
      maxArray.push(max);
    });

    var resultMin = d3.max(minArray);
    var resultMax = d3.min(maxArray);
    if (resultMin > resultMax) {
      utils.warn("getTimeLimits(): Availability of the indicator's data has no intersection. I give up and just return some valid time range where you'll find no data points. Enjoy!");
      resultMin = d3.min(minArray);
      resultMax = d3.max(maxArray);
    }

    //return false for the case when neither of hooks was an "indicator" or "important"
    return !min && !max ? false : { min: resultMin, max: resultMax };
  },


  /**
   * Computes the intersection of keys in all hooks: a set of keys that have data in each hook
   * @returns array of keys that have data in all hooks of this._datacube
   */
  getKeys: function getKeys(KEY) {
    var _this = this;
    var resultKeys = [];

    KEY = KEY || this._getFirstDimension();
    var TIME = this._getFirstDimension({ type: "time" });

    utils.forEach(this._dataCube || this.getSubhooks(true), function (hook, name) {

      // If hook use is constant, then we can provide no additional info about keys
      // We can just hope that we have something else than constants =)
      if (hook.use === "constant") return;

      // Get keys in data of this hook
      var nested = hook.getNestedItems([KEY, TIME]);
      var noDataPoints = hook.getHaveNoDataPointsPerKey();

      if (nested["undefined"]) delete nested["undefined"];

      var keys = Object.keys(nested);
      var keysNoDP = Object.keys(noDataPoints || []);

      // If ain't got nothing yet, set the list of keys to result
      if (resultKeys.length == 0) resultKeys = keys;

      // Remove the keys from it that are not in this hook
      if (hook._important) resultKeys = resultKeys.filter(function (f) {
        return keys.indexOf(f) > -1 && keysNoDP.indexOf(f) == -1;
      });
    });
    return resultKeys.map(function (d) {
      var r = {};r[KEY] = d;return r;
    });
  },


  /**
   * @param {Array} entities array of entities
   * @return String
   */
  _getCachePath: function _getCachePath(keys) {
    //array of steps -- names of all frames
    var steps = this._parent.time.getAllSteps();
    var cachePath = this.getClosestModel("locale").id + " - " + steps[0] + " - " + steps[steps.length - 1];
    this._dataCube = this._dataCube || this.getSubhooks(true);
    var dataLoading = false;
    utils.forEach(this._dataCube, function (hook, name) {
      if (hook._loadCall) dataLoading = true;
      cachePath = cachePath + "_" + hook._dataId + hook.which;
    });
    if (dataLoading) {
      return null;
    }
    if (keys) {
      cachePath = cachePath + "_" + keys.join(",");
    }
    return cachePath;
  },
  _getAllDimensions: function _getAllDimensions(opts) {

    var models = [];
    var _this = this;
    utils.forEach(this.space, function (name) {
      models.push(_this.getClosestModel(name));
    });

    opts = opts || {};
    var dims = [];
    var dim = void 0;

    utils.forEach(models, function (m) {
      if (opts.exceptType && m.getType() === opts.exceptType) {
        return true;
      }
      if (opts.onlyType && m.getType() !== opts.onlyType) {
        return true;
      }
      if (dim = m.getDimension()) {
        dims.push(dim);
      }
    });

    return dims;
  },


  /**
   * gets first dimension that matches type
   * @param {Object} options
   * @returns {Array} all unique dimensions
   */
  _getFirstDimension: function _getFirstDimension(opts) {
    var models = [];
    var _this = this;
    utils.forEach(this.space, function (name) {
      models.push(_this.getClosestModel(name));
    });

    opts = opts || {};

    var dim = false;
    utils.forEach(models, function (m) {
      if (opts.exceptType && m.getType() !== opts.exceptType) {
        dim = m.getDimension();
        return false;
      } else if (opts.type && m.getType() === opts.type) {
        dim = m.getDimension();
        return false;
      } else if (!opts.exceptType && !opts.type) {
        dim = m.getDimension();
        return false;
      }
    });
    return dim;
  },
  framesAreReady: function framesAreReady() {
    var cachePath = this._getCachePath();
    if (!this.cachedFrames) return false;
    return Object.keys(this.cachedFrames[cachePath]).length == this._parent.time.getAllSteps().length;
  },


  /**
   *
   * @param {String|null} time of a particularly requested data frame. Null if all frames are requested
   * @param {function} cb
   * @param {Array} keys array of entities
   * @return null
   */
  getFrame: function getFrame(time, cb, keys) {
    //keys = null;
    var _this = this;
    if (!this.cachedFrames) this.cachedFrames = {};

    var steps = this._parent.time.getAllSteps();
    // try to get frame from cache without keys
    var cachePath = this._getCachePath();
    if (!cachePath) return cb(null, time);
    if (time && _this.cachedFrames[cachePath] && _this.cachedFrames[cachePath][time]) {
      // if it does, then return that frame directly and stop here
      //QUESTION: can we call the callback and return the frame? this will allow callbackless API too
      return cb(_this.cachedFrames[cachePath][time], time);
    }
    cachePath = this._getCachePath(keys);
    if (!cachePath) return cb(null, time);

    // check if the requested time point has a cached animation frame
    if (time && _this.cachedFrames[cachePath] && _this.cachedFrames[cachePath][time]) {
      // if it does, then return that frame directly and stop here
      //QUESTION: can we call the callback and return the frame? this will allow callbackless API too
      return cb(_this.cachedFrames[cachePath][time], time);
    }

    // if it doesn't (the requested time point falls between animation frames or frame is not cached yet)
    // check if interpolation makes sense: we've requested a particular time and we have more than one frame
    if (time && steps.length > 1) {

      //find the next frame after the requested time point
      var nextFrameIndex = d3.bisectLeft(steps, time);

      if (!steps[nextFrameIndex]) {
        utils.warn("The requested frame is out of range: " + time);
        cb(null, time);
        return null;
      }

      //if "time" doesn't hit the frame precisely
      if (steps[nextFrameIndex].toString() != time.toString()) {

        //interpolate between frames and fire the callback
        this._interpolateBetweenFrames(time, nextFrameIndex, steps, function (response) {
          cb(response, time);
        }, keys);
        return null;
      }
    }

    //QUESTION: we don't need any further execution after we called for interpolation, right?
    //request preparing the data, wait until it's done
    _this.getFrames(time, keys).then(function () {
      if (!time && _this.cachedFrames[cachePath]) {
        //time can be null: then return all frames
        return cb(_this.cachedFrames[cachePath], time);
      } else if (_this.cachedFrames[cachePath] && _this.cachedFrames[cachePath][time]) {
        //time can be !null: then a particular frame calculation was forced and now it's done
        return cb(_this.cachedFrames[cachePath][time], time);
      }
      utils.warn("marker.js getFrame: Data is not available for frame: " + time);
      return cb(null, time);
    });
  },
  _interpolateBetweenFrames: function _interpolateBetweenFrames(time, nextFrameIndex, steps, cb, keys) {
    var _this = this;

    if (nextFrameIndex == 0) {
      //getFrame makes sure the frane is ready because a frame with non-existing data might be adressed
      this.getFrame(steps[nextFrameIndex], function (values) {
        return cb(values);
      }, keys);
    } else {
      var prevFrameTime = steps[nextFrameIndex - 1];
      var nextFrameTime = steps[nextFrameIndex];

      //getFrame makes sure the frane is ready because a frame with non-existing data might be adressed
      this.getFrame(prevFrameTime, function (pValues) {
        _this.getFrame(nextFrameTime, function (nValues) {
          var fraction = (time - prevFrameTime) / (nextFrameTime - prevFrameTime);
          var dataBetweenFrames = {};

          //loop across the hooks
          utils.forEach(pValues, function (values, hook) {
            dataBetweenFrames[hook] = {};

            if (_this._multiDim && _this[hook].use == "indicator") {
              var hookDataBF = dataBetweenFrames[hook];
              var TIME = _this[hook].dataSource._collection[_this[hook]._dataId].query.animatable;
              var KEY = _this[hook].dataSource._collection[_this[hook]._dataId].query.select.key.slice(0);
              if (TIME && KEY.indexOf(TIME) != -1) KEY.splice(KEY.indexOf(TIME), 1);

              var lastIndex = KEY.length - 1;
              var iterateKeys = function iterateKeys(firstKeyObject, lastKeyObject, firstKey, pValues, nValues, index) {
                var keys = Object.keys(pValues);
                for (var i = 0, j = keys.length; i < j; i++) {
                  if (index == 0) {
                    firstKey = keys[i]; //root level
                  }
                  if (index == lastIndex) {
                    mapValue(hookDataBF, firstKey, keys[i], firstKeyObject, lastKeyObject, pValues[keys[i]], nValues[keys[i]]);
                  } else {
                    if (index == 0) {
                      lastKeyObject = firstKeyObject = {};
                    }
                    var nextIndex = index + 1;
                    lastKeyObject[keys[i]] = {};
                    iterateKeys(firstKeyObject, lastKeyObject[keys[i]], firstKey, pValues[keys[i]], nValues[keys[i]], nextIndex);
                  }
                }
              };

              iterateKeys(null, null, null, values, nValues[hook], 0);
            } else {
              //loop across the entities
              utils.forEach(values, function (val1, key) {
                var val2 = nValues[hook][key];
                if (utils.isDate(val1)) {
                  dataBetweenFrames[hook][key] = time;
                } else if (!utils.isNumber(val1)) {
                  //we can be interpolating string values
                  dataBetweenFrames[hook][key] = val1;
                } else {
                  //interpolation between number and null should rerurn null, not a value in between (#1350)
                  dataBetweenFrames[hook][key] = val1 == null || val2 == null ? null : val1 + (val2 - val1) * fraction;
                }
              });
            }
          });
          cb(dataBetweenFrames);

          function mapValue(hookDataBF, firstKey, lastKey, firstKeyObject, lastKeyObject, val1, val2) {
            hookDataBF[firstKey] = firstKeyObject[firstKey];
            if (utils.isDate(val1)) {
              lastKeyObject[lastKey] = time;
            } else if (!utils.isNumber(val1)) {
              //we can be interpolating string values
              lastKeyObject[lastKey] = val1;
            } else {
              //interpolation between number and null should rerurn null, not a value in between (#1350)
              lastKeyObject[lastKey] = val1 == null || val2 == null ? null : val1 + (val2 - val1) * fraction;
            }
          }
        }, keys);
      }, keys);
    }
  },
  getFrames: function getFrames(forceFrame, selected) {
    var _this = this;
    if (!this.cachedFrames) this.cachedFrames = {};

    var KEY = this._getFirstDimension();
    var TIME = this._getFirstDimension({ type: "time" });

    if (!this.frameQueues) this.frameQueues = {}; //static queue of frames
    if (!this.partialResult) this.partialResult = {};

    //array of steps -- names of all frames
    var steps = this._parent.time.getAllSteps();

    var cachePath = this._getCachePath(selected);
    if (!cachePath) return new Promise(function (resolve, reject) {
      resolve();
    });
    //if the collection of frames for this data cube is not scheduled yet (otherwise no need to repeat calculation)
    if (!this.frameQueues[cachePath] || !(this.frameQueues[cachePath] instanceof Promise)) {

      //this is a promise nobody listens to - it prepares all the frames we need without forcing any
      this.frameQueues[cachePath] = new Promise(function (resolve, reject) {

        _this.partialResult[cachePath] = {};
        steps.forEach(function (t) {
          _this.partialResult[cachePath][t] = {};
        });

        // Assemble the list of keys as an intersection of keys in all queries of all hooks
        var keys = _this.getKeys();

        var deferredHooks = [];
        // Assemble data from each hook. Each frame becomes a vector containing the current configuration of hooks.
        // frame -> hooks -> entities: values
        utils.forEach(_this._dataCube, function (hook, name) {
          if (hook.use === "constant") {
            //special case: fill data with constant values
            steps.forEach(function (t) {
              _this.partialResult[cachePath][t][name] = {};
              keys.forEach(function (key) {
                _this.partialResult[cachePath][t][name][key[KEY]] = hook.which;
              });
            });
          } else if (hook.which === KEY) {
            //special case: fill data with keys to data itself
            steps.forEach(function (t) {
              _this.partialResult[cachePath][t][name] = {};
              keys.forEach(function (key) {
                _this.partialResult[cachePath][t][name][key[KEY]] = key[KEY];
              });
            });
          } else if (hook.which === TIME) {
            //special case: fill data with time points
            steps.forEach(function (t) {
              _this.partialResult[cachePath][t][name] = {};
              keys.forEach(function (key) {
                _this.partialResult[cachePath][t][name][key[KEY]] = new Date(t);
              });
            });
          } else {
            //calculation of async frames is taken outside the loop
            //hooks with real data that needs to be fetched from datamanager
            deferredHooks.push(hook);
          }
        });

        //check if we have any data to get from datamanager
        if (deferredHooks.length > 0) {
          var promises = [];
          utils.forEach(deferredHooks, function (hook) {
            promises.push(new Promise(function (res, rej) {
              // need to save the hook state before calling getFrames.
              // `hook` state might change between calling and resolving the call.
              // The result needs to be saved to the correct cache, so we need to save current hook state
              var currentHookState = {
                name: hook._name,
                which: hook.which
              };
              hook.getFrames(steps, selected).then(function (response) {
                utils.forEach(response, function (frame, t) {
                  _this.partialResult[cachePath][t][currentHookState.name] = frame[currentHookState.which];
                });
                res();
              });
            }));
          });
          Promise.all(promises).then(function () {
            _this.cachedFrames[cachePath] = _this.partialResult[cachePath];
            resolve();
          });
        } else {
          _this.cachedFrames[cachePath] = _this.partialResult[cachePath];
          resolve();
        }
      });
    }
    return new Promise(function (resolve, reject) {
      if (steps.length < 2 || !forceFrame) {
        //wait until the above promise is resolved, then resolve the current promise
        _this.frameQueues[cachePath].then(function () {
          resolve(); //going back to getFrame(), to ".then"
        });
      } else {
        var promises = [];
        utils.forEach(_this._dataCube, function (hook, name) {
          //exception: we know that these are knonwn, no need to calculate these
          if (hook.use !== "constant" && hook.which !== KEY && hook.which !== TIME) {
            (function (_hook, _name) {
              promises.push(new Promise(function (res, rej) {
                _hook.getFrame(steps, forceFrame, selected).then(function (response) {
                  _this.partialResult[cachePath][forceFrame][_name] = response[forceFrame][_hook.which];
                  res();
                });
              }));
            })(hook, name); //isolate this () code with its own hook and name
          }
        });
        if (promises.length > 0) {
          Promise.all(promises).then(function () {
            if (!_this.cachedFrames[cachePath]) {
              _this.cachedFrames[cachePath] = {};
            }
            _this.cachedFrames[cachePath][forceFrame] = _this.partialResult[cachePath][forceFrame];
            resolve();
          });
        }
      }
    });
  },
  listenFramesQueue: function listenFramesQueue(keys, cb) {
    var _this = this;
    var KEY = this._getFirstDimension();
    var TIME = this._getFirstDimension({ type: "time" });
    var steps = this._parent.time.getAllSteps();
    var preparedFrames = {};
    this.getFrames();
    var dataIds = [];
    utils.forEach(_this._dataCube, function (hook, name) {
      if (!(hook.use === "constant" || hook.which === KEY || hook.which === TIME)) {
        if (dataIds.indexOf(hook._dataId) == -1) {
          dataIds.push(hook._dataId);

          hook.dataSource.listenFrame(hook._dataId, steps, keys, function (dataId, time) {
            var keyName = time.toString();
            if (typeof preparedFrames[keyName] == "undefined") preparedFrames[keyName] = [];
            if (preparedFrames[keyName].indexOf(dataId) == -1) preparedFrames[keyName].push(dataId);
            if (preparedFrames[keyName].length == dataIds.length) {
              cb(time);
            }
          });
        }
      }
    });
  },


  /**
   * gets multiple values from the hook
   * @param {Object} filter Reference to the row. e.g: {geo: "swe", time: "1999", ... }
   * @param {Array} group_by How to nest e.g: ["geo"]
   * @param {Boolean} [previous = false] previous Append previous data points
   * @returns an array of values
   */
  getValues: function getValues(filter, group_by, previous) {
    var _this = this;

    if (this.isHook()) {
      return [];
    }

    var filtered = void 0,
        next = void 0,
        method = void 0,
        u = void 0,
        w = void 0,
        value = void 0;
    this._dataCube = this._dataCube || this.getSubhooks(true);
    filter = utils.clone(filter, this._getAllDimensions());
    var dimTime = this._getFirstDimension({
      type: "time"
    });
    var time = new Date(filter[dimTime]); //clone date
    filter = utils.clone(filter, null, dimTime);

    var response = {};
    var f_keys = Object.keys(filter);
    var f_values = f_keys.map(function (k) {
      return filter[k];
    });

    //if there's a filter, interpolate only that
    if (f_keys.length) {
      utils.forEach(this._dataCube, function (hook, name) {
        u = hook.use;
        w = hook.which;

        if (hook.use !== "property") next = next || d3.bisectLeft(hook.getUnique(dimTime), time);

        method = hook.getConceptprops ? hook.getConceptprops().interpolation : null;
        filtered = hook.getNestedItems(f_keys);
        utils.forEach(f_values, function (v) {
          filtered = filtered[v]; //get precise array (leaf)
        });
        value = utils.interpolatePoint(filtered, u, w, next, dimTime, time, method);
        response[name] = hook.mapValue(value);

        //concat previous data points
        if (previous) {
          var values = utils.filter(filtered, filter).filter(function (d) {
            return d[dimTime] <= time;
          }).map(function (d) {
            return hook.mapValue(d[w]);
          }).concat(response[name]);
          response[name] = values;
        }
      });
    }
    //else, interpolate all with time
    else {
        utils.forEach(this._dataCube, function (hook, name) {

          filtered = hook.getNestedItems(group_by);

          response[name] = {};
          //find position from first hook
          u = hook.use;
          w = hook.which;

          if (hook.use !== "property") next = typeof next === "undefined" ? d3.bisectLeft(hook.getUnique(dimTime), time) : next;

          method = hook.getConceptprops ? hook.getConceptprops().interpolation : null;

          var interpolate = function interpolate(arr, result, id) {
            //TODO: this saves when geos have different data length. line can be optimised.
            next = d3.bisectLeft(arr.map(function (m) {
              return m[dimTime];
            }), time);

            value = utils.interpolatePoint(arr, u, w, next, dimTime, time, method);
            result[id] = hook.mapValue(value);

            //concat previous data points
            if (previous) {
              var values = utils.filter(arr, filter).filter(function (d) {
                return d[dimTime] <= time;
              }).map(function (d) {
                return hook.mapValue(d[w]);
              }).concat(result[id]);
              result[id] = values;
            }
          };

          var iterateGroupKeys = function iterateGroupKeys(data, deep, result, cb) {
            deep--;
            utils.forEach(data, function (d, id) {
              if (deep) {
                result[id] = {};
                iterateGroupKeys(d, deep, result[id], cb);
              } else {
                cb(d, result, id);
              }
            });
          };

          iterateGroupKeys(filtered, group_by.length, response[name], interpolate);
        });
      }

    return response;
  },
  getEntityLimits: function getEntityLimits(entity) {
    var _this = this;
    var timePoints = this._parent.time.getAllSteps();
    var selectedEdgeTimes = [];
    var hooks = [];
    utils.forEach(_this.getSubhooks(), function (hook) {
      if (hook.use == "constant") return;
      if (hook._important) hooks.push(hook._name);
    });

    var findEntityWithCompleteHooks = function findEntityWithCompleteHooks(values) {
      if (!values) return false;
      for (var i = 0, j = hooks.length; i < j; i++) {
        if (!(values[hooks[i]][entity] || values[hooks[i]][entity] === 0)) return false;
      }
      return true;
    };

    var findSelectedTime = function findSelectedTime(iterator, findCB) {
      var point = iterator();
      if (point == null) return;
      _this.getFrame(timePoints[point], function (values) {
        if (findEntityWithCompleteHooks(values)) {
          findCB(point);
        } else {
          findSelectedTime(iterator, findCB);
        }
      });
    };
    var promises = [];
    promises.push(new Promise(function (resolve, reject) {

      //find startSelected time
      findSelectedTime(function () {
        var max = timePoints.length;
        var i = 0;
        return function () {
          return i < max ? i++ : null;
        };
      }(), function (point) {
        selectedEdgeTimes[0] = timePoints[point];
        resolve();
      });
    }));

    promises.push(new Promise(function (resolve, reject) {

      //find endSelected time
      findSelectedTime(function () {
        var i = timePoints.length - 1;
        return function () {
          return i >= 0 ? i-- : null;
        };
      }(), function (point) {
        selectedEdgeTimes[1] = timePoints[point];
        resolve();
      });
    }));

    return Promise.all(promises).then(function () {
      return { "min": selectedEdgeTimes[0], "max": selectedEdgeTimes[1] };
    });
  },


  /**
   * Learn what this model should hook to
   * @returns {Array} space array
   */
  getSpace: function getSpace() {
    if (utils.isArray(this.space)) {
      return this.space;
    }

    utils.error('ERROR: space not found.\n You must specify the objects this hook will use under the "space" attribute in the state.\n Example:\n space: ["entities", "time"]');
  }
});

exports.default = Marker;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _hook = __webpack_require__(42);

var _hook2 = _interopRequireDefault(_hook);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * VIZABI Data Model (options.data)
 */

var SideModel = _hook2.default.extend({

  /**
   * Default values for this model
   */

  getClassDefaults: function getClassDefaults() {
    var defaults = {
      use: null,
      which: null
    };
    return utils.deepExtend(this._super(), defaults);
  },


  /**
   * Initializes the size hook
   * @param {Object} values The initial values of this model
   * @param parent A reference to the parent model
   * @param {Object} bind Initial events to bind
   */
  init: function init(name, values, parent, bind) {

    this._type = "side";

    bind["readyOnce"] = this.readyOnce;

    this.state = { left: {}, right: {} };
    this._super(name, values, parent, bind);
  },
  readyOnce: function readyOnce() {
    if (!this.spaceRef) return;
    var dataConnChildren = this._space[this.spaceRef].dataConnectedChildren.slice(0);
    dataConnChildren.splice(dataConnChildren.indexOf("show"), 1);
    this._space[this.spaceRef].dataConnectedChildren = dataConnChildren;
  },
  switchSideState: function switchSideState() {
    var left = this.state.left;
    this.state.left = this.state.right;
    this.state.right = left;
  },
  clearSideState: function clearSideState() {
    this.state = { left: {}, right: {} };
  }
});

exports.default = SideModel;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _axis = __webpack_require__(90);

var _axis2 = _interopRequireDefault(_axis);

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 * VIZABI Size Model
 */

var SizeModel = _axis2.default.extend({

  /**
   * Default values for this model
   */
  getClassDefaults: function getClassDefaults() {
    var defaults = {
      use: null,
      which: null,
      domainMin: null,
      domainMax: null,
      zoomedMin: null,
      zoomedMax: null,
      extent: [0, 0.85],
      scaleType: null,
      allow: {
        scales: ["linear", "log", "genericLog", "pow"]
      }
    };
    return utils.deepExtend(this._super(), defaults);
  },


  _type: "size",

  buildScale: function buildScale() {
    //do whatever axis.buildScale does
    this._super();
    //but then also clamp a numeric scale
    if (this.scaleType !== "ordinal") this.scale.clamp(true);
  },
  autoGenerateModel: function autoGenerateModel() {
    if (this.which == null) {
      var concept = void 0;
      if (this.autogenerate) {
        concept = this.dataSource.getConceptByIndex(this.autogenerate.conceptIndex, this.autogenerate.conceptType);

        if (concept) {
          this.which = concept.concept;
          this.use = "indicator";
          this.scaleType = "linear";
        }
      }
      if (!concept) {
        this.which = "_default";
        this.use = "constant";
        this.scaleType = "ordinal";
      }
    }
    if (this.scaleType == null) {
      this.scaleType = this.dataSource.getConceptprops(this.which).scales[0];
    }
  }
});

exports.default = SizeModel;

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _hook = __webpack_require__(42);

var _hook2 = _interopRequireDefault(_hook);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*
 * VIZABI Stack Model
 */

var palettes = {
  "ALL": "all",
  _default: "none"
};

var StackModel = _hook2.default.extend({

  /**
   * Default values for this model
   */
  getClassDefaults: function getClassDefaults() {
    var defaults = {
      use: null,
      which: null,
      merge: false
    };
    return utils.deepExtend(this._super(), defaults);
  },


  /**
   * Initializes the stack hook
   * @param {Object} values The initial values of this model
   * @param parent A reference to the parent model
   * @param {Object} bind Initial events to bind
   */
  init: function init(name, values, parent, bind) {

    this._type = "model";

    this._super(name, values, parent, bind);
  },


  /**
   * Validates a color hook
   */
  validate: function validate() {
    //there must be no scale
    if (this.scale) this.scale = null;

    //use must not be "indicator"
    if (this.use === "indicator") {
      utils.warn("stack model: use must not be 'indicator'. Resetting use to 'constant' and which to '" + palettes._default);
      this.use = "constant";
      this.which = palettes._default;
    }

    //if use is "constant"
    if (this.use === "constant" && utils.values(palettes).indexOf(this.which) == -1) {
      utils.warn("stack model: the requested value '" + this.which + "' is not allowed. resetting to '" + palettes._default);
      this.which == palettes._default;
    }
  },


  /**
   * Get the above constants
   */
  getPalettes: function getPalettes() {
    return palettes;
  },


  /**
   * There must be no scale
   */
  buildScale: function buildScale() {}
});

exports.default = StackModel;

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _dataconnected = __webpack_require__(61);

var _dataconnected2 = _interopRequireDefault(_dataconnected);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*!
 * VIZABI Time Model
 */

// short-cut for developers to get UTC date strings
// not meant to be used in code!!!
Date.prototype.utc = Date.prototype.toUTCString;

/*
 * Time formats for internal data
 * all in UTC
 */
var formats = {
  "year": { data: d3.time.format.utc("%Y"), ui: d3.time.format.utc("%Y") },
  "month": { data: d3.time.format.utc("%Y-%m"), ui: d3.time.format.utc("%b %Y") }, // month needs separator according to ISO to not confuse YYYYMM with YYMMDD
  "day": { data: d3.time.format.utc("%Y%m%d"), ui: d3.time.format.utc("%c") },
  "hour": { data: d3.time.format.utc("%Y%m%dT%H"), ui: d3.time.format.utc("%b %d %Y, %H") },
  "minute": { data: d3.time.format.utc("%Y%m%dT%H%M"), ui: d3.time.format.utc("%b %d %Y, %H:%M") },
  "second": { data: d3.time.format.utc("%Y%m%dT%H%M%S"), ui: d3.time.format.utc("%b %d %Y, %H:%M:%S") },
  "week": { data: weekFormat(), ui: weekFormat() }, // %Yw%W d3 week format does not comply with ISO
  "quarter": { data: quarterFormat(), ui: quarterFormat() } // %Yq%Q d3 does not support quarters
};

var TimeModel = _dataconnected2.default.extend({

  objectLeafs: ["autogenerate"],

  /**
   * Default values for this model
   */
  getClassDefaults: function getClassDefaults() {
    var defaults = {
      dim: null,
      value: null,
      start: null,
      end: null,
      startOrigin: null,
      endOrigin: null,
      startSelected: null,
      endSelected: null,
      playable: true,
      playing: false,
      loop: false,
      round: "round",
      delay: 150, //delay between animation frames
      delayThresholdX2: 90, //delay X2 boundary: if less -- then every other frame will be dropped and animation dely will be double the value
      delayThresholdX4: 45, //delay X4 boundary: if less -- then 3/4 frame will be dropped and animation dely will be 4x the value
      unit: "year",
      format: { data: null, ui: null }, // overwrite of default formats
      step: 1, //step must be integer, and expressed in units
      immediatePlay: true,
      record: false
    };
    return utils.deepExtend(this._super(), defaults);
  },


  dataConnectedChildren: ["startOrigin", "endOrigin", "dim"],

  /**
   * Initializes the locale model.
   * @param {String} name
   * @param {Object} values The initial values of this model
   * @param parent A reference to the parent model
   * @param {Object} bind Initial events to bind
   */
  init: function init(name, values, parent, bind) {
    this._type = "time";

    //same constructor
    this._super(name, values, parent, bind);
    var _this = this;
    this.initFormatters();
    this.dragging = false;
    this.postponePause = false;
    this.allSteps = {};
    this.delayAnimations = this.delay;

    //bing play method to model change
    this.on({

      "change:playing": function changePlaying() {
        if (_this.playing === true) {
          _this._startPlaying();
        } else {
          _this._stopPlaying();
        }
      },

      "change:format": function changeFormat() {
        _this.initFormatters();
      }

    });
  },
  initFormatters: function initFormatters() {
    if (formats[this.unit]) {
      this.formatters = formats[this.unit];
    }
    // specifically set formats overwrite unit defaults
    if (typeof this.format == "string") {
      this.formatters.data = this.formatters.ui = d3.time.format.utc(this.format);
    } else {
      if (this.format.data) {
        this.formatters.data = d3.time.format.utc(this.format.data);
      }
      if (this.format.ui) {
        this.formatters.ui = d3.time.format.utc(this.format.ui);
      }
    }
    this.validateFormatting();
  },
  afterPreload: function afterPreload() {
    if (this.dim == null && this.autogenerate) {
      var dataSource = this.getClosestModel(this.autogenerate.data);
      this.dim = dataSource.getConceptByIndex(this.autogenerate.conceptIndex, this.autogenerate.conceptType).concept;
    }
  },


  /**
   * Formats value, start and end dates to actual Date objects
   */
  _formatToDates: function _formatToDates() {
    var persistentValues = ["value"];
    var date_attr = ["value", "start", "end", "startSelected", "endSelected"];
    for (var i = 0; i < date_attr.length; i++) {
      var attr = date_attr[i];
      if (!utils.isDate(this[attr])) {
        var date = this.parse(this[attr]);
        this.set(attr, date, null, persistentValues.indexOf(attr) !== -1);
      }
    }
  },


  /*
   * Formatting and parsing functions
   * @param {Date} dateObject
   * @param {String} type Either data or ui.
   * @returns {String}
   */
  formatDate: function formatDate(dateObject) {
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "data";

    if (["data", "ui"].indexOf(type) === -1) {
      utils.warn("Time.formatDate type parameter (" + type + ') invalid. Using "data".');
      type = data;
    }
    if (dateObject == null) return null;
    return this.formatters[type](dateObject);
  },

  /* parse to predefined unit */
  parse: function parse(timeString) {
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "data";

    if (timeString == null) return null;
    return this.formatters[type].parse(timeString.toString());
  },


  /* auto-determines unit from timestring */
  findFormat: function findFormat(timeString) {
    var keys = Object.keys(formats);
    for (var i = 0; i < keys.length; i++) {
      var dateObject = formats[keys[i]].data.parse(timeString);
      if (dateObject) return { unit: keys[i], time: dateObject, type: "data" };
      dateObject = formats[keys[i]].ui.parse(timeString);
      if (dateObject) return { unit: keys[i], time: dateObject, type: "ui" };
    }
    return null;
  },


  /**
   * Validates the model
   */
  validate: function validate() {

    //check if time start and end are not defined but start and end origins are defined
    if (this.start == null && this.startOrigin) this.set("start", this.startOrigin, null, false);
    if (this.end == null && this.endOrigin) this.set("end", this.endOrigin, null, false);

    if (this.formatters) {
      this.validateFormatting();
    }

    //unit has to be one of the available_time_units
    if (!formats[this.unit]) {
      utils.warn(this.unit + ' is not a valid time unit, using "year" instead.');
      this.unit = "year";
    }

    if (this.step < 1) {
      this.step = 1;
    }

    //end has to be >= than start
    if (this.end < this.start && this.start != null) {
      this.set("end", new Date(this.start), null, false);
    }

    if (this.value < this.startSelected && this.startSelected != null) {
      this.value = new Date(this.startSelected);
    }

    if (this.value > this.endSelected && this.endSelected != null) {
      this.value = new Date(this.endSelected);
    }
    if (this.splash === false) {
      if (this.startSelected < this.start && this.start != null) {
        this.set({ startSelected: new Date(this.start) }, null, false /*make change non-persistent for URL and history*/);
      }

      if (this.endSelected > this.end && this.end != null) {
        this.set({ endSelected: new Date(this.end) }, null, false /*make change non-persistent for URL and history*/);
      }
    }

    //value has to be between start and end
    if (this.value < this.start && this.start != null) {
      this.value = new Date(this.start);
    } else if (this.value > this.end && this.end != null) {
      this.value = new Date(this.end);
    }

    if (this.playable === false && this.playing === true) {
      this.set("playing", false, null, false);
    }
  },
  validateFormatting: function validateFormatting() {
    // default to current date. Other option: newTime['start'] || newTime['end'] || time.start || time.end;
    if (this.value == null) this.set("value", this.parse(this.formatDate(new Date())), null, false);

    //make sure dates are transformed into dates at all times
    if (!utils.isDate(this.start) || !utils.isDate(this.end) || !utils.isDate(this.value) || !utils.isDate(this.startSelected) || !utils.isDate(this.endSelected)) {
      this._formatToDates();
    }
  },


  /**
   * Plays time
   */
  play: function play() {
    this._startPlaying();
  },


  /**
   * Pauses time
   */
  pause: function pause(soft) {
    if (soft) {
      this.postponePause = true;
    } else {
      if (this.playing) {
        this.set("playing", false, null, false);
        this.set("value", this.value, true, true);
      }
    }
  },


  /**
   * Indicates dragging of time
   */
  dragStart: function dragStart() {
    this.dragging = true;
  },
  dragStop: function dragStop() {
    this.dragging = false;
  },


  /**
   * gets time range
   * @returns range between start and end
   */
  getRange: function getRange() {
    var is = this.getIntervalAndStep();
    return d3["utc" + is.interval].range(this.start, this.end, is.step);
  },


  /**
   * gets the d3 interval and stepsize for d3 time interval methods
   * D3's week-interval starts on sunday and d3 does not support a quarter interval
   **/
  getIntervalAndStep: function getIntervalAndStep() {
    var d3Interval = void 0,
        step = void 0;
    switch (this.unit) {
      case "week":
        d3Interval = "monday";step = this.step;break;
      case "quarter":
        d3Interval = "month";step = this.step * 3;break;
      default:
        d3Interval = this.unit;step = this.step;break;
    }
    return { interval: utils.capitalize(d3Interval), step: step };
  },


  /**
   * Gets filter for time
   * @param {Boolean} splash: get filter for current year only
   * @returns {Object} time filter
   */
  getFilter: function getFilter(splash) {
    var defaultStart = this.parse(this.startOrigin);
    var defaultEnd = this.parse(this.endOrigin);

    var dim = this.getDimension();
    var filter = null;

    if (splash) {
      if (this.value != null) {
        filter = {};
        filter[dim] = this.formatters.data(this.value);
      }
    } else {
      var gte = void 0,
          lte = void 0;
      if (defaultStart != null) {
        gte = this.formatters.data(defaultStart);
      }
      if (defaultEnd != null) {
        lte = this.formatters.data(defaultEnd);
      }
      if (gte || lte) {
        filter = {};
        filter[dim] = {};
        if (gte) filter[dim]["$gte"] = gte;
        if (lte) filter[dim]["$lte"] = lte;
      }
    }
    return filter;
  },


  /**
   * Gets parser for this model
   * @returns {Function} parser function
   */
  getParser: function getParser() {
    var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "data";

    return this.formatters[type].parse;
  },


  /**
  * Gets formatter for this model
  * @returns {Function} formatter function
  */
  getFormatter: function getFormatter() {
    var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "data";

    return this.formatters[type];
  },


  /**
   * Gets an array with all time steps for this model
   * @returns {Array} time array
   */
  getAllSteps: function getAllSteps() {
    if (!this.start || !this.end) {
      utils.warn("getAllSteps(): invalid start/end time is detected: " + this.start + ", " + this.end);
      return [];
    }
    var hash = "" + this.start + this.end + this.step;

    //return if cached
    if (this.allSteps[hash]) return this.allSteps[hash];

    this.allSteps[hash] = [];
    var curr = this.start;
    while (+curr <= +this.end) {
      var is = this.getIntervalAndStep();
      this.allSteps[hash].push(curr);
      curr = d3["utc" + is.interval].offset(curr, is.step);
    }
    return this.allSteps[hash];
  },


  /**
   * Snaps the time to integer
   * possible inputs are "start", "end", "value". "value" is default
   */
  snap: function snap(what) {
    if (!this.round) return;
    if (what == null) what = "value";
    var op = "round";
    if (this.round === "ceil") op = "ceil";
    if (this.round === "floor") op = "floor";
    var is = this.getIntervalAndStep();
    var time = d3["utc" + is.interval][op](this[what]);
    if (this.value - time != 0 || this.value - this.start == 0 || this.value - this.end == 0) {
      this.set(what, time, true); //3rd argumennt forces update
    }
  },


  /**
   * Starts playing the time, initializing the interval
   */
  _startPlaying: function _startPlaying() {
    //don't play if it's not playable
    if (!this.playable) return;

    var _this = this;

    //go to start if we start from end point
    if (this.value >= this.endSelected) {
      _this.getModelObject("value").set(_this.startSelected, null, false /*make change non-persistent for URL and history*/);
    } else {
        //the assumption is that the time is already snapped when we start playing
        //because only dragging the timeslider can un-snap the time, and it snaps on drag.end
        //so we don't need this line. let's see if we survive without.
        //as a consequence, the first time update in playing sequence will have this.playing flag up
        //so the bubble chart will zoom in smoothly. Closes #1213
        //this.snap();
      }
    this.set("playing", true, null, false);
    this.playInterval(this.immediatePlay);

    this.trigger("play");
  },
  playInterval: function playInterval(immediatePlay) {
    if (!this.playing) return;
    var _this = this;
    this.delayAnimations = this.delay;
    if (this.delay < this.delayThresholdX2) this.delayAnimations *= 2;
    if (this.delay < this.delayThresholdX4) this.delayAnimations *= 2;

    var delayAnimations = immediatePlay ? 1 : this.delayAnimations;

    this._intervals.setInterval("playInterval_" + this._id, function () {
      // when time is playing and it reached the end
      if (_this.value >= _this.endSelected) {
        // if looping
        if (_this.loop) {
          // reset time to start, silently
          _this.getModelObject("value").set(_this.startSelected, null, false /*make change non-persistent for URL and history*/);
        } else {
          _this.set("playing", false, null, false);
        }
      } else {

        _this._intervals.clearInterval("playInterval_" + _this._id);

        if (_this.postponePause || !_this.playing) {
          _this.set("playing", false, null, false);
          _this.postponePause = false;
          _this.getModelObject("value").set(_this.value, true, true /*force the change and make it persistent for URL and history*/);
        } else {
          var is = _this.getIntervalAndStep();
          if (_this.delay < _this.delayThresholdX2) is.step *= 2;
          if (_this.delay < _this.delayThresholdX4) is.step *= 2;
          var time = d3["utc" + is.interval].offset(_this.value, is.step);
          if (time >= _this.endSelected) {
            // if no playing needed anymore then make the last update persistent and not overshooting
            _this.getModelObject("value").set(_this.endSelected, null, true /*force the change and make it persistent for URL and history*/);
          } else {
            _this.getModelObject("value").set(time, null, false /*make change non-persistent for URL and history*/);
          }
          _this.playInterval();
        }
      }
    }, delayAnimations);
  },
  incrementTime: function incrementTime(time) {
    var is = this.getIntervalAndStep();
    return d3["utc" + is.interval].offset(time, is.step);
  },
  decrementTime: function decrementTime(time) {
    var is = this.getIntervalAndStep();
    return d3["utc" + is.interval].offset(time, -is.step);
  },


  /**
   * Stops playing the time, clearing the interval
   */
  _stopPlaying: function _stopPlaying() {
    this._intervals.clearInterval("playInterval_" + this._id);
    //this.snap();
    this.trigger("pause");
  }
});

/*
 * Week Format to format and parse dates
 * Conforms with ISO8601
 * Follows format: YYYYwWW: 2015w04, 3845w34, 0020w53
 */
function weekFormat() {

  var format = function format(d) {
    return formatWeekYear(d) + "w" + formatWeek(d);
  };

  format.parse = function parse(dateString) {
    var matchedDate = dateString.match(/^(\d{4})w(\d{2})$/);
    return matchedDate ? getDateFromWeek(matchedDate[1], matchedDate[2]) : null;
  };

  var formatWeekYear = function formatWeekYear(d) {
    var origin = +d;
    return new Date(origin + (4 - (d.getUTCDay() || 7)) * 86400000).getUTCFullYear();
  };

  var formatWeek = function formatWeek(d) {
    var origin = +d;
    var quote = new Date(origin + (4 - (d.getUTCDay() || 7)) * 86400000);
    var week = Math.ceil(((quote.getTime() - quote.setUTCMonth(0, 1)) / 86400000 + 1) / 7);
    return week < 10 ? "0" + week : week;
  };

  var getDateFromWeek = function getDateFromWeek(p1, p2) {
    var week = parseInt(p2);
    var year = p1;
    var startDateOfYear = new Date(); // always 4th of January (according to standard ISO 8601)
    startDateOfYear.setUTCFullYear(year);
    startDateOfYear.setUTCMonth(0);
    startDateOfYear.setUTCDate(4);
    var startDayOfWeek = startDateOfYear.getUTCDay() || 7;
    var dayOfWeek = 1; // Monday === 1
    var dayOfYear = week * 7 + dayOfWeek - (startDayOfWeek + 4);

    var date = formats["year"].parse(year);
    date = new Date(date.getTime() + dayOfYear * 24 * 60 * 60 * 1000);

    return date;
  };

  return format;
}

/*
 * Quarter Format to format and parse quarter dates
 * A quarter is the month%3
 * Follows format: YYYYqQ: 2015q4, 5847q1, 0040q2
 */
function quarterFormat() {

  var format = function format(d) {
    return formats.year.data(d) + "q" + formatQuarter(d);
  };

  format.parse = function (dateString) {
    var matchedDate = dateString.match(/^(\d{4})q(\d)$/);
    return matchedDate ? getDateFromQuarter(matchedDate[1], matchedDate[2]) : null;
  };

  var formatQuarter = function formatQuarter(d) {
    return (d.getUTCMonth() / 3 | 0) + 1;
  };

  var getDateFromQuarter = function getDateFromQuarter(p1, p2) {
    var quarter = parseInt(p2);
    var month = 3 * quarter - 2; // first month in quarter
    var year = p1;
    return formats.month.data.parse([year, (month < 9 ? "0" : "") + month].join("-"));
  };

  return format;
}

exports.default = TimeModel;

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _model = __webpack_require__(47);

var _model2 = _interopRequireDefault(_model);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//classes are vzb-portrait, vzb-landscape...
var class_prefix = "vzb-";
var class_presentation = "presentation";
var class_rtl = "rtl";
var class_portrait = "vzb-portrait";
var class_landscape = "vzb-landscape";

var UI = _model2.default.extend({

  screen_profiles: {
    small: {
      min_width: 0,
      min_height: 0
    },
    medium: {
      min_width: 600,
      min_height: 400
    },
    large: {
      min_width: 900,
      min_height: 520
    }
  },

  getClassDefaults: function getClassDefaults() {
    var defaults = {
      presentation: false,
      buttons: [],
      dialogs: {
        popup: [],
        sidebar: [],
        moreoptions: []
      },
      splash: false
    };
    return utils.deepExtend(this._super(), defaults);
  },


  /**
   * Initializes the layout manager
   */
  init: function init(name, values, parent, bind) {

    this._type = "ui";
    this._container = null;
    //dom element
    this._curr_profile = null;
    this._prev_size = {};

    //resize when window resizes
    this.resizeHandler = this.resizeHandler.bind(this);
    window.addEventListener("resize", this.resizeHandler);
    bind["change:presentation"] = this.updatePresentation.bind(this);

    this._super(name, values, parent, bind);
  },
  resizeHandler: function resizeHandler() {
    if (this._container) {
      this.setSize();
    }
  },


  /**
   * Calculates the size of the newly resized container
   */
  setSize: function setSize(force) {
    var _this = this;
    var width = this._container.clientWidth;
    var height = this._container.clientHeight;

    /**
     * issue #1118
     * check if device is iPhone then add top margin for searchbar if it visible
     */
    if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent) // browser is safari
    && navigator.userAgent.match(/iPhone/i) // checking device
    ) {
        this._container.style.top = 0;
        if (this._container.clientWidth > this._container.clientHeight // landscape mode
        && this._container.clientWidth < 700) {
          // small device
          var bodyHeight = this._container.clientHeight;
          var windowHeight = window.innerHeight;
          if (2 < bodyHeight - windowHeight && bodyHeight - windowHeight <= 45) {
            // check searchbar is visible
            this._container.style.top = 44 + "px";
            document.body.scrollTop = 44; // scrolling empty space
          }
        }
      }

    if (!force && this._prev_size && this._prev_size.width === width && this._prev_size.height === height) {
      return;
    }

    // choose profile depending on size
    utils.forEach(this.screen_profiles, function (range, size) {
      //remove class
      utils.removeClass(_this._container, class_prefix + size);
      //find best fit
      if (width >= range.min_width && height >= range.min_height) {
        _this._curr_profile = size;
      }
    });

    //update size class
    utils.addClass(this._container, class_prefix + this._curr_profile);

    //toggle, untoggle classes based on orientation
    utils.classed(this._container, class_portrait, width < height);
    utils.classed(this._container, class_landscape, !(width < height));

    this._prev_size.width = width;
    this._prev_size.height = height;
    this.trigger("resize");
  },


  /**
   * Sets the container for this layout
   * @param container DOM element
   */
  setContainer: function setContainer(container) {
    this._container = container;
    this.setSize();
    this.updatePresentation();
  },


  /**
   * Sets the presentation mode for this layout
   * @param {Bool} presentation mode on or off
   */
  updatePresentation: function updatePresentation() {
    utils.classed(this._container, class_prefix + class_presentation, this.presentation);
    this.trigger("resize");
  },
  getPresentationMode: function getPresentationMode() {
    return this.presentation;
  },
  setRTL: function setRTL(flag) {
    utils.classed(this._container, class_prefix + class_rtl, flag);
  },


  /**
   * Gets the current selected profile
   * @returns {String} name of current profile
   */
  currentProfile: function currentProfile() {
    return this._curr_profile;
  },
  clear: function clear() {
    window.removeEventListener("resize", this.resizeHandler);
  }
});

exports.default = UI;

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _reader = __webpack_require__(72);

var _reader2 = _interopRequireDefault(_reader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var cached = {};

var CSVReader = _reader2.default.extend({

  _name: "csv",

  /**
   * Initializes the reader.
   * @param {Object} readerInfo Information about the reader
   */
  init: function init(readerInfo) {
    this._data = [];
    this._basepath = readerInfo.path;
    this.delimiter = readerInfo.delimiter;
    this.keySize = readerInfo.keySize || 1;

    Object.assign(this.ERRORS, {
      WRONG_TIME_COLUMN_OR_UNITS: "reader/error/wrongTimeUnitsOrColumn",
      NOT_ENOUGH_ROWS_IN_FILE: "reader/error/notEnoughRows",
      UNDEFINED_DELIMITER: "reader/error/undefinedDelimiter",
      EMPTY_HEADERS: "reader/error/emptyHeaders"
    });
  },
  ensureDataIsCorrect: function ensureDataIsCorrect(_ref, parsers) {
    var columns = _ref.columns,
        data = _ref.data;

    var timeKey = columns[this.keySize];

    var _data = _slicedToArray(data, 1),
        firstRow = _data[0];

    var parser = parsers[timeKey];

    var time = firstRow[timeKey];
    if (parser && !parser(time)) {
      throw this.error(this.ERRORS.WRONG_TIME_COLUMN_OR_UNITS, undefined, {
        currentYear: new Date().getFullYear(),
        foundYear: time
      });
    }

    if (!columns.filter(Boolean).length) {
      throw this.error(this.ERRORS.EMPTY_HEADERS);
    }
  },


  /**
   * This function returns info about the dataset
   * in case of CSV reader it's just the name of the file
   * @returns {object} object of info about the dataset
   */
  getDatasetInfo: function getDatasetInfo() {
    return { name: this._basepath.split("/").pop() };
  },
  load: function load() {
    var _this = this;

    var path = this._basepath;


    return new Promise(function (resolve, reject) {
      var cachedData = cached[path];

      if (cachedData) {
        resolve(cachedData);
      } else {
        d3.text(path).get(function (error, text) {
          if (!text) {
            return reject("No permissions or empty file: " + path + ". " + error);
          }

          if (error) {
            return reject("Error happened while loading csv file: " + path + ". " + error);
          }

          try {
            var _delimiter = _this.delimiter,
                delimiter = _delimiter === undefined ? _this._guessDelimiter(text) : _delimiter;

            var parser = d3.dsvFormat(delimiter);
            var data = parser.parse(text);

            var result = { columns: data.columns, data: data };
            cached[path] = result;
            resolve(result);
          } catch (e) {
            return reject(e);
          }
        });
      }
    });
  },
  _guessDelimiter: function _guessDelimiter(text) {
    var stringsToCheck = 2;
    var rows = this._getRows(text, stringsToCheck).map(function (row) {
      return row.replace(/".*?"/g, "");
    });

    if (rows.length !== stringsToCheck) {
      throw this.error(this.ERRORS.NOT_ENOUGH_ROWS_IN_FILE);
    }

    var _rows = _slicedToArray(rows, 2),
        header = _rows[0],
        firstRow = _rows[1];

    var comma = ",",
        semicolon = ";";

    var commasCountInHeader = this._countCharsInLine(header, comma);
    var semicolonsCountInHeader = this._countCharsInLine(header, semicolon);
    var commasCountInFirstRow = this._countCharsInLine(firstRow, comma);
    var semicolonsCountInFirstRow = this._countCharsInLine(firstRow, semicolon);

    if (commasCountInHeader === commasCountInFirstRow && commasCountInHeader > 1 && (semicolonsCountInHeader !== semicolonsCountInFirstRow || !semicolonsCountInHeader && !semicolonsCountInFirstRow || commasCountInHeader > semicolonsCountInHeader && commasCountInFirstRow > semicolonsCountInFirstRow)) {
      return comma;
    } else if (semicolonsCountInHeader === semicolonsCountInFirstRow && semicolonsCountInHeader > 1 && (commasCountInHeader !== commasCountInFirstRow || !commasCountInHeader && !commasCountInFirstRow || semicolonsCountInHeader > commasCountInHeader && semicolonsCountInFirstRow > commasCountInFirstRow)) {
      return semicolon;
    }

    throw this.error(this.ERRORS.UNDEFINED_DELIMITER);
  },
  _getRows: function _getRows(text) {
    var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    var re = /([^\r\n]+)/g;
    var rows = [];
    var rowsCount = 0;

    var matches = true;
    while (matches && rowsCount !== count) {
      matches = re.exec(text);
      if (matches && matches.length > 1) {
        ++rowsCount;
        rows.push(matches[1]);
      }
    }

    return rows;
  },
  _countCharsInLine: function _countCharsInLine(text, char) {
    var re = new RegExp(char, "g");
    var matches = text.match(re);
    return matches ? matches.length : 0;
  }
});

exports.default = CSVReader;

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

var cof = __webpack_require__(28);
module.exports = function(it, msg){
  if(typeof it != 'number' && cof(it) != 'Number')throw TypeError(msg);
  return +it;
};

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)

var toObject = __webpack_require__(13)
  , toIndex  = __webpack_require__(57)
  , toLength = __webpack_require__(12);

module.exports = [].copyWithin || function copyWithin(target/*= 0*/, start/*= 0, end = @length*/){
  var O     = toObject(this)
    , len   = toLength(O.length)
    , to    = toIndex(target, len)
    , from  = toIndex(start, len)
    , end   = arguments.length > 2 ? arguments[2] : undefined
    , count = Math.min((end === undefined ? len : toIndex(end, len)) - from, len - to)
    , inc   = 1;
  if(from < to && to < from + count){
    inc  = -1;
    from += count - 1;
    to   += count - 1;
  }
  while(count-- > 0){
    if(from in O)O[to] = O[from];
    else delete O[to];
    to   += inc;
    from += inc;
  } return O;
};

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

var forOf = __webpack_require__(63);

module.exports = function(iter, ITERATOR){
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(17)
  , toObject  = __webpack_require__(13)
  , IObject   = __webpack_require__(69)
  , toLength  = __webpack_require__(12);

module.exports = function(that, callbackfn, aLen, memo, isRight){
  aFunction(callbackfn);
  var O      = toObject(that)
    , self   = IObject(O)
    , length = toLength(O.length)
    , index  = isRight ? length - 1 : 0
    , i      = isRight ? -1 : 1;
  if(aLen < 2)for(;;){
    if(index in self){
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if(isRight ? index < 0 : length <= index){
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for(;isRight ? index >= 0 : length > index; index += i)if(index in self){
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var aFunction  = __webpack_require__(17)
  , isObject   = __webpack_require__(6)
  , invoke     = __webpack_require__(78)
  , arraySlice = [].slice
  , factories  = {};

var construct = function(F, len, args){
  if(!(len in factories)){
    for(var n = [], i = 0; i < len; i++)n[i] = 'a[' + i + ']';
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /*, args... */){
  var fn       = aFunction(this)
    , partArgs = arraySlice.call(arguments, 1);
  var bound = function(/* args... */){
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if(isObject(fn.prototype))bound.prototype = fn.prototype;
  return bound;
};

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var dP          = __webpack_require__(9).f
  , create      = __webpack_require__(52)
  , redefineAll = __webpack_require__(55)
  , ctx         = __webpack_require__(37)
  , anInstance  = __webpack_require__(50)
  , defined     = __webpack_require__(29)
  , forOf       = __webpack_require__(63)
  , $iterDefine = __webpack_require__(101)
  , step        = __webpack_require__(164)
  , setSpecies  = __webpack_require__(56)
  , DESCRIPTORS = __webpack_require__(8)
  , fastKey     = __webpack_require__(43).fastKey
  , SIZE        = DESCRIPTORS ? '_s' : 'size';

var getEntry = function(that, key){
  // fast case
  var index = fastKey(key), entry;
  if(index !== 'F')return that._i[index];
  // frozen object case
  for(entry = that._f; entry; entry = entry.n){
    if(entry.k == key)return entry;
  }
};

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      anInstance(that, C, NAME, '_i');
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear(){
        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
          entry.r = true;
          if(entry.p)entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function(key){
        var that  = this
          , entry = getEntry(that, key);
        if(entry){
          var next = entry.n
            , prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if(prev)prev.n = next;
          if(next)next.p = prev;
          if(that._f == entry)that._f = next;
          if(that._l == entry)that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /*, that = undefined */){
        anInstance(this, C, 'forEach');
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
          , entry;
        while(entry = entry ? entry.n : this._f){
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while(entry && entry.r)entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key){
        return !!getEntry(this, key);
      }
    });
    if(DESCRIPTORS)dP(C.prototype, 'size', {
      get: function(){
        return defined(this[SIZE]);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry){
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that._f)that._f = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index !== 'F')that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function(C, NAME, IS_MAP){
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function(iterated, kind){
      this._t = iterated;  // target
      this._k = kind;      // kind
      this._l = undefined; // previous
    }, function(){
      var that  = this
        , kind  = that._k
        , entry = that._l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if(kind == 'keys'  )return step(0, entry.k);
      if(kind == 'values')return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = __webpack_require__(68)
  , from    = __webpack_require__(155);
module.exports = function(NAME){
  return function toJSON(){
    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var redefineAll       = __webpack_require__(55)
  , getWeak           = __webpack_require__(43).getWeak
  , anObject          = __webpack_require__(3)
  , isObject          = __webpack_require__(6)
  , anInstance        = __webpack_require__(50)
  , forOf             = __webpack_require__(63)
  , createArrayMethod = __webpack_require__(31)
  , $has              = __webpack_require__(14)
  , arrayFind         = createArrayMethod(5)
  , arrayFindIndex    = createArrayMethod(6)
  , id                = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function(that){
  return that._l || (that._l = new UncaughtFrozenStore);
};
var UncaughtFrozenStore = function(){
  this.a = [];
};
var findUncaughtFrozen = function(store, key){
  return arrayFind(store.a, function(it){
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function(key){
    var entry = findUncaughtFrozen(this, key);
    if(entry)return entry[1];
  },
  has: function(key){
    return !!findUncaughtFrozen(this, key);
  },
  set: function(key, value){
    var entry = findUncaughtFrozen(this, key);
    if(entry)entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function(key){
    var index = arrayFindIndex(this.a, function(it){
      return it[0] === key;
    });
    if(~index)this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      anInstance(that, C, NAME, '_i');
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function(key){
        if(!isObject(key))return false;
        var data = getWeak(key);
        if(data === true)return uncaughtFrozenStore(this)['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key){
        if(!isObject(key))return false;
        var data = getWeak(key);
        if(data === true)return uncaughtFrozenStore(this).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var data = getWeak(anObject(key), true);
    if(data === true)uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(8) && !__webpack_require__(5)(function(){
  return Object.defineProperty(__webpack_require__(93)('div'), 'a', {get: function(){ return 7; }}).a != 7;
});

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var isObject = __webpack_require__(6)
  , floor    = Math.floor;
module.exports = function isInteger(it){
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(3);
module.exports = function(iterator, fn, value, entries){
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch(e){
    var ret = iterator['return'];
    if(ret !== undefined)anObject(ret.call(iterator));
    throw e;
  }
};

/***/ }),
/* 164 */
/***/ (function(module, exports) {

module.exports = function(done, value){
  return {value: value, done: !!done};
};

/***/ }),
/* 165 */
/***/ (function(module, exports) {

// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x){
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var getKeys  = __webpack_require__(54)
  , gOPS     = __webpack_require__(82)
  , pIE      = __webpack_require__(70)
  , toObject = __webpack_require__(13)
  , IObject  = __webpack_require__(69)
  , $assign  = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(5)(function(){
  var A = {}
    , B = {}
    , S = Symbol()
    , K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function(k){ B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
  var T     = toObject(target)
    , aLen  = arguments.length
    , index = 1
    , getSymbols = gOPS.f
    , isEnum     = pIE.f;
  while(aLen > index){
    var S      = IObject(arguments[index++])
      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
  } return T;
} : $assign;

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

var dP       = __webpack_require__(9)
  , anObject = __webpack_require__(3)
  , getKeys  = __webpack_require__(54);

module.exports = __webpack_require__(8) ? Object.defineProperties : function defineProperties(O, Properties){
  anObject(O);
  var keys   = getKeys(Properties)
    , length = keys.length
    , i = 0
    , P;
  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(21)
  , gOPN      = __webpack_require__(53).f
  , toString  = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function(it){
  try {
    return gOPN(it);
  } catch(e){
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it){
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

var has          = __webpack_require__(14)
  , toIObject    = __webpack_require__(21)
  , arrayIndexOf = __webpack_require__(74)(false)
  , IE_PROTO     = __webpack_require__(106)('IE_PROTO');

module.exports = function(object, names){
  var O      = toIObject(object)
    , i      = 0
    , result = []
    , key;
  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while(names.length > i)if(has(O, key = names[i++])){
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

var getKeys   = __webpack_require__(54)
  , toIObject = __webpack_require__(21)
  , isEnum    = __webpack_require__(70).f;
module.exports = function(isEntries){
  return function(it){
    var O      = toIObject(it)
      , keys   = getKeys(O)
      , length = keys.length
      , i      = 0
      , result = []
      , key;
    while(length > i)if(isEnum.call(O, key = keys[i++])){
      result.push(isEntries ? [key, O[key]] : O[key]);
    } return result;
  };
};

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

// all object keys, includes non-enumerable and symbols
var gOPN     = __webpack_require__(53)
  , gOPS     = __webpack_require__(82)
  , anObject = __webpack_require__(3)
  , Reflect  = __webpack_require__(4).Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it){
  var keys       = gOPN.f(anObject(it))
    , getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

var $parseFloat = __webpack_require__(4).parseFloat
  , $trim       = __webpack_require__(66).trim;

module.exports = 1 / $parseFloat(__webpack_require__(111) + '-0') !== -Infinity ? function parseFloat(str){
  var string = $trim(String(str), 3)
    , result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

var $parseInt = __webpack_require__(4).parseInt
  , $trim     = __webpack_require__(66).trim
  , ws        = __webpack_require__(111)
  , hex       = /^[\-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix){
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;

/***/ }),
/* 174 */
/***/ (function(module, exports) {

// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y){
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-string-pad-start-end
var toLength = __webpack_require__(12)
  , repeat   = __webpack_require__(110)
  , defined  = __webpack_require__(29);

module.exports = function(that, maxLength, fillString, left){
  var S            = String(defined(that))
    , stringLength = S.length
    , fillStr      = fillString === undefined ? ' ' : String(fillString)
    , intMaxLength = toLength(maxLength);
  if(intMaxLength <= stringLength || fillStr == '')return S;
  var fillLen = intMaxLength - stringLength
    , stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if(stringFiller.length > fillLen)stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(7);

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(158);

// 23.1 Map Objects
module.exports = __webpack_require__(75)('Map', function(get){
  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key){
    var entry = strong.getEntry(this, key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value){
    return strong.def(this, key === 0 ? 0 : key, value);
  }
}, strong, true);

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

// 21.2.5.3 get RegExp.prototype.flags()
if(__webpack_require__(8) && /./g.flags != 'g')__webpack_require__(9).f(RegExp.prototype, 'flags', {
  configurable: true,
  get: __webpack_require__(77)
});

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(158);

// 23.2 Set Objects
module.exports = __webpack_require__(75)('Set', function(get){
  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value){
    return strong.def(this, value = value === 0 ? 0 : value, value);
  }
}, strong);

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var each         = __webpack_require__(31)(0)
  , redefine     = __webpack_require__(19)
  , meta         = __webpack_require__(43)
  , assign       = __webpack_require__(166)
  , weak         = __webpack_require__(160)
  , isObject     = __webpack_require__(6)
  , getWeak      = meta.getWeak
  , isExtensible = Object.isExtensible
  , uncaughtFrozenStore = weak.ufstore
  , tmp          = {}
  , InternalMap;

var wrapper = function(get){
  return function WeakMap(){
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key){
    if(isObject(key)){
      var data = getWeak(key);
      if(data === true)return uncaughtFrozenStore(this).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value){
    return weak.def(this, key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = __webpack_require__(75)('WeakMap', wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if(new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){
  InternalMap = weak.getConstructor(wrapper);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function(key){
    var proto  = $WeakMap.prototype
      , method = proto[key];
    redefine(proto, key, function(a, b){
      // store frozen objects on internal weakmap shim
      if(isObject(a) && !isExtensible(a)){
        if(!this._f)this._f = new InternalMap;
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _tool = __webpack_require__(15);

var _tool2 = _interopRequireDefault(_tool);

var _agepyramidComponent = __webpack_require__(215);

var _agepyramidComponent2 = _interopRequireDefault(_agepyramidComponent);

var _timeslider = __webpack_require__(26);

var _timeslider2 = _interopRequireDefault(_timeslider);

var _dialogs = __webpack_require__(23);

var _dialogs2 = _interopRequireDefault(_dialogs);

var _buttonlist = __webpack_require__(22);

var _buttonlist2 = _interopRequireDefault(_buttonlist);

var _treemenu = __webpack_require__(27);

var _treemenu2 = _interopRequireDefault(_treemenu);

var _datanotes = __webpack_require__(35);

var _datanotes2 = _interopRequireDefault(_datanotes);

var _steppedspeedslider = __webpack_require__(49);

var _steppedspeedslider2 = _interopRequireDefault(_steppedspeedslider);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//BAR CHART TOOL
var AgePyramid = _tool2.default.extend("AgePyramid", {

  /**
   * Initializes the tool (Bar Chart Tool).
   * Executed once before any template is rendered.
   * @param {Object} placeholder Placeholder element for the tool
   * @param {Object} external_model Model as given by the external page
   */
  init: function init(placeholder, external_model) {

    this.name = "agepyramid";

    //specifying components
    this.components = [{
      component: _agepyramidComponent2.default,
      placeholder: ".vzb-tool-viz",
      model: ["state.time", "state.marker", "state.entities", "state.entities_side", "locale", "ui"] //pass models to component
    }, {
      component: _timeslider2.default,
      placeholder: ".vzb-tool-timeslider",
      model: ["state.time", "state.entities", "state.marker", "ui"]
    }, {
      component: _dialogs2.default,
      placeholder: ".vzb-tool-dialogs",
      model: ["state", "ui", "locale"]
    }, {
      component: _buttonlist2.default,
      placeholder: ".vzb-tool-buttonlist",
      model: ["state", "ui", "locale"]
    }, {
      component: _treemenu2.default,
      placeholder: ".vzb-tool-treemenu",
      model: ["state.marker", "state.marker_tags", "state.time", "locale"]
    }, {
      component: _datanotes2.default,
      placeholder: ".vzb-tool-datanotes",
      model: ["state.marker", "locale"]
    }, {
      component: _steppedspeedslider2.default,
      placeholder: ".vzb-tool-stepped-speed-slider",
      model: ["state.time", "locale"]
    }];

    //constructor is the same as any tool
    this._super(placeholder, external_model);
  },


  default_model: {
    state: {
      marker_tags: {}
    },
    ui: {
      chart: {
        stacked: true,
        inpercent: false,
        flipSides: true
      },
      "buttons": ["colors", "inpercent", "side", "moreoptions", "fullscreen"],
      "dialogs": {
        "popup": ["timedisplay", "colors", "side", "moreoptions"],
        "sidebar": ["timedisplay", "colors", "show"],
        "moreoptions": ["opacity", "speed", "colors", "side", "presentation", "about"]
      },
      presentation: false
    },
    locale: {}
  }

}); /*!
     * VIZABI AGEPYRAMID
     */

exports.default = AgePyramid;

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _tool = __webpack_require__(15);

var _tool2 = _interopRequireDefault(_tool);

var _axislabelerComponent = __webpack_require__(216);

var _axislabelerComponent2 = _interopRequireDefault(_axislabelerComponent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var comp_template = "axislabeler.html"; /*!
                                         * VIZABI BARCHART
                                         */

var listPointer = 0;
var listData = [[-123, 123], [1.00000, 10000.0], [4.00000, 123.000], [0.00060, 123.000], [123.000, 4.00000], [123.000, 0.00060], [-123.00, -4.0000], [-123.00, -0.0006], [-4.0000, -123.00], [-0.0006, -123.00], [-123.00, 1800.00], [1800.00, -123.00], [123.000, -18000.0], [-18000.0, 123.000], [-0.0006, 1800.00], [1800.00, -0.0006], [0.00060, -1800.0], [-1800.0, 0.00060], [-12.000, -2.0000], [-80.000, 40.0000], [5.00000, 8.00000], [42.0000, 42.0000], [0.00000000005, 4554545484715], [-2611968678575, 4554545484715], [-0.0020, 0.00200], [-123, -0.1, 0.002, 1540], [-123, -0.001, 0.5, 1540], [123, 0.1, -0.002, -1540], [123, 0.001, -0.5, -1540]];

//AXIS LABELER TOOL
var AxisLabeler = _tool2.default.extend("AxisLabeler", {

  /**
   * Initializes the tool (Bar Chart Tool).
   * Executed once before any template is rendered.
   * @param {Object} placeholder Placeholder element for the tool
   * @param {Object} external_model Model as given by the external page
   */
  init: function init(placeholder, external_model) {

    this.name = "axislabeler";

    //specifying components
    this.components = [{
      component: _axislabelerComponent2.default,
      placeholder: ".vzb-tool-viz",
      model: ["state.scales", "state.show"] //pass models to component
    }];

    //constructor is the same as any tool
    this._super(placeholder, external_model);
  },


  default_model: {
    state: {
      scales: {
        domain: listData[listPointer],
        xScaleType: "linear",
        yScaleType: "genericLog"
      },
      show: {
        labelSize: "16px",
        labelMargin: { LR: "5px", TB: "5px" },
        toolMargin: { top: 30, right: 20, left: 40, bottom: 40 }
      }

    },
    data: { noConceptprops: true },
    locale: {},
    ui: {}
  }
});

exports.default = AxisLabeler;

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _tool = __webpack_require__(15);

var _tool2 = _interopRequireDefault(_tool);

var _barchartComponent = __webpack_require__(217);

var _barchartComponent2 = _interopRequireDefault(_barchartComponent);

var _timeslider = __webpack_require__(26);

var _timeslider2 = _interopRequireDefault(_timeslider);

var _dialogs = __webpack_require__(23);

var _dialogs2 = _interopRequireDefault(_dialogs);

var _buttonlist = __webpack_require__(22);

var _buttonlist2 = _interopRequireDefault(_buttonlist);

var _treemenu = __webpack_require__(27);

var _treemenu2 = _interopRequireDefault(_treemenu);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var comp_template = "barchart.html";

//BAR CHART TOOL
/*!
 * VIZABI BARCHART
 */

var BarChart = _tool2.default.extend("BarChart", {

  /**
   * Initializes the tool (Bar Chart Tool).
   * Executed once before any template is rendered.
   * @param {Object} placeholder Placeholder element for the tool
   * @param {Object} external_model Model as given by the external page
   */
  init: function init(placeholder, external_model) {

    this.name = "barchart";

    //specifying components
    this.components = [{
      component: _barchartComponent2.default,
      placeholder: ".vzb-tool-viz",
      model: ["state.time", "state.entities", "state.marker", "locale"] //pass models to component
    }, {
      component: _timeslider2.default,
      placeholder: ".vzb-tool-timeslider",
      model: ["state.time", "state.entities", "state.marker", "ui"]
    }, {
      component: _dialogs2.default,
      placeholder: ".vzb-tool-dialogs",
      model: ["state", "ui", "locale"]
    }, {
      component: _buttonlist2.default,
      placeholder: ".vzb-tool-buttonlist",
      model: ["state", "ui", "locale"]
    }, {
      component: _treemenu2.default,
      placeholder: ".vzb-tool-treemenu",
      model: ["state.marker", "state.marker_tags", "state.time", "locale"]
    }];

    //constructor is the same as any tool
    this._super(placeholder, external_model);
  },


  default_model: {
    state: {
      time: {},
      entities: {},
      marker: {
        label: {},
        axis_y: { allow: { scales: ["linear", "log"] } },
        axis_x: { allow: { scales: ["ordinal", "nominal"] } },
        color: {}
      }
    },
    locale: {},
    ui: {
      presentation: false,
      chart: {},
      "buttons": ["axes", "colors", "fullscreen"],
      "dialogs": {
        "popup": ["axes", "colors"]
      }
    }
  }
});

exports.default = BarChart;

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _tool = __webpack_require__(15);

var _tool2 = _interopRequireDefault(_tool);

var _barrankchartComponent = __webpack_require__(218);

var _barrankchartComponent2 = _interopRequireDefault(_barrankchartComponent);

var _timeslider = __webpack_require__(26);

var _timeslider2 = _interopRequireDefault(_timeslider);

var _dialogs = __webpack_require__(23);

var _dialogs2 = _interopRequireDefault(_dialogs);

var _buttonlist = __webpack_require__(22);

var _buttonlist2 = _interopRequireDefault(_buttonlist);

var _treemenu = __webpack_require__(27);

var _treemenu2 = _interopRequireDefault(_treemenu);

var _datanotes = __webpack_require__(35);

var _datanotes2 = _interopRequireDefault(_datanotes);

var _datawarning = __webpack_require__(40);

var _datawarning2 = _interopRequireDefault(_datawarning);

var _steppedspeedslider = __webpack_require__(49);

var _steppedspeedslider2 = _interopRequireDefault(_steppedspeedslider);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var BarRankChart = _tool2.default.extend("BarRankChart", {

  //Run when the tool is created
  init: function init(placeholder, external_model) {

    this.name = "barrankchart";

    this.components = [{
      component: _barrankchartComponent2.default,
      placeholder: ".vzb-tool-viz",
      model: ["state.time", "state.entities", "state.marker", "locale", "ui"]
    }, {
      component: _timeslider2.default,
      placeholder: ".vzb-tool-timeslider",
      model: ["state.time", "state.entities", "state.marker", "ui"]
    }, {
      component: _dialogs2.default,
      placeholder: ".vzb-tool-dialogs",
      model: ["state", "ui", "locale"]
    }, {
      component: _buttonlist2.default,
      placeholder: ".vzb-tool-buttonlist",
      model: ["state", "ui", "locale"]
    }, {
      component: _treemenu2.default,
      placeholder: ".vzb-tool-treemenu",
      model: ["state.marker", "state.marker_tags", "state.time", "locale"]
    }, {
      component: _datanotes2.default,
      placeholder: ".vzb-tool-datanotes",
      model: ["state.marker", "locale"]
    }, {
      component: _datawarning2.default,
      placeholder: ".vzb-tool-datawarning",
      model: ["locale"]
    }, {
      component: _steppedspeedslider2.default,
      placeholder: ".vzb-tool-stepped-speed-slider",
      model: ["state.time", "locale"]
    }];

    //constructor is the same as any tool
    this._super(placeholder, external_model);
  },


  /**
   * Determines the default model of this tool
   */
  default_model: {
    state: {
      entities: {
        dim: "id"
      },
      time: {},
      marker: {
        axis_x: { allow: { scales: ["linear", "log"] } },
        axis_y: { allow: { scales: ["ordinal", "nominal"] } },
        color: {}
      }
    },
    locale: {},
    ui: {
      chart: {},
      datawarning: {
        doubtDomain: [],
        doubtRange: []
      },
      "buttons": ["colors", "find", "show", "moreoptions", "fullscreen", "presentation"],
      "dialogs": {
        "popup": ["timedisplay", "colors", "find", "axes", "show", "moreoptions"],
        "sidebar": ["timedisplay", "colors", "find"],
        "moreoptions": ["opacity", "speed", "colors", "presentation", "about"]
      },
      presentation: false
    }
  }
});

exports.default = BarRankChart;

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _tool = __webpack_require__(15);

var _tool2 = _interopRequireDefault(_tool);

var _bubblechartComponent = __webpack_require__(219);

var _bubblechartComponent2 = _interopRequireDefault(_bubblechartComponent);

var _timeslider = __webpack_require__(26);

var _timeslider2 = _interopRequireDefault(_timeslider);

var _dialogs = __webpack_require__(23);

var _dialogs2 = _interopRequireDefault(_dialogs);

var _buttonlist = __webpack_require__(22);

var _buttonlist2 = _interopRequireDefault(_buttonlist);

var _treemenu = __webpack_require__(27);

var _treemenu2 = _interopRequireDefault(_treemenu);

var _datawarning = __webpack_require__(40);

var _datawarning2 = _interopRequireDefault(_datawarning);

var _datanotes = __webpack_require__(35);

var _datanotes2 = _interopRequireDefault(_datanotes);

var _steppedspeedslider = __webpack_require__(49);

var _steppedspeedslider2 = _interopRequireDefault(_steppedspeedslider);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var BubbleChart = _tool2.default.extend("BubbleChart", {

  /**
   * Initializes the tool (Bubble Chart Tool).
   * Executed once before any template is rendered.
   * @param {Object} placeholder Placeholder element for the tool
   * @param {Object} external_model Model as given by the external page
   */
  init: function init(placeholder, external_model) {

    this.name = "bubblechart";

    //specifying components
    this.components = [{
      component: _bubblechartComponent2.default,
      placeholder: ".vzb-tool-viz",
      model: ["state.time", "state.entities", "state.marker", "locale", "ui"] //pass models to component
    }, {
      component: _timeslider2.default,
      placeholder: ".vzb-tool-timeslider",
      model: ["state.time", "state.entities", "state.marker", "ui"]
    }, {
      component: _dialogs2.default,
      placeholder: ".vzb-tool-dialogs",
      model: ["state", "ui", "locale"]
    }, {
      component: _buttonlist2.default,
      placeholder: ".vzb-tool-buttonlist",
      model: ["state", "ui", "locale"]
    }, {
      component: _treemenu2.default,
      placeholder: ".vzb-tool-treemenu",
      model: ["state.marker", "state.marker_tags", "state.time", "locale"]
    }, {
      component: _datawarning2.default,
      placeholder: ".vzb-tool-datawarning",
      model: ["locale"]
    }, {
      component: _datanotes2.default,
      placeholder: ".vzb-tool-datanotes",
      model: ["state.marker", "locale"]
    }, {
      component: _steppedspeedslider2.default,
      placeholder: ".vzb-tool-stepped-speed-slider",
      model: ["state.time", "locale"]
    }];

    this._super(placeholder, external_model);
  },
  validate: function validate(model) {
    model = this.model || model;

    this._super(model);

    if (model.ui.chart.lockNonSelected) {
      var time = model.state.time.parse("" + model.ui.chart.lockNonSelected);
      if (time < model.state.time.start) model.ui.chart.lockNonSelected = model.state.time.formatDate(model.state.time.start);
      if (time > model.state.time.end) model.ui.chart.lockNonSelected = model.state.time.formatDate(model.state.time.end);
    }
  },


  /**
   * Determines the default model of this tool
   */
  default_model: {
    state: {
      time: {
        autogenerate: {
          data: "data",
          conceptIndex: 0,
          conceptType: "time"
        }
      },
      entities: {
        autogenerate: {
          data: "data",
          conceptIndex: 0
        }
      },
      entities_colorlegend: {
        autogenerate: {
          data: "data",
          conceptIndex: 0
        }
      },
      entities_tags: {},
      marker_tags: {
        space: ["entities_tags"],
        label: {},
        hook_parent: {}
      },
      marker: {
        space: ["entities", "time"],
        axis_x: {
          use: "indicator",
          autogenerate: {
            conceptIndex: 1,
            conceptType: "measure"
          }
        },
        axis_y: {
          use: "indicator",
          autogenerate: {
            conceptIndex: 0,
            conceptType: "measure"
          }
        },
        label: {
          use: "property",
          autogenerate: {
            conceptIndex: 0
          }
        },
        size: {
          autogenerate: {
            conceptIndex: 2,
            conceptType: "measure"
          }
        },
        color: {
          syncModels: ["marker_colorlegend"],
          autogenerate: {
            conceptIndex: 0,
            conceptType: "entity_set"
          }
        },
        size_label: {
          use: "constant",
          which: "_default",
          scaleType: "ordinal",
          _important: false,
          extent: [0, 0.33],
          allow: {
            names: ["_default"]
          }
        }
      },
      "marker_colorlegend": {
        "space": ["entities_colorlegend"],
        "label": {
          "use": "property",
          "which": "name"
        },
        "hook_rank": {
          "use": "property",
          "which": "rank"
        },
        "hook_geoshape": {
          "use": "property",
          "which": "shape_lores_svg"
        }
      }
    },
    locale: {},
    ui: {
      chart: {
        whenHovering: {
          showProjectionLineX: true,
          showProjectionLineY: true,
          higlightValueX: true,
          higlightValueY: true
        },
        labels: {
          dragging: true,
          removeLabelBox: false
        },
        trails: true,
        lockNonSelected: 0
      },
      datawarning: {
        doubtDomain: [],
        doubtRange: []
      },
      presentation: false,
      panWithArrow: false,
      adaptMinMaxZoom: false,
      cursorMode: "arrow",
      zoomOnScrolling: false,
      buttons: ["colors", "find", "trails", "lock", "moreoptions", "fullscreen", "presentation"],
      dialogs: {
        popup: ["colors", "find", "size", "zoom", "moreoptions"],
        sidebar: ["colors", "find", "size", "zoom"],
        moreoptions: ["opacity", "speed", "axes", "size", "colors", "label", "zoom", "presentation", "about"]
      }
    }
  }
});

exports.default = BubbleChart;

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _tool = __webpack_require__(15);

var _tool2 = _interopRequireDefault(_tool);

var _bubblemapComponent = __webpack_require__(222);

var _bubblemapComponent2 = _interopRequireDefault(_bubblemapComponent);

var _timeslider = __webpack_require__(26);

var _timeslider2 = _interopRequireDefault(_timeslider);

var _dialogs = __webpack_require__(23);

var _dialogs2 = _interopRequireDefault(_dialogs);

var _buttonlist = __webpack_require__(22);

var _buttonlist2 = _interopRequireDefault(_buttonlist);

var _treemenu = __webpack_require__(27);

var _treemenu2 = _interopRequireDefault(_treemenu);

var _datawarning = __webpack_require__(40);

var _datawarning2 = _interopRequireDefault(_datawarning);

var _datanotes = __webpack_require__(35);

var _datanotes2 = _interopRequireDefault(_datanotes);

var _steppedspeedslider = __webpack_require__(49);

var _steppedspeedslider2 = _interopRequireDefault(_steppedspeedslider);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//BAR CHART TOOL
/*!
 * VIZABI BUBBLEMAP
 */

var BubbleMap = _tool2.default.extend("BubbleMap", {

  /**
   * Initializes the tool (Bar Chart Tool).
   * Executed once before any template is rendered.
   * @param {Object} placeholder Placeholder element for the tool
   * @param {Object} external_model Model as given by the external page
   */
  init: function init(placeholder, external_model) {

    this.name = "bubblemap";

    //specifying components
    this.components = [{
      component: _bubblemapComponent2.default,
      placeholder: ".vzb-tool-viz",
      model: ["state.time", "state.entities", "state.marker", "locale", "ui"] //pass models to component
    }, {
      component: _timeslider2.default,
      placeholder: ".vzb-tool-timeslider",
      model: ["state.time", "state.entities", "state.marker", "ui"]
    }, {
      component: _dialogs2.default,
      placeholder: ".vzb-tool-dialogs",
      model: ["state", "ui", "locale"]
    }, {
      component: _buttonlist2.default,
      placeholder: ".vzb-tool-buttonlist",
      model: ["state", "ui", "locale"]
    }, {
      component: _treemenu2.default,
      placeholder: ".vzb-tool-treemenu",
      model: ["state.marker", "state.marker_tags", "state.time", "locale"]
    }, {
      component: _datawarning2.default,
      placeholder: ".vzb-tool-datawarning",
      model: ["locale"]
    }, {
      component: _datanotes2.default,
      placeholder: ".vzb-tool-datanotes",
      model: ["state.marker", "locale"]
    }, {
      component: _steppedspeedslider2.default,
      placeholder: ".vzb-tool-stepped-speed-slider",
      model: ["state.time", "locale"]
    }];

    //constructor is the same as any tool
    this._super(placeholder, external_model);
  },


  default_model: {
    state: {
      time: {
        "delay": 100,
        "delayThresholdX2": 50,
        "delayThresholdX4": 25
      },
      entities: {
        "opacitySelectDim": 0.3,
        "opacityRegular": 1
      }
    },
    locale: {},
    ui: {
      map: {
        path: null,
        colorGeo: false,
        preserveAspectRatio: true,
        scale: 0.95,
        offset: {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        },
        projection: "robinson",
        topology: {
          path: null,
          objects: {
            geo: "land",
            boundaries: "countries"
          },
          geoIdProperty: null
        }
      },
      chart: {
        labels: {
          dragging: true
        }
      },
      datawarning: {
        doubtDomain: [],
        doubtRange: []
      },
      "buttons": ["colors", "find", "size", "moreoptions", "fullscreen", "presentation"],
      "dialogs": {
        "popup": ["colors", "find", "size", "moreoptions"],
        "sidebar": ["colors", "find", "size"],
        "moreoptions": ["opacity", "speed", "size", "colors", "presentation", "about"]
      },
      presentation: false
    }
  }
});

exports.default = BubbleMap;

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _tool = __webpack_require__(15);

var _tool2 = _interopRequireDefault(_tool);

var _cartogramComponent = __webpack_require__(223);

var _cartogramComponent2 = _interopRequireDefault(_cartogramComponent);

var _timeslider = __webpack_require__(26);

var _timeslider2 = _interopRequireDefault(_timeslider);

var _dialogs = __webpack_require__(23);

var _dialogs2 = _interopRequireDefault(_dialogs);

var _buttonlist = __webpack_require__(22);

var _buttonlist2 = _interopRequireDefault(_buttonlist);

var _treemenu = __webpack_require__(27);

var _treemenu2 = _interopRequireDefault(_treemenu);

var _datawarning = __webpack_require__(40);

var _datawarning2 = _interopRequireDefault(_datawarning);

var _datanotes = __webpack_require__(35);

var _datanotes2 = _interopRequireDefault(_datanotes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//CARTOGRAM TOOL
var Cartogram = _tool2.default.extend("Cartogram", {

  /**
   * Initialized the tool
   * @param {Object} placeholder Placeholder element for the tool
   * @param {Object} external_model Model as given by the external page
   */
  init: function init(placeholder, external_model) {

    this.name = "cartogram";

    //specifying components
    this.components = [{
      component: _cartogramComponent2.default,
      placeholder: ".vzb-tool-viz",
      model: ["state.time", "state.entities", "state.marker", "locale", "ui"] //pass models to component
    }, {
      component: _timeslider2.default,
      placeholder: ".vzb-tool-timeslider",
      model: ["state.time", "state.entities", "state.marker", "ui"]
    }, {
      component: _dialogs2.default,
      placeholder: ".vzb-tool-dialogs",
      model: ["state", "ui", "locale"]
    }, {
      component: _buttonlist2.default,
      placeholder: ".vzb-tool-buttonlist",
      model: ["state", "ui", "locale"]
    }, {
      component: _treemenu2.default,
      placeholder: ".vzb-tool-treemenu",
      model: ["state.marker", "locale"]
    }, {
      component: _datawarning2.default,
      placeholder: ".vzb-tool-datawarning",
      model: ["locale"]
    }, {
      component: _datanotes2.default,
      placeholder: ".vzb-tool-datanotes",
      model: ["state.marker", "locale"]
    }];

    //constructor is the same as any tool
    this._super(placeholder, external_model);
  },


  default_model: {
    state: {},
    ui: {
      chart: {
        labels: {
          dragging: true
        },
        lockNonSelected: 0,
        lockActive: 0,
        sizeSelectorActive: 0
      },
      datawarning: {
        doubtDomain: [],
        doubtRange: []
      },
      presentation: false
    }
  }
}); /*!
     * VIZABI LINECHART
     */

exports.default = Cartogram;

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _tool = __webpack_require__(15);

var _tool2 = _interopRequireDefault(_tool);

var _donutchartComponent = __webpack_require__(224);

var _donutchartComponent2 = _interopRequireDefault(_donutchartComponent);

var _timeslider = __webpack_require__(26);

var _timeslider2 = _interopRequireDefault(_timeslider);

var _dialogs = __webpack_require__(23);

var _dialogs2 = _interopRequireDefault(_dialogs);

var _buttonlist = __webpack_require__(22);

var _buttonlist2 = _interopRequireDefault(_buttonlist);

var _treemenu = __webpack_require__(27);

var _treemenu2 = _interopRequireDefault(_treemenu);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var comp_template = "barchart.html";

//BAR CHART TOOL
//extend the base Tool class and register it in Vizabi tools under a name 'DunutChart'
/*!
 * VIZABI BARCHART
 */

var DonutChart = _tool2.default.extend("DonutChart", {

  //Run when the tool is created
  init: function init(placeholder, external_model) {

    //Let's give it a name
    this.name = "donutchart";

    //Now we can specify components that should be included in the tool:
    this.components = [{
      //choose which component to use:
      //at this point you can check Vizabi.Component.getCollection() to see which components are available
      component: "donut",
      //these placeholdes are defined by the Tool prototype class
      placeholder: ".vzb-tool-viz",
      //component should have access to the following models:
      model: ["state.time", "state.marker"]
    }, {
      component: "timeslider",
      placeholder: ".vzb-tool-timeslider",
      model: ["state.time", "state.entities", "state.marker", "ui"]
    }];

    this._super(placeholder, external_model);
  },


  //provide the default options
  default_model: {
    state: {},
    ui: {
      presentation: false
    },
    locale: {}
  }
});

exports.default = DonutChart;

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _tool = __webpack_require__(15);

var _tool2 = _interopRequireDefault(_tool);

var _bubblemapComponent = __webpack_require__(225);

var _bubblemapComponent2 = _interopRequireDefault(_bubblemapComponent);

var _timeslider = __webpack_require__(26);

var _timeslider2 = _interopRequireDefault(_timeslider);

var _dialogs = __webpack_require__(23);

var _dialogs2 = _interopRequireDefault(_dialogs);

var _buttonlist = __webpack_require__(22);

var _buttonlist2 = _interopRequireDefault(_buttonlist);

var _treemenu = __webpack_require__(27);

var _treemenu2 = _interopRequireDefault(_treemenu);

var _datawarning = __webpack_require__(40);

var _datawarning2 = _interopRequireDefault(_datawarning);

var _datanotes = __webpack_require__(35);

var _datanotes2 = _interopRequireDefault(_datanotes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//BAR CHART TOOL
var LBubbleMap = _tool2.default.extend("LBubbleMap", {

  /**
   * Initializes the tool (Bar Chart Tool).
   * Executed once before any template is rendered.
   * @param {Object} placeholder Placeholder element for the tool
   * @param {Object} external_model Model as given by the external page
   */
  init: function init(placeholder, external_model) {

    this.name = "bubblemap";

    //specifying components
    this.components = [{
      component: _bubblemapComponent2.default,
      placeholder: ".vzb-tool-viz",
      model: ["state.time", "state.entities", "state.marker", "locale", "ui"] //pass models to component
    }, {
      component: _timeslider2.default,
      placeholder: ".vzb-tool-timeslider",
      model: ["state.time", "state.entities", "state.marker", "ui"]
    }, {
      component: _dialogs2.default,
      placeholder: ".vzb-tool-dialogs",
      model: ["state", "ui", "locale"]
    }, {
      component: _buttonlist2.default,
      placeholder: ".vzb-tool-buttonlist",
      model: ["state", "ui", "locale"]
    }, {
      component: _treemenu2.default,
      placeholder: ".vzb-tool-treemenu",
      model: ["state.marker", "state.marker_tags", "state.time", "locale"]
    }, {
      component: _datawarning2.default,
      placeholder: ".vzb-tool-datawarning",
      model: ["locale"]
    }, {
      component: _datanotes2.default,
      placeholder: ".vzb-tool-datanotes",
      model: ["state.marker", "locale"]
    }];
    //constructor is the same as any tool
    this._super(placeholder, external_model);
  },


  default_model: {
    state: {
      time: {
        "delay": 100,
        "delayThresholdX2": 50,
        "delayThresholdX4": 25
      },
      entities: {
        "opacitySelectDim": 0.3,
        "opacityRegular": 1
      }
    },
    locale: {},
    ui: {
      map: {
        path: null,
        colorGeo: false,
        preserveAspectRatio: true,
        mapEngine: "google",
        mapLayer: "terrain",
        topojsonLayer: true,
        bounds: {
          north: 37,
          west: -30,
          south: -39,
          east: 58
        },
        offset: {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0
        },
        projection: "mercator",
        topology: {
          path: null,
          objects: {
            geo: "countries",
            boundaries: "countries"
          },
          geoIdProperty: null
        }
      },
      chart: {
        labels: {
          dragging: true
        }
      },
      datawarning: {
        doubtDomain: [],
        doubtRange: []
      },
      presentation: false
    }
  }
}); /*!
     * VIZABI BUBBLEMAP
     */

exports.default = LBubbleMap;

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _tool = __webpack_require__(15);

var _tool2 = _interopRequireDefault(_tool);

var _linechartComponent = __webpack_require__(227);

var _linechartComponent2 = _interopRequireDefault(_linechartComponent);

var _timeslider = __webpack_require__(26);

var _timeslider2 = _interopRequireDefault(_timeslider);

var _dialogs = __webpack_require__(23);

var _dialogs2 = _interopRequireDefault(_dialogs);

var _buttonlist = __webpack_require__(22);

var _buttonlist2 = _interopRequireDefault(_buttonlist);

var _treemenu = __webpack_require__(27);

var _treemenu2 = _interopRequireDefault(_treemenu);

var _datawarning = __webpack_require__(40);

var _datawarning2 = _interopRequireDefault(_datawarning);

var _datanotes = __webpack_require__(35);

var _datanotes2 = _interopRequireDefault(_datanotes);

var _steppedspeedslider = __webpack_require__(49);

var _steppedspeedslider2 = _interopRequireDefault(_steppedspeedslider);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//LINE CHART TOOL
/*!
 * VIZABI LINECHART
 */

var LineChart = _tool2.default.extend("LineChart", {
  /**
   * Initialized the tool
   * @param {Object} placeholder Placeholder element for the tool
   * @param {Object} external_model Model as given by the external page
   */
  init: function init(placeholder, external_model) {

    this.name = "linechart";

    this.components = [{
      component: _linechartComponent2.default,
      placeholder: ".vzb-tool-viz",
      model: ["state.time", "state.entities", "state.marker", "locale", "ui"] //pass models to component
    }, {
      component: _timeslider2.default,
      placeholder: ".vzb-tool-timeslider",
      model: ["state.time", "state.entities", "state.marker", "ui"],
      ui: { show_value_when_drag_play: false, axis_aligned: true }
    }, {
      component: _dialogs2.default,
      placeholder: ".vzb-tool-dialogs",
      model: ["state", "ui", "locale"]
    }, {
      component: _buttonlist2.default,
      placeholder: ".vzb-tool-buttonlist",
      model: ["state", "ui", "locale"]
    }, {
      component: _treemenu2.default,
      placeholder: ".vzb-tool-treemenu",
      model: ["state.marker", "state.marker_tags", "state.time", "locale"]
    }, {
      component: _datawarning2.default,
      placeholder: ".vzb-tool-datawarning",
      model: ["locale"]
    }, {
      component: _datanotes2.default,
      placeholder: ".vzb-tool-datanotes",
      model: ["state.marker", "locale"]
    }, {
      component: _steppedspeedslider2.default,
      placeholder: ".vzb-tool-stepped-speed-slider",
      model: ["state.time", "locale"]
    }];

    this._super(placeholder, external_model);
  },


  default_model: {
    state: {
      time: {},
      marker: {
        axis_x: { allow: { scales: ["time"] } },
        axis_y: { allow: { scales: ["linear", "log"] } }
      }
    },
    locale: {},
    "ui": {
      "chart": {
        "labels": {
          "min_number_of_entities_when_values_hide": 2 //values hide when showing 2 entities or more
        },
        "whenHovering": {
          "hideVerticalNow": false,
          "showProjectionLineX": true,
          "showProjectionLineY": true,
          "higlightValueX": true,
          "higlightValueY": true,
          "showTooltip": false
        }
      },
      datawarning: {
        doubtDomain: [],
        doubtRange: []
      },
      "buttons": ["colors", "find", "show", "moreoptions", "fullscreen", "presentation"],
      "dialogs": {
        "popup": ["colors", "find", "show", "moreoptions"],
        "sidebar": ["colors", "show"],
        "moreoptions": ["opacity", "speed", "axes", "colors", "presentation", "about"]
      },
      "presentation": false
    }
  }

});

exports.default = LineChart;

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _tool = __webpack_require__(15);

var _tool2 = _interopRequireDefault(_tool);

var _mountainchartComponent = __webpack_require__(228);

var _mountainchartComponent2 = _interopRequireDefault(_mountainchartComponent);

var _timeslider = __webpack_require__(26);

var _timeslider2 = _interopRequireDefault(_timeslider);

var _dialogs = __webpack_require__(23);

var _dialogs2 = _interopRequireDefault(_dialogs);

var _buttonlist = __webpack_require__(22);

var _buttonlist2 = _interopRequireDefault(_buttonlist);

var _treemenu = __webpack_require__(27);

var _treemenu2 = _interopRequireDefault(_treemenu);

var _datawarning = __webpack_require__(40);

var _datawarning2 = _interopRequireDefault(_datawarning);

var _datanotes = __webpack_require__(35);

var _datanotes2 = _interopRequireDefault(_datanotes);

var _steppedspeedslider = __webpack_require__(49);

var _steppedspeedslider2 = _interopRequireDefault(_steppedspeedslider);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//MOUNTAIN CHART TOOL
var MountainChart = _tool2.default.extend("MountainChart", {

  /**
   * Initializes the tool (MountainChart Tool).
   * Executed once before any template is rendered.
   * @param {Object} placeholder Placeholder element for the tool
   * @param {Object} external_model Model as given by the external page
   */
  init: function init(placeholder, external_model) {

    this.name = "mountainchart";

    //specifying components
    this.components = [{
      component: _mountainchartComponent2.default,
      placeholder: ".vzb-tool-viz",
      model: ["state.time", "state.entities", "state.marker", "locale", "ui"] //pass models to component
    }, {
      component: _timeslider2.default,
      placeholder: ".vzb-tool-timeslider",
      model: ["state.time", "state.entities", "state.marker", "ui"]
    }, {
      component: _dialogs2.default,
      placeholder: ".vzb-tool-dialogs",
      model: ["state", "ui", "locale"]
    }, {
      component: _buttonlist2.default,
      placeholder: ".vzb-tool-buttonlist",
      model: ["state", "ui", "locale"]
    }, {
      component: _treemenu2.default,
      placeholder: ".vzb-tool-treemenu",
      model: ["state.marker", "state.marker_tags", "state.time", "locale"]
    }, {
      component: _datawarning2.default,
      placeholder: ".vzb-tool-datawarning",
      model: ["locale"]
    }, {
      component: _datanotes2.default,
      placeholder: ".vzb-tool-datanotes",
      model: ["state.marker", "locale"]
    }, {
      component: _steppedspeedslider2.default,
      placeholder: ".vzb-tool-stepped-speed-slider",
      model: ["state.time", "locale"]
    }];

    //constructor is the same as any tool
    this._super(placeholder, external_model);
  },


  default_model: {
    state: {
      time: {
        "delay": 100,
        "delayThresholdX2": 50,
        "delayThresholdX4": 25
      },
      "entities": {
        "opacitySelectDim": 0.3,
        "opacityRegular": 0.7
      }
    },
    locale: {},
    ui: {
      chart: {
        manualSortingEnabled: true,
        yMaxMethod: "latest",
        showProbeX: true,
        probeX: 1.85,
        xLogStops: [1, 2, 5],
        xPoints: 50
      },
      "buttons": ["colors", "find", "stack", "show", "moreoptions", "fullscreen", "presentation"],
      "dialogs": {
        "popup": ["colors", "find", "stack", "show", "moreoptions"],
        "sidebar": ["colors", "find", "stack"],
        "moreoptions": ["opacity", "speed", "stack", "axesmc", "colors", "presentation", "about"]
      },
      datawarning: {
        doubtDomain: [],
        doubtRange: []
      },
      presentation: false
    }
  }
});

exports.default = MountainChart;

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _requireAll = __webpack_require__(71);

var _requireAll2 = _interopRequireDefault(_requireAll);

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _tool = __webpack_require__(15);

var _tool2 = _interopRequireDefault(_tool);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _model = __webpack_require__(47);

var _model2 = _interopRequireDefault(_model);

var _reader = __webpack_require__(72);

var _reader2 = _interopRequireDefault(_reader);

var _events = __webpack_require__(46);

var _events2 = _interopRequireDefault(_events);

var _globals = __webpack_require__(34);

var _globals2 = _interopRequireDefault(_globals);

var _d = __webpack_require__(211);

var _d2 = _interopRequireDefault(_d);

var _d3 = __webpack_require__(212);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Vzb = function Vzb(name, placeholder, external_model) {
  var tool = _tool2.default.get(name);
  if (tool) {
    var t = new tool(placeholder, external_model);
    Vzb._instances[t._id] = t;
    return t;
  }
  utils.error('Tool "' + name + '" was not found.');
};

//stores reference to each tool on the page
Vzb._instances = {};
//stores global variables accessible by any tool or component
Vzb._globals = _globals2.default;

//TODO: clear all objects and intervals as well
//garbage collection
Vzb.clearInstances = function (id) {
  if (id) {
    Vzb._instances[id] = void 0;
  } else {
    for (var i in Vzb._instances) {
      Vzb._instances[i].clear();
    }
    Vzb._instances = {};
  }
};

//available readers = all
var readers = (0, _requireAll2.default)(__webpack_require__(477));

//register available readers
utils.forEach(readers, function (reader, name) {
  _reader2.default.register(name, reader);
});

var components = (0, _requireAll2.default)(__webpack_require__(473), 1);

//register available components
utils.forEach(components, function (component, name) {
  _component2.default.register(name, component);
});

//d3 addons

//import * as touchFixes from 'helpers/d3.touchFixes';

//d3 v3 -> v4

// Copies a variable number of methods from source to target.
d3.rebind = function (target, source) {
  var i = 1,
      method = void 0;
  var n = arguments.length;
  while (++i < n) {
    target[method = arguments[i]] = d3_rebind(target, source, source[method]);
  }return target;
};

// Method is assumed to be a standard D3 getter-setter:
// If passed with no arguments, gets the value.
// If passed with arguments, sets the value and returns the target.
function d3_rebind(target, source, method) {
  return function () {
    var value = method.apply(source, arguments);
    return value === source ? target : value;
  };
}

d3.scale = {};
d3.scale.linear = d3.scaleLinear;
d3.scale.sqrt = d3.scaleSqrt;
d3.scale.pow = d3.scalePow;
d3.scale.log = d3.scaleLog;
d3.scale.quantize = d3.scaleQuantize;
d3.scale.threshold = d3.scaleThreshold;
d3.scale.quantile = d3.scaleQuantile;
d3.scale.identity = d3.scaleIdentity;
d3.scale.ordinal = d3.scaleOrdinal;
d3.time = {};
d3.time.scale = d3.scaleTime;
d3.time.scale.utc = d3.scaleUtc;
d3.time.format = function (f) {
  var format = d3.timeFormat(f);
  format.parse = d3.timeParse(f);
  return format;
};
d3.time.format.utc = function (f) {
  var format = d3.utcFormat(f);
  format.parse = d3.utcParse(f);
  return format;
};
d3.time.format.iso = function (f) {
  var format = d3.isoFormat(f);
  format.parse = d3.isoParse(f);
  return format;
};
d3.round = function (x, n) {
  return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
};

d3.scale.genericLog = _d2.default;
d3.selection.prototype.onTap = _d3.onTap;
d3.selection.prototype.onLongTap = _d3.onLongTap;

//TODO: Fix for scroll on mobile chrome on d3 v3.5.17. It must be retested/removed on d3 v4.x.x
//see explanation here https://github.com/vizabi/vizabi/issues/2020#issuecomment-250205191
//d3.svg.brush = touchFixes.brush;
//d3.drag = touchFixes.drag;
//d3.behavior.zoom = touchFixes.zoom;

//makes all objects accessible
Vzb.Tool = _tool2.default;
Vzb.Component = _component2.default;
Vzb.Model = _model2.default;
Vzb.Reader = _reader2.default;
Vzb.Events = _events2.default;
Vzb.utils = utils;

exports.default = Vzb;

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

__webpack_require__(414);

__webpack_require__(471);

__webpack_require__(234);

if (global._babelPolyfill) {
  throw new Error("only one instance of babel-polyfill is allowed");
}
global._babelPolyfill = true;

var DEFINE_PROPERTY = "defineProperty";
function define(O, key, value) {
  O[key] || Object[DEFINE_PROPERTY](O, key, {
    writable: true,
    configurable: true,
    value: value
  });
}

define(String.prototype, "padLeft", "".padStart);
define(String.prototype, "padRight", "".padEnd);

"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
  [][key] && define(Array, key, Function.call.bind([][key]));
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(85)))

/***/ }),
/* 194 */
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),
/* 195 */,
/* 196 */,
/* 197 */,
/* 198 */,
/* 199 */,
/* 200 */,
/* 201 */,
/* 202 */,
/* 203 */,
/* 204 */,
/* 205 */,
/* 206 */,
/* 207 */,
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _class = __webpack_require__(16);

var _class2 = _interopRequireDefault(_class);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Intervals = _class2.default.extend({

  /**
   * Initializes intervals
   */
  init: function init() {
    this.intervals = {};
  },


  /**
   * Sets an interval
   * @param {String} name name of interval
   * @param {Function} func function to be executed
   * @param {Number} duration duration in milliseconds
   */
  setInterval: function (_setInterval) {
    function setInterval(_x, _x2, _x3) {
      return _setInterval.apply(this, arguments);
    }

    setInterval.toString = function () {
      return _setInterval.toString();
    };

    return setInterval;
  }(function (name, func, duration) {
    this.clearInterval(name);
    this.intervals[name] = setInterval(func, duration);
  }),


  /**
   * Clears an interval
   * @param {String} name name of interval to be removed
   */
  clearInterval: function (_clearInterval) {
    function clearInterval(_x4) {
      return _clearInterval.apply(this, arguments);
    }

    clearInterval.toString = function () {
      return _clearInterval.toString();
    };

    return clearInterval;
  }(function (name) {
    return name ? clearInterval(this.intervals[name]) : this.clearAllIntervals();
  }),


  /**
   * Clears all intervals
   */
  clearAllIntervals: function clearAllIntervals() {
    for (var i in this.intervals) {
      this.clearInterval(i);
    }
  }
});

exports.default = Intervals;

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = collisionResolver;
//d3.svg.collisionResolver

function collisionResolver() {
  return function collision_resolver() {
    var DURATION = 300;
    var labelHeight = {};
    var labelPosition = {};
    // MAINN FUNCTION. RUN COLLISION RESOLVER ON A GROUP g
    function resolver(g) {
      if (data == null) {
        console.warn("D3 collision resolver stopped: missing data to work with. Example: data = {asi: {valueY: 45, valueX: 87}, ame: {valueY: 987, valueX: 767}}");
        return;
      }
      if (selector == null) {
        console.warn("D3 collision resolver stopped: missing a CSS slector");
        return;
      }
      if (height == null) {
        console.warn("D3 collision resolver stopped: missing height of the canvas");
        return;
      }
      if (value == null) {
        console.warn("D3 collision resolver stopped: missing pointer within data objects. Example: value = 'valueY' ");
        return;
      }
      if (KEY == null) {
        console.warn("D3 collision resolver stopped: missing a key for data. Example: key = 'geo' ");
        return;
      }
      g.each(function (d, index) {
        labelHeight[d[KEY]] = d3.select(this).select(selector).node().getBBox().height;
      });
      labelPosition = resolver.calculatePositions(data, value, height, scale);
      //actually reposition the labels
      g.each(function (d, i) {
        if (!data[d[KEY]] || data[d[KEY]][fixed]) return;
        var resolvedY = labelPosition[d[KEY]] || scale(data[d[KEY]][value]) || 0;
        var resolvedX = null;
        if (handleResult != null) {
          handleResult(d, i, this, resolvedX, resolvedY);
          return;
        }
        d3.select(this).selectAll(selector).transition().duration(DURATION).attr("transform", "translate(0," + resolvedY + ")");
      });
    }

    // CALCULATE OPTIMIZED POSITIONS BASED ON LABELS' HEIGHT AND THEIR PROXIMITY (DELTA)
    resolver.calculatePositions = function (data, value, height, scale) {
      var result = {};
      var keys = Object.keys(data).sort(function (a, b) {
        return data[a][value] - data[b][value];
      });
      keys.forEach(function (d, index) {
        //initial positioning
        result[d] = scale(data[d][value]);
        // check the overlapping chain reaction all the way down
        for (var j = index; j > 0; j--) {
          // if overlap found shift the overlapped label downwards
          var _delta = result[keys[j - 1]] - result[keys[j]] - labelHeight[keys[j]];
          if (_delta < 0) result[keys[j - 1]] -= _delta;
          // if the chain reaction stopped because found some gap in the middle, then quit
          if (_delta > 0) break;
        }
      });
      // check if the lowest label is breaking the boundary...
      var delta = height - result[keys[0]] - labelHeight[keys[0]];
      // if it does, then
      if (delta < 0) {
        // shift the lowest up
        result[keys[0]] += delta;
        // check the overlapping chain reaction all the way up
        for (var j = 0; j < keys.length - 1; j++) {
          // if overlap found shift the overlapped label upwards
          delta = result[keys[j]] - result[keys[j + 1]] - labelHeight[keys[j + 1]];
          if (delta < 0) result[keys[j + 1]] += delta;
          // if the chain reaction stopped because found some gap in the middle, then quit
          if (delta > 0) break;
        }
      }
      return result;
    };
    // GETTERS AND SETTERS
    var data = null;
    resolver.data = function (arg) {
      if (!arguments.length) return data;
      data = arg;
      return resolver;
    };
    var selector = null;
    resolver.selector = function (arg) {
      if (!arguments.length) return selector;
      selector = arg;
      return resolver;
    };
    var height = null;
    resolver.height = function (arg) {
      if (!arguments.length) return height;
      height = arg;
      return resolver;
    };
    var scale = d3.scale.linear().domain([0, 1]).range([0, 1]);
    resolver.scale = function (arg) {
      if (!arguments.length) return scale;
      scale = arg;
      return resolver;
    };
    var value = null;
    resolver.value = function (arg) {
      if (!arguments.length) return value;
      value = arg;
      return resolver;
    };
    var fixed = null;
    resolver.fixed = function (arg) {
      if (!arguments.length) return fixed;
      fixed = arg;
      return resolver;
    };
    var handleResult = null;
    resolver.handleResult = function (arg) {
      if (!arguments.length) return handleResult;
      handleResult = arg;
      return resolver;
    };
    var KEY = null;
    resolver.KEY = function (arg) {
      if (!arguments.length) return KEY;
      KEY = arg;
      return resolver;
    };
    return resolver;
  }();
}

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = colorPicker;
//d3.svg.colorPicker


var instance = null;

function colorPicker() {

  return function getInstance() {
    if (instance == null) {
      instance = d3_color_picker();
    }
    return instance;
  }();

  function d3_color_picker() {
    // tuning defaults
    var nCellsH = 15;
    // number of cells by hues (angular)
    var minH = 0;
    // which hue do we start from: 0 to 1 instead of 0 to 365
    var nCellsL = 4;
    // number of cells by lightness (radial)
    var minL = 0.5;
    // which lightness to start from: 0 to 1. Recommended .3...0.5
    var satConstant = 0.7;
    // constant saturation for color wheel: 0 to 1. Recommended .7...0.8
    var outerL_display = 0.4;
    // ecxeptional saturation of the outer circle. the one displayed 0 to 1
    var outerL_meaning = 0.3;
    // ecxeptional saturation of the outer circle. the one actually ment 0 to 1
    var firstAngleSat = 0;
    // exceptional saturation at first angular segment. Set 0 to have shades of grey
    var minRadius = 15;
    //radius of the central hole in color wheel: px
    var maxWidth = 280;
    var maxHeight = 323;
    var margin = {
      top: 0.1,
      bottom: 0.1,
      left: 0.1,
      right: 0.1
    };
    //margins in % of container's width and height
    var colorOld = "#000";
    var colorDef = "#000";
    var colorWhite = "#f8f8f8";
    // names of CSS classes
    var css = {
      INVISIBLE: "vzb-invisible",
      COLOR_POINTER: "vzb-colorpicker-pointer",
      COLOR_BUTTON: "vzb-colorpicker-cell",
      COLOR_DEFAULT: "vzb-colorpicker-default",
      COLOR_SAMPLE: "vzb-colorpicker-sample",
      COLOR_PICKER: "vzb-colorpicker-svg",
      COLOR_CIRCLE: "vzb-colorpicker-circle",
      COLOR_CIRCLES: "vzb-colorpicker-circles",
      COLOR_SEGMENT: "vzb-colorpicker-segment",
      COLOR_BACKGR: "vzb-colorpicker-background"
    };
    var colorData = [];
    //here we store color data. formatted as follows:
    /*
     [
     [ // outer circle
     {display: "#123456", meaning: "#123456"}, // first angle
     ...
     {display: "#123456", meaning: "#123456"} // last angle, clockwise
     ],
     [ // next circle
     {display: "#123456", meaning: "#123456"}, // first angle
     ...
     {display: "#123456", meaning: "#123456"} // last angle, clockwise
     ],
      ...
      [ // inner circle
     {display: "#123456", meaning: "#123456"}, // first angle
     ...
     {display: "#123456", meaning: "#123456"} // last angle, clockwise
     ]
     ]
     */
    var arc = d3.arc();
    var pie = d3.pie().sort(null).value(function (d) {
      return 1;
    });
    var svg = null;
    var container = null;
    var colorPointer = null;
    var showColorPicker = false;
    var sampleRect = null;
    var sampleText = null;
    var background = null;
    var callback = function callback(value) {
      console.info("Color picker callback example. Setting color to " + value);
    };

    function _generateColorData() {
      var result = [];
      // loop across circles
      for (var l = 0; l < nCellsL; l++) {
        var lightness = minL + (1 - minL) / nCellsL * l;
        // new circle of cells
        result.push([]);
        // loop across angles
        for (var h = 0; h <= nCellsH; h++) {
          var hue = minH + (1 - minH) / nCellsH * h;
          // new cell
          result[l].push({
            display: _hslToRgb(hue, h == 0 ? firstAngleSat : satConstant, l == 0 ? outerL_display : lightness),
            meaning: _hslToRgb(hue, h == 0 ? firstAngleSat : satConstant, l == 0 ? outerL_meaning : lightness)
          });
        }
      }
      return result;
    }

    function _hslToRgb(h, s, l) {
      var r = void 0,
          g = void 0,
          b = void 0;
      if (s == 0) {
        r = g = b = l; // achromatic
      } else {
        var _hue2rgb = function _hue2rgb(p, q, t) {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1 / 6) return p + (q - p) * 6 * t;
          if (t < 1 / 2) return q;
          if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
          return p;
        };
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = _hue2rgb(p, q, h + 1 / 3);
        g = _hue2rgb(p, q, h);
        b = _hue2rgb(p, q, h - 1 / 3);
      }
      return "#" + Math.round(r * 255).toString(16) + Math.round(g * 255).toString(16) + Math.round(b * 255).toString(16);
    }

    // this is init function. call it once after you are satisfied with parameters tuning
    // container should be a D3 selection that has a div where we want to render color picker
    // that div should have !=0 width and height in its style
    function colorPicker(container) {
      colorPicker.container = container;
      svg = container.select("." + css.COLOR_PICKER);
      if (!svg.empty()) {
        return;
      }
      container.on("click", function () {
        colorPicker.show(false);
        d3.event.stopPropagation();
      });
      colorData = _generateColorData();

      svg = container.append("svg").style("position", "absolute").style("top", "0").style("left", "0").style("width", "100%").style("max-width", maxWidth + "px").style("height", "100%").style("max-height", maxHeight + "px").style("z-index", 9999).attr("class", css.COLOR_PICKER + " vzb-dialog-shadow").classed(css.INVISIBLE, !showColorPicker).on("mouseout", function (d) {
        _cellHover(colorOld);
      });

      var width = parseInt(svg.style("width"));
      var height = parseInt(svg.style("height"));
      var maxRadius = width / 2 * (1 - margin.left - margin.right);
      background = svg.append("rect").attr("width", width).attr("height", maxHeight).attr("class", css.COLOR_BUTTON + " " + css.COLOR_BACKGR).on("mouseover", function (d) {
        _cellHover(colorOld);
      });
      var circles = svg.append("g").attr("class", css.COLOR_CIRCLES).attr("transform", "translate(" + (maxRadius + width * margin.left) + "," + (maxRadius + height * margin.top) + ")");

      svg.append("rect").attr("class", css.COLOR_SAMPLE).attr("width", width / 2).attr("height", height * margin.top / 2);

      sampleRect = svg.append("rect").attr("class", css.COLOR_SAMPLE).attr("width", width / 2).attr("x", width / 2).attr("height", height * margin.top / 2);

      svg.append("text").attr("x", width * margin.left).attr("y", height * margin.top / 2).attr("dy", "1.3em").attr("class", css.COLOR_SAMPLE).style("text-anchor", "start");

      sampleText = svg.append("text").attr("x", width * (1 - margin.right)).attr("y", height * margin.top / 2).attr("dy", "1.3em").attr("class", css.COLOR_SAMPLE).style("text-anchor", "end");

      svg.append("text").attr("x", width * 0.1).attr("y", height * (1 - margin.bottom)).attr("dy", "1.2em").attr("class", "vzb-default-label").style("text-anchor", "start").text("default");

      svg.append("circle").attr("class", css.COLOR_DEFAULT + " " + css.COLOR_BUTTON).attr("r", width * margin.left / 2).attr("cx", width * margin.left * 1.5).attr("cy", height * (1 - margin.bottom * 1.5)).on("mouseover", function () {
        d3.select(this).style("stroke", "#444");
        _cellHover(colorDef);
      }).on("mouseout", function () {
        d3.select(this).style("stroke", "none");
      });

      circles.selectAll("." + css.COLOR_CIRCLE).data(colorData).enter().append("g").attr("class", css.COLOR_CIRCLE).each(function (circleData, index) {
        arc.outerRadius(minRadius + (maxRadius - minRadius) / nCellsL * (nCellsL - index)).innerRadius(minRadius + (maxRadius - minRadius) / nCellsL * (nCellsL - index - 1));
        var segment = d3.select(this).selectAll("." + css.COLOR_SEGMENT).data(pie(circleData)).enter().append("g").attr("class", css.COLOR_SEGMENT);

        segment.append("path").attr("class", css.COLOR_BUTTON).attr("d", arc).style("fill", function (d) {
          return d.data.display;
        }).style("stroke", function (d) {
          return d.data.display;
        }).on("mouseover", function (d) {
          _cellHover(d.data.meaning, this);
        }).on("mouseout", function (d) {
          _cellUnHover();
        });
      });

      circles.append("circle").attr("r", minRadius).attr("fill", colorWhite).attr("class", css.COLOR_BUTTON).on("mouseover", function () {
        d3.select(this).style("stroke", "#555");
        _cellHover(colorWhite);
      }).on("mouseout", function () {
        d3.select(this).style("stroke", "none");
      });

      colorPointer = circles.append("path").attr("class", css.COLOR_POINTER + " " + css.INVISIBLE);

      svg.selectAll("." + css.COLOR_BUTTON).on("click", function () {
        d3.event.stopPropagation();
        _this.show(false);
      });
      _doTheStyling(svg);
      colorPicker.resize(svg);
    }

    var _doTheStyling = function _doTheStyling(svg) {
      //styling
      svg.select("." + css.COLOR_BACKGR).style("fill", "white");

      svg.select("." + css.COLOR_POINTER).style("stroke-width", 2).style("stroke", colorWhite).style("pointer-events", "none").style("fill", "none");

      svg.selectAll("." + css.COLOR_BUTTON).style("cursor", "pointer");

      svg.selectAll("text").style("fill", "#D9D9D9").style("font-size", "0.7em").style("text-transform", "uppercase");

      svg.selectAll("circle." + css.COLOR_BUTTON).style("stroke-width", 2);
    };

    var _this = colorPicker;
    var _cellHover = function _cellHover(value, view) {
      // show color pointer if the view is set (a cell of colorwheel)
      if (view != null) colorPointer.classed(css.INVISIBLE, false).attr("d", d3.select(view).attr("d"));

      sampleRect.style("fill", value);
      sampleText.text(value);
      callback(value);
    };
    var _cellUnHover = function _cellUnHover() {
      colorPointer.classed(css.INVISIBLE, true);
    };
    //Use this function to hide or show the color picker
    //true = show, false = hide, "toggle" or TOGGLE = toggle
    var TOGGLE = "toggle";
    colorPicker.show = function (arg) {
      if (!arguments.length) return showColorPicker;
      if (svg == null) console.warn("Color picker is missing SVG element. Was init sequence performed?");
      showColorPicker = arg == TOGGLE ? !showColorPicker : arg;
      if (!showColorPicker) {
        callback = function callback() {};
      }
      svg.classed(css.INVISIBLE, !showColorPicker);
    };
    // getters and setters
    colorPicker.nCellsH = function (arg) {
      if (!arguments.length) return nCellsH;
      nCellsH = arg;
      return colorPicker;
    };
    colorPicker.minH = function (arg) {
      if (!arguments.length) return minH;
      minH = arg;
      return colorPicker;
    };
    colorPicker.nCellsL = function (arg) {
      if (!arguments.length) return nCellsL;
      nCellsL = arg;
      return colorPicker;
    };
    colorPicker.minL = function (arg) {
      if (!arguments.length) return minL;
      minL = arg;
      return colorPicker;
    };
    colorPicker.outerL_display = function (arg) {
      if (!arguments.length) return outerL_display;
      outerL_display = arg;
      return colorPicker;
    };
    colorPicker.outerL_meaning = function (arg) {
      if (!arguments.length) return outerL_meaning;
      outerL_meaning = arg;
      return colorPicker;
    };
    colorPicker.satConstant = function (arg) {
      if (!arguments.length) return satConstant;
      satConstant = arg;
      return colorPicker;
    };
    colorPicker.firstAngleSat = function (arg) {
      if (!arguments.length) return firstAngleSat;
      firstAngleSat = arg;
      return colorPicker;
    };
    colorPicker.minRadius = function (arg) {
      if (!arguments.length) return minRadius;
      minRadius = arg;
      return colorPicker;
    };
    colorPicker.margin = function (arg) {
      if (!arguments.length) return margin;
      margin = arg;
      return colorPicker;
    };
    colorPicker.callback = function (arg) {
      if (!arguments.length) return callback;
      callback = arg;
      return colorPicker;
    };
    colorPicker.colorDef = function (arg) {
      if (!arguments.length) return colorDef;
      if (typeof arg !== "undefined") {
        colorDef = arg;
      }
      if (svg == null) console.warn("Color picker is missing SVG element. Was init sequence performed?");
      svg.select("." + css.COLOR_DEFAULT).style("fill", colorDef);
      return colorPicker;
    };
    colorPicker.translate = function (translator) {
      if (translator instanceof Function) {
        svg.select(".vzb-default-label").text(translator("colorpicker/default"));
      }
      return colorPicker;
    };
    /**
     * @param {ClientRect} screen parent element
     * @param {int[]} arg [x,y] of color picker position
     */
    colorPicker.fitToScreen = function (arg) {
      var screen = colorPicker.container.node().getBoundingClientRect();
      var xPos = void 0,
          yPos = void 0;

      var width = parseInt(svg.style("width"));
      var height = parseInt(svg.style("height"));

      if (!arg) {
        xPos = screen.width - parseInt(svg.style("right")) - width;
        yPos = parseInt(svg.style("top"));
      } else {
        xPos = arg[0] - screen.left;
        yPos = arg[1] - screen.top;
      }

      var styles = { left: "" };
      if (screen.width * 0.8 <= width) {
        styles.right = (screen.width - width) * 0.5 + "px";
      } else if (xPos + width > screen.width) {
        styles.right = Math.min(screen.width * 0.1, 20) + "px";
      } else {
        styles.right = screen.width - xPos - width + "px";
      }
      if (styles.right) {
        svg.style("right", styles.right);
      }
      if (screen.height * 0.8 <= height) {
        styles.top = (screen.height - height) * 0.5 + "px";
      } else if (yPos + height * 1.2 > screen.height) {
        styles.top = screen.height * 0.9 - height + "px";
      } else {
        styles.top = yPos + "px";
      }
      if (styles.top) {
        svg.style("top", styles.top);
      }
      svg.style("left", styles.left);
      return colorPicker;
    };
    colorPicker.colorOld = function (arg) {
      if (!arguments.length) return colorOld;
      colorOld = arg;
      if (svg == null) console.warn("Color picker is missing SVG element. Was init sequence performed?");
      svg.select("rect." + css.COLOR_SAMPLE).style("fill", colorOld);
      svg.select("text." + css.COLOR_SAMPLE).text(colorOld);
      return colorPicker;
    };

    colorPicker.resize = function (arg) {

      if (!arguments.length) return resize;
      if (typeof arg !== "undefined") {
        var _svg = arg;
        var width = parseInt(_svg.style("width"));
        var height = parseInt(_svg.style("height"));
        var maxRadius = width / 2 * (1 - margin.left - margin.right);
        var selectedColor = _svg.select("." + css.COLOR_DEFAULT);
        var defaultLabel = _svg.select(".vzb-default-label");
        var circles = _svg.select("." + css.COLOR_CIRCLES);

        var hPos = maxRadius + height * margin.top;
        var hPosCenter = (1 + margin.top * 0.5) * height * 0.5;
        hPos = hPos > hPosCenter ? hPosCenter : hPos;
        circles.attr("transform", "translate(" + (maxRadius + width * margin.left) + "," + hPos + ")");
        selectedColor.attr("cx", width * margin.left * 1.5).attr("cy", height * (1 - margin.bottom * 1.5));
        defaultLabel.attr("x", width * 0.1).attr("y", height * (1 - margin.bottom));
      }
      colorPicker.fitToScreen();

      return colorPicker;
    };
    return colorPicker;
  }
}

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = genericLog;

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

//  d3.scale.genericLog
function genericLog() {
  return function d3_scale_genericLog(logScale) {
    var _this = this;
    var scales = [];
    var domainParts = [];
    var eps = 0.1;
    var delta = 5;
    var domain = logScale.domain();
    var range = logScale.range();
    var interpolator = null;
    var rangePointingForward = void 0,
        domainPointingForward = void 0;

    var abs = function abs(arg) {
      if (arg instanceof Array) return arg.map(function (d) {
        return Math.abs(d);
      });
      return Math.abs(arg);
    };

    var _buildLinearScale = function _buildLinearScale(fakeDomain, fakeRange) {
      return {
        domain: fakeDomain,
        sign: 1,
        range: fakeRange,
        scale: d3.scale.linear().domain(fakeDomain).range(fakeRange)
      };
    };

    var _buildLogScale = function _buildLogScale(fakeDomain, fakeRange, revertDomain) {
      var normalizedDomain = fakeDomain;
      //var normalizedRange = fakeRange.slice(0);
      if (revertDomain) {
        normalizedDomain = abs(fakeDomain);
        //fakeRange.reverse();
      }
      return {
        domain: fakeDomain,
        sign: revertDomain ? -1 : 1,
        range: fakeRange,
        scale: d3.scale.log().domain(normalizedDomain).range(fakeRange)
      };
    };

    var buildScales = function buildScales() {
      rangePointingForward = range[0] < range[range.length - 1];
      var rangePointingSign = rangePointingForward ? 1 : -1;
      scales = [];
      if (domainParts.length == 1) {
        if (domainParts[0][0] <= 0 && domainParts[0][1] >= 0) {
          scales = [_buildLinearScale(domainParts[0], range)];
        } else {
          scales = [_buildLogScale(domainParts[0], range, domainParts[0][0] <= 0)];
        }
      } else {
        var maxDomain = d3.max(abs(domain));
        var rangeLength = abs(d3.max(range) - d3.min(range));
        var rangePointKoef = 1;
        var firstRangePoint = 0,
            secondRangePoint = 0,
            firstEps = 0,
            secondEps = 0;
        logScale.domain([eps, maxDomain]).range([0, rangeLength]);
        var minRangePoint = delta; //logScale(eps * 2);
        if (domain[0] != 0 && abs(domain[0]) > eps) firstRangePoint = logScale(abs(domain[0]));
        if (domain[domain.length - 1] != 0 && abs(domain.length - 1) > eps) secondRangePoint = logScale(abs(domain[domain.length - 1]));

        if (abs(domain[0]) > eps) firstEps = minRangePoint;

        if (abs(domain[domain.length - 1]) > eps) secondEps = minRangePoint;

        rangeLength = rangeLength - firstEps - secondEps;
        if (secondRangePoint != 0) rangePointKoef = abs(firstRangePoint / secondRangePoint);

        var point1 = void 0,
            point2 = void 0;
        if (domainParts.length == 2) {
          // example: [-eps..0,eps][eps, val]
          if (domain[0] == 0 || abs(domain[0]) <= eps) {
            point1 = range[0] + firstRangePoint * rangePointKoef * rangePointingSign + secondEps * rangePointingSign;
            scales = [_buildLinearScale(domainParts[0], [range[0], point1]), _buildLogScale(domainParts[1], [point1, range[range.length - 1]], !domainPointingForward)];
          } else if (domain[domain.length - 1] == 0 || abs(domain[domain.length - 1]) <= eps) {
            // example: [-val,-eps][-eps, 0..eps]
            point1 = range[range.length - 1] - (firstEps + secondEps) * rangePointKoef * rangePointingSign;
            scales = [_buildLogScale(domainParts[0], [range[0], point1], domainPointingForward), _buildLinearScale(domainParts[1], [point1, range[range.length - 1]])];
          }
        } else {
          point1 = range[0] + rangeLength / (1 / rangePointKoef + 1) * rangePointingSign;
          point2 = range[0] + (rangeLength / (1 / rangePointKoef + 1) + firstEps + secondEps) * rangePointingSign;
          scales = [_buildLogScale(domainParts[0], [range[0], point1], domainPointingForward), _buildLinearScale(domainParts[1], [point1, point2]), _buildLogScale(domainParts[2], [point2, range[range.length - 1]], !domainPointingForward)];
        }
      }
    };

    var buildDomain = function buildDomain() {
      domainPointingForward = domain[0] < domain[domain.length - 1];
      domainParts = [];
      if (d3.min(domain) > 0 && d3.max(domain) > 0 || d3.min(domain) < 0 && d3.max(domain) < 0) {
        domainParts = [domain];
      } else {
        var start = void 0,
            end = void 0;
        if (domainPointingForward) {
          start = domain[0];
          end = domain[domain.length - 1];
        } else {
          start = domain[domain.length - 1];
          end = domain[0];
        }
        var _addSubdomain = function _addSubdomain(first, second) {
          if (domainPointingForward) {
            domainParts.push([first, second]);
          } else {
            domainParts.unshift([second, first]);
          }
        };
        while (start != end) {
          if (end <= -eps || start >= -eps && end <= eps || start >= eps) {
            _addSubdomain(start, end);
            start = end;
          } else if (start < -eps && end >= -eps) {
            _addSubdomain(start, -eps);
            start = -eps;
          } else if (start >= -eps && end >= eps) {
            _addSubdomain(start, eps);
            start = eps;
          } else {
            console.warn("Something wrong while build subdomains: " + start + " " + end);
            start = end;
          }
        }
      }
      buildScales();
    };

    var _getScaleByDomain = function _getScaleByDomain(x) {
      if (domainPointingForward) {
        if (x < domain[0]) {
          return scales[0];
        } else if (x > domain[domain.length - 1]) {
          return scales[scales.length - 1];
        }

        for (var i = 0; i < scales.length; i++) {
          if (x >= scales[i].domain[0] && x <= scales[i].domain[scales[i].domain.length - 1]) {
            return scales[i];
          }
        }
      } else {
        if (x > domain[0]) {
          return scales[0];
        } else if (x < domain[domain.length - 1]) {
          return scales[scales.length - 1];
        }

        for (var _i = 0; _i < scales.length; _i++) {
          if (x <= scales[_i].domain[0] && x >= scales[_i].domain[scales[_i].domain.length - 1]) {
            return scales[_i];
          }
        }
      }
    };

    var getScaleByRange = function getScaleByRange(x) {
      if (rangePointingForward) {
        if (x < range[0]) {
          return scales[0];
        } else if (x > range[range.length - 1]) {
          return scales[scales.length - 1];
        }

        for (var i = 0; i < scales.length; i++) {
          if (x >= scales[i].range[0] && x <= scales[i].range[scales[i].range.length - 1]) {
            return scales[i];
          }
        }
      } else {
        if (x > range[0]) {
          return scales[0];
        } else if (x < range[range.length - 1]) {
          return scales[scales.length - 1];
        }

        for (var _i2 = 0; _i2 < scales.length; _i2++) {
          if (x <= scales[_i2].range[0] && x >= scales[_i2].range[1]) {
            return scales[_i2];
          }
        }
      }
    };

    //polyfill for IE11
    Math.sign = Math.sign || function (x) {
      x = +x;
      if (x === 0 || isNaN(x)) {
        return x;
      }
      return x > 0 ? 1 : -1;
    };

    function scale(x) {
      var currScale = _getScaleByDomain(x);

      return interpolator ? interpolator(currScale.scale(x * currScale.sign)) : currScale.scale(x * currScale.sign);
    }

    scale.eps = function (arg) {
      if (!arguments.length) return eps;
      eps = arg;
      scale.domain(domain);
      return scale;
    };

    scale.delta = function (arg) {
      if (!arguments.length) return delta;
      delta = arg;
      scale.range(range);
      return scale;
    };

    scale.domain = function (arg) {
      if (!arguments.length) return domain;

      // this is an internal array, it will be modified. the input _arg should stay intact
      switch (arg.length) {
        // if no values are given, reset input to the default domain (do nothing)
        case 0:
          arg = domain;
          break;
        // use the given value as a center, get the domain /2 and *2 around it
        case 1:
          arg = [arg[0] / 2, arg[0] * 2];
          break;
      }
      //if the domain is just a single value
      if (arg[0] == arg[arg.length - 1]) {
        arg[0] /= 2;
        arg[arg.length - 1] = arg[arg.length - 1] * 2;
      }
      domain = arg;
      var min = d3.min(abs(domain).filter(function (val) {
        return !!val;
      }));
      if (min) eps = Math.min(eps, min / 100);
      buildDomain();
      return scale;
    };

    scale.range = function (arg, force) {
      if (!arguments.length) return interpolator ? interpolator.range() : range;

      switch (arg.length) {
        // reset input to the default range
        case 0:
          arg = range;
          break;
        // use the only value as a center, get the range ±100 around it
        case 1:
          arg = [arg[0] - 100, arg[0] + 100];
          break;
        // two is the standard case. do nothing
      }

      //console.log("LOG and LIN range:", logScale.range(), linScale.range());
      if (interpolator && !force) {
        interpolator.range(arg);
      } else {
        range = arg;
        var min = d3.min(abs(range).filter(function (val) {
          return !!val;
        }));

        if (min) delta = Math.min(delta, min / 100);
        buildScales();
      }
      return scale;
    };

    scale.interpolate = function (arg) {
      interpolator = d3.scale.linear().domain(domain).range(range).interpolate(arg);
      scale.range(interpolator.domain(), true);
      return scale;
    };

    scale.invert = function (arg) {
      var currScale = getScaleByRange(arg);
      return currScale.scale.invert(arg) * currScale.sign;
    };

    scale.ticks = function (arg) {
      var partTicks = void 0;
      var ticks = [];
      for (var i = 0; i < scales.length; i++) {
        if (scales[i].sign == -1) {
          partTicks = scales[i].scale.ticks().reverse().map(function (val) {
            return val * -1;
          });
        } else {
          partTicks = scales[i].scale.ticks();
        }
        if (ticks.length > 0 && partTicks.length > 0 && ticks[ticks.length - 1] == partTicks[0]) {
          partTicks.splice(0, 1);
        }
        ticks.push.apply(ticks, _toConsumableArray(partTicks));
      }
      return ticks;
    };

    scale.copy = function () {
      return d3_scale_genericLog(logScale).domain(domain).range(range).delta(delta).eps(eps);
    };

    return d3.rebind(scale, logScale, "base", "rangeRound", "clamp", "nice", "tickFormat");
  }(d3.scale.log().domain([0.1, 200]).range([0, 1000]));
}

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
function detectTouchEvent(element, onTap, onLongTap) {
  var start;
  var coordX;
  var coordY;
  var namespace = onTap ? '.onTap' : '.onLongTap';
  d3.select(element).on('touchstart' + namespace, function (d, i) {
    start = d3.event.timeStamp;
    coordX = d3.event.changedTouches[0].screenX;
    coordY = d3.event.changedTouches[0].screenY;
  }).on('touchend' + namespace, function (d, i) {
    coordX = Math.abs(coordX - d3.event.changedTouches[0].screenX);
    coordY = Math.abs(coordY - d3.event.changedTouches[0].screenY);
    if (coordX < 5 && coordY < 5) {
      if (d3.event.timeStamp - start < 500) return onTap ? onTap(d, i) : undefined;
      return onLongTap ? onLongTap(d, i) : undefined;
    } else return undefined;
  });
}

//d3.selection.prototype.onTap
var onTap = function onTap(callback) {
  return this.each(function () {
    detectTouchEvent(this, callback);
  });
};

//d3.selection.prototype.onLongTap
var onLongTap = function onLongTap(callback) {
  return this.each(function () {
    detectTouchEvent(this, null, callback);
  });
};

exports.default = {
  onTap: onTap,
  onLongTap: onLongTap
};
exports.onTap = onTap;
exports.onLongTap = onLongTap;

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _csv = __webpack_require__(152);

var _csv2 = _interopRequireDefault(_csv);

var _utils = __webpack_require__(1);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var CSVTimeInColumnsReader = _csv2.default.extend({

  _name: "csv-time_in_columns",

  init: function init(readerInfo) {
    this._super(readerInfo);
    this.timeKey = "time";
  },
  load: function load() {
    var _this = this;

    return this._super().then(function (_ref) {
      var data = _ref.data,
          columns = _ref.columns;

      var indicatorKey = columns[_this.keySize];

      var concepts = data.reduce(function (result, row) {
        Object.keys(row).forEach(function (concept) {
          concept = concept === indicatorKey ? row[indicatorKey] : concept;

          if (Number(concept) != concept && !result.includes(concept)) {
            result.push(concept);
          }
        });

        return result;
      }, []);
      concepts.splice(1, 0, _this.timeKey);

      var indicators = concepts.slice(2);

      var _concepts = _slicedToArray(concepts, 1),
          entityDomain = _concepts[0];

      return {
        columns: concepts,
        data: data.reduce(function (result, row) {
          var resultRows = result.filter(function (resultRow) {
            return resultRow[entityDomain] === row[entityDomain];
          });
          if (resultRows.length) {
            resultRows.forEach(function (resultRow) {
              resultRow[row[indicatorKey]] = row[resultRow[_this.timeKey]];
            });
          } else {
            Object.keys(row).forEach(function (key) {
              if (![entityDomain, indicatorKey].includes(key)) {
                var _Object$assign;

                result.push(Object.assign((_Object$assign = {}, _defineProperty(_Object$assign, entityDomain, row[entityDomain]), _defineProperty(_Object$assign, _this.timeKey, key), _Object$assign), indicators.reduce(function (result, indicator) {
                  result[indicator] = row[indicatorKey] === indicator ? row[key] : null;
                  return result;
                }, {})));
              }
            });
          }

          return result;
        }, [])
      };
    });
  }
});

exports.default = CSVTimeInColumnsReader;

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _reader = __webpack_require__(72);

var _reader2 = _interopRequireDefault(_reader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Inline Reader
 * the simplest reader possible
 */

var InlineReader = _reader2.default.extend({

  _name: "inline",

  init: function init(readerInfo) {
    this._data = readerInfo.data || [{}];
  },
  load: function load() {
    return Promise.resolve({
      columns: Object.keys(this._data[0]),
      data: this._data
    });
  }
});

exports.default = InlineReader;

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _d = __webpack_require__(41);

var _d2 = _interopRequireDefault(_d);

var _iconset = __webpack_require__(10);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/*!
 * VIZABI POP BY AGE Component
 */

//POP BY AGE CHART COMPONENT
var AgePyramid = _component2.default.extend({

  /**
   * Initializes the component (Bar Chart).
   * Executed once before any template is rendered.
   * @param {Object} config The config passed to the component
   * @param {Object} context The component's parent
   */
  init: function init(config, context) {
    this.name = "agepyramid";
    this.template = __webpack_require__(457);

    //define expected models for this component
    this.model_expects = [{
      name: "time",
      type: "time"
    }, {
      name: "marker",
      type: "model"
    }, {
      name: "entities",
      type: "entities"
    }, {
      name: "entities_side",
      type: "entities"
    }, {
      name: "locale",
      type: "locale"
    }, {
      name: "ui",
      type: "ui"
    }];

    var _this = this;
    this.model_binds = {
      "change:time.value": function changeTimeValue(evt) {
        if (!_this._readyOnce) return;
        if (_this.model.time.step != 1 && !_this.snapped && !_this.model.time.playing && !_this.model.time.dragging) {
          var next = d3.bisectLeft(_this.timeSteps, _this.model.time.value);
          if (next != 0 && _this.timeSteps[next] - _this.model.time.value) {
            _this.snapped = true;
            var time = _this.model.time.value;
            var prev = _this.timeSteps[next - 1];
            next = _this.timeSteps[next];
            var snapTime = time - prev < next - time ? prev : next;
            _this.model.time.value = new Date(snapTime);
          }
        }
        if (!_this.snapped) {
          if (_this.timeSteps.filter(function (t) {
            return t - _this.model.time.value == 0;
          }).length) {
            _this.model.marker.getFrame(_this.model.time.value, function (frame) {
              _this.frame = frame;
              _this.frameAxisX = frame.axis_x;
              _this._updateEntities();
              _this.updateBarsOpacity();
            });
          } else {
            var nextIndex = d3.bisectLeft(_this.timeSteps, _this.model.time.value);
            var prevFrameTime = _this.timeSteps[nextIndex - 1];
            var nextFrameTime = _this.timeSteps[nextIndex];
            var fraction = (_this.model.time.value - prevFrameTime) / (nextFrameTime - prevFrameTime);
            _this.model.marker.getFrame(nextFrameTime, function (nValues) {
              _this.model.marker.getFrame(prevFrameTime, function (pValues) {
                _this.frameAxisX = _this.interpolateDiagonal(pValues.axis_x, nValues.axis_x, fraction);
                _this._updateEntities();
                _this.updateBarsOpacity();
              });
            });
          }
        }
        _this.snapped = false;
      },
      "change:marker.select": function changeMarkerSelect(evt) {
        _this.someSelected = _this.model.marker.select.length > 0;
        _this.nonSelectedOpacityZero = false;
      },
      "change:marker.highlight": function changeMarkerHighlight(evt, path) {
        if (!_this._readyOnce) return;
        _this._highlightBars();
      },
      "change:marker.opacitySelectDim": function changeMarkerOpacitySelectDim() {
        _this.updateBarsOpacity();
      },
      "change:marker.opacityRegular": function changeMarkerOpacityRegular() {
        _this.updateBarsOpacity();
      },
      "change:marker.color.palette": function changeMarkerColorPalette(evt) {
        if (!_this._readyOnce) return;
        _this._updateEntities();
      },
      "change:marker.color.scaleType": function changeMarkerColorScaleType(evt) {
        if (!_this._readyOnce) return;
        _this._updateEntities();
      },
      "change:marker.side.which": function changeMarkerSideWhich(evt) {
        if (!_this._readyOnce) return;
        var sideDim = _this.model.marker.side.use == "constant" ? null : _this.model.marker.side.which;
        _this.model.marker.side.clearSideState();
        _this.model.entities_side.clearShow();
        _this.model.entities_side.set("dim", sideDim);
      },
      "change:entities.show": function changeEntitiesShow(evt) {
        if (!_this._readyOnce) return;
        if (_this.model.entities.dim === _this.model.entities_side.dim && !utils.isEmpty(_this.model.entities.show) && !utils.isEmpty(_this.model.entities_side.show)) {
          utils.forEach(_this.model.entities_side.getFilteredEntities(), function (s) {
            if (!_this.model.entities.isShown(s)) {
              _this.model.marker.side.clearSideState();
              _this.model.entities_side.showEntity(s);
            }
          });
        }
      },
      "change:entities_side.show": function changeEntities_sideShow(evt) {
        if (!_this._readyOnce) return;

        var doReturn = false;
        var _entitiesSameDimWithSide = null;
        utils.forEach(_this.model.marker.side._space, function (h) {
          if (h.dim === _this.model.entities_side.dim && h._name !== _this.model.entities_side._name) {
            _entitiesSameDimWithSide = h;
          }
        });
        if (_entitiesSameDimWithSide && !utils.isEmpty(_entitiesSameDimWithSide.show)) {
          utils.forEach(_this.model.entities_side.getFilteredEntities(), function (s) {
            if (!_entitiesSameDimWithSide.isShown(s)) {
              _entitiesSameDimWithSide.showEntity(s);
              doReturn = true;
            }
          });
        }
        if (doReturn) return;

        _this._updateIndicators();
        _this._updateLimits();
        _this.resize();
        _this._updateEntities();
      },
      "change:ui.chart.inpercent": function changeUiChartInpercent(evt) {
        if (!_this._readyOnce) return;
        _this._updateLimits();
        _this.resize();
        _this._updateEntities();
      },
      "change:ui.chart.flipSides": function changeUiChartFlipSides(evt) {
        if (!_this._readyOnce) return;
        _this.model.marker.side.switchSideState();
        _this._updateIndicators();
        _this.resize();
        _this._updateEntities();
      }
    };

    //contructor is the same as any component
    this._super(config, context);

    this.xScale = null;
    this.yScale = null;
    this.cScale = null;

    this.xAxis = (0, _d2.default)("bottom");
    this.xAxisLeft = (0, _d2.default)("bottom");
    this.yAxis = (0, _d2.default)("left");
    this.xScales = [];
    this.SHIFTEDAGEDIM = "s_age";

    this.totalFieldName = "Total";
  },


  // afterPreload: function() {
  //   var obj = {};
  //   obj["which"] = this.model.marker.axis_x.which;
  //   obj["use"] = this.model.marker.axis_x.use;
  //   this.model.marker_side.hook_total.set(obj);
  // },

  /**
   * DOM is ready
   */
  readyOnce: function readyOnce() {
    var _this = this;
    this.el = this.el ? this.el : d3.select(this.element);
    this.element = this.el;

    this.interaction = this._interaction();

    this.graph = this.element.select(".vzb-bc-graph");
    this.yAxisEl = this.graph.select(".vzb-bc-axis-y");
    this.xAxisEl = this.graph.select(".vzb-bc-axis-x");
    this.xAxisLeftEl = this.graph.select(".vzb-bc-axis-x-left");
    this.xTitleEl = this.element.select(".vzb-bc-axis-x-title");
    this.xInfoEl = this.element.select(".vzb-bc-axis-x-info");
    this.yTitleEl = this.graph.select(".vzb-bc-axis-y-title");
    this.barsCrop = this.graph.select(".vzb-bc-bars-crop");
    this.labelsCrop = this.graph.select(".vzb-bc-labels-crop");
    this.bars = this.graph.select(".vzb-bc-bars");
    this.labels = this.graph.select(".vzb-bc-labels");

    this.title = this.element.select(".vzb-bc-title");
    this.titleRight = this.element.select(".vzb-bc-title-right");
    this.year = this.element.select(".vzb-bc-year");

    this.on("resize", function () {
      _this._updateEntities();
    });

    this._attributeUpdaters = {
      _newWidth: function _newWidth(d, i) {
        d["x_"] = 0;
        var width = void 0;
        if (_this.stackSkip) {
          width = d[_this.PREFIXEDSIDEDIM] == d[_this.PREFIXEDSTACKDIM] ? _this.frameAxisX[d[_this.PREFIXEDSIDEDIM]][d[_this.AGEDIM] + _this.ageShift] : 0;
        } else if (_this.sideSkip) {
          width = _this.frameAxisX[d[_this.PREFIXEDSTACKDIM]][d[_this.AGEDIM] + _this.ageShift];
        } else {
          width = _this.frameAxisX[d[_this.PREFIXEDSTACKDIM]][d[_this.PREFIXEDSIDEDIM]][d[_this.AGEDIM] + _this.ageShift];
        }
        d["width_"] = width ? _this.xScale(width) : 0;
        if (_this.ui.chart.inpercent) {
          d["width_"] /= _this.total[d[_this.PREFIXEDSIDEDIM]];
        }
        return d.width_;
      },
      _newX: function _newX(d, i) {
        var prevSbl = this.previousSibling;
        if (prevSbl) {
          var prevSblDatum = d3.select(prevSbl).datum();
          d["x_"] = prevSblDatum.x_ + prevSblDatum.width_;
        } else {
          d["x_"] = 0;
        }
        return d.x_;
      }
    };
  },


  /*
   * Both model and DOM are ready
   */
  ready: function ready() {
    //TODO: get component ready if some submodel doesn't ready ??????
    if (!this.model.marker._ready) return;

    var _this = this;

    this.timeSteps = this.model.time.getAllSteps();

    this.shiftScale = d3.scale.linear().domain([this.timeSteps[0], this.timeSteps[this.timeSteps.length - 1]]).range([0, this.timeSteps.length - 1]);

    this.side = this.model.marker.label_side.getEntity();
    this.SIDEDIM = this.side.getDimension();
    this.PREFIXEDSIDEDIM = "side_" + this.SIDEDIM;
    this.stack = this.model.marker.label_stack.getEntity();
    this.STACKDIM = this.stack.getDimension() || this.model.marker.color.which;
    this.PREFIXEDSTACKDIM = "stack_" + this.STACKDIM;
    this.age = this.model.marker.axis_y.getEntity();
    this.AGEDIM = this.age.getDimension();
    this.TIMEDIM = this.model.time.getDimension();
    this.groupBy = this.age.grouping || 1;
    this.stackSkip = this.STACKDIM == this.SIDEDIM;
    this.sideSkip = _this.model.marker.side.use == "constant";
    this.updateUIStrings();
    this._updateIndicators();

    this.model.marker.getFrame(_this.model.time.value, function (frame) {
      _this.frame = frame;
      _this.frameAxisX = frame.axis_x;

      _this._createLimits();
      _this._updateLimits();
      //_this._createStepData(_this.model.marker.axis_x);

      _this.resize();
      _this._updateEntities(true);
      _this.updateBarsOpacity();
    });
  },
  interpolateDiagonal: function interpolateDiagonal(pValues, nValues, fraction) {
    var _this = this;
    var dataBetweenFrames = {};
    var data = void 0;
    var val1 = void 0,
        val2 = void 0,
        shiftedAge = void 0;
    var groupBy = this.groupBy;
    if (this.stackSkip) {
      utils.forEach(_this.sideKeys, function (side) {
        data = dataBetweenFrames[side] = {};
        utils.forEach(_this.ageKeys, function (age) {
          shiftedAge = +age + groupBy;
          val1 = pValues[side][age];
          val2 = nValues[side][shiftedAge] || 0;
          data[shiftedAge] = val1 == null || val2 == null ? null : val1 + (val2 - val1) * fraction;
        });
        data[0] = nValues[side][0] || 0;
      });
    } else if (this.sideSkip) {
      utils.forEach(_this.stackKeys, function (stack) {
        data = dataBetweenFrames[stack] = {};
        utils.forEach(_this.ageKeys, function (age) {
          shiftedAge = +age + groupBy;
          val1 = pValues[stack][age];
          val2 = nValues[stack][shiftedAge] || 0;
          data[shiftedAge] = val1 == null || val2 == null ? null : val1 + (val2 - val1) * fraction;
        });
        data[0] = nValues[stack][0] || 0;
      });
    } else {
      utils.forEach(_this.stackKeys, function (stack) {
        dataBetweenFrames[stack] = {};
        utils.forEach(_this.sideKeys, function (side) {
          data = dataBetweenFrames[stack][side] = {};
          utils.forEach(_this.ageKeys, function (age) {
            shiftedAge = +age + groupBy;
            val1 = pValues[stack][side][age];
            val2 = nValues[stack][side][shiftedAge] || 0;
            data[shiftedAge] = val1 == null || val2 == null ? null : val1 + (val2 - val1) * fraction;
          });
          data[0] = nValues[stack][side][0] || 0;
        });
      });
    }
    return dataBetweenFrames;
  },
  updateUIStrings: function updateUIStrings() {
    var _this = this;
    this.translator = this.model.locale.getTFunction();

    var titleStringX = this.model.marker.axis_x.getConceptprops().name;

    var xTitle = this.xTitleEl.selectAll("text").data([0]);
    xTitle.enter().append("text");
    xTitle.text(titleStringX).on("click", function () {
      _this.parent.findChildByName("gapminder-treemenu").markerID("axis_x").alignX(_this.model.locale.isRTL() ? "right" : "left").alignY("top").updateView().toggle();
    });

    utils.setIcon(this.xInfoEl, _iconset.question).select("svg").attr("width", "0px").attr("height", "0px");

    this.xInfoEl.on("click", function () {
      _this.parent.findChildByName("gapminder-datanotes").pin();
    });
    this.xInfoEl.on("mouseover", function () {
      if (_this.model.time.dragging) return;
      var rect = this.getBBox();
      var coord = utils.makeAbsoluteContext(this, this.farthestViewportElement)(rect.x - 10, rect.y + rect.height + 10);
      var toolRect = _this.root.element.getBoundingClientRect();
      var chartRect = _this.element.node().getBoundingClientRect();
      _this.parent.findChildByName("gapminder-datanotes").setHook("axis_x").show().setPos(coord.x + chartRect.left - toolRect.left, coord.y);
    });
    this.xInfoEl.on("mouseout", function () {
      if (_this.model.time.dragging) return;
      _this.parent.findChildByName("gapminder-datanotes").hide();
    });

    // var titleStringY = this.model.marker.axis_y.getConceptprops().name;

    // var yTitle = this.yTitleEl.selectAll("text").data([0]);
    // yTitle.enter().append("text");
    // yTitle
    //   .attr("y", "-6px")
    //   .attr("x", "-9px")
    //   .attr("dx", "-0.72em")
    //   .text(titleStringY);
  },


  /**
   * Changes labels for indicators
   */
  _updateIndicators: function _updateIndicators() {
    var _this2 = this;

    var _this = this;
    this.duration = this.model.time.delayAnimations;
    this.yScale = this.model.marker.axis_y.getScale();
    this.xScale = this.model.marker.axis_x.getScale();
    this.yAxis.tickFormat(_this.model.marker.axis_y.getTickFormatter());
    this.xAxis.tickFormat(_this.model.marker.axis_x.getTickFormatter());
    this.xAxisLeft.tickFormat(_this.model.marker.axis_x.getTickFormatter());

    var sideDim = this.SIDEDIM;
    var stackDim = this.STACKDIM;
    var ageDim = this.AGEDIM;
    var groupBy = this.groupBy;

    var ages = this.model.marker.getKeys(ageDim);
    var ageKeys = [];
    ageKeys = ages.map(function (m) {
      return m[ageDim];
    });
    this.ageKeys = ageKeys;

    this.shiftedAgeKeys = this.timeSteps.map(function (m, i) {
      return -i * groupBy;
    }).slice(1).reverse().concat(ageKeys);

    var sideItems = this.model.marker.label_side.getItems();
    //var sideKeys = Object.keys(sideItems);
    var sideKeys = [];
    if (!utils.isEmpty(sideItems)) {
      var sideFiltered = !!this.model.marker.side.getEntity().show[sideDim];
      var sides = this.model.marker.getKeys(sideDim).filter(function (f) {
        return !sideFiltered || _this2.model.marker.side.getEntity().isShown(f);
      });
      sideKeys = sides.map(function (m) {
        return m[sideDim];
      });

      if (sideKeys.length > 2) sideKeys.length = 2;
      if (sideKeys.length > 1) {
        var sortFunc = this.ui.chart.flipSides ? d3.ascending : d3.descending;
        sideKeys.sort(sortFunc);
      }
    }
    if (!sideKeys.length) sideKeys.push("undefined");
    this.sideKeys = sideKeys;

    var stacks = this.model.marker.getKeys(stackDim);
    var stackKeys = utils.without(stacks.map(function (m) {
      if (m[stackDim] == _this.totalFieldName) _this.dataWithTotal = true;
      return m[stackDim];
    }), this.totalFieldName);

    var sortedStackKeys = utils.keys(this.model.marker.color.getPalette()).reduce(function (arr, val) {
      if (stackKeys.indexOf(val) != -1) arr.push(val);
      return arr;
    }, []);

    if (sortedStackKeys.length != stackKeys.length) {
      sortedStackKeys = stackKeys.reduce(function (arr, val) {
        if (arr.indexOf(val) == -1) arr.push(val);
        return arr;
      }, sortedStackKeys);
    }
    this.stackKeys = sortedStackKeys;
    this.stackItems = this.model.marker.label_stack.getItems();

    this.stacked = this.ui.chart.stacked && this.model.marker.color.use != "constant" && this.stack.getDimension();

    this.twoSided = this.sideKeys.length > 1;
    this.titleRight.classed("vzb-hidden", !this.twoSided);
    if (this.twoSided) {
      this.xScaleLeft = this.xScale.copy();
      this.title.text(sideItems[this.sideKeys[1]]);
      this.titleRight.text(sideItems[this.sideKeys[0]]);
    } else {
      var title = this.sideKeys.length && sideItems[this.sideKeys[0]] ? sideItems[this.sideKeys[0]] : "";
      this.title.text(title);
    }

    this.cScale = this.model.marker.color.getScale();

    var shiftedAgeDim = this.SHIFTEDAGEDIM;
    this.markers = this.model.marker.getKeys(ageDim);
  },
  _createLimits: function _createLimits() {
    var _this = this;
    var axisX = this.model.marker.axis_x;

    var sideKeysNF = Object.keys(this.model.marker.side.getItems());
    if (!sideKeysNF.length) sideKeysNF.push("undefined");

    var keys = this.sideSkip ? [this.STACKDIM] : this.stackSkip ? [this.SIDEDIM] : [this.STACKDIM, this.SIDEDIM];
    var limits = axisX.getLimitsByDimensions(keys.concat([this.AGEDIM, this.TIMEDIM]));
    var timeKeys = axisX.getUnique();
    var totals = {};
    var inpercentMaxLimits = {};
    var maxLimits = {};
    sideKeysNF.forEach(function (s) {
      maxLimits[s] = [];
      inpercentMaxLimits[s] = [];
    });

    if (_this.sideSkip) {
      utils.forEach(timeKeys, function (time) {
        totals[time] = {};
        var ageSum = 0;
        var sideMaxLimits = [];
        utils.forEach(_this.ageKeys, function (age) {
          var stackSum = 0;
          utils.forEach(_this.stackKeys, function (stack) {
            if (limits[stack] && limits[stack][age] && limits[stack][age][time]) {
              stackSum += limits[stack][age][time].max;
              ageSum += stackSum;
            }
          });
          sideMaxLimits.push(stackSum);
        });
        totals[time][sideKeysNF[0]] = ageSum;
        var maxSideLimit = Math.max.apply(Math, sideMaxLimits);
        inpercentMaxLimits[sideKeysNF[0]].push(maxSideLimit / ageSum);
        maxLimits[sideKeysNF[0]].push(maxSideLimit);
      });
    } else if (_this.stackSkip) {
      utils.forEach(timeKeys, function (time) {
        totals[time] = {};
        utils.forEach(sideKeysNF, function (side) {
          var ageSum = 0;
          var sideMaxLimits = [];
          utils.forEach(_this.ageKeys, function (age) {
            var stackSum = 0;
            if (limits[side] && limits[side][age] && limits[side][age][time]) {
              stackSum += limits[side][age][time].max;
              ageSum += stackSum;
            }
            sideMaxLimits.push(stackSum);
          });
          totals[time][side] = ageSum;
          var maxSideLimit = Math.max.apply(Math, sideMaxLimits);
          inpercentMaxLimits[side].push(maxSideLimit / ageSum);
          maxLimits[side].push(maxSideLimit);
        });
      });
    } else {
      utils.forEach(timeKeys, function (time) {
        totals[time] = {};
        utils.forEach(sideKeysNF, function (side) {
          var ageSum = 0;
          var sideMaxLimits = [];
          utils.forEach(_this.ageKeys, function (age) {
            var stackSum = 0;
            utils.forEach(_this.stackKeys, function (stack) {
              if (limits[stack][side] && limits[stack][side][age] && limits[stack][side][age][time]) {
                stackSum += limits[stack][side][age][time].max;
                ageSum += stackSum;
              }
            });
            sideMaxLimits.push(stackSum);
          });
          totals[time][side] = ageSum;
          var maxSideLimit = Math.max.apply(Math, sideMaxLimits);
          inpercentMaxLimits[side].push(maxSideLimit / ageSum);
          maxLimits[side].push(maxSideLimit);
        });
      });
    }

    this.maxLimits = {};
    this.inpercentMaxLimits = {};
    sideKeysNF.forEach(function (s) {
      _this.maxLimits[s] = Math.max.apply(Math, _toConsumableArray(maxLimits[s]));
      _this.inpercentMaxLimits[s] = Math.max.apply(Math, _toConsumableArray(inpercentMaxLimits[s]));
    });
    this.totals = totals;
  },
  _updateLimits: function _updateLimits() {
    var _this = this;
    var axisX = this.model.marker.axis_x;
    var domain = void 0;
    if (this.ui.chart.inpercent) {
      domain = [0, Math.max.apply(Math, _toConsumableArray(this.sideKeys.map(function (s) {
        return _this.inpercentMaxLimits[s];
      })))];
    } else {
      domain = axisX.domainMin != null && axisX.domainMax != null ? [+axisX.domainMin, +axisX.domainMax] : [0, Math.max.apply(Math, _toConsumableArray(this.sideKeys.map(function (s) {
        return _this.maxLimits[s];
      })))];
    }
    this.xScale.domain(domain);
    if (this.xScaleLeft) this.xScaleLeft.domain(this.xScale.domain());
  },
  _interpolateBetweenTotals: function _interpolateBetweenTotals(timeSteps, totals, time) {
    var nextStep = d3.bisectLeft(timeSteps, time);
    var fraction = (time - timeSteps[nextStep - 1]) / (timeSteps[nextStep] - timeSteps[nextStep - 1]);
    var total = {};
    utils.forEach(this.sideKeys, function (side) {
      total[side] = totals[timeSteps[nextStep]][side] * fraction + totals[timeSteps[nextStep - 1]][side] * (1 - fraction);
    });
    return total;
  },


  /**
   * Updates entities
   */
  _updateEntities: function _updateEntities(reorder) {

    var _this = this;
    var time = this.model.time;
    var sideDim = this.SIDEDIM;
    var prefixedSideDim = this.PREFIXEDSIDEDIM;
    var ageDim = this.AGEDIM;
    var stackDim = this.STACKDIM;
    var prefixedStackDim = this.PREFIXEDSTACKDIM;
    var timeDim = this.TIMEDIM;
    var duration = time.playing ? time.delayAnimations : 0;
    var total = void 0;

    var groupBy = this.groupBy;
    //var group_offset = this.model.marker.group_offset ? Math.abs(this.model.marker.group_offset % groupBy) : 0;

    if (this.ui.chart.inpercent) {
      this.total = this.totals[time.value] ? this.totals[time.value] : this._interpolateBetweenTotals(this.timeSteps, this.totals, time.value);
    }

    var domain = this.yScale.domain();

    //this.model.age.setVisible(markers);

    var nextStep = d3.bisectLeft(this.timeSteps, time.value);

    var shiftedAgeDim = this.SHIFTEDAGEDIM;

    var markers = this.markers.map(function (data) {
      var o = {};
      o[ageDim] = o[shiftedAgeDim] = +data[ageDim];
      o[ageDim] -= nextStep * groupBy;
      return o;
    });

    var ageBars = markers.slice(0);

    var outAge = {};
    outAge[shiftedAgeDim] = markers.length * groupBy;
    outAge[ageDim] = outAge[shiftedAgeDim] - nextStep * groupBy;

    this.ageShift = nextStep * groupBy;

    if (nextStep) ageBars.push(outAge);

    this.entityBars = this.bars.selectAll(".vzb-bc-bar").data(ageBars, function (d) {
      return d[ageDim];
    });
    //exit selection
    this.entityBars.exit().remove();

    var oneBarHeight = this.oneBarHeight;
    var barHeight = this.barHeight;
    var firstBarOffsetY = this.firstBarOffsetY;

    //enter selection -- init bars
    this.entityBars = this.entityBars.enter().append("g").attr("class", function (d) {
      return "vzb-bc-bar " + "vzb-bc-bar-" + d[ageDim];
    }).attr("transform", function (d, i) {
      return "translate(0," + (firstBarOffsetY - (d[shiftedAgeDim] - domain[0] - groupBy) * oneBarHeight) + ")";
    }).merge(this.entityBars);

    // this.entityBars.attr("class", function(d) {
    //     return "vzb-bc-bar " + "vzb-bc-bar-" + d[ageDim];
    //   })


    this.sideBars = this.entityBars.selectAll(".vzb-bc-side").data(function (d) {
      return _this.sideKeys.map(function (m) {
        var r = {};
        r[ageDim] = d[ageDim];
        r[shiftedAgeDim] = d[shiftedAgeDim];
        r[prefixedSideDim] = m;
        r[sideDim] = m;
        return r;
      });
    }, function (d) {
      return d[prefixedSideDim];
    });

    this.sideBars.exit().remove();
    this.sideBars = this.sideBars.enter().append("g").attr("class", function (d, i) {
      return "vzb-bc-side " + "vzb-bc-side-" + (!i != !_this.twoSided ? "right" : "left");
    }).merge(this.sideBars);

    this.sideBars.attr("transform", function (d, i) {
      return i ? "scale(-1,1) translate(" + _this.activeProfile.centerWidth + ",0)" : "";
    });

    if (reorder) {
      this.sideBars.attr("transform", function (d, i) {
        return i ? "scale(-1,1) translate(" + _this.activeProfile.centerWidth + ",0)" : "";
      });
    }

    var _attributeUpdaters = this._attributeUpdaters;

    this.stackBars = this.sideBars.selectAll(".vzb-bc-stack").data(function (d, i) {
      var stacks = _this.stacked ? _this.stackKeys : [_this.totalFieldName];
      return stacks.map(function (m) {
        var r = {};
        r[ageDim] = d[ageDim];
        r[shiftedAgeDim] = d[shiftedAgeDim];
        r[sideDim] = d[sideDim];
        r[stackDim] = m;
        r[prefixedSideDim] = d[prefixedSideDim];
        r[prefixedStackDim] = m;
        return r;
      });
    }, function (d) {
      return d[prefixedStackDim];
    });

    this.stackBars.exit().remove();
    this.stackBars = this.stackBars.enter().append("rect").attr("class", function (d, i) {
      return "vzb-bc-stack " + "vzb-bc-stack-" + i + (_this.highlighted ? " vzb-dimmed" : "");
    }).attr("y", 0).attr("height", barHeight).attr("fill", function (d) {
      return _this.cScale(d[prefixedStackDim]);
    }).attr("width", _attributeUpdaters._newWidth).attr("x", _attributeUpdaters._newX).on("mouseover", _this.interaction.mouseover).on("mouseout", _this.interaction.mouseout).on("click", _this.interaction.click).onTap(_this.interaction.tap).merge(this.stackBars);

    if (reorder) this.stackBars.order();

    // this.stackBars = this.bars.selectAll('.vzb-bc-bar')
    //   .selectAll('.vzb-bc-side')
    //     .attr("transform", function(d, i) {
    //       return i ? ("scale(-1,1) translate(" + _this.activeProfile.centerWidth + ",0)") : "";
    //     })
    //   .selectAll('.vzb-bc-stack')
    //     .attr("height", barHeight)
    //     .attr("fill", function(d) {
    //       //return _this._temporaryBarsColorAdapter(values, d, ageDim);
    //       //return _this.cScale(values.color[d[ageDim]]);
    //       return _this.cScale(d[stackDim]);
    //     })
    //     //.attr("shape-rendering", "crispEdges") // this makes sure there are no gaps between the bars, but also disables anti-aliasing
    //     .each(function(d, i) {
    //       var total = _this.ui.chart.inpercent ? _this.totalValues[d[sideDim]] : 1;
    //       var sum = 0;
    //       if(shiftedValues[d[ageDim]]) {
    //         if(_this.stacked) {
    //           sum = shiftedValues[d[ageDim]][d[sideDim]][d[stackDim]];
    //         } else {
    //           var stacksData = shiftedValues[d[ageDim]][d[sideDim]];
    //           utils.forEach(stacksData, function(val) {
    //             sum += val;
    //           });
    //         }
    //       }
    //       //var prevWidth = +this.getAttribute("width");
    //       d["width_"] = _this.xScale(sum / total);
    //       //d3.select(this).classed("vzb-hidden", d["width_"] < 1 && prevWidth < 1);

    //       var prevSbl = this.previousSibling;
    //       if(prevSbl) {
    //         var prevSblDatum = d3.select(prevSbl).datum();
    //         d["x_"] = prevSblDatum.x_ + prevSblDatum.width_;
    //       } else {
    //         d["x_"] = 0;
    //       }
    //     });

    var stepShift = ageBars[0][shiftedAgeDim] - ageBars[0][ageDim] - this.shiftScale(time.value) * groupBy;

    if (duration) {
      var transition = d3.transition().duration(duration).ease(d3.easeLinear);

      this.entityBars.transition(transition).attr("transform", function (d, i) {
        return "translate(0," + (firstBarOffsetY - (d[shiftedAgeDim] - domain[0] - stepShift) * oneBarHeight) + ")";
      });
      this.stackBars.transition(transition).attr("width", _attributeUpdaters._newWidth).attr("x", _attributeUpdaters._newX);
    } else {
      this.entityBars.interrupt().attr("transform", function (d, i) {
        return "translate(0," + (firstBarOffsetY - (d[shiftedAgeDim] - domain[0] - stepShift) * oneBarHeight) + ")";
      });
      this.stackBars.interrupt().attr("width", _attributeUpdaters._newWidth).attr("x", _attributeUpdaters._newX);
    }

    this.entityLabels = this.labels.selectAll(".vzb-bc-label").data(markers);
    //exit selection
    this.entityLabels.exit().remove();

    this.entityLabels.enter().append("g").attr("class", "vzb-bc-label").attr("id", function (d) {
      return "vzb-bc-label-" + d[shiftedAgeDim] + "-" + _this._id;
    }).append("text").attr("class", "vzb-bc-age").merge(this.entityLabels).each(function (d, i) {
      var yearOlds = _this.translator("agepyramid/yearOlds");

      var age = parseInt(d[ageDim], 10);

      if (groupBy > 1) {
        age = age + "-to-" + (age + groupBy - 1);
      }

      d["text"] = age + yearOlds;
    }).attr("y", function (d, i) {
      return firstBarOffsetY - (d[shiftedAgeDim] - domain[0]) * oneBarHeight - 10;
    });
    // .style("fill", function(d) {
    //   var color = _this.cScale(values.color[d[ageDim]]);
    //   return d3.rgb(color).darker(2);
    // });

    if (duration) {
      this.year.transition().duration(duration).ease(d3.easeLinear).on("end", this._setYear(time.value));
    } else {
      this.year.interrupt().text(time.formatDate(time.value)).transition();
    }
  },
  _setYear: function _setYear(timeValue) {
    var formattedTime = this.model.time.formatDate(timeValue);
    return function () {
      d3.select(this).text(formattedTime);
    };
  },
  _interaction: function _interaction() {
    var _this = this;
    return {
      mouseover: function mouseover(d, i) {
        if (utils.isTouchDevice()) return;
        _this.model.marker.highlightMarker(d);
        _this._showLabel(d);
      },
      mouseout: function mouseout(d, i) {
        if (utils.isTouchDevice()) return;
        _this.model.marker.clearHighlighted();
      },
      click: function click(d, i) {
        if (utils.isTouchDevice()) return;
        _this.model.marker.selectMarker(d);
      },
      tap: function tap(d) {
        d3.event.stopPropagation();
        _this.model.marker.selectMarker(d);
      }
    };
  },
  _highlightBars: function _highlightBars(d) {
    var _this = this;

    _this.someHighlighted = _this.model.marker.highlight.length > 0;

    _this.updateBarsOpacity();

    if (!_this.someHighlighted) {
      //hide labels
      _this.labels.selectAll(".vzb-hovered").classed("vzb-hovered", false);
    }
  },
  _showLabel: function _showLabel(d) {
    var _this = this;
    var formatter = _this.ui.chart.inpercent ? d3.format(".1%") : _this.model.marker.axis_x.getTickFormatter();
    var sideDim = _this.SIDEDIM;
    var ageDim = _this.AGEDIM;
    var stackDim = _this.STACKDIM;
    var shiftedAgeDim = "s_age";

    var left = _this.sideKeys.indexOf(d[sideDim]);
    var label = _this.labels.select("#vzb-bc-label-" + d[shiftedAgeDim] + "-" + _this._id);
    label.selectAll(".vzb-bc-age").text(function (textData) {
      //var total = _this.ui.chart.inpercent ? _this.totalValues[d[sideDim]] : 1;
      var text = _this.stackKeys.length > 1 ? _this.stackItems[d[stackDim]] : textData.text;
      text = _this.twoSided ? text : textData.text + " " + _this.stackItems[d[stackDim]];
      var value = _this.xScale.invert(d["width_"]);
      //var value = (_this.dataWithTotal || _this.stacked) ? _this.values1.axis_x[d[shiftedAgeDim]][d[sideDim]][d[stackDim]] / total : _this.xScale.invert(d["width_"]);
      return text + ": " + formatter(value);
    }).attr("x", (left ? -1 : 1) * (_this.activeProfile.centerWidth * 0.5 + 7)).classed("vzb-text-left", left);

    label.classed("vzb-hovered", true);
  },


  /**
   * Executes everytime the container or vizabi is resized
   * Ideally,it contains only operations related to size
   */

  presentationProfileChanges: {
    medium: {
      margin: { right: 80, bottom: 80 },
      infoElHeight: 32
    },
    large: {
      margin: { top: 100, right: 100, left: 100, bottom: 80 },
      infoElHeight: 32
    }
  },

  profiles: {
    "small": {
      margin: {
        top: 70,
        right: 20,
        left: 40,
        bottom: 40
      },
      infoElHeight: 16,
      minRadius: 2,
      maxRadius: 40,
      centerWidth: 2,
      titlesSpacing: 5
    },
    "medium": {
      margin: {
        top: 80,
        right: 60,
        left: 60,
        bottom: 40
      },
      infoElHeight: 20,
      minRadius: 3,
      maxRadius: 60,
      centerWidth: 2,
      titlesSpacing: 10
    },
    "large": {
      margin: {
        top: 100,
        right: 60,
        left: 60,
        bottom: 40
      },
      infoElHeight: 22,
      minRadius: 4,
      maxRadius: 80,
      centerWidth: 2,
      titlesSpacing: 20
    }
  },

  resize: function resize() {

    var _this = this;

    this.activeProfile = this.getActiveProfile(this.profiles, this.presentationProfileChanges);

    //this.activeProfile = this.profiles[this.getLayoutProfile()];
    var margin = this.activeProfile.margin;
    var infoElHeight = this.activeProfile.infoElHeight;

    //stage
    this.height = parseInt(this.element.style("height"), 10) - margin.top - margin.bottom || 0;
    this.width = parseInt(this.element.style("width"), 10) - margin.left - margin.right || 0;

    if (this.height <= 0 || this.width <= 0) return utils.warn("Pop by age resize() abort: vizabi container is too little or has display:none");

    this.graph.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    this.barsCrop.attr("width", this.width).attr("height", Math.max(0, this.height));

    this.labelsCrop.attr("width", this.width).attr("height", Math.max(0, this.height));

    var groupBy = this.groupBy;

    var domain = this.yScale.domain();
    this.oneBarHeight = this.height / (domain[1] - domain[0]);
    var barHeight = this.barHeight = this.oneBarHeight * groupBy; // height per bar is total domain height divided by the number of possible markers in the domain
    this.firstBarOffsetY = this.height - this.barHeight;

    if (this.stackBars) this.stackBars.attr("height", barHeight);

    if (this.sideBars) this.sideBars.attr("transform", function (d, i) {
      return i ? "scale(-1,1) translate(" + _this.activeProfile.centerWidth + ",0)" : "";
    });

    //update scales to the new range
    if (this.model.marker.axis_y.scaleType !== "ordinal") {
      this.yScale.range([this.height, 0]);
    } else {
      this.yScale.rangePoints([this.height, 0]).range();
    }

    var maxRange = this.twoSided ? (this.width - this.activeProfile.centerWidth) * 0.5 : this.width;

    if (this.model.marker.axis_x.scaleType !== "ordinal") {
      this.xScale.range([0, maxRange]);
    } else {
      this.xScale.rangePoints([0, maxRange]).range();
    }

    //apply scales to axes and redraw
    this.yAxis.scale(this.yScale).tickSizeInner(-this.width).tickSizeOuter(0).tickPadding(6).tickSizeMinor(-this.width, 0).labelerOptions({
      scaleType: this.model.marker.axis_y.scaleType,
      toolMargin: margin,
      limitMaxTickNumber: 19
    });

    var format = this.ui.chart.inpercent ? d3.format((groupBy > 3 ? "" : ".1") + "%") : this.model.marker.axis_x.getTickFormatter();

    this.xAxis.scale(this.xScale).tickFormat(format).tickSizeInner(-this.height).tickSizeOuter(0).tickPadding(6).tickSizeMinor(-this.height, 0).labelerOptions({
      scaleType: this.model.marker.axis_x.scaleType,
      toolMargin: margin,
      limitMaxTickNumber: 6
    });

    var translateX = this.twoSided ? (this.width + _this.activeProfile.centerWidth) * 0.5 : 0;

    this.xAxisEl.attr("transform", "translate(" + translateX + "," + this.height + ")").call(this.xAxis);

    this.yAxisEl.attr("transform", "translate(" + 0 + ",0)").call(this.yAxis);
    //this.xAxisEl.call(this.xAxis);
    this.xAxisLeftEl.classed("vzb-hidden", !this.twoSided);
    if (this.twoSided) {
      if (this.model.marker.axis_x.scaleType !== "ordinal") {
        this.xScaleLeft.range([(this.width - this.activeProfile.centerWidth) * 0.5, 0]);
      } else {
        this.xScaleLeft.rangePoints([(this.width - this.activeProfile.centerWidth) * 0.5, 0]).range();
      }

      this.xAxisLeft.scale(this.xScaleLeft).tickFormat(format).tickSizeInner(-this.height).tickSizeOuter(0).tickPadding(6).tickSizeMinor(-this.height, 0).labelerOptions({
        scaleType: this.model.marker.axis_x.scaleType,
        toolMargin: margin,
        limitMaxTickNumber: 6
      });

      this.xAxisLeftEl.attr("transform", "translate(0," + this.height + ")").call(this.xAxisLeft);
      var zeroTickEl = this.xAxisEl.select(".tick text");
      if (!zeroTickEl.empty()) {
        var zeroTickWidth = zeroTickEl.node().getBBox().width;
        zeroTickEl.attr("dx", -(this.activeProfile.centerWidth + zeroTickWidth) * 0.5);
      }
    }

    var isRTL = this.model.locale.isRTL();

    this.bars.attr("transform", "translate(" + translateX + ",0)");
    this.labels.attr("transform", "translate(" + translateX + ",0)");

    this.title.attr("x", margin.left + (this.twoSided ? translateX - this.activeProfile.titlesSpacing : 0)).style("text-anchor", this.twoSided ? "end" : "").attr("y", margin.top * 0.7);
    this.titleRight.attr("x", margin.left + translateX + this.activeProfile.titlesSpacing).attr("y", margin.top * 0.7);

    this.xTitleEl.style("font-size", infoElHeight + "px").attr("transform", "translate(" + (isRTL ? this.width : margin.left * 0.4) + "," + margin.top * 0.4 + ")");
    // this.xTitleEl.select("text")
    //   .attr('x', margin.left / 2)
    //   .attr('y', margin.top / 2);

    if (this.xInfoEl.select("svg").node()) {
      var titleBBox = this.xTitleEl.node().getBBox();
      var t = utils.transform(this.xTitleEl.node());
      var hTranslate = isRTL ? titleBBox.x + t.translateX - infoElHeight * 1.4 : titleBBox.x + t.translateX + titleBBox.width + infoElHeight * 0.4;

      this.xInfoEl.select("svg").attr("width", infoElHeight + "px").attr("height", infoElHeight + "px");
      this.xInfoEl.attr("transform", "translate(" + hTranslate + "," + (t.translateY - infoElHeight * 0.8) + ")");
    }

    this.year.attr("x", this.width + margin.left).attr("y", margin.top * 0.4);
  },
  updateBarsOpacity: function updateBarsOpacity(duration) {
    var _this = this;
    //if(!duration)duration = 0;

    var OPACITY_HIGHLT = 1.0;
    var OPACITY_HIGHLT_DIM = this.model.marker.opacityHighlightDim;
    var OPACITY_SELECT = this.model.marker.opacityRegular;
    var OPACITY_REGULAR = this.model.marker.opacityRegular;
    var OPACITY_SELECT_DIM = this.model.marker.opacitySelectDim;

    this.stackBars
    //.transition().duration(duration)
    .style("opacity", function (d) {

      if (_this.someHighlighted) {
        //highlight or non-highlight
        if (_this.model.marker.isHighlighted(d)) return OPACITY_HIGHLT;
      }

      if (_this.someSelected) {
        //selected or non-selected
        return _this.model.marker.isSelected(d) ? OPACITY_SELECT : OPACITY_SELECT_DIM;
      }

      if (_this.someHighlighted) return OPACITY_HIGHLT_DIM;

      return OPACITY_REGULAR;
    });

    var nonSelectedOpacityZero = _this.model.marker.opacitySelectDim < 0.01;

    // when pointer events need update...
    if (nonSelectedOpacityZero != this.nonSelectedOpacityZero) {
      this.stackBars.style("pointer-events", function (d) {
        return !_this.someSelected || !nonSelectedOpacityZero || _this.model.marker.isSelected(d) ? "visible" : "none";
      });
    }

    this.nonSelectedOpacityZero = _this.model.marker.opacitySelectDim < 0.01;
  }
});

exports.default = AgePyramid;

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _d = __webpack_require__(41);

var _d2 = _interopRequireDefault(_d);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//BAR CHART COMPONENT
var AxisLabelerComponent = _component2.default.extend({

  /**
   * Initializes the component (Bar Chart).
   * Executed once before any template is rendered.
   * @param {Object} config The options passed to the component
   * @param {Object} context The component's parent
   */
  init: function init(config, context) {
    this.name = "axislabeler";
    this.template = __webpack_require__(458);

    //define expected models for this component
    this.model_expects = [{ name: "scales" }, { name: "show" }];

    var _this = this;

    this.model_binds = {
      "change:scales": function changeScales(evt) {
        _this.initScales();
        _this.update();
      },
      "change:show": function changeShow(evt, path) {
        _this.initScales();
        _this.update();
      }
    };

    //contructor is the same as any component
    this._super(config, context);

    this.xScale = null;
    this.yScale = null;

    this.xAxis = (0, _d2.default)("bottom");
    this.yAxis = (0, _d2.default)("left");
  },


  /**
   * DOM is ready
   */
  readyOnce: function readyOnce() {
    var _this = this;
    this.element = d3.select(this.element);

    // reference elements
    this.graph = this.element.select(".vzb-al-graph");
    this.xAxisEl = this.graph.select(".vzb-al-axis-x");
    this.yAxisEl = this.graph.select(".vzb-al-axis-y");

    //$(".vzb-bc-axis-x, .vzb-bc-axis-y").css('font-size',this.model.show.labelSize);
    this.xInvert = function (d) {
      return _this.xScale(_this.xScale.invert(_this.xScale(d)));
    };
    this.yInvert = function (d) {
      return _this.yScale(_this.yScale.invert(_this.yScale(d)));
    };

    this.line = d3.svg.line().x(function (d) {
      return _this.xScale(d);
    }).y(function (d) {
      return _this.yScale(d);
    });

    this.lineInvert = d3.svg.line().x(function (d) {
      return _this.xInvert(d);
    }).y(function (d) {
      return _this.yInvert(d);
    });

    //component events
    this.on("resize", function () {
      _this.update();
    });
  },


  /*
   * Both model and DOM are ready
   */
  ready: function ready() {
    console.log("Model ready");
    this.initScales();
    this.update();
  },
  initScales: function initScales() {
    var _this = this;

    var domain = this.model.scales.domain;

    this.xScale = d3.scale[this.model.scales.xScaleType]();
    this.yScale = d3.scale[this.model.scales.yScaleType]();

    this.xScale.domain(domain);

    this.yScale.domain(domain);

    this.mockData = d3.range(domain[0], domain[domain.length - 1], (domain[domain.length - 1] - domain[0]) / 10000);
    this.mockData.push(domain[domain.length - 1]);
  },
  update: function update() {
    var _this = this;

    var margin = this.model.show.toolMargin.getPlainObject();

    //stage
    var height = parseInt(this.element.style("height"), 10) - margin.top - margin.bottom || 0;
    var width = parseInt(this.element.style("width"), 10) - margin.left - margin.right || 0;

    if (height <= 0 || width <= 0) return utils.warn("Axis Labeler update() call interrupted for Vizabi container is too little or has display:none");

    //graph group is shifted according to margins (while svg element is at 100 by 100%)
    this.graph.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    //update scales to the new range
    var xLength = this.xScale.domain().length;
    var yLength = this.yScale.domain().length;
    this.xScale.range(d3.range(xLength).map(function (n) {
      return width / (xLength - 1) * n;
    })); //.nice();
    this.yScale.range(d3.range(yLength).map(function (n) {
      return height / (yLength - 1) * n;
    }).reverse()); //.nice();

    this.xAxis.scale(this.xScale).tickSize(6, 0).tickSizeMinor(3, 0).labelerOptions({
      scaleType: this.model.scales.xScaleType,
      toolMargin: margin
    });

    this.yAxis.scale(this.yScale).tickSize(6, 0).tickSizeMinor(3, 0).labelerOptions({
      scaleType: this.model.scales.yScaleType,
      toolMargin: margin
    });

    this.xAxisEl.attr("transform", "translate(0," + height + ")");
    this.xAxisEl.call(this.xAxis);
    this.yAxisEl.call(this.yAxis);

    //TODO: remove. make font sizing through plain CSS
    //this.xAxisEl.selectAll("text").style('font-size',this.model.show.labelSize);
    //this.yAxisEl.selectAll("text").style('font-size',this.model.show.labelSize);


    var path = this.graph.selectAll(".vzb-al-line").data([0]);
    path.enter().append("path").attr("class", "vzb-al-line");
    path.datum(this.mockData).attr("d", this.line);

    var pathInvert = this.graph.selectAll(".vzb-al-line-invert").data([0]);
    pathInvert.enter().append("path").attr("class", "vzb-al-line-invert");
    pathInvert.datum(this.mockData).attr("d", this.lineInvert);

    var format = d3.format(".4r");

    var dots = this.graph.selectAll(".vzb-al-dots").data(this.mockData);
    dots.enter().append("circle").attr("class", "vzb-al-dots").attr("r", 5).on("mouseenter", function (d, i) {
      console.log("Point #" + i + ": " + d + " x=" + format(_this.xScale(d)) + " y=" + format(_this.yScale(d)));
    });
    dots.exit().remove();
    dots.attr("cx", function (d) {
      return _this.xScale(d);
    }).attr("cy", function (d) {
      return _this.yScale(d);
    });

    var dotsInvert = this.graph.selectAll(".vzb-al-dots-invert").data(this.mockData);
    dotsInvert.enter().append("circle").attr("class", "vzb-al-dots-invert").attr("r", 5).on("mouseenter", function (d, i) {
      console.log("Point #" + i + ": " + d + " x=" + format(_this.xScale(d)) + " y=" + format(_this.yScale(d)));
    });
    dotsInvert.exit().remove();
    dotsInvert.attr("cx", function (d) {
      return _this.xInvert(d);
    }).attr("cy", function (d) {
      return _this.yInvert(d);
    });
  }
});

exports.default = AxisLabelerComponent;

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _d = __webpack_require__(41);

var _d2 = _interopRequireDefault(_d);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//BAR CHART COMPONENT
var BarComponent = _component2.default.extend({

  /**
   * Initializes the component (Bar Chart).
   * Executed once before any template is rendered.
   * @param {Object} config The options passed to the component
   * @param {Object} context The component's parent
   */
  init: function init(config, context) {
    this.name = "barchart";
    this.template = __webpack_require__(459);

    //define expected models for this component
    this.model_expects = [{
      name: "time",
      type: "time"
    }, {
      name: "entities",
      type: "entities"
    }, {
      name: "marker",
      type: "model"
    }, {
      name: "locale",
      type: "locale"
    }];

    var _this = this;

    this.model_binds = {
      "change:time.value": function changeTimeValue(evt) {
        _this.model.marker.getFrame(_this.model.time.value, function (values) {
          _this.values = values;
          _this.updateEntities();
        });
      },
      "change:marker": function changeMarker(evt, path) {
        if (!_this._readyOnce) return;
        if (path.indexOf("color.palette") > -1) return;
        if (path.indexOf("which") > -1 || path.indexOf("use") > -1) return;

        _this.ready();
      },
      "change:marker.color.palette": utils.debounce(function (evt) {
        if (!_this._readyOnce) return;
        _this.updateEntities();
      }, 200)
    };

    //contructor is the same as any component
    this._super(config, context);

    this.xScale = null;
    this.yScale = null;
    this.cScale = d3.scale.category10();

    this.xAxis = (0, _d2.default)("bottom");
    this.yAxis = (0, _d2.default)("left");
  },


  /**
   * DOM is ready
   */
  readyOnce: function readyOnce() {
    this.element = d3.select(this.element);

    this.graph = this.element.select(".vzb-bc-graph");
    this.yAxisEl = this.graph.select(".vzb-bc-axis-y");
    this.xAxisEl = this.graph.select(".vzb-bc-axis-x");
    this.yTitleEl = this.graph.select(".vzb-bc-axis-y-title");
    this.xTitleEl = this.graph.select(".vzb-bc-axis-x-title");
    this.bars = this.graph.select(".vzb-bc-bars");
    this.year = this.element.select(".vzb-bc-year");

    var _this = this;
    this.on("resize", function () {
      _this.updateEntities();
    });
  },


  /*
   * Both model and DOM are ready
   */
  ready: function ready() {
    var _this = this;
    this.model.marker.getFrame(this.model.time.value, function (values) {
      _this.values = values;
      _this.updateIndicators();
      _this.resize();
      _this.updateEntities();
    });
  },


  /**
   * Changes labels for indicators
   */
  updateIndicators: function updateIndicators() {

    var _this = this;
    this.translator = this.model.locale.getTFunction();
    this.duration = this.model.time.delayAnimations;

    var titleStringY = this.translator("indicator/" + this.model.marker.axis_y.which);
    var titleStringX = this.translator("indicator/" + this.model.marker.axis_x.which);

    var yTitle = this.yTitleEl.selectAll("text").data([0]);
    yTitle.enter().append("text");
    yTitle.attr("y", "-6px").attr("x", "-9px").attr("dx", "-0.72em").text(titleStringY).on("click", function () {
      //TODO: Optimise updateView
      _this.parent.findChildByName("gapminder-treemenu").markerID("axis_y").alignX("left").alignY("top").updateView().toggle();
    });

    var xTitle = this.xTitleEl.selectAll("text").data([0]);
    xTitle.enter().append("text");
    xTitle.attr("y", "-3px").attr("dx", "-0.72em").text(titleStringX).on("click", function () {
      //TODO: Optimise updateView
      _this.parent.findChildByName("gapminder-treemenu").markerID("axis_x").alignY("bottom").alignX("center").updateView().toggle();
    });

    this.yScale = this.model.marker.axis_y.getScale();
    this.xScale = this.model.marker.axis_x.getScale();
    this.cScale = this.model.marker.color.getScale();

    var xFormatter = this.model.marker.axis_x.which == "geo.world_4region" ? function (x) {
      return _this.translator("entity/geo.world_4region/" + x);
    } : _this.model.marker.axis_x.getTickFormatter();

    this.yAxis.tickFormat(_this.model.marker.axis_y.getTickFormatter());
    this.xAxis.tickFormat(xFormatter);
  },


  /**
   * Updates entities
   */
  updateEntities: function updateEntities() {

    var _this = this;
    var time = this.model.time;
    var timeDim = time.getDimension();
    var entityDim = this.model.entities.getDimension();
    var duration = time.playing ? time.delayAnimations : 0;
    var filter = {};
    filter[timeDim] = time.value;
    var items = this.model.marker.getKeys(filter);

    this.entityBars = this.bars.selectAll(".vzb-bc-bar").data(items);

    //exit selection
    this.entityBars.exit().remove();

    //enter selection -- init circles
    this.entityBars.enter().append("rect").attr("class", "vzb-bc-bar").on("mousemove", function (d, i) {}).on("mouseout", function (d, i) {}).on("click", function (d, i) {});

    //positioning and sizes of the bars

    var bars = this.bars.selectAll(".vzb-bc-bar");
    var barWidth = this.xScale.rangeBand();

    this.bars.selectAll(".vzb-bc-bar").attr("width", barWidth).attr("fill", function (d) {
      return _this.cScale(_this.values.color[d[entityDim]]);
    }).attr("x", function (d) {
      return _this.xScale(_this.values.axis_x[d[entityDim]]);
    }).transition().duration(duration).ease(d3.easeLinear).attr("y", function (d) {
      return _this.yScale(_this.values.axis_y[d[entityDim]]);
    }).attr("height", function (d) {
      return _this.height - _this.yScale(_this.values.axis_y[d[entityDim]]);
    });
    this.year.text(this.model.time.formatDate(this.model.time.value));
  },


  /**
   * Executes everytime the container or vizabi is resized
   * Ideally,it contains only operations related to size
   */
  resize: function resize() {

    var _this = this;

    this.profiles = {
      "small": {
        margin: {
          top: 30,
          right: 20,
          left: 40,
          bottom: 50
        },
        padding: 2,
        minRadius: 2,
        maxRadius: 40
      },
      "medium": {
        margin: {
          top: 30,
          right: 60,
          left: 60,
          bottom: 60
        },
        padding: 2,
        minRadius: 3,
        maxRadius: 60
      },
      "large": {
        margin: {
          top: 30,
          right: 60,
          left: 60,
          bottom: 80
        },
        padding: 2,
        minRadius: 4,
        maxRadius: 80
      }
    };

    this.activeProfile = this.profiles[this.getLayoutProfile()];
    var margin = this.activeProfile.margin;

    //stage
    this.height = parseInt(this.element.style("height"), 10) - margin.top - margin.bottom || 0;
    this.width = parseInt(this.element.style("width"), 10) - margin.left - margin.right || 0;

    if (this.height <= 0 || this.width <= 0) return utils.warn("Bar chart resize() abort: vizabi container is too little or has display:none");

    this.graph.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    //update scales to the new range
    if (this.model.marker.axis_y.scaleType !== "ordinal") {
      this.yScale.range([this.height, 0]);
    } else {
      this.yScale.rangePoints([this.height, 0], _this.activeProfile.padding).range();
    }
    if (this.model.marker.axis_x.scaleType !== "ordinal") {
      this.xScale.range([0, this.width]);
    } else {
      this.xScale.rangePoints([0, this.width], _this.activeProfile.padding).range();
    }

    //apply scales to axes and redraw
    this.yAxis.scale(this.yScale).tickSize(6, 0).tickSizeMinor(3, 0).labelerOptions({
      scaleType: this.model.marker.axis_y.scaleType,
      timeFormat: this.model.time.getFormatter(),
      toolMargin: { top: 5, right: margin.right, left: margin.left, bottom: margin.bottom },
      limitMaxTickNumber: 6
    });

    this.xAxis.scale(this.xScale).tickSize(6, 0).tickSizeMinor(3, 0).labelerOptions({
      scaleType: this.model.marker.axis_x.scaleType,
      timeFormat: this.model.time.getFormatter(),
      toolMargin: margin,
      viewportLength: this.width
    });

    this.xAxisEl.attr("transform", "translate(0," + this.height + ")").call(this.xAxis);

    this.xScale.rangeRoundBands([0, this.width], 0.1, 0.2);

    this.yAxisEl.call(this.yAxis);
    this.xAxisEl.call(this.xAxis);

    var xAxisSize = this.xAxisEl.node().getBoundingClientRect();
    var xTitleSize = this.xTitleEl.node().getBoundingClientRect();
    var xTitleXPos = xAxisSize.width / 2 - xTitleSize.width / 2;
    var xTitleYPos = this.height + xAxisSize.height + xTitleSize.height;
    this.xTitleEl.attr("transform", "translate(" + xTitleXPos + "," + xTitleYPos + ")");
    this.year.attr("x", this.width).attr("y", 0);
  }
});

exports.default = BarComponent;

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _d = __webpack_require__(41);

var _d2 = _interopRequireDefault(_d);

var _iconset = __webpack_require__(10);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var COLOR_BLACKISH = "#333";
var COLOR_WHITEISH = "#fdfdfd";

var BarRankChart = _component2.default.extend({

  /**
   * Initializes the component (Bar Chart).
   * Executed once before any template is rendered.
   * @param {Object} config The config passed to the component
   * @param {Object} context The component's parent
   */
  init: function init(config, context) {
    var _this2 = this;

    this.name = "barrankchart-component";
    this.template = __webpack_require__(460);

    //define expected models for this component
    this.model_expects = [{
      name: "time",
      type: "time"
    }, {
      name: "entities",
      type: "entities"
    }, {
      name: "marker",
      type: "model"
    }, {
      name: "locale",
      type: "locale"
    }, {
      name: "ui",
      type: "ui"
    }];

    this.model_binds = {
      "change:time.value": function changeTimeValue() {
        if (_this2._readyOnce) {
          _this2.onTimeChange();
        }
      },
      "change:marker.select": function changeMarkerSelect() {
        if (_this2._readyOnce) {
          _this2._selectBars();
          _this2._updateOpacity();
          _this2._updateDoubtOpacity();
          _this2._scroll();
        }
      },
      "change:marker.axis_x.scaleType": function changeMarkerAxis_xScaleType() {
        if (_this2._readyOnce) {
          _this2.loadData();
          _this2.draw(true);
        }
      },
      "change:marker.color.palette": function changeMarkerColorPalette() {
        _this2._drawColors();
      },
      "change:marker.highlight": function changeMarkerHighlight() {
        _this2._updateOpacity();
      },
      "change:marker.opacitySelectDim": function changeMarkerOpacitySelectDim() {
        _this2._updateOpacity();
      },
      "change:marker.opacityRegular": function changeMarkerOpacityRegular() {
        _this2._updateOpacity();
      }
    };

    //contructor is the same as any component
    this._super(config, context);

    // set up the scales
    this.xScale = null;
    this.cScale = d3.scaleOrdinal(d3.schemeCategory10);

    // set up the axes
    this.xAxis = (0, _d2.default)("bottom");
  },
  onTimeChange: function onTimeChange() {
    var _this3 = this;

    this.model.marker.getFrame(this.model.time.value, function (values) {
      _this3.values = values;
      _this3.loadData();
      _this3.draw();
    });
  },


  /**
   * DOM and model are ready
   */
  readyOnce: function readyOnce() {
    this.element = d3.select(this.element);

    // reference elements
    //this.graph = this.element.select('.vzb-br-graph');
    //this.yearEl = this.element.select('.vzb-br-year');
    //this.year = new DynamicBackground(this.yearEl);
    this.header = this.element.select(".vzb-br-header");
    this.infoEl = this.element.select(".vzb-br-axis-info");
    this.barViewport = this.element.select(".vzb-br-barsviewport");
    this.barSvg = this.element.select(".vzb-br-bars-svg");
    this.barContainer = this.element.select(".vzb-br-bars");
    this.dataWarningEl = this.element.select(".vzb-data-warning");
    this.wScale = d3.scale.linear().domain(this.model.ui.datawarning.doubtDomain).range(this.model.ui.datawarning.doubtRange);

    // set up formatters
    this.xAxis.tickFormat(this.model.marker.axis_x.getTickFormatter());

    this._localeId = this.model.locale.id;
    this._presentation = !this.model.ui.presentation;
    this._formatter = this.model.marker.axis_x.getTickFormatter();

    this.ready();

    this._selectBars();
  },


  /**
   * Both model and DOM are ready
   */
  ready: function ready() {
    var _this4 = this;

    this.model.marker.getFrame(this.model.time.value, function (values) {

      _this4.values = values;
      _this4.loadData();
      _this4.draw(true);
      _this4._updateOpacity();
      _this4._drawColors();
    });
  },
  resize: function resize() {
    this.draw(true);
  },
  loadData: function loadData() {
    var _this5 = this;

    var _this = this;

    this.translator = this.model.locale.getTFunction();
    // sort the data (also sets this.total)
    this.sortedEntities = this._sortByIndicator(this.values.axis_x);

    this.header.select(".vzb-br-title").select("text").on("click", function () {
      return _this5.parent.findChildByName("gapminder-treemenu").markerID("axis_x").alignX("left").alignY("top").updateView().toggle();
    });

    // new scales and axes
    this.xScale = this.model.marker.axis_x.getScale();
    this.cScale = this.model.marker.color.getScale();

    utils.setIcon(this.dataWarningEl, _iconset.warn).select("svg").attr("width", 0).attr("height", 0);

    this.dataWarningEl.append("text").text(this.translator("hints/dataWarning"));

    this.dataWarningEl.on("click", function () {
      return _this5.parent.findChildByName("gapminder-datawarning").toggle();
    }).on("mouseover", function () {
      return _this5._updateDoubtOpacity(1);
    }).on("mouseout", function () {
      return _this5._updateDoubtOpacity();
    });

    utils.setIcon(this.infoEl, _iconset.question).select("svg").attr("width", 0).attr("height", 0);

    this.infoEl.on("click", function () {
      _this5.parent.findChildByName("gapminder-datanotes").pin();
    });

    this.infoEl.on("mouseover", function () {
      var rect = this.getBBox();
      var ctx = utils.makeAbsoluteContext(this, this.farthestViewportElement);
      var coord = ctx(rect.x - 10, rect.y + rect.height + 10);
      _this.parent.findChildByName("gapminder-datanotes").setHook("axis_y").show().setPos(coord.x, coord.y);
    });

    this.infoEl.on("mouseout", function () {
      _this.parent.findChildByName("gapminder-datanotes").hide();
    });
  },
  draw: function draw() {
    var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    this.time_1 = this.time == null ? this.model.time.value : this.time;
    this.time = this.model.time.value;
    //smooth animation is needed when playing, except for the case when time jumps from end to start
    var duration = this.model.time.playing && this.time - this.time_1 > 0 ? this.model.time.delayAnimations : 0;

    //return if drawAxes exists with error
    if (this.drawAxes(duration, force)) return;
    this.drawData(duration, force);
  },


  /*
   * draw the chart/stage
   */
  drawAxes: function drawAxes() {
    var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

    var profiles = {
      small: {
        margin: { top: 60, right: 5, left: 5, bottom: 20 },
        headerMargin: { top: 10, right: 20, bottom: 20, left: 20 },
        infoElHeight: 16,
        infoElMargin: 5,
        barHeight: 18,
        barMargin: 3,
        barRectMargin: 5,
        barValueMargin: 5,
        scrollMargin: 20
      },
      medium: {
        margin: { top: 60, right: 5, left: 5, bottom: 20 },
        headerMargin: { top: 10, right: 20, bottom: 20, left: 20 },
        infoElHeight: 16,
        infoElMargin: 5,
        barHeight: 21,
        barMargin: 3,
        barRectMargin: 5,
        barValueMargin: 5,
        scrollMargin: 25
      },
      large: {
        margin: { top: 60, right: 5, left: 5, bottom: 20 },
        headerMargin: { top: 10, right: 20, bottom: 20, left: 20 },
        infoElHeight: 16,
        infoElMargin: 5,
        barHeight: 28,
        barMargin: 4,
        barRectMargin: 5,
        barValueMargin: 5,
        scrollMargin: 25
      }
    };

    var presentationProfileChanges = {
      medium: {
        margin: { top: 60, right: 10, left: 10, bottom: 40 },
        headerMargin: { top: 10, right: 20, bottom: 20, left: 20 },
        infoElHeight: 25,
        infoElMargin: 10,
        barHeight: 25,
        barMargin: 6
      },
      large: {
        margin: { top: 60, right: 10, left: 10, bottom: 40 },
        headerMargin: { top: 10, right: 20, bottom: 20, left: 20 },
        infoElHeight: 16,
        infoElMargin: 10,
        barHeight: 30,
        barMargin: 6
      }
    };

    this.activeProfile = this.getActiveProfile(profiles, presentationProfileChanges);

    var _activeProfile = this.activeProfile,
        margin = _activeProfile.margin,
        headerMargin = _activeProfile.headerMargin,
        infoElHeight = _activeProfile.infoElHeight,
        infoElMargin = _activeProfile.infoElMargin;


    this.height = +this.element.style("height").replace("px", "");
    this.width = +this.element.style("width").replace("px", "");

    this.barViewport.style("height", this.height - margin.bottom - margin.top + "px");

    // header
    this.header.attr("height", margin.top);
    var headerTitle = this.header.select(".vzb-br-title");

    // change header titles for new data

    var _model$marker$axis_x$ = this.model.marker.axis_x.getConceptprops(),
        name = _model$marker$axis_x$.name,
        unit = _model$marker$axis_x$.unit;

    var headerTitleText = headerTitle.select("text");

    if (unit) {
      headerTitleText.text(name + ", " + unit);

      var rightEdgeOfLeftText = headerMargin.left + headerTitle.node().getBBox().width + infoElMargin + infoElHeight;

      if (rightEdgeOfLeftText > this.width - headerMargin.right) {
        headerTitleText.text(name);
      }
    }

    var headerTitleBBox = headerTitle.node().getBBox();

    var titleTx = headerMargin.left;
    var titleTy = headerMargin.top + headerTitleBBox.height;
    headerTitle.attr("transform", "translate(" + titleTx + ", " + titleTy + ")");

    var headerInfo = this.infoEl;

    headerInfo.select("svg").attr("width", infoElHeight + "px").attr("height", infoElHeight + "px");

    var infoTx = titleTx + headerTitle.node().getBBox().width + infoElMargin;
    var infoTy = headerMargin.top + infoElHeight / 4;
    headerInfo.attr("transform", "translate(" + infoTx + ", " + infoTy + ")");

    var headerTotal = this.header.select(".vzb-br-total");

    if (duration) {
      headerTotal.select("text").transition("text").delay(duration).text(this.model.time.formatDate(this.time));
    } else {
      headerTotal.select("text").interrupt().text(this.model.time.formatDate(this.time));
    }
    headerTotal.style("opacity", Number(this.getLayoutProfile() !== "large"));

    var headerTotalBBox = headerTotal.node().getBBox();

    var totalTx = this.width - headerMargin.right - headerTotalBBox.width;
    var totalTy = headerMargin.top + headerTotalBBox.height;
    headerTotal.attr("transform", "translate(" + totalTx + ", " + totalTy + ")").classed("vzb-transparent", headerTitleBBox.width + headerTotalBBox.width + 10 > this.width);

    this.element.select(".vzb-data-warning-svg").style("height", margin.bottom + "px");

    var warningBBox = this.dataWarningEl.select("text").node().getBBox();
    this.dataWarningEl.attr("transform", "translate(" + (this.width - margin.right - warningBBox.width) + ", " + warningBBox.height + ")").select("text");

    this.dataWarningEl.select("svg").attr("width", warningBBox.height).attr("height", warningBBox.height).attr("x", -warningBBox.height - 5).attr("y", -warningBBox.height + 1);

    this._updateDoubtOpacity();
  },
  drawData: function drawData() {
    var _this6 = this;

    var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var localeChanged = this._localeId !== this.model.locale.id;
    if (force || localeChanged) {
      this._localeId = this.model.locale.id;
      this.barContainer.selectAll(".vzb-br-bar").remove();
    }

    // update the shown bars for new data-set
    this._createAndDeleteBars(this.barContainer.selectAll(".vzb-br-bar").data(this.sortedEntities, function (d) {
      return d.entity;
    }));

    var presentation = this.model.ui.presentation;

    var presentationModeChanged = this._presentation !== presentation;

    if (presentationModeChanged) {
      this._presentation = presentation;
    }

    var entitiesCountChanged = typeof this._entitiesCount === "undefined" || this._entitiesCount !== this.sortedEntities.length;

    if (presentationModeChanged || entitiesCountChanged) {
      if (entitiesCountChanged) {
        this._entitiesCount = this.sortedEntities.length;
      }
    }

    this._resizeSvg();
    this._scroll(duration);

    var _activeProfile2 = this.activeProfile,
        barRectMargin = _activeProfile2.barRectMargin,
        barValueMargin = _activeProfile2.barValueMargin,
        scrollMargin = _activeProfile2.scrollMargin,
        margin = _activeProfile2.margin;
    var axis_x = this.model.marker.axis_x;

    var limits = axis_x.getLimits(axis_x.which);
    var ltr = Math.abs(limits.max) >= Math.abs(limits.min);

    var rightEdge = this.width - margin.right - margin.left - this._getWidestLabelWidth() - barRectMargin - scrollMargin;
    this.xScale.range([0, rightEdge]);

    var zeroValueWidth = this.xScale(0) || 0;
    var shift = this._getWidestLabelWidth();

    if (zeroValueWidth > (ltr ? margin.left : margin.right) + this._getWidestLabelWidth()) {
      shift = zeroValueWidth;
    }

    if (zeroValueWidth < 0) {
      this.xScale.range([0, rightEdge - Math.abs(zeroValueWidth)]);
      zeroValueWidth = this.xScale(0) || 0;
    }

    var barWidth = function barWidth(value) {
      return _this6.xScale(value) - zeroValueWidth;
    };

    var labelAnchor = ltr ? "end" : "start";
    var valueAnchor = ltr ? "start" : "end";

    var labelX = ltr ? margin.left + shift : this.width - shift - scrollMargin - margin.right;

    var barX = ltr ? labelX + barRectMargin : labelX - barRectMargin;

    var valueX = ltr ? barX + barValueMargin : barX - barValueMargin;

    var isLabelBig = this._getWidestLabelWidth(true) + (ltr ? margin.left : margin.right) < shift;
    this.sortedEntities.forEach(function (bar) {
      var value = bar.value;


      if (force || presentationModeChanged || bar.isNew) {
        bar.barLabel.attr("x", labelX).attr("y", _this6.activeProfile.barHeight / 2).attr("text-anchor", labelAnchor).text(isLabelBig ? bar.labelFull : bar.labelSmall);

        bar.barRect.attr("rx", _this6.activeProfile.barHeight / 4).attr("ry", _this6.activeProfile.barHeight / 4).attr("height", _this6.activeProfile.barHeight);

        bar.barValue.attr("x", valueX).attr("y", _this6.activeProfile.barHeight / 2).attr("text-anchor", valueAnchor);
      }

      if (force || bar.changedWidth || presentationModeChanged) {
        var width = Math.max(0, value && barWidth(Math.abs(value)));

        if (force || bar.changedWidth || presentationModeChanged) {
          bar.barRect.transition().duration(duration).ease(d3.easeLinear).attr("width", width);
        }

        bar.barRect.attr("x", barX - (value < 0 ? width : 0));

        if (force || bar.changedValue) {
          bar.barValue.text(_this6._formatter(value) || _this6.translator("hints/nodata"));
        }
      }

      if (force || bar.changedIndex || presentationModeChanged) {
        bar.self.transition().duration(duration).ease(d3.easeLinear).attr("transform", "translate(0, " + _this6._getBarPosition(bar.index) + ")");
      }
    });
  },
  _resizeSvg: function _resizeSvg() {
    var _activeProfile3 = this.activeProfile,
        barHeight = _activeProfile3.barHeight,
        barMargin = _activeProfile3.barMargin;

    this.barSvg.attr("height", (barHeight + barMargin) * this.sortedEntities.length + "px");
  },
  _scroll: function _scroll() {
    var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

    var follow = this.barContainer.select(".vzb-selected");
    if (!follow.empty()) {
      var d = follow.datum();
      var yPos = this._getBarPosition(d.index);

      var margin = this.activeProfile.margin;

      var height = this.height - margin.top - margin.bottom;

      var scrollTo = yPos - (height + this.activeProfile.barHeight) / 2;
      this.barViewport.transition().duration(duration).tween("scrollfor" + d.entity, this._scrollTopTween(scrollTo));
    }
  },
  _createAndDeleteBars: function _createAndDeleteBars(updatedBars) {
    var _this = this;

    // remove groups for entities that are gone
    updatedBars.exit().remove();

    // make the groups for the entities which were not drawn yet (.data.enter() does this)
    updatedBars = updatedBars.enter().append("g").each(function (d) {
      var self = d3.select(this);

      self.attr("class", "vzb-br-bar").classed("vzb-selected", _this.model.marker.isSelected(d)).attr("id", "vzb-br-bar-" + d.entity + "-" + _this._id).on("mousemove", function (d) {
        return _this.model.marker.highlightMarker(d);
      }).on("mouseout", function () {
        return _this.model.marker.clearHighlighted();
      }).on("click", function (d) {
        _this.model.marker.selectMarker(d);
      });

      var barRect = self.append("rect").attr("stroke", "transparent");

      var labelFull = _this.values.label[d.entity];
      var labelSmall = labelFull.length < 12 ? labelFull : labelFull.substring(0, 9) + "...";
      var barLabel = self.append("text").attr("class", "vzb-br-label").attr("dy", ".325em");

      var labelFullWidth = barLabel.text(labelFull).node().getBBox().width;
      var labelSmallWidth = barLabel.text(labelSmall).node().getBBox().width;

      var barValue = self.append("text").attr("class", "vzb-br-value").attr("dy", ".325em");

      Object.assign(d, {
        self: self,
        barRect: barRect,
        barLabel: barLabel,
        barValue: barValue,
        isNew: true,
        labelFullWidth: labelFullWidth,
        labelSmallWidth: labelSmallWidth,
        labelFull: labelFull,
        labelSmall: labelSmall
      });
    }).merge(updatedBars);
  },
  _getWidestLabelWidth: function _getWidestLabelWidth() {
    var big = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var widthKey = big ? "labelFullWidth" : "labelSmallWidth";
    var labelKey = big ? "labelFull" : "labelSmall";

    var bar = this.sortedEntities.reduce(function (a, b) {
      return a[widthKey] < b[widthKey] ? b : a;
    });

    var text = bar.barLabel.text();
    var width = bar.barLabel.text(bar[labelKey]).node().getBBox().width;
    bar.barLabel.text(text);

    return width;
  },
  _drawColors: function _drawColors() {
    var _this7 = this;

    var _this = this;

    this.barContainer.selectAll(".vzb-br-bar>rect").each(function (_ref) {
      var entity = _ref.entity;

      var self = d3.select(this);
      var color = _this.values.color[entity];

      if (!color && color !== 0) {
        self.style("fill", COLOR_WHITEISH).attr("stroke", COLOR_BLACKISH);
      } else {
        self.style("fill", _this._getColor(color)).attr("stroke", "transparent");
      }
    });

    this.barContainer.selectAll(".vzb-br-bar>text").style("fill", function (_ref2) {
      var entity = _ref2.entity;
      return _this7._getDarkerColor(_this7.values.color[entity]);
    });
  },
  _getColor: function _getColor(value) {
    return d3.rgb(this.cScale(value));
  },
  _getDarkerColor: function _getDarkerColor(d) {
    return this._getColor(d).darker(2);
  },


  /**
   * DATA HELPER FUNCTIONS
   */

  _scrollTopTween: function _scrollTopTween(scrollTop) {
    return function () {
      var node = this,
          i = d3.interpolateNumber(this.scrollTop, scrollTop);
      return function (t) {
        node.scrollTop = i(t);
      };
    };
  },
  _getBarPosition: function _getBarPosition(i) {
    return (this.activeProfile.barHeight + this.activeProfile.barMargin) * i;
  },


  _entities: {},

  _sortByIndicator: function _sortByIndicator(values) {
    var _this8 = this;

    return Object.keys(values).map(function (entity) {
      var _this8$_entities$enti;

      var cached = _this8._entities[entity];
      var value = values[entity];
      var formattedValue = _this8._formatter(value);

      if (cached) {
        return Object.assign(cached, {
          value: value,
          formattedValue: formattedValue,
          changedValue: formattedValue !== cached.formattedValue,
          changedWidth: value !== cached.value,
          isNew: false
        });
      }

      return _this8._entities[entity] = (_this8$_entities$enti = {
        entity: entity,
        value: value,
        formattedValue: formattedValue
      }, _defineProperty(_this8$_entities$enti, _this8.model.entities.dim, entity), _defineProperty(_this8$_entities$enti, "changedValue", true), _defineProperty(_this8$_entities$enti, "changedWidth", true), _defineProperty(_this8$_entities$enti, "isNew", true), _this8$_entities$enti);
    }).sort(function (_ref3, _ref4) {
      var a = _ref3.value;
      var b = _ref4.value;
      return b - a;
    }).map(function (entity, index) {
      return Object.assign(entity, {
        index: index,
        changedIndex: index !== entity.index
      });
    });
  },
  _selectBars: function _selectBars() {
    var _this9 = this;

    var entityDim = this.model.entities.dim;
    var selected = this.model.marker.select;

    // unselect all bars
    this.barContainer.classed("vzb-dimmed-selected", false);
    this.barContainer.selectAll(".vzb-br-bar.vzb-selected").classed("vzb-selected", false);

    // select the selected ones
    if (selected.length) {
      this.barContainer.classed("vzb-dimmed-selected", true);
      selected.forEach(function (selectedBar) {
        _this9.barContainer.select("#vzb-br-bar-" + selectedBar[entityDim] + "-" + _this9._id).classed("vzb-selected", true);
      });
    }
  },
  _updateOpacity: function _updateOpacity() {
    var marker = this.model.marker;


    var OPACITY_HIGHLIGHT_DEFAULT = 1;
    var highlight = marker.highlight,
        select = marker.select,
        OPACITY_HIGHLIGHT_DIM = marker.opacityHighlightDim,
        OPACITY_SELECT_DIM = marker.opacitySelectDim,
        OPACITY_REGULAR = marker.opacityRegular;
    var someHighlighted = highlight.length > 0,
        someSelected = select.length > 0;


    this.barContainer.selectAll(".vzb-br-bar").style("opacity", function (d) {
      if (someHighlighted && marker.isHighlighted(d)) {
        return OPACITY_HIGHLIGHT_DEFAULT;
      }

      if (someSelected) {
        return marker.isSelected(d) ? OPACITY_REGULAR : OPACITY_SELECT_DIM;
      }

      if (someHighlighted) {
        return OPACITY_HIGHLIGHT_DIM;
      }

      return OPACITY_REGULAR;
    });
  },
  _updateDoubtOpacity: function _updateDoubtOpacity(opacity) {
    this.dataWarningEl.style("opacity", opacity || (!this.model.marker.select.length ? this.wScale(+this.model.time.value.getUTCFullYear().toString()) : 1));
  }
});

exports.default = BarRankChart;

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _bubblechartTrail = __webpack_require__(221);

var _bubblechartTrail2 = _interopRequireDefault(_bubblechartTrail);

var _bubblechartPanzoom = __webpack_require__(220);

var _bubblechartPanzoom2 = _interopRequireDefault(_bubblechartPanzoom);

var _svgexport = __webpack_require__(138);

var _svgexport2 = _interopRequireDefault(_svgexport);

var _labels = __webpack_require__(73);

var _labels2 = _interopRequireDefault(_labels);

var _d = __webpack_require__(41);

var _d2 = _interopRequireDefault(_d);

var _d3 = __webpack_require__(60);

var _d4 = _interopRequireDefault(_d3);

var _iconset = __webpack_require__(10);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//BUBBLE CHART COMPONENT
var BubbleChartComp = _component2.default.extend({

  /**
   * Initializes the component (Bubble Chart).
   * Executed once before any template is rendered.
   * @param {Object} config The config passed to the component
   * @param {Object} context The component's parent
   */
  init: function init(config, context) {
    var _this = this;
    this.name = "bubblechart";
    this.template = __webpack_require__(461);

    //define expected models for this component
    this.model_expects = [{
      name: "time",
      type: "time"
    }, {
      name: "entities",
      type: "entities"
    }, {
      name: "marker",
      type: "model"
    }, {
      name: "locale",
      type: "locale"
    }, {
      name: "ui",
      type: "ui"
    }];

    this.model_binds = {
      "change:time.playing": function changeTimePlaying(evt, original) {
        if (utils.isTouchDevice() && _this.model.time.playing && _this.someHighlighted) {
          _this.model.marker.clearHighlighted();
        }
      },
      "change:time.start": function changeTimeStart(evt, original) {
        if (_this.model.marker.color.scaleType === "time") {
          _this.model.marker.color.scale = null;
        }
        if (!_this._readyOnce || _this.model.time.splash) return;
        _this._trails.create().then(function () {
          _this._trails.run(["findVisible", "reveal", "opacityHandler"]);
        });
      },
      "change:time.end": function changeTimeEnd(evt, original) {
        if (!_this._readyOnce || _this.model.time.splash) return;
        _this._trails.create().then(function () {
          _this._trails.run(["findVisible", "reveal", "opacityHandler"]);
        });
      },
      "change:time.record": function changeTimeRecord() {
        //console.log("change time record");
        if (_this.model.time.record) {
          _this._export.open(this.element, this.name);
        } else {
          _this._export.reset();
        }
      },
      "change:ui.chart.trails": function changeUiChartTrails(evt) {
        //console.log("EVENT change:time:trails");
        _this._trails.toggle(_this.model.ui.chart.trails);
        _this.redrawDataPoints();
      },
      "change:ui.chart.lockNonSelected": function changeUiChartLockNonSelected(evt) {
        //console.log("EVENT change:time:lockNonSelected");
        _this.redrawDataPoints(500);
      },
      "change:marker": function changeMarker(evt, path) {
        // bubble size change is processed separately
        if (!_this._readyOnce) return;
        if (path.indexOf("scaleType") > -1) {
          _this.ready();
          return;
        }

        if (path.indexOf("marker.color") !== -1) return;
        if (path.indexOf("marker.size") !== -1) return;
        if (path.indexOf("marker.size_label") !== -1) return;

        if (path.indexOf("domainMin") > -1 || path.indexOf("domainMax") > -1) {
          if (!_this.yScale || !_this.xScale) return; //abort if building of the scale is in progress
          _this.updateSize();
          _this.updateMarkerSizeLimits();
          _this._trails.run("findVisible");
          _this.redrawDataPoints();
          _this._trails.run("resize", null, 500);
        } else if (path.indexOf("zoomedMin") > -1 || path.indexOf("zoomedMax") > -1) {
          if (_this.draggingNow) return;

          //avoid zooming again if values didn't change.
          //also prevents infinite loop on forced URL update from zoom.stop()
          if (utils.approxEqual(_this._zoomedXYMinMax.axis_x.zoomedMin, _this.model.marker.axis_x.zoomedMin, 0.01) && utils.approxEqual(_this._zoomedXYMinMax.axis_x.zoomedMax, _this.model.marker.axis_x.zoomedMax, 0.01) && utils.approxEqual(_this._zoomedXYMinMax.axis_y.zoomedMin, _this.model.marker.axis_y.zoomedMin, 0.01) && utils.approxEqual(_this._zoomedXYMinMax.axis_y.zoomedMax, _this.model.marker.axis_y.zoomedMax, 0.01)) return;
          var playAfterZoom = false;
          if (_this.model.time.playing) {
            playAfterZoom = true;
            _this.model.time.pause(true);
          }
          _this._trails.run("abortAnimation");
          _this._panZoom.zoomToMaxMin(_this.model.marker.axis_x.zoomedMin, _this.model.marker.axis_x.zoomedMax, _this.model.marker.axis_y.zoomedMin, _this.model.marker.axis_y.zoomedMax, 500 /*duration*/, "don't feed these zoom values back to state");
          if (playAfterZoom) {
            _this.model.time.postponePause = false;
          }
        }

        //console.log("EVENT change:marker", evt);
      },
      "change:marker.select": function changeMarkerSelect(evt, path) {
        if (!_this._readyOnce || !_this.entityBubbles) return;
        //console.log("EVENT change:entities:select");

        //disable trails if too many items get selected at once
        //otherwise it's too much waiting time
        if ((evt.source._val || []).length - (evt.source._previousVal || []).length > 50) _this.model.ui.chart.trails = false;

        _this.selectDataPoints();
        _this.redrawDataPoints();
        _this._trails.create().then(function () {
          _this._trails.run(["findVisible", "reveal", "opacityHandler"]);
        });
        _this.updateBubbleOpacity();
        _this._updateDoubtOpacity();
      },
      "change:marker.highlight": function changeMarkerHighlight(evt, path) {
        if (!_this._readyOnce) return;
        //path have values if trail is highlighted
        if (path != "highlight") {
          if (path !== null) {
            var titles = _this._formatSTitleValues(path.size, path.color);
            _this._updateSTitle(titles[0], titles[1]);
          } else {
            _this._updateSTitle();
          }
          return;
        }
        //console.log("EVENT change:entities:highlight");
        _this.highlightDataPoints();
      },
      "change:time.value": function changeTimeValue() {
        if (!_this._readyOnce || !_this.entityBubbles) return;
        if (!_this.calculationQueue) {
          // collect timestamp that we request
          _this.calculationQueue = [_this.model.time.value.toString()];
        } else {
          _this.calculationQueue.push(_this.model.time.value.toString());
        }
        (function (time) {
          // isolate timestamp
          //_this._bubblesInteract().mouseout();
          _this.model.marker.getFrame(time, function (frame, time) {
            if (!_this._frameIsValid(frame)) return utils.warn("change:time.value: empty data received from marker.getFrame(). doing nothing");
            var index = _this.calculationQueue.indexOf(time.toString()); //
            if (index == -1) {
              // we was receive more recent frame before so we pass this frame
              return;
            }
            _this.calculationQueue.splice(0, index + 1); // remove timestamps that added to queue before current timestamp
            _this.frameChanged(frame, time);
          });
        })(_this.model.time.value);
      },
      "change:ui.adaptMinMaxZoom": function changeUiAdaptMinMaxZoom() {
        //console.log("EVENT change:ui:adaptMinMaxZoom");
        if (_this.model.ui.adaptMinMaxZoom) {
          _this._panZoom.expandCanvas(500);
        } else {
          _this._panZoom.reset();
        }
      },
      "change:marker.size.extent": function changeMarkerSizeExtent(evt, path) {
        //console.log("EVENT change:marker:size:max");
        if (!_this._readyOnce) return;
        _this.updateMarkerSizeLimits();
        _this.redrawDataPointsOnlySize();
        _this._trails.run("resize");
      },
      "change:marker.color": function changeMarkerColor(evt, path) {
        if (!_this._readyOnce) return;
        //console.log("EVENT change:marker:color:palette");
        _this.redrawDataPointsOnlyColors();
        _this._trails.run("recolor");
      },
      // 'change:marker.color.palette': function(evt, path) {
      //   if(!_this._readyOnce) return;
      //   //console.log("EVENT change:marker:color:palette");
      //   _this.redrawDataPointsOnlyColors();
      //   _this._trails.run("recolor");
      // },
      "change:marker.opacitySelectDim": function changeMarkerOpacitySelectDim() {
        _this.updateBubbleOpacity();
      },
      "change:marker.opacityRegular": function changeMarkerOpacityRegular() {
        _this.updateBubbleOpacity();
        _this._trails.run("opacityHandler");
      },
      "change:ui.cursorMode": function changeUiCursorMode() {
        var svg = _this.chartSvg;
        if (_this.model.ui.cursorMode === "plus") {
          svg.classed("vzb-zoomin", true);
          svg.classed("vzb-zoomout", false);
          svg.classed("vzb-panhand", false);
        } else if (_this.model.ui.cursorMode === "minus") {
          svg.classed("vzb-zoomin", false);
          svg.classed("vzb-zoomout", true);
          svg.classed("vzb-panhand", false);
        } else if (_this.model.ui.cursorMode === "hand") {
          svg.classed("vzb-zoomin", false);
          svg.classed("vzb-zoomout", false);
          svg.classed("vzb-panhand", true);
        } else {
          svg.classed("vzb-zoomin", false);
          svg.classed("vzb-zoomout", false);
          svg.classed("vzb-panhand", false);
        }
      },
      "ready": function ready() {
        // if(_this.model.marker.color.scaleType === 'time') {
        //   _this.model.marker.color.scale = null;
        //   utils.defer(function() {
        //     _this.trigger('ready');
        //   });
        // }
      }
    };

    this._super(config, context);

    this.xScale = null;
    this.yScale = null;
    this.sScale = null;
    this.cScale = null;

    this.xAxis = (0, _d2.default)("bottom");
    this.yAxis = (0, _d2.default)("left");

    _this.COLOR_BLACKISH = "#333";
    _this.COLOR_WHITEISH = "#fdfdfd";

    this.isCanvasPreviouslyExpanded = false;
    this.draggingNow = null;

    this._trails = new _bubblechartTrail2.default(this);
    this._panZoom = new _bubblechartPanzoom2.default(this);
    this._export = new _svgexport2.default(this);
    this._export.prefix("vzb-bc-").deleteClasses(["vzb-bc-bubbles-crop", "vzb-hidden", "vzb-bc-year", "vzb-bc-zoom-rect", "vzb-bc-projection-x", "vzb-bc-projection-y", "vzb-bc-axis-c-title"]);
    this._labels = new _labels2.default(this);
    this._labels.config({
      CSS_PREFIX: "vzb-bc",
      LABELS_CONTAINER_CLASS: "vzb-bc-labels",
      LINES_CONTAINER_CLASS: "vzb-bc-bubbles",
      LINES_CONTAINER_SELECTOR_PREFIX: "bubble-"
    });
  },
  _rangeBump: function _rangeBump(arg, undo) {
    var bump = this.activeProfile.maxRadius / 2;
    undo = undo ? -1 : 1;
    if (utils.isArray(arg) && arg.length > 1) {
      var z1 = arg[0];
      var z2 = arg[arg.length - 1];

      //the sign of bump depends on the direction of the scale
      if (z1 < z2) {
        z1 += bump * undo;
        z2 -= bump * undo;
        // if the scale gets inverted because of bump, set it to avg between z1 and z2
        if (z1 > z2) z1 = z2 = (z1 + z2) / 2;
      } else if (z1 > z2) {
        z1 -= bump * undo;
        z2 += bump * undo;
        // if the scale gets inverted because of bump, set it to avg between z1 and z2
        if (z1 < z2) z1 = z2 = (z1 + z2) / 2;
      } else {
        utils.warn("rangeBump error: the input scale range has 0 length. that sucks");
      }
      return [z1, z2];
    }
    utils.warn("rangeBump error: input is not an array or empty");
  },


  //  _marginUnBump: function(arg) {
  //    var bump = this.profiles[this.getLayoutProfile()].maxRadius/2;
  //    if(utils.isObject(arg)) {
  //      return {
  //        left: arg.left - bump,
  //        right: arg.right - bump,
  //        top: arg.top - bump,
  //        bottom: arg.bottom - bump
  //      };
  //    } else {
  //      utils.warn("marginUnBump error: input is not an object {left top bottom right}");
  //    }
  //  },


  /**
   * Executes right after the template is in place, but the model is not yet ready
   */
  readyOnce: function readyOnce() {
    var _this = this;
    this._readyOnce = false;
    this.scrollableAncestor = utils.findScrollableAncestor(this.element);
    this.element = d3.select(this.element);

    // reference elements
    this.chartSvg = this.element.select("svg");
    this.graph = this.element.select(".vzb-bc-graph");
    this.yAxisElContainer = this.graph.select(".vzb-bc-axis-y");
    this.yAxisEl = this.yAxisElContainer.select("g");

    this.xAxisElContainer = this.graph.select(".vzb-bc-axis-x");
    this.xAxisEl = this.xAxisElContainer.select("g");

    this.yTitleEl = this.graph.select(".vzb-bc-axis-y-title");
    this.xTitleEl = this.graph.select(".vzb-bc-axis-x-title");
    this.sTitleEl = this.graph.select(".vzb-bc-axis-s-title");
    this.cTitleEl = this.graph.select(".vzb-bc-axis-c-title");
    this.yearEl = this.graph.select(".vzb-bc-year");

    this.year = new _d4.default(this.yearEl);

    this.yInfoEl = this.graph.select(".vzb-bc-axis-y-info");
    this.xInfoEl = this.graph.select(".vzb-bc-axis-x-info");
    this.dataWarningEl = this.graph.select(".vzb-data-warning");

    this.projectionX = this.graph.select(".vzb-bc-projection-x");
    this.projectionY = this.graph.select(".vzb-bc-projection-y");
    this.lineEqualXY = this.graph.select(".vzb-bc-line-equal-xy");

    this.trailsContainer = this.graph.select(".vzb-bc-trails");
    this.bubbleContainerCrop = this.graph.select(".vzb-bc-bubbles-crop");
    this.zoomSelection = this.graph.select(".vzb-zoom-selection");
    this.labelsContainerCrop = this.graph.select(".vzb-bc-labels-crop");
    this.bubbleContainer = this.graph.select(".vzb-bc-bubbles");
    this.labelsContainer = this.graph.select(".vzb-bc-labels");
    this.linesContainer = this.graph.select(".vzb-bc-lines");
    this.zoomRect = this.element.select(".vzb-bc-zoom-rect");
    this.eventArea = this.element.select(".vzb-bc-eventarea");

    this.entityBubbles = null;
    this.bubbleCrown = this.element.select(".vzb-bc-bubble-crown");
    //set filter
    this.bubbleCrown.selectAll(".vzb-crown-glow").attr("filter", "url(" + location.pathname + "#vzb-glow-filter)");
    this.tooltip = this.element.select(".vzb-bc-tooltip");
    //set filter
    this.tooltip.select(".vzb-tooltip-glow").attr("filter", "url(" + location.pathname + "#vzb-glow-filter)");

    this.tooltipMobile = this.element.select(".vzb-tooltip-mobile");
    //component events
    this.on("resize", function () {
      //console.log("EVENT: resize");
      //return if updatesize exists with error
      _this._trails.run("abortAnimation");
      if (_this.updateSize()) return;
      _this.updateMarkerSizeLimits();
      _this._labels.updateSize();
      (function (xMin, xMax, yMin, yMax) {
        _this._panZoom.zoomer.dontFeedToState = true;
        _this._panZoom.rerun(); // includes redraw data points and trail resize
        _this._panZoom.zoomToMaxMin(xMin, xMax, yMin, yMax, 0, true);
      })(_this._zoomedXYMinMax.axis_x.zoomedMin, _this._zoomedXYMinMax.axis_x.zoomedMax, _this._zoomedXYMinMax.axis_y.zoomedMin, _this._zoomedXYMinMax.axis_y.zoomedMax);
    });

    //keyboard listeners
    d3.select("body").on("keydown", function () {
      if (_this.model.ui.cursorMode !== "arrow" && _this.model.ui.cursorMode !== "hand") return;
      if (d3.event.metaKey || d3.event.ctrlKey) _this.element.select("svg").classed("vzb-zoomin", true);
    }).on("keyup", function () {
      if (_this.model.ui.cursorMode !== "arrow" && _this.model.ui.cursorMode !== "hand") return;
      if (!d3.event.metaKey && !d3.event.ctrlKey) _this.element.select("svg").classed("vzb-zoomin", false);
    })
    //this is for the case when user would press ctrl and move away from the browser tab or window
    //keyup event would happen somewhere else and won't be captured, so zoomin class would get stuck
    .on("mouseenter", function () {
      if (_this.model.ui.cursorMode !== "arrow" && _this.model.ui.cursorMode !== "hand") return;
      if (!d3.event.metaKey && !d3.event.ctrlKey) _this.element.select("svg").classed("vzb-zoomin", false);
    });

    this.root.on("resetZoom", function () {
      _this._panZoom.reset(null, 500);
    });

    this._panZoom.zoomSelection(this.bubbleContainerCrop);
    this.bubbleContainerCrop.call(this._panZoom.dragRectangle).call(this._panZoom.zoomer).on("dblclick.zoom", null).on("mouseup", function () {
      _this.draggingNow = false;
    }).on("click", function () {
      var cursor = _this.model.ui.cursorMode;
      if (!d3.event.defaultPrevented && cursor !== "arrow" && cursor !== "hand") {
        _this._panZoom.zoomByIncrement(cursor, 500);
      }
    });

    this.KEY = this.model.entities.getDimension();
    this.TIMEDIM = this.model.time.getDimension();

    this.updateUIStrings();

    this.wScale = d3.scale.linear().domain(this.model.ui.datawarning.doubtDomain).range(this.model.ui.datawarning.doubtRange);

    this._labels.readyOnce();

    _this._readyOnce = true;
  },
  _frameIsValid: function _frameIsValid(frame) {
    return !(!frame || Object.keys(frame.axis_y).length === 0 || Object.keys(frame.axis_x).length === 0 || Object.keys(frame.size).length === 0);
  },
  ready: function ready() {
    var _this = this;
    this.updateUIStrings();
    var endTime = this.model.time.end;
    this.updateIndicators();
    this.updateTime();
    if (!_this.model.time.splash) {
      _this._trails.create();
    }
    this.model.marker.getFrame(this.model.time.value, function (frame, time) {
      // TODO: temporary fix for case when after data loading time changed on validation
      if (time.toString() != _this.model.time.value.toString()) {
        utils.defer(function () {
          _this.ready();
        });
        return;
      }
      if (!_this._frameIsValid(frame)) return utils.warn("ready: empty data received from marker.getFrame(). doing nothing");

      _this.frame = frame;
      _this.updateSize();
      _this.updateMarkerSizeLimits();
      _this.updateEntities();
      _this._labels.ready();
      _this.redrawDataPoints();
      _this.selectDataPoints();
      _this.updateBubbleOpacity();
      _this._updateDoubtOpacity();
      _this.zoomToMarkerMaxMin(); // includes redraw data points and trail resize
      if (!_this.model.time.splash) {
        _this._trails.run(["findVisible", "reveal", "opacityHandler"]);
      }
      if (_this.model.ui.adaptMinMaxZoom) _this._panZoom.expandCanvas();
    });
  },


  /*
   * Zoom to the min and max values given in the URL axes markers.
   */
  zoomToMarkerMaxMin: function zoomToMarkerMaxMin() {
    /*
     * Reset just the zoom values without triggering a zoom event. This ensures
     * a clean zoom state for the subsequent zoom event.
     */
    this._panZoom.resetZoomState();

    var xAxis = this.model.marker.axis_x;
    var yAxis = this.model.marker.axis_y;

    var xDomain = xAxis.getScale().domain();
    var yDomain = yAxis.getScale().domain();

    /*
     * The axes may return null when there is no value given for the zoomed
     * min and max values. In that case, fall back to the axes' domain values.
     */
    var zoomedMinX = xAxis.zoomedMin ? xAxis.zoomedMin : xDomain[0];
    var zoomedMaxX = xAxis.zoomedMax ? xAxis.zoomedMax : xDomain[1];
    var zoomedMinY = yAxis.zoomedMin ? yAxis.zoomedMin : yDomain[0];
    var zoomedMaxY = yAxis.zoomedMax ? yAxis.zoomedMax : yDomain[1];

    //by default this will apply no transition and feed values back to state
    this._panZoom.zoomToMaxMin(zoomedMinX, zoomedMaxX, zoomedMinY, zoomedMaxY, 0, "don't feed these zoom values back to state");
  },


  /*
   * UPDATE INDICATORS
   */
  updateIndicators: function updateIndicators() {
    var _this = this;

    //scales
    this.yScale = this.model.marker.axis_y.getScale();
    this.xScale = this.model.marker.axis_x.getScale();
    this.sScale = this.model.marker.size.getScale();
    this.cScale = this.model.marker.color.getScale();
    this._labels.setScales(this.xScale, this.yScale);

    this.yAxis.tickFormat(_this.model.marker.axis_y.getTickFormatter());
    this.xAxis.tickFormat(_this.model.marker.axis_x.getTickFormatter());
  },
  frameChanged: function frameChanged(frame, time) {
    //    if (time.toString() != this.model.time.value.toString()) return; // frame is outdated
    this.frame = frame;
    this.updateTime();

    this._updateDoubtOpacity();
    this._trails.run("findVisible");
    if (this.model.ui.adaptMinMaxZoom) {
      this._panZoom.expandCanvas();
    } else {
      this.redrawDataPoints();
    }
    this._trails.run("reveal", null, this.duration);
    this.tooltipMobile.classed("vzb-hidden", true);
    this._reorderEntities();
  },
  updateUIStrings: function updateUIStrings() {
    var _this = this;

    var conceptPropsY = _this.model.marker.axis_y.getConceptprops();
    var conceptPropsX = _this.model.marker.axis_x.getConceptprops();
    var conceptPropsS = _this.model.marker.size.getConceptprops();
    var conceptPropsC = _this.model.marker.color.getConceptprops();
    this.translator = this.model.locale.getTFunction();

    this.strings = {
      title: {
        Y: conceptPropsY.name,
        X: conceptPropsX.name,
        S: conceptPropsS.name,
        C: conceptPropsC.name
      },
      unit: {
        Y: conceptPropsY.unit || "",
        X: conceptPropsX.unit || "",
        S: conceptPropsS.unit || "",
        C: conceptPropsC.unit || ""
      }
    };

    var yTitle = this.yTitleEl.selectAll("text").data([0]);
    yTitle.enter().append("text");
    yTitle
    //.attr("y", "-6px")
    .on("click", function () {
      _this.parent.findChildByName("gapminder-treemenu").markerID("axis_y").alignX(_this.model.locale.isRTL() ? "right" : "left").alignY("top").updateView().toggle();
    });

    var xTitle = this.xTitleEl.selectAll("text").data([0]);
    xTitle.enter().append("text");
    xTitle.on("click", function () {
      _this.parent.findChildByName("gapminder-treemenu").markerID("axis_x").alignX(_this.model.locale.isRTL() ? "right" : "left").alignY("bottom").updateView().toggle();
    });

    var sTitle = this.sTitleEl.selectAll("text").data([0]);
    sTitle.enter().append("text");
    sTitle.attr("text-anchor", "end");

    utils.setIcon(this.dataWarningEl, _iconset.warn).select("svg").attr("width", "0px").attr("height", "0px");
    this.dataWarningEl.append("text").attr("text-anchor", "end").text(this.translator("hints/dataWarning"));

    utils.setIcon(this.yInfoEl, _iconset.question).select("svg").attr("width", "0px").attr("height", "0px");

    utils.setIcon(this.xInfoEl, _iconset.question).select("svg").attr("width", "0px").attr("height", "0px");

    //TODO: move away from UI strings, maybe to ready or ready once
    this.yInfoEl.on("click", function () {
      _this.parent.findChildByName("gapminder-datanotes").pin();
    });
    this.yInfoEl.on("mouseover", function () {
      var rect = this.getBBox();
      var coord = utils.makeAbsoluteContext(this, this.farthestViewportElement)(rect.x - 10, rect.y + rect.height + 10);
      var toolRect = _this.root.element.getBoundingClientRect();
      var chartRect = _this.element.node().getBoundingClientRect();
      _this.parent.findChildByName("gapminder-datanotes").setHook("axis_y").show().setPos(coord.x + chartRect.left - toolRect.left, coord.y);
    });
    this.yInfoEl.on("mouseout", function () {
      _this.parent.findChildByName("gapminder-datanotes").hide();
    });
    this.xInfoEl.on("click", function () {
      _this.parent.findChildByName("gapminder-datanotes").pin();
    });
    this.xInfoEl.on("mouseover", function () {
      if (_this.model.time.dragging) return;
      var rect = this.getBBox();
      var coord = utils.makeAbsoluteContext(this, this.farthestViewportElement)(rect.x - 10, rect.y + rect.height + 10);
      var toolRect = _this.root.element.getBoundingClientRect();
      var chartRect = _this.element.node().getBoundingClientRect();
      _this.parent.findChildByName("gapminder-datanotes").setHook("axis_x").show().setPos(coord.x + chartRect.left - toolRect.left, coord.y);
    });
    this.xInfoEl.on("mouseout", function () {
      if (_this.model.time.dragging) return;
      _this.parent.findChildByName("gapminder-datanotes").hide();
    });
    this.dataWarningEl.on("click", function () {
      _this.parent.findChildByName("gapminder-datawarning").toggle();
    }).on("mouseover", function () {
      _this._updateDoubtOpacity(1);
    }).on("mouseout", function () {
      _this._updateDoubtOpacity();
    });
  },
  _updateDoubtOpacity: function _updateDoubtOpacity(opacity) {
    if (opacity == null) opacity = this.wScale(+this.model.time.formatDate(this.time));
    if (this.someSelected) opacity = 1;
    this.dataWarningEl.style("opacity", opacity);
  },


  /*
   * UPDATE ENTITIES:
   * Ideally should only update when show parameters change or data changes
   */
  updateEntities: function updateEntities() {
    var _this = this;
    var KEY = this.KEY;
    var TIMEDIM = this.TIMEDIM;

    var getKeys = function getKeys(prefix) {
      prefix = prefix || "";
      return _this.model.marker.getKeys().map(function (d) {
        var pointer = {};
        pointer[KEY] = d[KEY];
        pointer[TIMEDIM] = endTime;
        pointer.sortValue = _this.frame.size[d[KEY]] || 0;
        pointer[KEY] = prefix + d[KEY];
        return pointer;
      }).sort(function (a, b) {
        return b.sortValue - a.sortValue;
      });
    };

    // get array of GEOs, sorted by the size hook
    // that makes larger bubbles go behind the smaller ones
    var endTime = this.model.time.end;
    var markers = getKeys.call(this);
    this.model.marker.setVisible(markers);

    //unselecting bubbles with no data is used for the scenario when
    //some bubbles are selected and user would switch indicator.
    //bubbles would disappear but selection would stay
    if (!this.model.time.splash) {
      this.unselectBubblesWithNoData(markers);
    }
    this.entityBubbles = this.bubbleContainer.selectAll("circle.vzb-bc-entity").data(this.model.marker.getVisible(), function (d) {
      return d[KEY];
    }); // trails have not keys

    //exit selection
    this.entityBubbles.exit().remove();

    //enter selection -- init circles
    this.entityBubbles = this.entityBubbles.enter().append("circle").attr("class", function (d) {
      return "vzb-bc-entity " + "bubble-" + d[KEY];
    }).on("mouseover", function (d, i) {
      if (utils.isTouchDevice() || _this.model.ui.cursorMode !== "arrow" && _this.model.ui.cursorMode !== "hand") return;
      _this._bubblesInteract().mouseover(d, i);
    }).on("mouseout", function (d, i) {
      if (utils.isTouchDevice() || _this.model.ui.cursorMode !== "arrow" && _this.model.ui.cursorMode !== "hand") return;

      _this._bubblesInteract().mouseout(d, i);
    }).on("click", function (d, i) {
      if (utils.isTouchDevice() || _this.model.ui.cursorMode !== "arrow" && _this.model.ui.cursorMode !== "hand") return;

      _this._bubblesInteract().click(d, i);
    }).onTap(function (d, i) {
      d3.event.stopPropagation();
      _this._bubblesInteract().click(d, i);
    }).onLongTap(function (d, i) {}).merge(this.entityBubbles);

    this._reorderEntities();
  },
  unselectBubblesWithNoData: function unselectBubblesWithNoData(entities) {
    var _this = this;
    var KEY = this.KEY;
    if (!this.model.marker.select.length) return;

    var _select = [];
    var keys = entities.map(function (d) {
      return d[KEY];
    });

    this.model.marker.select.forEach(function (d) {
      if (keys.indexOf(d[KEY]) !== -1) _select.push(d);
    });

    if (_select.length !== _this.model.marker.select.length) _this.model.marker.select = _select;
  },
  _reorderEntities: function _reorderEntities() {
    var _this = this;
    var KEY = this.KEY;
    this.bubbleContainer.selectAll(".vzb-bc-entity").sort(function (a, b) {
      var sizeA = _this.frame.size[a[KEY]];
      var sizeB = _this.frame.size[b[KEY]];

      if (typeof sizeA == "undefined" && typeof sizeB != "undefined") return -1;
      if (typeof sizeA != "undefined" && typeof sizeB == "undefined") return 1;
      if (sizeA != sizeB) return d3.descending(sizeA, sizeB);
      if (a[KEY] != b[KEY]) return d3.ascending(a[KEY], b[KEY]);
      if (typeof a.trailStartTime != "undefined" || typeof b.trailStartTime != "undefined") return typeof a.trailStartTime != "undefined" ? -1 : 1; // only lines has trailStartTime
      if (typeof a.limits != "undefined" || typeof b.limits != "undefined") return typeof a.limits != "undefined" ? -1 : 1; // only trails has attribute limits
      return d3.descending(sizeA, sizeB);
    });
  },
  _bubblesInteract: function _bubblesInteract() {
    var _this = this;
    var KEY = this.KEY;
    var TIMEDIM = this.TIMEDIM;

    return {
      mouseover: function mouseover(d, i) {
        _this.model.marker.highlightMarker(d);

        _this._labels.showCloseCross(d, true);
      },
      mouseout: function mouseout(d, i) {
        _this.model.marker.clearHighlighted();

        _this._labels.showCloseCross(d, false);
      },
      click: function click(d, i) {
        if (_this.draggingNow) return;
        var isSelected = _this.model.marker.isSelected(d);
        _this.model.marker.selectMarker(d);
        //return to highlighted state
        if (!utils.isTouchDevice()) {
          if (isSelected) _this.model.marker.highlightMarker(d);
          _this.highlightDataPoints();
        }
      }
    };
  },


  /*
   * UPDATE TIME:
   * Ideally should only update when time or data changes
   */
  updateTime: function updateTime() {
    var _this = this;

    this.time_1 = this.time == null ? this.model.time.value : this.time;
    this.time = this.model.time.value;
    this.duration = this.model.time.playing && this.time - this.time_1 > 0 ? this.model.time.delayAnimations : 0;
    this.year.setText(this.model.time.formatDate(this.time, "ui"), this.duration);
  },


  /*
   * RESIZE:
   * Executed whenever the container is resized
   */
  updateSize: function updateSize() {

    var profiles = {
      small: {
        margin: { top: 30, right: 10, left: 40, bottom: 35 },
        padding: 2,
        minRadius: 0.5,
        maxRadius: 30,
        infoElHeight: 16,
        yAxisTitleBottomMargin: 6,
        xAxisTitleBottomMargin: 4
      },
      medium: {
        margin: { top: 40, right: 15, left: 60, bottom: 55 },
        padding: 2,
        minRadius: 1,
        maxRadius: 55,
        infoElHeight: 20,
        yAxisTitleBottomMargin: 6,
        xAxisTitleBottomMargin: 5
      },
      large: {
        margin: { top: 50, right: 20, left: 60, bottom: 60 },
        padding: 2,
        minRadius: 1,
        maxRadius: 65,
        infoElHeight: 22,
        yAxisTitleBottomMargin: 6,
        xAxisTitleBottomMargin: 5,
        hideSTitle: true
      }
    };

    var presentationProfileChanges = {
      "medium": {
        margin: { top: 80, bottom: 80, left: 100 },
        yAxisTitleBottomMargin: 20,
        xAxisTitleBottomMargin: 20,
        infoElHeight: 26
      },
      "large": {
        margin: { top: 80, bottom: 100, left: 100 },
        yAxisTitleBottomMargin: 20,
        xAxisTitleBottomMargin: 20,
        infoElHeight: 32,
        hideSTitle: true
      }
    };

    var _this = this;

    this.activeProfile = this.getActiveProfile(profiles, presentationProfileChanges);
    var margin = this.activeProfile.margin;
    var infoElHeight = this.activeProfile.infoElHeight;

    //labels
    _this._labels.setCloseCrossHeight(_this.activeProfile.infoElHeight * 1.2);

    //stage
    this.height = parseInt(this.element.style("height"), 10) - margin.top - margin.bottom || 0;
    this.width = parseInt(this.element.style("width"), 10) - margin.left - margin.right || 0;

    if (this.height <= 0 || this.width <= 0) return utils.warn("Bubble chart updateSize() abort: vizabi container is too little or has display:none");

    //graph group is shifted according to margins (while svg element is at 100 by 100%)
    this.graph.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    this.year.resize(this.width, this.height);
    this.eventArea.attr("width", this.width).attr("height", Math.max(0, this.height));

    //update scales to the new range
    if (this.model.marker.axis_y.scaleType !== "ordinal") {
      this.yScale.range(this._rangeBump([this.height, 0]));
    } else {
      this.yScale.rangePoints([this.height, 0], _this.activeProfile.padding).range();
    }
    if (this.model.marker.axis_x.scaleType !== "ordinal") {
      this.xScale.range(this._rangeBump([0, this.width]));
    } else {
      this.xScale.rangePoints([0, this.width], _this.activeProfile.padding).range();
    }

    //apply scales to axes and redraw
    this.yAxis.scale(this.yScale).tickSizeInner(-this.width).tickSizeOuter(0).tickPadding(6).tickSizeMinor(-this.width, 0).labelerOptions({
      scaleType: this.model.marker.axis_y.scaleType,
      toolMargin: margin,
      limitMaxTickNumber: 6,
      bump: this.activeProfile.maxRadius / 2,
      viewportLength: this.height,
      formatter: this.model.marker.axis_y.getTickFormatter()
    });

    this.xAxis.scale(this.xScale).tickSizeInner(-this.height).tickSizeOuter(0).tickPadding(6).tickSizeMinor(-this.height, 0).labelerOptions({
      scaleType: this.model.marker.axis_x.scaleType,
      toolMargin: margin,
      bump: this.activeProfile.maxRadius / 2,
      viewportLength: this.width,
      formatter: this.model.marker.axis_x.getTickFormatter()
    });

    this.bubbleContainerCrop.attr("width", this.width).attr("height", Math.max(0, this.height));

    this.labelsContainerCrop.attr("width", this.width).attr("height", Math.max(0, this.height));

    this.xAxisElContainer.attr("width", this.width + 1).attr("height", this.activeProfile.margin.bottom + this.height).attr("y", -1).attr("x", -1);
    this.xAxisEl.attr("transform", "translate(1," + (1 + this.height) + ")");

    this.yAxisElContainer.attr("width", this.activeProfile.margin.left + this.width).attr("height", Math.max(0, this.height)).attr("x", -this.activeProfile.margin.left);
    this.yAxisEl.attr("transform", "translate(" + (this.activeProfile.margin.left - 1) + "," + 0 + ")");

    this.yAxisEl.call(this.yAxis);
    this.xAxisEl.call(this.xAxis);

    this.projectionX.attr("y1", _this.yScale.range()[0] + this.activeProfile.maxRadius / 2);
    this.projectionY.attr("x2", _this.xScale.range()[0] - this.activeProfile.maxRadius / 2);

    // reduce font size if the caption doesn't fit
    this._updateSTitle();
    this.sTitleEl.attr("transform", "translate(" + this.width + "," + 20 + ") rotate(-90)");

    var isRTL = this.model.locale.isRTL();
    this.yTitleEl.style("font-size", infoElHeight + "px").attr("transform", "translate(" + (isRTL ? this.width : 10 - this.activeProfile.margin.left) + ", -" + this.activeProfile.yAxisTitleBottomMargin + ")");

    this.xTitleEl.style("font-size", infoElHeight + "px").attr("transform", "translate(" + (isRTL ? this.width : 0) + "," + (this.height + margin.bottom - this.activeProfile.xAxisTitleBottomMargin) + ")");

    var ySeparator = this.strings.unit.Y ? ", " : "";
    var yTitleText = this.yTitleEl.select("text").text(this.strings.title.Y + ySeparator + this.strings.unit.Y);
    if (yTitleText.node().getBBox().width > this.width) yTitleText.text(this.strings.title.Y);

    var xSeparator = this.strings.unit.Y ? ", " : "";
    var xTitleText = this.xTitleEl.select("text").text(this.strings.title.X + xSeparator + this.strings.unit.X);
    if (xTitleText.node().getBBox().width > this.width - 100) xTitleText.text(this.strings.title.X);

    if (this.yInfoEl.select("svg").node()) {
      var titleBBox = this.yTitleEl.node().getBBox();
      var t = utils.transform(this.yTitleEl.node());
      var hTranslate = isRTL ? titleBBox.x + t.translateX - infoElHeight * 1.4 : titleBBox.x + t.translateX + titleBBox.width + infoElHeight * 0.4;

      this.yInfoEl.select("svg").attr("width", infoElHeight + "px").attr("height", infoElHeight + "px");
      this.yInfoEl.attr("transform", "translate(" + hTranslate + "," + (t.translateY - infoElHeight * 0.8) + ")");
    }

    if (this.xInfoEl.select("svg").node()) {
      var _titleBBox = this.xTitleEl.node().getBBox();
      var _t = utils.transform(this.xTitleEl.node());
      var _hTranslate = isRTL ? _titleBBox.x + _t.translateX - infoElHeight * 1.4 : _titleBBox.x + _t.translateX + _titleBBox.width + infoElHeight * 0.4;

      this.xInfoEl.select("svg").attr("width", infoElHeight + "px").attr("height", infoElHeight + "px");
      this.xInfoEl.attr("transform", "translate(" + _hTranslate + "," + (_t.translateY - infoElHeight * 0.8) + ")");
    }

    this._resizeDataWarning();
  },
  _updateLineEqualXY: function _updateLineEqualXY(duration) {
    var oneMeasure = this.model.marker.axis_x.which == this.model.marker.axis_y.which;
    this.lineEqualXY.classed("vzb-invisible", !oneMeasure);
    if (!oneMeasure) return;

    var min = d3.min(this.yScale.domain().concat(this.xScale.domain()));
    var max = d3.max(this.yScale.domain().concat(this.xScale.domain()));

    this.lineEqualXY.transition().duration(duration || 0).attr("y1", this.yScale(min)).attr("y2", this.yScale(max)).attr("x1", this.xScale(min)).attr("x2", this.xScale(max));
  },
  _resizeDataWarning: function _resizeDataWarning() {
    // reset font size to remove jumpy measurement
    var dataWarningText = this.dataWarningEl.select("text").style("font-size", null);

    // reduce font size if the caption doesn't fit
    var dataWarningWidth = dataWarningText.node().getBBox().width + dataWarningText.node().getBBox().height * 3;
    var remainingWidth = this.width - this.xTitleEl.node().getBBox().width - this.activeProfile.infoElHeight;
    var font = parseInt(dataWarningText.style("font-size")) * remainingWidth / dataWarningWidth;
    dataWarningText.style("font-size", dataWarningWidth > remainingWidth ? font + "px" : null);

    // position the warning icon
    var warnBB = dataWarningText.node().getBBox();
    this.dataWarningEl.select("svg").attr("width", warnBB.height * 0.75).attr("height", warnBB.height * 0.75).attr("x", -warnBB.width - warnBB.height * 1.2).attr("y", -warnBB.height * 0.65);

    this.dataWarningEl.attr("transform", "translate(" + (this.model.locale.isRTL() ? warnBB.width + warnBB.height : this.width) + "," + (this.height + this.activeProfile.margin.bottom - this.activeProfile.xAxisTitleBottomMargin) + ")");
  },
  updateMarkerSizeLimits: function updateMarkerSizeLimits() {
    var _this = this;
    var extent = this.model.marker.size.extent || [0, 1];

    if (!this.activeProfile) return utils.warn("updateMarkerSizeLimits() is called before ready(). This can happen if events get unfrozen and getFrame() still didn't return data");

    var minRadius = this.activeProfile.minRadius;
    var maxRadius = this.activeProfile.maxRadius;

    this.minRadius = Math.max(maxRadius * extent[0], minRadius);
    this.maxRadius = Math.max(maxRadius * extent[1], minRadius);

    if (this.model.marker.size.scaleType !== "ordinal") {
      this.sScale.range([utils.radiusToArea(_this.minRadius), utils.radiusToArea(_this.maxRadius)]);
    } else {
      this.sScale.rangePoints([utils.radiusToArea(_this.minRadius), utils.radiusToArea(_this.maxRadius)], _this.activeProfile.padding).range();
    }
  },
  redrawDataPointsOnlyColors: function redrawDataPointsOnlyColors() {
    var _this = this;
    if (!this.entityBubbles) return utils.warn("redrawDataPointsOnlyColors(): no entityBubbles defined. likely a premature call, fix it!");

    var valuesNow = void 0;
    var KEY = this.KEY;

    var time = this.model.time.value;

    if (this.model.ui.chart.lockNonSelected && this.someSelected) {
      time = this.model.time.parse("" + this.model.ui.chart.lockNonSelected);
    }
    this.model.marker.getFrame(time, function (valuesLocked) {
      if (!_this._frameIsValid(valuesLocked)) return utils.warn("redrawDataPointsOnlyColor: empty data received from marker.getFrame(). doing nothing");

      valuesNow = _this.frame;
      _this.entityBubbles.each(function (d, index) {

        var selected = _this.model.marker.isSelected(d);

        var valueC = selected ? valuesNow.color[d[KEY]] : valuesLocked.color[d[KEY]];

        var scaledC = valueC != null ? _this.cScale(valueC) : _this.COLOR_WHITEISH;

        d3.select(this).style("fill", scaledC);

        //update lines of labels
        if (selected) {

          var select = utils.find(_this.model.marker.select, function (f) {
            return f[KEY] == d[KEY];
          });

          var trailStartTime = _this.model.time.parse("" + select.trailStartTime);

          _this.model.marker.getFrame(trailStartTime, function (valuesTrailStart) {
            if (!valuesTrailStart) return utils.warn("redrawDataPointsOnlyColor: empty data received from marker.getFrames(). doing nothing");

            var cache = {};
            if (!_this.model.ui.chart.trails || trailStartTime - _this.time == 0) {
              cache.scaledC0 = scaledC;
            } else {
              var _valueC = valuesTrailStart.color[d[KEY]];
              cache.scaledC0 = _valueC != null ? _this.cScale(_valueC) : _this.COLOR_WHITEISH;
            }

            _this._labels.updateLabelOnlyColor(d, index, cache);
          });
        }
      });
    });
  },
  redrawDataPointsOnlySize: function redrawDataPointsOnlySize() {
    var _this = this;

    var valuesNow = void 0;
    var KEY = this.KEY;

    var time = this.model.time.value;

    if (this.model.ui.chart.lockNonSelected && this.someSelected) {
      time = this.model.time.parse("" + this.model.ui.chart.lockNonSelected);
    }
    this.model.marker.getFrame(time, function (valuesLocked) {
      if (!_this._frameIsValid(valuesLocked)) return utils.warn("redrawDataPointsOnlySize: empty data received from marker.getFrame(). doing nothing");

      valuesNow = _this.frame;
      _this.entityBubbles.each(function (d, index) {

        var selected = _this.model.marker.isSelected(d);

        var valueS = selected ? valuesNow.size[d[KEY]] : valuesLocked.size[d[KEY]];
        if (valueS == null) return;

        var scaledS = utils.areaToRadius(_this.sScale(valueS));
        d3.select(this).attr("r", scaledS);

        //update lines of labels
        if (selected) {

          var select = utils.find(_this.model.marker.select, function (f) {
            return f[KEY] == d[KEY];
          });

          var trailStartTime = _this.model.time.parse("" + select.trailStartTime);

          _this.model.marker.getFrame(trailStartTime, function (valuesTrailStart) {
            if (!valuesTrailStart) return utils.warn("redrawDataPointsOnlySize: empty data received from marker.getFrames(). doing nothing");

            var cache = {};
            if (!_this.model.ui.chart.trails || trailStartTime - _this.time == 0) {
              cache.scaledS0 = scaledS;
            } else {
              cache.scaledS0 = utils.areaToRadius(_this.sScale(valuesTrailStart.size[d[KEY]]));
            }

            _this._labels.updateLabelOnlyPosition(d, index, cache);
          });
        }
      });
    });
  },


  /*
   * REDRAW DATA POINTS:
   * Here plotting happens
   * debouncing to improve performance: events might trigger it more than 1x
   */
  redrawDataPoints: function redrawDataPoints(duration) {
    var _this = this;
    var KEY = this.KEY;
    if (duration == null) duration = _this.duration;

    if (this.model.ui.chart.lockNonSelected && this.someSelected) {
      var time = this.model.time.parse("" + this.model.ui.chart.lockNonSelected);

      //get values for locked frames
      this.model.marker.getFrame(time, function (lockedFrame) {
        if (!lockedFrame) return utils.warn("redrawDataPoints: empty data received from marker.getFrames(). doing nothing");

        // each bubble
        _this.entityBubbles.each(function (d, index) {
          var frame = _this.model.marker.isSelected(d) ? _this.frame : lockedFrame;
          _this._updateBubble(d, frame, index, d3.select(this), duration);
        });
      });
    } else {
      // each bubble
      _this.entityBubbles.each(function (d, index) {
        _this._updateBubble(d, _this.frame, index, d3.select(this), duration);
      });
    }

    this._updateLineEqualXY(duration);
  },


  //redraw Data Points
  _updateBubble: function _updateBubble(d, values, index, view, duration) {
    var _this = this;
    var KEY = this.KEY;

    var showhide = false;

    var valueY = values.axis_y[d[KEY]];
    var valueX = values.axis_x[d[KEY]];
    var valueS = values.size[d[KEY]];
    var valueL = values.label[d[KEY]];
    var valueC = values.color[d[KEY]];
    var valueLST = values.size_label[d[KEY]];

    // check if fetching data succeeded
    if (!valueL && valueL !== 0 || !valueY && valueY !== 0 || !valueX && valueX !== 0 || !valueS && valueS !== 0) {
      // if entity is missing data it should hide
      if (!d.hidden) {
        d.hidden = true;
        showhide = true;
      }

      if (showhide) {
        if (duration) {
          var opacity = view.style("opacity");
          view.transition().duration(duration).ease(d3.easeExp).style("opacity", 0).on("end", function () {
            //to avoid transition from null state add class with a delay
            view.classed("vzb-invisible", d.hidden);
            view.style("opacity", opacity);
          });
        } else {
          //immediately hide the bubble
          view.classed("vzb-invisible", d.hidden);
        }
      }
    } else {
      if (d.hidden || view.classed("vzb-invisible")) {
        d.hidden = false;
        showhide = true;
      }

      // if entity has all the data we update the visuals
      var scaledS = utils.areaToRadius(_this.sScale(valueS));

      view.style("fill", valueC != null ? _this.cScale(valueC) : _this.COLOR_WHITEISH);

      if (duration) {
        if (showhide) {
          var _opacity = view.style("opacity");
          view.classed("vzb-invisible", d.hidden);
          view.style("opacity", 0).attr("cy", _this.yScale(valueY)).attr("cx", _this.xScale(valueX)).attr("r", scaledS).transition().duration(duration).ease(d3.easeExp).style("opacity", _opacity);
        } else {
          view.transition().duration(duration).ease(d3.easeLinear).attr("cy", _this.yScale(valueY)).attr("cx", _this.xScale(valueX)).attr("r", scaledS);
        }
      } else {

        //interrupt the ongoing transition and immediately do the visual updates
        view.interrupt().attr("cy", _this.yScale(valueY)).attr("cx", _this.xScale(valueX)).attr("r", scaledS).transition();

        //show entity if it was hidden
        if (showhide) view.classed("vzb-invisible", d.hidden);
      }

      if (this.model.time.record) _this._export.write({
        type: "circle",
        id: d[KEY],
        time: this.model.time.value.getUTCFullYear(),
        fill: valueC != null ? _this.cScale(valueC) : _this.COLOR_WHITEISH,
        cx: _this.xScale(valueX),
        cy: _this.yScale(valueY),
        r: scaledS
      });
    } // data exists
    _this._updateLabel(d, index, valueX, valueY, valueS, valueC, valueL, valueLST, duration, showhide);
  },
  _updateLabel: function _updateLabel(d, index, valueX, valueY, valueS, valueC, valueL, valueLST, duration, showhide) {
    var _this = this;
    var KEY = this.KEY;

    // only for selected markers
    if (_this.model.marker.isSelected(d)) {

      var cache = {};

      var select = utils.find(_this.model.marker.select, function (f) {
        return f[KEY] == d[KEY];
      });

      var time = _this.model.time.formatDate(_this.time);
      if (!this.model.ui.chart.trails || select.trailStartTime == time || select.trailStartTime == null) {
        if (this.model.ui.chart.trails && select.trailStartTime == null) select.trailStartTime = time; // need only when trailStartTime == null

        cache.labelX0 = valueX;
        cache.labelY0 = valueY;
        cache.scaledC0 = valueC != null ? _this.cScale(valueC) : _this.COLOR_WHITEISH, cache.scaledS0 = valueS || valueS === 0 ? utils.areaToRadius(_this.sScale(valueS)) : null;
      }

      var trailStartTime = _this.model.time.parse("" + select.trailStartTime);

      var labelText = valueL + (_this.model.ui.chart.trails ? " " + select.trailStartTime : "");

      if (showhide && d.hidden && _this.model.ui.chart.trails && trailStartTime && trailStartTime < _this.time) showhide = false;
      if (d.hidden && !_this.model.ui.chart.trails) showhide = true;

      this._labels.updateLabel(d, index, cache, valueX, valueY, valueS, valueC, labelText, valueLST, duration, showhide);
    }
  },
  _formatSTitleValues: function _formatSTitleValues(titleS, titleC) {
    var _this = this;
    var unitS = this.strings.unit.S;
    var unitC = this.strings.unit.C;

    var formatterS = this.model.marker.size.getTickFormatter();
    var formatterC = this.model.marker.color.getTickFormatter();

    //resolve labels for colors via the color legend
    if (this.model.marker.color.isDiscrete() && this.model.marker.color.use !== "constant" && titleC && this.model.marker.color.getColorlegendMarker()) {
      titleC = this.model.marker.color.getColorlegendMarker().label.getItems()[titleC] || "";
    }

    return [formatterS(titleS) + " " + unitS, titleC || titleC === 0 ? formatterC(titleC) + " " + unitC : this.translator("hints/nodata")];
  },
  _updateSTitle: function _updateSTitle(titleS, titleC) {

    // vertical text about size and color
    if (this.activeProfile.hideSTitle && this.model.ui.dialogs.sidebar.indexOf("colors") > -1 && this.model.ui.dialogs.sidebar.indexOf("size") > -1) {
      this.sTitleEl.classed("vzb-invisible", true);
      return;
    }
    if (this.sTitleEl.classed("vzb-invisible")) {
      this.sTitleEl.classed("vzb-invisible", false);
    }
    var sTitleContentON = this.model.marker.size.use !== "constant";
    var cTitleContentON = this.model.marker.color.use !== "constant";
    var sTitleText = this.sTitleEl.select("text")
    // reset font size to remove jumpy measurement
    .style("font-size", null).text((sTitleContentON ? this.translator("buttons/size") + ": " + (titleS ? titleS : this.strings.title.S) : "") + (sTitleContentON && cTitleContentON ? ", " : "") + (cTitleContentON ? this.translator("buttons/colors") + ": " + (titleC ? titleC : this.strings.title.C) : ""));
    var sTitleWidth = sTitleText.node().getBBox().width;
    var remainigHeight = this.height - 30;
    var font = parseInt(sTitleText.style("font-size")) * remainigHeight / sTitleWidth;
    sTitleText.style("font-size", sTitleWidth > remainigHeight ? font + "px" : null);
  },
  selectDataPoints: function selectDataPoints() {
    var _this = this;
    var KEY = this.KEY;

    if (utils.isTouchDevice()) {
      _this.model.marker.clearHighlighted();
      _this._labels.showCloseCross(null, false);
    } else {
      //hide tooltip
      _this._setTooltip();
      _this._setBubbleCrown();
    }

    _this.someSelected = _this.model.marker.select.length > 0;
    _this.nonSelectedOpacityZero = false;
  },
  _setBubbleCrown: function _setBubbleCrown(x, y, r, glow, skipInnerFill) {
    if (x != null) {
      this.bubbleCrown.classed("vzb-hidden", false);
      this.bubbleCrown.select(".vzb-crown").attr("cx", x).attr("cy", y).attr("r", r).attr("fill", skipInnerFill ? "none" : glow);
      this.bubbleCrown.selectAll(".vzb-crown-glow").attr("cx", x).attr("cy", y).attr("r", r + 10).attr("stroke", glow);
    } else {
      this.bubbleCrown.classed("vzb-hidden", true);
    }
  },
  _setTooltip: function _setTooltip(tooltipText, x, y, offset, glow) {
    if (tooltipText) {
      var xPos = void 0,
          yPos = void 0,
          xSign = -1,
          ySign = -1,
          xOffset = 0,
          yOffset = 0;

      if (offset) {
        xOffset = offset * 0.71; // .71 - sin and cos for 315
        yOffset = offset * 0.71;
      }
      //position tooltip
      this.tooltip.classed("vzb-hidden", false)
      //.attr("style", "left:" + (mouse[0] + 50) + "px;top:" + (mouse[1] + 50) + "px")
      .selectAll("text").text(tooltipText);

      var contentBBox = this.tooltip.select("text").node().getBBox();
      if (x - xOffset - contentBBox.width < 0) {
        xSign = 1;
        x += contentBBox.width + 5; // corrective to the block Radius and text padding
      } else {
        x -= 5; // corrective to the block Radius and text padding
      }
      if (y - yOffset - contentBBox.height < 0) {
        ySign = 1;
        y += contentBBox.height;
      } else {
        y -= 11; // corrective to the block Radius and text padding
      }
      if (offset) {
        xPos = x + xOffset * xSign;
        yPos = y + yOffset * ySign; // 5 and 11 - corrective to the block Radius and text padding
      } else {
        xPos = x + xOffset * xSign; // .71 - sin and cos for 315
        yPos = y + yOffset * ySign; // 5 and 11 - corrective to the block Radius and text padding
      }
      this.tooltip.attr("transform", "translate(" + xPos + "," + yPos + ")");

      this.tooltip.selectAll("rect").attr("width", contentBBox.width + 8).attr("height", contentBBox.height * 1.2).attr("x", -contentBBox.width - 4).attr("y", -contentBBox.height * 0.85).attr("rx", contentBBox.height * 0.2).attr("ry", contentBBox.height * 0.2);

      this.tooltip.select(".vzb-tooltip-glow").attr("stroke", glow);
    } else {
      this.tooltip.classed("vzb-hidden", true);
    }
  },


  /*
   * Shows and hides axis projections
   */
  _axisProjections: function _axisProjections(d) {
    var _this = this;
    var TIMEDIM = this.TIMEDIM;
    var KEY = this.KEY;

    if (d != null) {

      this.model.marker.getFrame(d[TIMEDIM], function (values) {
        var valueY = values.axis_y[d[KEY]];
        var valueX = values.axis_x[d[KEY]];
        var valueS = values.size[d[KEY]];
        var radius = utils.areaToRadius(_this.sScale(valueS));

        if (!valueY && valueY !== 0 || !valueX && valueX !== 0 || !valueS && valueS !== 0) return;

        if (_this.model.ui.chart.whenHovering.showProjectionLineX && _this.xScale(valueX) > 0 && _this.xScale(valueX) < _this.width && _this.yScale(valueY) + radius < _this.height) {
          _this.projectionX.style("opacity", 1).attr("y2", _this.yScale(valueY) + radius).attr("x1", _this.xScale(valueX)).attr("x2", _this.xScale(valueX));
        }

        if (_this.model.ui.chart.whenHovering.showProjectionLineY && _this.yScale(valueY) > 0 && _this.yScale(valueY) < _this.height && _this.xScale(valueX) - radius > 0) {
          _this.projectionY.style("opacity", 1).attr("y1", _this.yScale(valueY)).attr("y2", _this.yScale(valueY)).attr("x1", _this.xScale(valueX) - radius);
        }

        if (_this.model.ui.chart.whenHovering.higlightValueX) _this.xAxisEl.call(_this.xAxis.highlightValue(valueX));

        if (_this.model.ui.chart.whenHovering.higlightValueY) _this.yAxisEl.call(_this.yAxis.highlightValue(valueY));
      });
    } else {

      this.projectionX.style("opacity", 0);
      this.projectionY.style("opacity", 0);
      this.xAxisEl.call(this.xAxis.highlightValue("none"));
      this.yAxisEl.call(this.yAxis.highlightValue("none"));
    }
  },


  /*
   * Highlights all hovered bubbles
   */
  highlightDataPoints: function highlightDataPoints() {
    var _this = this;
    var TIMEDIM = this.TIMEDIM;
    var KEY = this.KEY;

    this.someHighlighted = this.model.marker.highlight.length > 0;

    this.updateBubbleOpacity();

    if (this.model.marker.highlight.length === 1) {
      var d = utils.clone(this.model.marker.highlight[0]);

      if (_this.model.ui.chart.lockNonSelected && _this.someSelected && !_this.model.marker.isSelected(d)) {
        d[TIMEDIM] = _this.model.time.parse("" + _this.model.ui.chart.lockNonSelected);
      } else {
        d[TIMEDIM] = _this.model.time.parse("" + d.trailStartTime) || _this.time;
      }

      _this.model.marker.getFrame(d[TIMEDIM], function (values) {
        if (!values) return;
        var x = _this.xScale(values.axis_x[d[KEY]]);
        var y = _this.yScale(values.axis_y[d[KEY]]);
        var s = utils.areaToRadius(_this.sScale(values.size[d[KEY]]));
        var c = values.color[d[KEY]] != null ? _this.cScale(values.color[d[KEY]]) : _this.COLOR_WHITEISH;
        var entityOutOfView = false;

        var titles = _this._formatSTitleValues(values.size[d[KEY]], values.color[d[KEY]]);
        _this._updateSTitle(titles[0], titles[1]);
        if (x + s < 0 || x - s > _this.width || y + s < 0 || y - s > _this.height) {
          entityOutOfView = true;
        }

        //show tooltip
        var text = "";
        var hoverTrail = false;
        if (_this.model.marker.isSelected(d) && _this.model.ui.chart.trails) {
          text = _this.model.time.formatDate(_this.time);
          var _selectedData = utils.find(_this.model.marker.select, function (f) {
            return f[KEY] == d[KEY];
          });
          hoverTrail = text !== _selectedData.trailStartTime && !d3.select(d3.event.target).classed("bubble-" + d[KEY]);
          text = text !== _selectedData.trailStartTime && _this.time === d[TIMEDIM] ? text : "";
        } else {
          text = _this.model.marker.isSelected(d) ? "" : values.label[d[KEY]];
        }

        _this._labels.highlight(null, false);
        _this._labels.highlight(d, true);
        if (_this.model.marker.isSelected(d)) {
          var skipCrownInnerFill = !d.trailStartTime || d.trailStartTime == _this.model.time.formatDate(_this.time);
          _this._setBubbleCrown(x, y, s, c, skipCrownInnerFill);
        }

        if (!entityOutOfView && !hoverTrail) {
          _this._axisProjections(d);
        }

        //set tooltip and show axis projections
        if (text && !entityOutOfView && !hoverTrail) {
          _this._setTooltip(text, x, y, s + 3, c);
        }

        var selectedData = utils.find(_this.model.marker.select, function (f) {
          return f[KEY] == d[KEY];
        });
        if (selectedData) {
          var clonedSelectedData = utils.clone(selectedData);
          //change opacity to OPACITY_HIGHLT = 1.0;
          clonedSelectedData.opacity = 1.0;
          _this._trails.run(["opacityHandler"], clonedSelectedData);
        }
      });
    } else {
      this._axisProjections();
      this._trails.run(["opacityHandler"]);
      //hide tooltip
      _this._updateSTitle();
      this._setTooltip();
      this._setBubbleCrown();
      this._labels.highlight(null, false);
    }
  },
  updateBubbleOpacity: function updateBubbleOpacity(duration) {
    var _this = this;
    //if(!duration)duration = 0;

    var OPACITY_HIGHLT = 1.0;
    var OPACITY_HIGHLT_DIM = this.model.marker.opacityHighlightDim;
    var OPACITY_SELECT = this.model.marker.opacityRegular;
    var OPACITY_REGULAR = this.model.marker.opacityRegular;
    var OPACITY_SELECT_DIM = this.model.marker.opacitySelectDim;

    this.entityBubbles
    //.transition().duration(duration)
    .style("opacity", function (d) {

      if (_this.someHighlighted) {
        //highlight or non-highlight
        if (_this.model.marker.isHighlighted(d)) return OPACITY_HIGHLT;
      }

      if (_this.someSelected) {
        //selected or non-selected
        return _this.model.marker.isSelected(d) ? OPACITY_SELECT : OPACITY_SELECT_DIM;
      }

      if (_this.someHighlighted) return OPACITY_HIGHLT_DIM;

      return OPACITY_REGULAR;
    });

    var nonSelectedOpacityZero = _this.model.marker.opacitySelectDim < 0.01;

    // when pointer events need update...
    if (nonSelectedOpacityZero != this.nonSelectedOpacityZero) {
      this.entityBubbles.style("pointer-events", function (d) {
        return !_this.someSelected || !nonSelectedOpacityZero || _this.model.marker.isSelected(d) ? "visible" : "none";
      });
    }

    this.nonSelectedOpacityZero = _this.model.marker.opacitySelectDim < 0.01;
  }
});

exports.default = BubbleChartComp;

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _class = __webpack_require__(16);

var _class2 = _interopRequireDefault(_class);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = _class2.default.extend({
  init: function init(context) {
    this.context = context;

    this.dragRectangle = d3.drag();
    this.zoomer = d3.zoom();

    // this.dragLock = false;

    this.dragRectangle.subject(this.dragSubject()).on("start", this.drag().start).on("drag", this.drag().go).on("end", this.drag().stop);

    this.zoomer.filter(this.zoomFilter()).on("start", this.zoom().start).on("zoom", this.zoom().go).on("end", this.zoom().stop);

    this.zoomer.ratioX = 1;
    this.zoomer.ratioY = 1;

    context._zoomedXYMinMax = { axis_x: { zoomedMin: null, zoomedMax: null }, axis_y: { zoomedMin: null, zoomedMax: null } };
  },
  dragSubject: function dragSubject() {
    var _this = this.context;
    var self = this;

    return function (d) {
      /*
       * Do not drag if the Ctrl key, Meta key, or plus cursor mode is
       * not enabled. Also do not drag if zoom-pinching on touchmove
       * events.
       */
      if (!(d3.event.sourceEvent.ctrlKey || d3.event.sourceEvent.metaKey || _this.ui.cursorMode === "plus") || _this.ui.cursorMode === "minus" || (d3.event.sourceEvent.type === "touchmove" || d3.event.sourceEvent.type === "touchstart") && (d3.event.sourceEvent.touches.length > 1 || d3.event.sourceEvent.targetTouches.length > 1)) {
        return null;
      }

      return {
        x: d3.mouse(this)[0],
        y: d3.mouse(this)[1]
      };
    };
  },
  drag: function drag() {
    var _this = this.context;
    var self = this;

    return {
      start: function start(d, i) {
        /*
        * Do not drag if the Ctrl key, Meta key, or plus cursor mode is
        * not enabled. Also do not drag if zoom-pinching on touchmove
        * events.
        */
        //   if(!(d3.event.sourceEvent.ctrlKey || d3.event.sourceEvent.metaKey ||
        //          _this.ui.cursorMode === "plus") ||
        //          (d3.event.sourceEvent.type === "touchmove" || d3.event.sourceEvent.type === "touchstart") &&
        //          (d3.event.sourceEvent.touches.length > 1 || d3.event.sourceEvent.targetTouches.length > 1)) {
        //         return;
        //     }

        // self.dragLock = true;
        this.origin = {
          x: d3.mouse(this)[0],
          y: d3.mouse(this)[1]
        };
        _this.zoomRect.classed("vzb-invisible", false);
      },
      go: function go(d, i) {
        /*
         * Cancel drag if drag lock is false, or when zoom-pinching via
         * touchmove events.
         */
        // if (!self.dragLock || (d3.event.sourceEvent.type === "touchmove" || d3.event.sourceEvent.type === "touchstart") &&
        //             (d3.event.sourceEvent.touches.length > 1 || d3.event.sourceEvent.targetTouches.length > 1)) {
        //   self.dragLock = false;

        //   _this.zoomRect
        //     .attr("width", 0)
        //     .attr("height", 0)
        //     .classed("vzb-invisible", true);

        //   return;
        // }

        var origin = this.origin;
        var mouse = {
          x: d3.event.x,
          y: d3.event.y
        };

        _this.zoomRect.attr("x", Math.min(mouse.x, origin.x)).attr("y", Math.min(mouse.y, origin.y)).attr("width", Math.abs(mouse.x - origin.x)).attr("height", Math.abs(mouse.y - origin.y));
      },
      stop: function stop(e) {
        // if (!self.dragLock) return;
        // self.dragLock = false;

        _this.zoomRect.attr("width", 0).attr("height", 0).classed("vzb-invisible", true);

        this.target = {
          x: d3.mouse(this)[0],
          y: d3.mouse(this)[1]
        };
        if (Math.abs(this.origin.x - this.target.x) < 10 || Math.abs(this.origin.y - this.target.y) < 10) return;

        /*
         * Only compensate for dragging when the Ctrl key or Meta key
         * are pressed, or if the cursorMode is not in plus mode.
         */
        var compensateDragging = d3.event.sourceEvent.ctrlKey || d3.event.sourceEvent.metaKey || _this.ui.cursorMode === "plus";

        self._zoomOnRectangle(d3.select(this), this.origin.x, this.origin.y, this.target.x, this.target.y, compensateDragging, 500);
      }
    };
  },
  zoomFilter: function zoomFilter() {
    var _this = this.context;
    var self = this;

    return function (d) {
      var event = d3.event;

      if (event.ctrlKey || event.metaKey) return false;

      // Cancel drag lock when zoom-pinching via touchmove events.
      if ((event.type === "touchmove" || event.type === "touchstart") && (event.touches.length > 1 || event.targetTouches.length > 1)) return true;

      if ((event.type === "wheel" || event.type === "mousewheel") && _this.ui.zoomOnScrolling) {
        // if (_this.scrollableAncestor) {
        //   _this.scrollableAncestor.scrollTop -= (event.deltaY || -event.wheelDelta);
        // }
        // d3.event.scale = null;
        //zoomer.scale(this.savedScale);
        return true;
      }

      if ((event.type === "mousedown" || event.type === "touchstart") && _this.ui.cursorMode !== "plus" && _this.ui.cursorMode !== "minus" && (_this.ui.panWithArrow || _this.ui.cursorMode === "hand")) return true;

      return false;
    };
  },
  zoom: function zoom() {
    var _this = this.context;
    var zoomer = this.zoomer;
    var self = this;

    return {
      start: function start() {
        //this.savedScale = zoomer.scale;
        if (_this.ui.cursorMode !== "plus" && _this.ui.cursorMode !== "minus") {
          _this.chartSvg.classed("vzb-zooming", true);
        }

        _this.model._data.marker.clearHighlighted();
        _this._setTooltip();
      },
      go: function go() {

        var sourceEvent = d3.event.sourceEvent;

        //if (sourceEvent != null && (sourceEvent.ctrlKey || sourceEvent.metaKey)) return;

        // Cancel drag lock when zoom-pinching via touchmove events.
        // if (sourceEvent !== null &&
        //             (sourceEvent.type === "touchmove" || sourceEvent.type === "touchstart") &&
        //             (sourceEvent.touches.length > 1 || sourceEvent.targetTouches.length > 1)) {
        //   self.dragLock = false;
        // }

        //if (self.dragLock) return;

        //send the event to the page if fully zoomed our or page not scrolled into view
        //
        //                    if(d3.event.scale == 1)
        //
        //                    if(utils.getViewportPosition(_this.element.node()).y < 0 && d3.event.scale > 1) {
        //                        _this.scrollableAncestor.scrollTop += d3.event.sourceEvent.deltaY;
        //                        return;
        //                    }
        /*
         * Do not zoom on the chart if the scroll event is a wheel
         * scroll. Instead, redirect the scroll event to the scrollable
         * ancestor
         */
        // if (sourceEvent != null && (sourceEvent.type === "wheel" || sourceEvent.type === "mousewheel") &&
        //             !_this.ui.zoomOnScrolling) {
        //   if (_this.scrollableAncestor) {
        //     _this.scrollableAncestor.scrollTop += (sourceEvent.deltaY || -sourceEvent.wheelDelta);
        //   }
        //   d3.event.scale = null;
        //             //zoomer.scale(this.savedScale);
        //   this.quitZoom = true;
        //   return;
        // }
        // this.quitZoom = false;

        //_this.model._data.marker.clearHighlighted();
        //_this._setTooltip();

        //var transform = d3.zoomTransform(self.zoomSelection.node())
        //  .translate(, )
        //.scale(d3.event.transform.k);
        var zoom = d3.event.transform.k;

        var pan = [d3.event.transform.x, d3.event.transform.y]; //d3.event.translate;
        var ratioY = zoomer.ratioY;
        var ratioX = zoomer.ratioX;

        _this.draggingNow = true;

        //value protections and fallbacks
        if (isNaN(zoom) || zoom == null) zoom = zoomer.scale;
        if (isNaN(zoom) || zoom == null) zoom = 1;

        //TODO: this is a patch to fix #221. A proper code review of zoom and zoomOnRectangle logic is needed
        /*
         * Mouse wheel and touchmove events set the zoom value
         * independently of axis ratios. If the zoom event was triggered
         * by a mouse wheel event scrolling down or touchmove event with
         * more than 1 contact that sets zoom to 1, then set the axis
         * ratios to 1 as well, which will fully zoom out.
         */
        if (zoom === 1 && sourceEvent !== null && ((sourceEvent.type === "wheel" || sourceEvent.type === "mousewheel") && (sourceEvent.deltaY || -sourceEvent.wheelDelta) > 0 || sourceEvent.type === "touchmove" && sourceEvent.touches.length > 1)) {
          zoomer.ratioX = 1;
          ratioX = 1;
          zoomer.ratioY = 1;
          ratioY = 1;
        }

        //                if(isNaN(pan[0]) || isNaN(pan[1]) || pan[0] == null || pan[1] == null) pan = zoomer.translate();
        if (isNaN(pan[0]) || isNaN(pan[1]) || pan[0] == null || pan[1] == null) pan = [0, 0];

        // limit the zooming, so that it never goes below min value of zoom for any of the axes
        var minZoomScale = zoomer.scaleExtent()[0];
        if (zoom * ratioY < minZoomScale) {
          ratioY = minZoomScale / zoom;
          zoomer.ratioY = ratioY;
        }
        if (zoom * ratioX < minZoomScale) {
          ratioX = minZoomScale / zoom;
          zoomer.ratioX = ratioX;
        }

        var zoomXOut = zoom * ratioX < 1;
        var zoomYOut = zoom * ratioY < 1;

        //limit the panning, so that we are never outside the possible range
        if (!zoomXOut) {
          if (pan[0] > 0) pan[0] = 0;
          if (pan[0] < (1 - zoom * ratioX) * _this.width) pan[0] = (1 - zoom * ratioX) * _this.width;
        } else {
          if (pan[0] < 0) pan[0] = 0;
          if (pan[0] > (1 - zoom * ratioX) * _this.width) pan[0] = (1 - zoom * ratioX) * _this.width;
        }

        if (!zoomYOut) {
          if (pan[1] > 0) pan[1] = 0;
          if (pan[1] < (1 - zoom * ratioY) * _this.height) pan[1] = (1 - zoom * ratioY) * _this.height;
        } else {
          if (pan[1] < 0) pan[1] = 0;
          if (pan[1] > (1 - zoom * ratioY) * _this.height) pan[1] = (1 - zoom * ratioY) * _this.height;
        }

        var xPanOffset = _this.width * zoom * ratioX;
        var yPanOffset = _this.height * zoom * ratioY;

        var xRange = [0 * zoom * ratioX + pan[0], xPanOffset + pan[0]];
        var yRange = [yPanOffset + pan[1], 0 * zoom * ratioY + pan[1]];

        var xRangeBumped = _this._rangeBump(xRange);
        var yRangeBumped = _this._rangeBump(yRange);

        /*
         * Shift xRange and yRange by the difference between the bumped
         * ranges, which is scaled by the zoom factor. This accounts for
         * the range bump, which controls a gutter around the
         * bubblechart, while correctly zooming.
         */
        var xRangeMinOffset = (xRangeBumped[0] - xRange[0]) * zoom * ratioX;
        var xRangeMaxOffset = (xRangeBumped[1] - xRange[1]) * zoom * ratioX;

        var yRangeMinOffset = (yRangeBumped[0] - yRange[0]) * zoom * ratioY;
        var yRangeMaxOffset = (yRangeBumped[1] - yRange[1]) * zoom * ratioY;

        xRange[0] += xRangeMinOffset;
        xRange[1] += xRangeMaxOffset;

        yRange[0] += yRangeMinOffset;
        yRange[1] += yRangeMaxOffset;

        // Calculate the maximum xRange and yRange available.
        var xRangeBounds = [0, _this.width];
        var yRangeBounds = [_this.height, 0];

        var xRangeBoundsBumped = _this._rangeBump(xRangeBounds);
        var yRangeBoundsBumped = _this._rangeBump(yRangeBounds);

        /*
         * Set the pan to account for the range bump by subtracting
         * offsets and preventing panning past the range bump gutter.
         */
        if (!zoomXOut) {
          if (xRange[0] > xRangeBoundsBumped[0]) pan[0] = xRangeBoundsBumped[0] - xRangeMinOffset;
          if (xRange[1] < xRangeBoundsBumped[1]) pan[0] = xRangeBoundsBumped[1] - xRangeMaxOffset - xPanOffset;
        } else {
          if (xRange[0] < xRangeBoundsBumped[0]) pan[0] = xRangeBoundsBumped[0] - xRangeMinOffset;
          if (xRange[1] > xRangeBoundsBumped[1]) pan[0] = xRangeBoundsBumped[1] - xRangeMaxOffset - xPanOffset;
        }

        if (!zoomYOut) {
          if (yRange[0] < yRangeBoundsBumped[0]) pan[1] = yRangeBoundsBumped[0] - yRangeMinOffset - yPanOffset;
          if (yRange[1] > yRangeBoundsBumped[1]) pan[1] = yRangeBoundsBumped[1] - yRangeMaxOffset;
        } else {
          if (yRange[0] > yRangeBoundsBumped[0]) pan[1] = yRangeBoundsBumped[0] - yRangeMinOffset - yPanOffset;
          if (yRange[1] < yRangeBoundsBumped[1]) pan[1] = yRangeBoundsBumped[1] - yRangeMaxOffset;
        }

        //zoomer.translate = pan;
        //self.zoomSelection.property("__zoom", d3.zoomIdentity.translate(pan[0], pan[1]).scale(zoom));

        /*
         * Clamp the xRange and yRange by the amount that the bounds
         * that are range bumped.
         *
         * Additionally, take the amount clamped on the end of the range
         * and either subtract or add it to the range's other end. This
         * prevents visible stretching of the range when only panning.
         */
        if (!zoomXOut) {
          if (xRange[0] > xRangeBoundsBumped[0]) {
            xRange[1] -= Math.abs(xRange[0] - xRangeBoundsBumped[0]);
            xRange[0] = xRangeBoundsBumped[0];
          }

          if (xRange[1] < xRangeBoundsBumped[1]) {
            xRange[0] += Math.abs(xRange[1] - xRangeBoundsBumped[1]);
            xRange[1] = xRangeBoundsBumped[1];
          }
        } else {
          if (xRange[0] < xRangeBoundsBumped[0]) {
            xRange[1] += Math.abs(xRange[0] - xRangeBoundsBumped[0]);
            xRange[0] = xRangeBoundsBumped[0];
          }

          if (xRange[1] > xRangeBoundsBumped[1]) {
            xRange[0] -= Math.abs(xRange[1] - xRangeBoundsBumped[1]);
            xRange[1] = xRangeBoundsBumped[1];
          }
        }

        if (!zoomYOut) {
          if (yRange[0] < yRangeBoundsBumped[0]) {
            yRange[1] += Math.abs(yRange[0] - yRangeBoundsBumped[0]);
            yRange[0] = yRangeBoundsBumped[0];
          }

          if (yRange[1] > yRangeBoundsBumped[1]) {
            yRange[0] -= Math.abs(yRange[1] - yRangeBoundsBumped[1]);
            yRange[1] = yRangeBoundsBumped[1];
          }
        } else {
          if (yRange[0] > yRangeBoundsBumped[0]) {
            yRange[1] -= Math.abs(yRange[0] - yRangeBoundsBumped[0]);
            yRange[0] = yRangeBoundsBumped[0];
          }

          if (yRange[1] < yRangeBoundsBumped[1]) {
            yRange[0] += Math.abs(yRange[1] - yRangeBoundsBumped[1]);
            yRange[1] = yRangeBoundsBumped[1];
          }
        }

        if (_this.model.marker.axis_x.scaleType === "ordinal") {
          _this.xScale.rangeBands(xRange);
        } else {
          _this.xScale.range(xRange);
        }

        if (_this.model.marker.axis_y.scaleType === "ordinal") {
          _this.yScale.rangeBands(yRange);
        } else {
          _this.yScale.range(yRange);
        }

        var formatter = function formatter(n) {
          return utils.isDate(n) ? n : d3.round(n, 2);
        };

        var zoomedXRange = xRangeBoundsBumped;
        var zoomedYRange = yRangeBoundsBumped;

        /*
         * Set the zoomed min/max to the correct value depending on if the
         * min/max values lie within the range bound regions.
         */
        /*
                        if(!zoomXOut) {
                            zoomedXRange[0] = xRangeBounds[0] > xRange[0] ? xRangeBounds[0] : xRange[0];
                            zoomedXRange[1] = xRangeBounds[1] < xRange[1] ? xRangeBounds[1] : xRange[1];
                        }
        
                        if(!zoomYOut) {
                            zoomedYRange[0] = yRangeBounds[0] < yRange[0] ? yRangeBounds[0] : yRange[0];
                            zoomedYRange[1] = yRangeBounds[1] > yRange[1] ? yRangeBounds[1] : yRange[1];
                        }
        */

        _this._zoomedXYMinMax = {
          axis_x: {
            zoomedMin: formatter(_this.xScale.invert(zoomedXRange[0])),
            zoomedMax: formatter(_this.xScale.invert(zoomedXRange[1]))
          },
          axis_y: {
            zoomedMin: formatter(_this.yScale.invert(zoomedYRange[0])),
            zoomedMax: formatter(_this.yScale.invert(zoomedYRange[1]))
          }
        };

        if (!zoomer.dontFeedToState) _this.model.marker.set(_this._zoomedXYMinMax, null, false /*avoid storing it in URL*/);

        // Keep the min and max size (pixels) constant, when zooming.
        //                    _this.sScale.range([utils.radiusToArea(_this.minRadius) * zoom * zoom * ratioY * ratioX,
        //                                        utils.radiusToArea(_this.maxRadius) * zoom * zoom * ratioY * ratioX ]);

        var optionsY = _this.yAxis.labelerOptions();
        var optionsX = _this.xAxis.labelerOptions();
        optionsY.limitMaxTickNumber = zoom * ratioY < 1.5 ? 8 : zoom * ratioY * 8;
        optionsX.limitMaxTickNumber = zoom * ratioX < 1.5 ? 8 : zoom * ratioX * 8;
        optionsY.transitionDuration = zoomer.duration;
        optionsX.transitionDuration = zoomer.duration;

        _this.xAxisEl.call(_this.xAxis.labelerOptions(optionsX));
        _this.yAxisEl.call(_this.yAxis.labelerOptions(optionsY));
        _this.redrawDataPoints(zoomer.duration);
        _this._trails.run("resize", null, zoomer.duration);

        zoomer.duration = 0;
      },
      stop: function stop() {
        _this.chartSvg.classed("vzb-zooming", false);

        _this.draggingNow = false;

        // if (this.quitZoom) return;

        //Force the update of the URL and history, with the same values
        if (!zoomer.dontFeedToState) _this.model.marker.set(_this._zoomedXYMinMax, true, true);
        zoomer.dontFeedToState = null;
      }
    };
  },
  expandCanvas: function expandCanvas(duration) {
    var _this = this.context;
    if (!duration) duration = _this.duration;

    //d3 extent returns min and max of the input array as [min, max]
    var mmX = d3.extent(utils.values(_this.frame.axis_x));
    var mmY = d3.extent(utils.values(_this.frame.axis_y));

    //protection agains unreasonable min-max results -- abort function
    if (!mmX[0] && mmX[0] !== 0 || !mmX[1] && mmX[1] !== 0 || !mmY[0] && mmY[0] !== 0 || !mmY[1] && mmY[1] !== 0) {
      return utils.warn("panZoom.expandCanvas: X or Y min/max are broken. Aborting with no action");
    }
    /*
     * Use a range bumped scale to correctly accommodate the range bump
     * gutter.
     */
    var suggestedFrame = {
      x1: _this.xScale(mmX[0]),
      y1: _this.yScale(mmY[0]),
      x2: _this.xScale(mmX[1]),
      y2: _this.yScale(mmY[1])
    };
    var xBounds = [0, _this.width];
    var yBounds = [_this.height, 0];

    // Get the current zoom frame based on the current dimensions.
    var frame = {
      x1: xBounds[0],
      x2: xBounds[1],
      y1: yBounds[0],
      y2: yBounds[1]
    };

    var TOLERANCE = 0.0;

    /*
     * If there is no current zoom frame, or if any of the suggested frame
     * points extend outside of the current zoom frame, then expand the
     * canvas.
     */
    if (!_this.isCanvasPreviouslyExpanded || suggestedFrame.x1 < frame.x1 * (1 - TOLERANCE) || suggestedFrame.x2 > frame.x2 * (1 + TOLERANCE) || suggestedFrame.y2 < frame.y2 * (1 - TOLERANCE) || suggestedFrame.y1 > frame.y1 * (1 + TOLERANCE)) {
      /*
       * If there is already a zoom frame, then clamp the suggested frame
       * points to only zoom out and expand the canvas.
       *
       * If any of x1, x2, y1, or y2 is within the current frame
       * boundaries, then clamp them to the frame boundaries. If any of
       * the above values will translate into a data value that is outside
       * of the possible data range, then clamp them to the frame
       * coordinate that corresponds to the maximum data value that can
       * be displayed.
       */
      if (_this.isCanvasPreviouslyExpanded) {
        /*
         * Calculate bounds and bumped scale for calculating the data boundaries
         * to which the suggested frame points need to be clamped.
         */
        var xBoundsBumped = _this._rangeBump(xBounds);
        var yBoundsBumped = _this._rangeBump(yBounds);

        if (suggestedFrame.x1 > xBoundsBumped[0]) suggestedFrame.x1 = xBoundsBumped[0];
        if (suggestedFrame.x2 < xBoundsBumped[1]) suggestedFrame.x2 = xBoundsBumped[1];
        if (suggestedFrame.y1 < yBoundsBumped[0]) suggestedFrame.y1 = yBoundsBumped[0];
        if (suggestedFrame.y2 > yBoundsBumped[0]) suggestedFrame.y2 = yBoundsBumped[1];
      }

      _this.isCanvasPreviouslyExpanded = true;
      this._zoomOnRectangle(_this.element, suggestedFrame.x1, suggestedFrame.y1, suggestedFrame.x2, suggestedFrame.y2, false, duration);
    } else {
      _this.redrawDataPoints(duration);
    }
  },
  zoomToMaxMin: function zoomToMaxMin(zoomedMinX, zoomedMaxX, zoomedMinY, zoomedMaxY, duration, dontFeedToState) {
    var _this = this.context;
    var minX = zoomedMinX;
    var maxX = zoomedMaxX;
    var minY = zoomedMinY;
    var maxY = zoomedMaxY;

    var xDomain = _this.xScale.domain();
    var yDomain = _this.yScale.domain();

    /*
     * Prevent zoomout if only one of zoom edges set outside domain
     */
    if (minX < xDomain[0] && maxX < xDomain[1]) minX = xDomain[0];
    if (minX > xDomain[0] && maxX > xDomain[1]) maxX = xDomain[1];
    if (minY < yDomain[0] && maxY < yDomain[1]) minY = yDomain[0];
    if (minY > yDomain[0] && maxY > yDomain[1]) maxY = yDomain[1];

    var xRange = [_this.xScale(minX), _this.xScale(maxX)];
    var yRange = [_this.yScale(minY), _this.yScale(maxY)];

    this._zoomOnRectangle(_this.element, xRange[0], yRange[0], xRange[1], yRange[1], false, duration, dontFeedToState);
  },
  _zoomOnRectangle: function _zoomOnRectangle(element, zoomedX1, zoomedY1, zoomedX2, zoomedY2, compensateDragging, duration, dontFeedToState) {
    var _this = this.context;
    var zoomer = this.zoomer;
    var transform = d3.zoomTransform(this.zoomSelection.node());

    var x1 = zoomedX1;
    var y1 = zoomedY1;
    var x2 = zoomedX2;
    var y2 = zoomedY2;

    /*
     * When dragging to draw a rectangle, the translate vector has (x2 - x1)
     * added to zoomer.translate()[0], and (y2 - 1) added to
     * zoomer.translate()[1].
     *
     * We need to compensate for this addition when
     * zooming with a rectangle, because zooming with a rectangle will
     * update the translate vector with new values based on the rectangle
     * dimensions.
     */
    if (compensateDragging) {
      transform.translate(x1 - x2, y1 - y2);
      // zoomer.translate([
      //     zoomer.translate()[0] + x1 - x2,
      //     zoomer.translate()[1] + y1 - y2
      // ]);
    }

    var xRangeBounds = [0, _this.width];
    var yRangeBounds = [_this.height, 0];

    var xRangeBoundsBumped = _this._rangeBump(xRangeBounds);
    var yRangeBoundsBumped = _this._rangeBump(yRangeBounds);

    var minZoom = zoomer.scaleExtent()[0];
    var maxZoom = zoomer.scaleExtent()[1];
    var zoom = void 0,
        ratioX = void 0,
        ratioY = void 0;

    if (Math.abs(x1 - x2) > Math.abs(y1 - y2)) {
      zoom = Math.abs(yRangeBoundsBumped[0] - yRangeBoundsBumped[1]) / Math.abs(y1 - y2) * transform.k;

      /*
       * Clamp the zoom scalar to the maximum zoom allowed before
       * calculating the next ratioX and ratioY.
       */
      if (zoom < minZoom) {
        zoomer.ratioY *= zoom / transform.k;
        zoom = minZoom;
      }
      if (zoom > maxZoom) zoom = maxZoom;

      ratioX = Math.abs(xRangeBoundsBumped[0] - xRangeBoundsBumped[1]) / Math.abs(x1 - x2) * transform.k / zoom * zoomer.ratioX;
      ratioY = zoomer.ratioY;
    } else {
      zoom = Math.abs(xRangeBoundsBumped[0] - xRangeBoundsBumped[1]) / Math.abs(x1 - x2) * transform.k;

      /*
       * Clamp the zoom scalar to the maximum zoom allowed before
       * calculating the next ratioX and ratioY.
       */
      if (zoom < minZoom) {
        zoomer.ratioX *= zoom / transform.k;
        zoom = minZoom;
      }
      if (zoom > maxZoom) zoom = maxZoom;

      ratioY = Math.abs(yRangeBoundsBumped[0] - yRangeBoundsBumped[1]) / Math.abs(y1 - y2) * transform.k / zoom * zoomer.ratioY;
      ratioX = zoomer.ratioX;
    }

    var pan = [(transform.x - Math.min(x1, x2)) / transform.k / zoomer.ratioX * zoom * ratioX + (xRangeBoundsBumped[0] - xRangeBounds[0]), (transform.y - Math.min(y1, y2)) / transform.k / zoomer.ratioY * zoom * ratioY + (yRangeBoundsBumped[1] - yRangeBounds[1])];

    zoomer.dontFeedToState = dontFeedToState;
    //zoomer.scale(zoom);
    zoomer.ratioY = ratioY;
    zoomer.ratioX = ratioX;
    //zoomer.translate(pan);
    zoomer.duration = duration ? duration : 0;

    //zoomer.event(element);
    this.zoomSelection.call(zoomer.transform, d3.zoomIdentity.translate(pan[0], pan[1]).scale(zoom));
  },


  /*
   * Incrementally zoom in or out and pan the view so that it never looses the point where click happened
   * this function is a modified d3's own zoom behavior on double click
   * for the original code see https://github.com/mbostock/d3/blob/master/src/behavior/zoom.js
   * function dblclicked() and what it refers to
   */
  zoomByIncrement: function zoomByIncrement(direction, duration) {
    var _this = this.context;
    var transform = d3.zoomTransform(this.zoomSelection.node());

    var ratio = transform.k;
    var pan = [transform.x, transform.y];

    var mouse = d3.mouse(this.zoomSelection.node());
    var k = Math.log(ratio) / Math.LN2;

    //change factor direction based on the input. default is no direction supplied
    if (direction == "plus" || !direction) k = Math.floor(k) + 1;
    if (direction == "minus") k = Math.ceil(k) - 1;

    //decode panning
    var locus = [(mouse[0] - pan[0]) / ratio, (mouse[1] - pan[1]) / ratio];

    //recalculate zoom ratio
    var scaleExtent = this.zoomer.scaleExtent();
    if (ratio == scaleExtent[0]) {
      this.zoomer.ratioY = 1;
      this.zoomer.ratioX = 1;
    }
    ratio = Math.max(scaleExtent[0], Math.min(scaleExtent[1], Math.pow(2, k)));

    //recalculate panning
    locus = [locus[0] * ratio + pan[0], locus[1] * ratio + pan[1]];
    pan[0] += mouse[0] - locus[0];
    pan[1] += mouse[1] - locus[1];

    //save changes to the zoom behavior and run the event
    //this.zoomer.scale(ratio);
    //this.zoomer.translate([pan[0], pan[1]]);
    this.zoomer.duration = duration || 0;
    //this.zoomer.event(_this.element);
    this.zoomSelection.call(this.zoomer.transform, d3.zoomIdentity.translate(pan[0], pan[1]).scale(ratio));
  },


  /*
   * Reset zoom values without triggering a zoom event.
   */
  resetZoomState: function resetZoomState(element) {
    //this.zoomer.scaleTo(element, 1);
    this.zoomer.ratioY = 1;
    this.zoomer.ratioX = 1;
    //this.zoomer.translate([0, 0]);
    (element || this.zoomSelection).property("__zoom", d3.zoomIdentity);
  },
  reset: function reset(element, duration) {
    var _this = this.context;
    _this.isCanvasPreviouslyExpanded = false;

    //this.zoomer.scale(1);
    this.zoomer.ratioY = 1;
    this.zoomer.ratioX = 1;
    //this.zoomer.translate([0, 0]);
    this.zoomer.duration = duration || 0;
    //this.zoomer.event(element || _this.element);
    (element || this.zoomSelection).call(this.zoomer.transform, d3.zoomIdentity);
  },
  rerun: function rerun(element) {
    var _this = this.context;
    //this.zoomer.event(element || _this.element);
    (element || this.zoomSelection).call(this.zoomer.scaleBy, 1);
  },
  zoomSelection: function zoomSelection(element) {
    this.zoomSelection = element;
  }
});

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _class = __webpack_require__(16);

var _class2 = _interopRequireDefault(_class);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.default = _class2.default.extend({
  init: function init(context) {
    this.context = context;
    this._isCreated = null;
    this.actionsQueue = {};
    this.entityTrails = {};
    this.trailsData = [];
    this.trailsInProgress = {};
    this.activePromises = {};
    this.trailTransitions = {};
    this.delayedIterations = {};
    this.drawingQueue = {};
  },
  toggle: function toggle(arg) {
    var _context = this.context;
    if (arg) {

      _context._trails.create().then(function () {
        _context._trails.run(["findVisible", "reveal", "opacityHandler"]);
      });
    } else {
      _context._trails.run("remove");
      _context.model.marker.select.forEach(function (d) {
        d.trailStartTime = null;
      });
    }
  },
  create: function create(selection) {
    var _context = this.context;
    var _this = this;
    var KEY = _context.KEY;
    var TIMEDIM = _context.TIMEDIM;
    this._isCreated = new Promise(function (resolve, reject) {
      //quit if the function is called accidentally
      if (!_context.model.ui.chart.trails) return;

      var timePoints = _context.model.time.getAllSteps();

      //work with marker.select (all selected entities), if no particular selection is specified
      var promises = [];
      selection = selection == null ? _context.model.marker.select : [selection];
      _this._clearActions(selection);
      _this.trailsData = _context.model.marker.select.map(function (d) {
        var r = {
          status: "created",
          selectedEntityData: d
        };
        r[KEY] = d[KEY];
        return r;
      });
      _this.trailTransitions = {};
      var _trails = _context.bubbleContainer.selectAll("g.vzb-bc-entity.entity-trail").data(_this.trailsData, function (d) {
        return d[KEY];
      });

      _trails.exit().remove();
      _trails.enter().insert("g", function (d) {
        return this.querySelector(".bubble-" + d[KEY]);
      }).attr("class", function (d) {
        return "vzb-bc-entity entity-trail trail-" + d[KEY];
      }).merge(_trails).each(function (d, index) {
        // used for prevent move trail start time forward when we have empty values at end of time range
        var trail = this;
        promises.push(new Promise(function (resolve, reject) {
          var trailSegmentData = timePoints.map(function (m) {
            return {
              t: m,
              key: d[KEY]
            };
          });
          var entityTrails = d3.select(trail).selectAll("g").data(trailSegmentData).classed("vzb-invisible", true);

          entityTrails.exit().remove();

          _this.entityTrails[d[KEY]] = entityTrails.enter().append("g").attr("class", "vzb-bc-trailsegment").on("mouseover", function (segment, index) {
            if (utils.isTouchDevice()) return;

            var pointer = {};
            pointer[KEY] = segment.key;
            pointer[TIMEDIM] = segment.t;

            _context._axisProjections(pointer);
            _context._labels.highlight(d, true);
            var text = _context.model.time.formatDate(segment.t);
            var selectedData = utils.find(_context.model.marker.select, function (f) {
              return f[KEY] == d[KEY];
            });
            _context.model.marker.getFrame(pointer[TIMEDIM], function (values) {
              var x = _context.xScale(values.axis_x[pointer[KEY]]);
              var y = _context.yScale(values.axis_y[pointer[KEY]]);
              var s = utils.areaToRadius(_context.sScale(values.size[pointer[KEY]]));
              var c = values.color[pointer[KEY]] != null ? _context.cScale(values.color[pointer[KEY]]) : _context.COLOR_WHITEISH;
              if (text !== selectedData.trailStartTime) {
                _context._setTooltip(text, x, y, s + 3, c);
              }
              _context._setBubbleCrown(x, y, s, c);
              _context.model.marker.getModelObject("highlight").trigger("change", { "size": values.size[pointer[KEY]], "color": values.color[pointer[KEY]] });
            });
            //change opacity to OPACITY_HIGHLT = 1.0;
            d3.select(this).style("opacity", 1.0);
          }).on("mouseout", function (segment, index) {
            if (utils.isTouchDevice()) return;
            _context._axisProjections();
            _context._setTooltip();
            _context._setBubbleCrown();
            _context._labels.highlight(null, false);
            _context.model.marker.getModelObject("highlight").trigger("change", null);
            d3.select(this).style("opacity", _context.model.marker.opacityRegular);
          }).each(function (segment, index) {
            var view = d3.select(this);
            view.append("circle");
            view.append("line");
          }).merge(entityTrails);
          resolve();
        }));
      });
      if (promises.length > 0) {
        Promise.all(promises).then(function (segments) {
          resolve(true);
        });
      } else {
        resolve(true);
      }
    });
    return this._isCreated;
  },


  /**
   * add actions for each selected entities
   * @param selections
   * @param actions
   * @private
   */
  _addActions: function _addActions(selections, actions) {
    var _context = this.context;
    var _this = this;
    var KEY = _context.KEY;

    selections.forEach(function (d) {
      if (!_this.actionsQueue[d[KEY]]) _this.actionsQueue[d[KEY]] = [];
      _this.actionsQueue[d[KEY]] = [].concat(_this.actionsQueue[d[KEY]].filter(function (value) {
        return actions.indexOf(value) == -1;
      }), actions);
    });
  },
  _clearActions: function _clearActions(selections) {
    var _context = this.context;
    var _this = this;
    var KEY = _context.KEY;

    selections.forEach(function (d) {
      if (!_this.actionsQueue[d[KEY]]) _this.actionsQueue[d[KEY]] = [];
      _this.actionsQueue[d[KEY]] = [];
      _this.drawingQueue[d[KEY]] = {};
      _this.delayedIterations[d[KEY]] = {};
      if (!_this.activePromises[d[KEY]]) _this.activePromises[d[KEY]] = [];
      utils.forEach(_this.activePromises[d[KEY]], function (promise, key) {
        if (promise.status === "pending") promise.reject();
      });
      _this.trailsInProgress[d[KEY]] = null;
      _this.activePromises[d[KEY]] = [];
    });
  },
  _getNextAction: function _getNextAction(key) {
    return this.actionsQueue[key].shift();
  },
  run: function run(actions, selection, duration) {
    var _context = this.context;
    var _this = this;
    var KEY = _context.KEY;
    if (!this._isCreated || _context.model.time.splash) return;
    if (typeof actions == "string") actions = [actions];

    this._isCreated.then(function () {
      //quit if function is called accidentally
      if ((!_context.model.ui.chart.trails || !_context.model.marker.select.length) && actions != "remove") return;

      if (!duration) duration = 0;

      //work with marker.select (all selected entities), if no particular selection is specified
      selection = selection == null ? _context.model.marker.select : [selection];
      for (var i = 0; i < actions.length; i++) {
        if (["resize", "recolor", "remove"].indexOf(actions[i]) != -1) {
          (function () {
            var action = actions.splice(i, 1).pop();
            --i;
            _this.trailsData.forEach(function (d) {
              var trail = _this.entityTrails[d[KEY]];
              _context._trails["_" + action](trail, duration, d);
            });
          })();
        }
      }
      if (actions.length == 0) {
        return;
      }
      _this._addActions(selection, actions);
      _this.trailsData.forEach(function (d) {
        if (actions.indexOf("findVisible") != -1) {
          _this.drawingQueue[d[KEY]] = {};
          _this.delayedIterations[d[KEY]] = {};
        }
        var trail = _this.entityTrails[d[KEY]];
        //do all the actions over "trail"
        var executeSequential = function executeSequential(index) {
          // some function can be async, but we should run next when previous completed
          var action = _this._getNextAction(d[KEY]);
          if (action) {
            _this.trailsInProgress[d[KEY]] = action;
            var response = _context._trails["_" + action](trail, duration, d);
            if (response && response instanceof Promise) {
              response.then(function () {
                _this.trailsInProgress[d[KEY]] = null;
                executeSequential(index + 1);
              }, function () {
                _this.trailsInProgress[d[KEY]] = null;
              });
            } else {
              _this.trailsInProgress[d[KEY]] = null;
              executeSequential(index + 1);
            }
          }
        };
        if (!_this.trailsInProgress[d[KEY]]) {
          executeSequential(0);
        }
      });
    });
  },
  _remove: function _remove(trail, duration, d) {
    this.actionsQueue[d[this.context.KEY]] = [];
    if (trail) {
      // TODO: in some reason run twice
      d3.select(this.entityTrails[d[this.context.KEY]].node().parentNode).remove();
      this.entityTrails[d[this.context.KEY]] = null;
    }
  },
  _resize: function _resize(trail, duration, d) {
    var _context = this.context;
    if (_context.model.time.splash) {
      return;
    }
    //    this._isCreated.then(function() {
    var updateLabel = false;

    trail.each(function (segment, index) {

      if (segment.valueY == null || segment.valueX == null || segment.valueS == null) return;

      var view = d3.select(this);
      if (duration) {
        view.select("circle").transition().duration(duration).ease(d3.easeLinear).attr("cy", _context.yScale(segment.valueY)).attr("cx", _context.xScale(segment.valueX)).attr("r", utils.areaToRadius(_context.sScale(segment.valueS)));
      } else {
        view.select("circle").interrupt().attr("cy", _context.yScale(segment.valueY)).attr("cx", _context.xScale(segment.valueX)).attr("r", utils.areaToRadius(_context.sScale(segment.valueS))).transition();
      }

      if (!updateLabel && !segment.transparent) {
        updateLabel = true;
        _context._labels.updateLabelOnlyPosition(d, null, { "scaledS0": utils.areaToRadius(_context.sScale(segment.valueS)) });
      }

      if (!segment.next) return;
      var next = segment.next;
      if (next == null) return;
      if (next.valueY == null || next.valueX == null) return;

      var lineLength = Math.sqrt(Math.pow(_context.xScale(segment.valueX) - _context.xScale(next.valueX), 2) + Math.pow(_context.yScale(segment.valueY) - _context.yScale(next.valueY), 2));
      if (duration) {
        view.select("line").transition().duration(duration).ease(d3.easeLinear).attr("x1", _context.xScale(next.valueX)).attr("y1", _context.yScale(next.valueY)).attr("x2", _context.xScale(segment.valueX)).attr("y2", _context.yScale(segment.valueY)).attr("stroke-dasharray", lineLength).attr("stroke-dashoffset", utils.areaToRadius(_context.sScale(segment.valueS)));
      } else {
        view.select("line").interrupt().attr("x1", _context.xScale(next.valueX)).attr("y1", _context.yScale(next.valueY)).attr("x2", _context.xScale(segment.valueX)).attr("y2", _context.yScale(segment.valueY)).attr("stroke-dasharray", lineLength).attr("stroke-dashoffset", utils.areaToRadius(_context.sScale(segment.valueS))).transition();
      }
    });
  },
  _recolor: function _recolor(trail, duration, d) {
    var _context = this.context;

    trail.each(function (segment, index) {

      var view = d3.select(this);

      var strokeColor = _context.model.marker.color.which == "geo.world_4region" ?
      //use predefined shades for color palette for "geo.world_4region" (hardcoded)
      _context.model.marker.color.getColorShade({
        colorID: segment.valueC,
        shadeID: "shade"
      }) :
      //otherwise use color of the bubble with a fallback to bubble stroke color (blackish)
      segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_BLACKISH;

      view.select("circle")
      //.transition().duration(duration).ease(d3.easeLinear)
      .style("fill", segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_WHITEISH);
      view.select("line")
      //.transition().duration(duration).ease(d3.easeLinear)
      .style("stroke", strokeColor);
    });
  },
  _opacityHandler: function _opacityHandler(trail, duration, d) {
    var _context = this.context;

    trail.each(function (segment, index) {

      var view = d3.select(this);

      view
      //.transition().duration(duration).ease(d3.easeLinear)
      .style("opacity", d.opacity || _context.model.marker.opacityRegular);
    });
  },
  _findVisible: function _findVisible(trail, duration, d) {
    var _context = this.context;
    var _this = this;
    var KEY = _context.KEY;
    return new Promise(function (resolve, reject) {
      new Promise(function (resolve1, reject1) {
        if (!d.limits) {
          _context.model.marker.getEntityLimits(d[KEY]).then(function (limits) {
            d.limits = limits;
            resolve1();
          });
        } else {
          resolve1();
        }
      }).then(function () {
        if (!d.selectedEntityData.trailStartTime) {
          d.selectedEntityData.trailStartTime = _context.model.time.formatDate(_context.time);
        }
        var trailStartTime = _context.model.time.parse("" + d.selectedEntityData.trailStartTime);
        if (_context.time - trailStartTime < 0 || d.limits.min - trailStartTime > 0) {
          if (_context.time - trailStartTime < 0) {
            // move trail start time with trail label back if need
            d.selectedEntityData.trailStartTime = _context.model.time.formatDate(d3.max([_context.time, d.limits.min]));
            trailStartTime = _context.model.time.parse("" + d.selectedEntityData.trailStartTime);
          } else {
            // move trail start time with trail label to start time if need
            d.selectedEntityData.trailStartTime = _context.model.time.formatDate(d.limits.min);
            trailStartTime = _context.model.time.parse("" + d.selectedEntityData.trailStartTime);
          }
          var cache = _context._labels.cached[d[KEY]];
          var valueS = _context.frame.size[d[KEY]];
          var valueC = _context.frame.color[d[KEY]];
          cache.labelX0 = _context.frame.axis_x[d[KEY]];
          cache.labelY0 = _context.frame.axis_y[d[KEY]];
          cache.scaledS0 = valueS || valueS === 0 ? utils.areaToRadius(_context.sScale(valueS)) : null;
          cache.scaledC0 = valueC != null ? _context.cScale(valueC) : _context.COLOR_WHITEISH;
          _context._updateLabel(d, 0, _context.frame.axis_x[d[KEY]], _context.frame.axis_y[d[KEY]], _context.frame.size[d[KEY]], _context.frame.color[d[KEY]], _context.frame.label[d[KEY]], _context.frame.size_label[d[KEY]], 0, true);
        }
        trail.each(function (segment, index) {
          // segment is transparent if it is after current time or before trail StartTime
          var segmentVisibility = segment.transparent;
          segment.transparent = d.selectedEntityData.trailStartTime == null || segment.t - _context.time > 0 || trailStartTime - segment.t > 0
          //no trail segment should be visible if leading bubble is shifted backwards, beyond start time
          || d.selectedEntityData.trailStartTime - _context.model.time.formatDate(_context.time) >= 0;
          // always update nearest 2 points
          if (segmentVisibility != segment.transparent || Math.abs(_context.model.time.formatDate(segment.t) - _context.model.time.formatDate(_context.time)) < 2) segment.visibilityChanged = true; // segment changed, so need to update it
          if (segment.transparent) {
            d3.select(trail._groups[0][index]).classed("vzb-invisible", segment.transparent);
          }
        });
        _this.drawingQueue[d[KEY]] = {};
        _this.delayedIterations[d[KEY]] = {};
        resolve();
      });
    });
  },
  _abortAnimation: function _abortAnimation() {
    var _context = this.context;
    var _this = this;
    var KEY = _context.KEY;
    _this.trailsData.forEach(function (d) {
      if (_this.trailTransitions[d[KEY]]) {
        _this.trailTransitions[d[KEY]].select("line").interrupt().transition();
      }
    });
  },
  _reveal: function _reveal(trail, duration, d) {
    var _context = this.context;
    var _this = this;
    var KEY = _context.KEY;
    d.status = "reveal";
    var trailStartTime = _context.model.time.parse("" + d.selectedEntityData.trailStartTime);
    var generateTrailSegment = function generateTrailSegment(trail, index, nextIndex, level) {
      return new Promise(function (resolve, reject) {
        var view = d3.select(trail._groups[0][index]);

        var segment = view.datum();

        //console.log(d[KEY] + " transparent: " + segment.transparent + " vis_changed:" + segment.visibilityChanged);
        if (nextIndex - index == 1) {
          if (segment.transparent) {
            view.classed("vzb-invisible", segment.transparent);
            return resolve();
          } else if (!segment.visibilityChanged) {
            // pass segment if it is not changed
            return resolve();
          }
        }
        _context.model.marker.getFrame(segment.t, function (frame) {
          if (d.status != "reveal") return resolve();
          if (!frame) return resolve();
          segment.valueY = frame.axis_y[d[KEY]];
          segment.valueX = frame.axis_x[d[KEY]];
          segment.valueS = frame.size[d[KEY]];
          segment.valueC = frame.color[d[KEY]];

          if (segment.valueY == null || segment.valueX == null || segment.valueS == null) {
            return resolve();
          }

          // fix label position if it not in correct place
          if (trailStartTime && trailStartTime.toString() == segment.t.toString()) {
            var cache = _context._labels.cached[d[KEY]];
            cache.labelX0 = segment.valueX;
            cache.labelY0 = segment.valueY;
            var valueS = segment.valueS;
            cache.scaledS0 = valueS || valueS === 0 ? utils.areaToRadius(_context.sScale(valueS)) : null;
            cache.scaledC0 = segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_WHITEISH;
            _context._updateLabel(d, index, segment.valueX, segment.valueY, segment.valueS, segment.valueC, frame.label[d[KEY]], frame.size_label[d[KEY]], 0, true);
          }
          view.select("circle")
          //.transition().duration(duration).ease(d3.easeLinear)
          .attr("cy", _context.yScale(segment.valueY)).attr("cx", _context.xScale(segment.valueX)).attr("r", utils.areaToRadius(_context.sScale(segment.valueS))).style("fill", segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_WHITEISH);

          view.select("line").attr("x2", _context.xScale(segment.valueX)).attr("y2", _context.yScale(segment.valueY)).attr("x1", _context.xScale(segment.valueX)).attr("y1", _context.yScale(segment.valueY));

          // last point should have data for line but it is invisible
          if (_context.time - segment.t > 0) {
            segment.visibilityChanged = false;
            view.classed("vzb-invisible", segment.transparent);
          } else {
            view.classed("vzb-invisible", true);
          }

          if (!trail._groups[0][nextIndex] || _context.time.toString() == segment.t.toString()) {
            return resolve();
          }

          var next = d3.select(trail._groups[0][nextIndex]);
          var nextSegment = next.datum();
          nextSegment.previous = segment;
          segment.next = nextSegment;
          var nextTime = nextSegment.t;
          if (_context.time - nextSegment.t < 0) {
            // time is not equal start of year
            segment.visibilityChanged = true; // redraw needed next time because line not have full length
            nextTime = _context.time;
          }
          _context.model.marker.getFrame(nextTime, function (nextFrame) {
            if (d.status != "reveal") return resolve();
            if (!nextFrame || segment.valueY == null || segment.valueX == null || segment.valueS == null) {
              return resolve();
            }

            if (nextFrame.axis_x[d[KEY]] == null || nextFrame.axis_y[d[KEY]] == null) {
              return resolve();
            }

            nextSegment.valueY = nextFrame.axis_y[d[KEY]];
            nextSegment.valueX = nextFrame.axis_x[d[KEY]];
            nextSegment.valueS = nextFrame.size[d[KEY]];
            nextSegment.valueC = nextFrame.color[d[KEY]];

            _this.trailTransitions[d[KEY]] = view;
            var strokeColor = _context.model.marker.color.which == "geo.world_4region" ?
            //use predefined shades for color palette for "geo.world_4region" (hardcoded)
            _context.model.marker.color.getColorShade({
              colorID: segment.valueC,
              shadeID: "shade"
            }) :
            //otherwise use color of the bubble with a fallback to bubble stroke color (blackish)
            segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_BLACKISH;

            var lineLength = Math.sqrt(Math.pow(_context.xScale(segment.valueX) - _context.xScale(nextFrame.axis_x[d[KEY]]), 2) + Math.pow(_context.yScale(segment.valueY) - _context.yScale(nextFrame.axis_y[d[KEY]]), 2));
            view.select("line").transition().duration(duration).ease(d3.easeLinear).attr("x1", _context.xScale(nextSegment.valueX)).attr("y1", _context.yScale(nextSegment.valueY)).attr("x2", _context.xScale(segment.valueX)).attr("y2", _context.yScale(segment.valueY)).attr("stroke-dasharray", lineLength).attr("stroke-dashoffset", utils.areaToRadius(_context.sScale(segment.valueS))).style("stroke", strokeColor);
            if (nextIndex - index > 1) {
              addNewIntervals(index, nextIndex);
              return resolve();
            }
            return resolve();
          });
        });
      });
    };
    var addPointBetween = function addPointBetween(previousIndex, nextIndex, index) {
      return new Promise(function (resolve, reject) {
        var previous = d3.select(trail._groups[0][previousIndex]);
        var next = d3.select(trail._groups[0][nextIndex]);
        var view = d3.select(trail._groups[0][index]);
        var previousSegment = previous.datum();
        var nextSegment = next.datum();
        var segment = view.datum();

        if (!previousSegment.previous && !previousSegment.next || !nextSegment.previous && !nextSegment.next) {
          // segment data cleared by create action
          return resolve();
        }

        _context.model.marker.getFrame(segment.t, function (frame) {
          if (d.status != "reveal") return resolve();
          if (!frame || typeof frame.axis_x == "undefined" || frame.axis_x[d[KEY]] == null || typeof frame.axis_y == "undefined" || frame.axis_y[d[KEY]] == null) {
            utils.warn("Frame for trail missed: " + segment.t);
            return resolve();
          }
          segment.valueY = frame.axis_y[d[KEY]];
          segment.valueX = frame.axis_x[d[KEY]];
          segment.valueS = frame.size[d[KEY]];
          segment.valueC = frame.color[d[KEY]];

          segment.previous = previousSegment;
          segment.next = nextSegment;
          previousSegment.next = segment;
          nextSegment.previous = segment;

          if (segment.valueY == null || segment.valueX == null || segment.valueS == null) {
            utils.warn("Data for trail point missed: " + segment.t);
            return resolve();
          }

          var strokeColor = _context.model.marker.color.which == "geo.world_4region" ?
          //use predefined shades for color palette for "geo.world_4region" (hardcoded)
          _context.model.marker.color.getColorShade({
            colorID: segment.valueC,
            shadeID: "shade"
          }) :
          //otherwise use color of the bubble with a fallback to bubble stroke color (blackish)
          segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_BLACKISH;

          var firstLineLength = Math.sqrt(Math.pow(_context.xScale(previousSegment.valueX) - _context.xScale(segment.valueX), 2) + Math.pow(_context.yScale(previousSegment.valueY) - _context.yScale(segment.valueX), 2));

          previous.select("line").transition().duration(duration).ease(d3.easeLinear).attr("x1", _context.xScale(segment.valueX)).attr("y1", _context.yScale(segment.valueY)).attr("x2", _context.xScale(previousSegment.valueX)).attr("y2", _context.yScale(previousSegment.valueY)).attr("stroke-dasharray", firstLineLength).attr("stroke-dashoffset", utils.areaToRadius(_context.sScale(previousSegment.valueS))).style("stroke", strokeColor);

          view.classed("vzb-invisible", segment.transparent);

          if (!segment.transparent) {
            view.select("circle")
            //.transition().duration(duration).ease(d3.easeLinear)
            .attr("cy", _context.yScale(segment.valueY)).attr("cx", _context.xScale(segment.valueX)).attr("r", utils.areaToRadius(_context.sScale(segment.valueS))).style("fill", segment.valueC != null ? _context.cScale(segment.valueC) : _context.COLOR_WHITEISH);

            var secondLineLength = Math.sqrt(Math.pow(_context.xScale(segment.valueX) - _context.xScale(nextSegment.valueX), 2) + Math.pow(_context.yScale(segment.valueY) - _context.yScale(nextSegment.valueY), 2));

            view.select("line").transition().duration(duration).ease(d3.easeLinear).attr("x1", _context.xScale(nextSegment.valueX)).attr("y1", _context.yScale(nextSegment.valueY)).attr("x2", _context.xScale(segment.valueX)).attr("y2", _context.yScale(segment.valueY)).attr("stroke-dasharray", secondLineLength).attr("stroke-dashoffset", utils.areaToRadius(_context.sScale(segment.valueS))).style("stroke", strokeColor);
          }
          addNewIntervals(previousIndex, index, nextIndex);
          resolve();
        });
      });
    };
    var addNewIntervals = function addNewIntervals(previousIndex, index, nextIndex) {
      var mediumIndex = void 0;
      if (index - previousIndex > 1) {
        mediumIndex = getPointBetween(previousIndex, index);
        _this.delayedIterations[d[KEY]][previousIndex] = {
          first: previousIndex,
          next: index,
          medium: mediumIndex
        };
      }
      if (nextIndex && nextIndex - index > 1) {
        mediumIndex = getPointBetween(index, nextIndex);
        _this.delayedIterations[d[KEY]][index] = {
          first: index,
          next: nextIndex,
          medium: mediumIndex
        };
      }
    };
    var getPointBetween = function getPointBetween(previous, next) {
      return Math.round(previous + (next - previous) / 2);
    };

    var _generateKeys = function _generateKeys(d, trail, div) {
      var response = [];
      var min = 0,
          max = 0;
      var maxValue = d3.min([d.limits.max, _context.time]);
      var minValue = d3.max([d.limits.min, _context.model.time.parse("" + d.selectedEntityData.trailStartTime)]);
      utils.forEach(trail._groups[0], function (segment, index) {
        var data = segment.__data__;
        if (data.t - minValue == 0) {
          min = index;
        } else if (data.t - maxValue == 0) {
          max = index;
        } else {
          if (data.t > minValue && data.t < maxValue) {
            if (_context.model.time.formatDate(data.t) % div == 0 || data.next && data.previous) {
              response.push(index);
            }
          }
        }
      });
      response.unshift(min);
      if (max > 0) {
        response.push(max);
      }
      return response;
    };

    var processPoints = function processPoints() {
      return new Promise(function (resolve, reject) {
        var processPoint = function processPoint() {
          var pointIndex = Object.keys(_this.drawingQueue[d[KEY]])[Math.floor(Math.random() * Object.keys(_this.drawingQueue[d[KEY]]).length)];
          var point = JSON.parse(JSON.stringify(_this.drawingQueue[d[KEY]][pointIndex]));
          delete _this.drawingQueue[d[KEY]][pointIndex];
          addPointBetween(point.first, point.next, point.medium).then(function () {
            if (Object.keys(_this.drawingQueue[d[KEY]]).length > 0) {
              processPoint();
            } else {
              resolve();
            }
          });
        };
        if (Object.keys(_this.drawingQueue[d[KEY]]).length > 0) {
          processPoint(_this.drawingQueue[d[KEY]]);
        } else {
          resolve();
        }
      });
    };

    return new Promise(function (resolve, reject) {
      /**
       * iteration for each point from first segment to last
       * @param trail
       * @param index
       */
      var generateTrails = function generateTrails(trail, index) {
        if (index < 0 || index >= trail._groups[0].length) {
          return resolve();
        }
        generateTrailSegment(trail, index, index + 1).then(function () {
          generateTrails(trail, index + 1);
        }, function () {
          return resolve();
        });
      };

      /**
       * recursive iteration for drawing point between points calculated in previous step
       */
      var processPointsBetween = function processPointsBetween() {
        processPoints().then(function () {
          if (Object.keys(_this.delayedIterations[d[KEY]]).length == 0) {
            return resolve();
          }
          _this.drawingQueue[d[KEY]] = _this.delayedIterations[d[KEY]];
          _this.delayedIterations[d[KEY]] = {};
          processPointsBetween();
        }, function () {
          return resolve();
        });
      };

      if (_context.model.marker.framesAreReady()) {
        generateTrails(trail, 0);
      } else {
        _this.delayedIterations[d[KEY]] = {};
        _this.drawingQueue[d[KEY]] = {};
        var trailKeys = _generateKeys(d, trail, 50);
        var segments = [];
        if (trailKeys.length <= 1) {
          return resolve();
        }

        _this.delayedIterations[d[KEY]] = {};
        for (var i = 0; i < trailKeys.length - 1; i++) {
          segments.push(generateTrailSegment(trail, trailKeys[i], trailKeys[i + 1], 1));
        }
        Promise.all(segments).then(function () {
          if (Object.keys(_this.delayedIterations[d[KEY]]).length == 0) {
            resolve();
          } else {
            _this.drawingQueue[d[KEY]] = _this.delayedIterations[d[KEY]];
            _this.delayedIterations[d[KEY]] = {};
            processPointsBetween();
          }
        }, function () {
          resolve();
        });
      }
    });
  }
});

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _labels = __webpack_require__(73);

var _labels2 = _interopRequireDefault(_labels);

var _iconset = __webpack_require__(10);

var _topojson = __webpack_require__(139);

var _topojson2 = _interopRequireDefault(_topojson);

var _d = __webpack_require__(89);

var _d2 = _interopRequireDefault(_d);

var _d3 = __webpack_require__(60);

var _d4 = _interopRequireDefault(_d3);

var _globals = __webpack_require__(34);

var _globals2 = _interopRequireDefault(_globals);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//import Selectlist from 'bubblemap-selectlist';

//BUBBLE MAP CHART COMPONENT
var BubbleMapComponent = _component2.default.extend({
  /**
   * Initializes the component (Bubble Map Chart).
   * Executed once before any template is rendered.
   * @param {Object} config The config passed to the component
   * @param {Object} context The component's parent
   */
  init: function init(config, context) {
    this.name = "bubblemap";
    this.template = __webpack_require__(462);
    this.bubblesDrawing = null;

    this.isMobile = utils.isMobileOrTablet();

    //define expected models for this component
    this.model_expects = [{
      name: "time",
      type: "time"
    }, {
      name: "entities",
      type: "entities"
    }, {
      name: "marker",
      type: "model"
    }, {
      name: "locale",
      type: "locale"
    }, {
      name: "ui",
      type: "ui"
    }];

    var _this = this;
    this.model_binds = {
      "change:time.value": function changeTimeValue(evt) {
        if (!_this._readyOnce) return;
        _this.model.marker.getFrame(_this.model.time.value, _this.frameChanged.bind(_this));
      },
      "change:marker.highlight": function changeMarkerHighlight(evt) {
        if (!_this._readyOnce) return;
        _this.highlightMarkers();
        _this.updateOpacity();
      },
      "change:marker": function changeMarker(evt, path) {
        // bubble size change is processed separately
        if (!_this._readyOnce) return;

        if (path.indexOf("scaleType") > -1) {
          _this.ready();
        }
      },
      "change:marker.size.extent": function changeMarkerSizeExtent(evt, path) {
        //console.log("EVENT change:marker:size:max");
        if (!_this._readyOnce || !_this.entityBubbles) return;
        _this.updateMarkerSizeLimits();
        _this.redrawDataPoints(null, false);
      },
      "change:marker.color.palette": function changeMarkerColorPalette(evt, path) {
        if (!_this._readyOnce) return;
        _this.redrawDataPoints(null, false);
      },
      "change:marker.select": function changeMarkerSelect(evt) {
        if (!_this._readyOnce) return;
        _this.selectMarkers();
        _this.redrawDataPoints(null, false);
        _this.updateOpacity();
        _this.updateDoubtOpacity();
      },
      "change:marker.opacitySelectDim": function changeMarkerOpacitySelectDim(evt) {
        _this.updateOpacity();
      },
      "change:marker.opacityRegular": function changeMarkerOpacityRegular(evt) {
        _this.updateOpacity();
      }
    };

    //this._selectlist = new Selectlist(this);

    //contructor is the same as any component
    this._super(config, context);

    this.sScale = null;
    this.cScale = d3.scaleOrdinal(d3.schemeCategory10);

    _this.COLOR_WHITEISH = "#fdfdfd";

    (0, _d2.default)();

    this._labels = new _labels2.default(this);
    this._labels.config({
      CSS_PREFIX: "vzb-bmc",
      LABELS_CONTAINER_CLASS: "vzb-bmc-labels",
      LINES_CONTAINER_CLASS: "vzb-bmc-lines",
      SUPPRESS_HIGHLIGHT_DURING_PLAY: false
    });
  },


  /**
   * DOM is ready
   */
  readyOnce: function readyOnce() {

    this.element = d3.select(this.element);

    this.graph = this.element.select(".vzb-bmc-graph");
    this.mapSvg = this.element.select(".vzb-bmc-map-background");

    this.bubbleContainerCrop = this.graph.select(".vzb-bmc-bubbles-crop");
    this.bubbleContainer = this.graph.select(".vzb-bmc-bubbles");
    this.labelListContainer = this.graph.select(".vzb-bmc-bubble-labels");
    this.dataWarningEl = this.graph.select(".vzb-data-warning");

    this.yTitleEl = this.graph.select(".vzb-bmc-axis-y-title");
    this.cTitleEl = this.graph.select(".vzb-bmc-axis-c-title");
    this.yInfoEl = this.graph.select(".vzb-bmc-axis-y-info");
    this.cInfoEl = this.graph.select(".vzb-bmc-axis-c-info");

    this.entityBubbles = null;
    this.tooltip = this.element.select(".vzb-bmc-tooltip");

    // year background
    this.yearEl = this.graph.select(".vzb-bmc-year");
    this.year = new _d4.default(this.yearEl);
    this.year.setConditions({ xAlign: "left", yAlign: "bottom" });

    var _this = this;
    this.on("resize", function () {
      //return if updatesize exists with error
      if (_this.updateSize()) return;
      _this.updateMarkerSizeLimits();
      _this._labels.updateSize();
      _this.redrawDataPoints();
      //_this._selectlist.redraw();
    });

    this.initMap();

    this.KEY = this.model.entities.getDimension();
    this.TIMEDIM = this.model.time.getDimension();

    this.updateUIStrings();

    this.wScale = d3.scale.linear().domain(this.model.ui.datawarning.doubtDomain).range(this.model.ui.datawarning.doubtRange);

    this._labels.readyOnce();
  },


  /*
   * Both model and DOM are ready
   */
  ready: function ready() {
    var _this = this;
    this.updateUIStrings();
    this.updateIndicators();
    this.updateSize();
    this.updateMarkerSizeLimits();
    this.model.marker.getFrame(this.model.time.value, function (values, time) {
      // TODO: temporary fix for case when after data loading time changed on validation
      if (time.toString() != _this.model.time.value.toString()) {
        utils.defer(function () {
          _this.ready();
        });
        return;
      } // frame is outdated

      if (!values) return;
      _this.values = values;
      _this.updateEntities();
      _this.updateTime();
      _this._labels.ready();
      _this.redrawDataPoints();
      _this.highlightMarkers();
      _this.selectMarkers();
      //    this._selectlist.redraw();
      _this.updateDoubtOpacity();
      _this.updateOpacity();
    });
  },
  frameChanged: function frameChanged(frame, time) {
    if (time.toString() != this.model.time.value.toString()) return; // frame is outdated
    if (!frame) return;

    this.values = frame;
    this.updateTime();
    this.updateDoubtOpacity();
    this.redrawDataPoints(null, false);
  },
  updateUIStrings: function updateUIStrings() {
    var _this = this;

    this.translator = this.model.locale.getTFunction();
    var conceptPropsS = _this.model.marker.size.getConceptprops();
    var conceptPropsC = _this.model.marker.color.getConceptprops();

    this.strings = {
      title: {
        S: conceptPropsS.name,
        C: conceptPropsC.name
      }
    };

    this.yTitleEl.select("text").text(this.translator("buttons/size") + ": " + this.strings.title.S).on("click", function () {
      _this.parent.findChildByName("gapminder-treemenu").markerID("size").alignX(_this.model.locale.isRTL() ? "right" : "left").alignY("top").updateView().toggle();
    });

    this.cTitleEl.select("text").text(this.translator("buttons/color") + ": " + this.strings.title.C).on("click", function () {
      _this.parent.findChildByName("gapminder-treemenu").markerID("color").alignX(_this.model.locale.isRTL() ? "right" : "left").alignY("top").updateView().toggle();
    });

    utils.setIcon(this.dataWarningEl, _iconset.warn).select("svg").attr("width", "0px").attr("height", "0px");
    this.dataWarningEl.append("text").attr("text-anchor", "end").text(this.translator("hints/dataWarning"));

    this.dataWarningEl.on("click", function () {
      _this.parent.findChildByName("gapminder-datawarning").toggle();
    }).on("mouseover", function () {
      _this.updateDoubtOpacity(1);
    }).on("mouseout", function () {
      _this.updateDoubtOpacity();
    });

    this.yInfoEl.html(_iconset.question).select("svg").attr("width", "0px").attr("height", "0px");

    //TODO: move away from UI strings, maybe to ready or ready once
    this.yInfoEl.on("click", function () {
      _this.parent.findChildByName("gapminder-datanotes").pin();
    });
    this.yInfoEl.on("mouseover", function () {
      var rect = this.getBBox();
      var coord = utils.makeAbsoluteContext(this, this.farthestViewportElement)(rect.x - 10, rect.y + rect.height + 10);
      var toolRect = _this.root.element.getBoundingClientRect();
      var chartRect = _this.element.node().getBoundingClientRect();
      _this.parent.findChildByName("gapminder-datanotes").setHook("size").show().setPos(coord.x + chartRect.left - toolRect.left, coord.y);
    });
    this.yInfoEl.on("mouseout", function () {
      _this.parent.findChildByName("gapminder-datanotes").hide();
    });

    this.cInfoEl.html(_iconset.question).select("svg").attr("width", "0px").attr("height", "0px");

    //TODO: move away from UI strings, maybe to ready or ready once
    this.cInfoEl.on("click", function () {
      _this.parent.findChildByName("gapminder-datanotes").pin();
    });
    this.cInfoEl.on("mouseover", function () {
      var rect = this.getBBox();
      var coord = utils.makeAbsoluteContext(this, this.farthestViewportElement)(rect.x - 10, rect.y + rect.height + 10);
      var toolRect = _this.root.element.getBoundingClientRect();
      var chartRect = _this.element.node().getBoundingClientRect();
      _this.parent.findChildByName("gapminder-datanotes").setHook("color").show().setPos(coord.x + chartRect.left - toolRect.left, coord.y);
    });
    this.cInfoEl.on("mouseout", function () {
      _this.parent.findChildByName("gapminder-datanotes").hide();
    });
  },


  // show size number on title when hovered on a bubble
  updateTitleNumbers: function updateTitleNumbers() {
    var _this = this;

    var mobile = void 0; // if is mobile device and only one bubble is selected, update the ytitle for the bubble
    if (_this.isMobile && _this.model.marker.select && _this.model.marker.select.length === 1) {
      mobile = _this.model.marker.select[0];
    }

    if (_this.hovered || mobile) {
      var conceptPropsS = _this.model.marker.size.getConceptprops();
      var conceptPropsC = _this.model.marker.color.getConceptprops();

      var hovered = _this.hovered || mobile;
      var formatterS = _this.model.marker.size.getTickFormatter();
      var formatterC = _this.model.marker.color.getTickFormatter();

      var unitS = conceptPropsS.unit || "";
      var unitC = conceptPropsC.unit || "";

      var valueS = _this.values.size[hovered[_this.KEY]];
      var valueC = _this.values.color[hovered[_this.KEY]];

      //resolve value for color from the color legend model
      if (_this.model.marker.color.isDiscrete() && valueC) {
        valueC = this.model.marker.color.getColorlegendMarker().label.getItems()[valueC] || "";
      }

      _this.yTitleEl.select("text").text(_this.translator("buttons/size") + ": " + formatterS(valueS) + " " + unitS);

      _this.cTitleEl.select("text").text(_this.translator("buttons/color") + ": " + (valueC || valueC === 0 ? formatterC(valueC) + " " + unitC : _this.translator("hints/nodata")));

      this.yInfoEl.classed("vzb-hidden", true);
      this.cInfoEl.classed("vzb-hidden", true);
    } else {
      this.yTitleEl.select("text").text(this.translator("buttons/size") + ": " + this.strings.title.S);
      this.cTitleEl.select("text").text(this.translator("buttons/color") + ": " + this.strings.title.C);

      this.yInfoEl.classed("vzb-hidden", false);
      this.cInfoEl.classed("vzb-hidden", false || this.cTitleEl.classed("vzb-hidden"));
    }
  },
  updateDoubtOpacity: function updateDoubtOpacity(opacity) {
    if (opacity == null) opacity = this.wScale(+this.time.getUTCFullYear().toString());
    if (this.someSelected) opacity = 1;
    this.dataWarningEl.style("opacity", opacity);
  },
  updateOpacity: function updateOpacity() {
    var _this = this;
    /*
    this.entityBubbles.classed("vzb-selected", function (d) {
        return _this.model.marker.isSelected(d);
    });
    */

    var OPACITY_HIGHLT = 1.0;
    var OPACITY_HIGHLT_DIM = 0.3;
    var OPACITY_SELECT = this.model.marker.opacityRegular;
    var OPACITY_REGULAR = this.model.marker.opacityRegular;
    var OPACITY_SELECT_DIM = this.model.marker.opacitySelectDim;

    this.entityBubbles.style("opacity", function (d) {

      if (_this.someHighlighted) {
        //highlight or non-highlight
        if (_this.model.marker.isHighlighted(d)) return OPACITY_HIGHLT;
      }

      if (_this.someSelected) {
        //selected or non-selected
        return _this.model.marker.isSelected(d) ? OPACITY_SELECT : OPACITY_SELECT_DIM;
      }

      if (_this.someHighlighted) return OPACITY_HIGHLT_DIM;

      return OPACITY_REGULAR;
    });

    this.entityBubbles.classed("vzb-selected", function (d) {
      return _this.model.marker.isSelected(d);
    });

    var nonSelectedOpacityZero = _this.model.marker.opacitySelectDim < 0.01;

    // when pointer events need update...
    if (nonSelectedOpacityZero !== this.nonSelectedOpacityZero) {
      this.entityBubbles.style("pointer-events", function (d) {
        return !_this.someSelected || !nonSelectedOpacityZero || _this.model.marker.isSelected(d) ? "visible" : "none";
      });
    }

    this.nonSelectedOpacityZero = _this.model.marker.opacitySelectDim < 0.01;
  },


  /**
   * Changes labels for indicators
   */
  updateIndicators: function updateIndicators() {
    this.sScale = this.model.marker.size.getScale();
    this.cScale = this.model.marker.color.getScale();
  },


  /**
   * Updates entities
   */
  updateEntities: function updateEntities() {

    var _this = this;
    var KEY = this.KEY;
    var TIMEDIM = this.TIMEDIM;

    var getKeys = function getKeys(prefix) {
      prefix = prefix || "";
      return _this.model.marker.getKeys().map(function (d) {
        var pointer = {};
        pointer[KEY] = d[KEY];
        pointer[TIMEDIM] = endTime;
        pointer.sortValue = _this.values.size[d[KEY]] || 0;
        pointer[KEY] = prefix + d[KEY];
        return pointer;
      }).sort(function (a, b) {
        return b.sortValue - a.sortValue;
      });
    };

    // get array of GEOs, sorted by the size hook
    // that makes larger bubbles go behind the smaller ones
    var endTime = this.model.time.end;
    this.model.marker.setVisible(getKeys.call(this));

    //unselecting bubbles with no data is used for the scenario when
    //some bubbles are selected and user would switch indicator.
    //bubbles would disappear but selection would stay
    if (!this.model.time.splash) {
      this.unselectBubblesWithNoData();
    }

    // TODO: add to csv
    //Africa 9.1021° N, 18.2812°E
    //Europe 53.0000° N, 9.0000° E
    //Asia 49.8380° N, 105.8203° E
    //north American 48.1667° N and longitude 100.1667° W
    /*
    var pos = {
      "afr": {lat: 9.1, lng: 18.3},
      "eur": {lat: 53.0, lng: 9.0},
      "asi": {lat: 49.8, lng: 105.8},
      "ame": {lat: 48.2, lng: -100.2},
    };
    */

    this.entityBubbles = this.bubbleContainer.selectAll(".vzb-bmc-bubble").data(this.model.marker.getVisible(), function (d) {
      return d[KEY];
    }).order();

    //exit selection
    this.entityBubbles.exit().remove();

    //enter selection -- init circles
    this.entityBubbles = this.entityBubbles.enter().append("circle").attr("class", "vzb-bmc-bubble").on("mouseover", function (d, i) {
      if (utils.isTouchDevice()) return;
      _this._interact()._mouseover(d, i);
    }).on("mouseout", function (d, i) {
      if (utils.isTouchDevice()) return;
      _this._interact()._mouseout(d, i);
    }).on("click", function (d, i) {
      if (utils.isTouchDevice()) return;
      _this._interact()._click(d, i);
      _this.highlightMarkers();
    }).onTap(function (d, i) {
      _this._interact()._click(d, i);
      d3.event.stopPropagation();
    }).onLongTap(function (d, i) {}).merge(this.entityBubbles);
  },
  unselectBubblesWithNoData: function unselectBubblesWithNoData(frame) {
    var _this = this;
    var KEY = this.KEY;
    if (!frame) frame = this.values;

    if (!frame || !frame.size) return;

    this.model.marker.select.forEach(function (d) {
      if (!frame.size[d[KEY]] && frame.size[d[KEY]] !== 0) _this.model.marker.selectMarker(d);
    });
  },
  redrawDataPoints: function redrawDataPoints(duration, reposition) {
    var _this = this;
    if (!duration) duration = this.duration;
    if (!reposition) reposition = true;
    if (!this.entityBubbles) return utils.warn("redrawDataPoints(): no entityBubbles defined. likely a premature call, fix it!");
    this.entityBubbles.each(function (d, index) {
      var view = d3.select(this);
      var geo = d3.select("#" + d[_this.KEY]);

      var valueX = _this.values.hook_lng[d[_this.KEY]];
      var valueY = _this.values.hook_lat[d[_this.KEY]];
      var valueS = _this.values.size[d[_this.KEY]];
      var valueC = _this.values.color[d[_this.KEY]];
      var valueL = _this.values.label[d[_this.KEY]];

      d.hidden_1 = d.hidden;
      d.hidden = !valueS && valueS !== 0 || valueX == null || valueY == null;

      if (d.hidden !== d.hidden_1) {
        if (duration) {
          view.transition().duration(duration).ease(d3.easeLinear).style("opacity", 0).on("end", function () {
            return view.classed("vzb-hidden", d.hidden).style("opacity", _this.model.marker.opacityRegular);
          });
        } else {
          view.classed("vzb-hidden", d.hidden);
        }
      }
      if (!d.hidden) {

        d.r = utils.areaToRadius(_this.sScale(valueS || 0));
        d.label = valueL;

        view.classed("vzb-hidden", false).attr("fill", valueC != null ? _this.cScale(valueC) : _this.COLOR_WHITEISH);

        if (_this.model.ui.map.colorGeo) geo.style("fill", valueC != null ? _this.cScale(valueC) : "#999");

        if (reposition) {
          d.cLoc = _this.skew(_this.projection([valueX || 0, valueY || 0]));

          view.attr("cx", d.cLoc[0]).attr("cy", d.cLoc[1]);
        }

        if (duration) {
          view.transition().duration(duration).ease(d3.easeLinear).attr("r", d.r);
        } else {
          view.interrupt().attr("r", d.r).transition();
        }

        _this._updateLabel(d, index, d.cLoc[0], d.cLoc[1], valueS, valueC, d.label, duration);
      } else {
        _this._updateLabel(d, index, 0, 0, valueS, valueC, valueL, duration);
      }
    });
  },


  /*
   * UPDATE TIME:
   * Ideally should only update when time or data changes
   */
  updateTime: function updateTime() {
    var _this = this;

    this.time_1 = this.time == null ? this.model.time.value : this.time;
    this.time = this.model.time.value;
    this.duration = this.model.time.playing && this.time - this.time_1 > 0 ? this.model.time.delayAnimations : 0;
    this.year.setText(this.model.time.formatDate(this.time), this.duration);

    //possibly update the exact value in size title
    this.updateTitleNumbers();
  },
  fitSizeOfTitles: function fitSizeOfTitles() {
    // reset font sizes first to make the measurement consistent
    var yTitleText = this.yTitleEl.select("text");
    yTitleText.style("font-size", null);

    var cTitleText = this.cTitleEl.select("text");
    cTitleText.style("font-size", null);

    var yTitleBB = yTitleText.node().getBBox();
    var cTitleBB = this.cTitleEl.classed("vzb-hidden") ? yTitleBB : cTitleText.node().getBBox();

    var font = Math.max(parseInt(yTitleText.style("font-size")), parseInt(cTitleText.style("font-size"))) * this.width / Math.max(yTitleBB.width, cTitleBB.width);

    if (Math.max(yTitleBB.width, cTitleBB.width) > this.width) {
      yTitleText.style("font-size", font + "px");
      cTitleText.style("font-size", font + "px");
    } else {

      // Else - reset the font size to default so it won't get stuck
      yTitleText.style("font-size", null);
      cTitleText.style("font-size", null);
    }
  },
  initMap: function initMap() {
    var _this2 = this;

    if (!this.topology) utils.warn("bubble map afterPreload: missing country shapes " + this.topology);

    // http://bl.ocks.org/mbostock/d4021aa4dccfd65edffd patterson
    // http://bl.ocks.org/mbostock/3710566 robinson
    // map background

    //stage

    this.projection = d3["geo" + utils.capitalize(this.model.ui.map.projection)]();

    this.mapPath = d3.geoPath().projection(this.projection);

    this.mapGraph = this.element.select(".vzb-bmc-map-graph");
    this.mapGraph.html("");

    this.mapFeature = _topojson2.default.feature(this.topology, this.topology.objects[this.model.ui.map.topology.objects.geo]);
    var boundaries = _topojson2.default.mesh(this.topology, this.topology.objects[this.model.ui.map.topology.objects.boundaries], function (a, b) {
      return a !== b;
    });

    // project to bounding box https://bl.ocks.org/mbostock/4707858
    this.projection.scale(1).translate([0, 0]);

    this.mapBounds = this.mapPath.bounds(this.mapFeature);

    if (this.mapFeature.features) {
      this.mapGraph.selectAll(".land").data(this.mapFeature.features).enter().insert("path").attr("d", this.mapPath).attr("id", function (d) {
        return d.properties[_this2.model.ui.map.topology.geoIdProperty].toLowerCase();
      }).attr("class", "land");
    } else {
      this.mapGraph.insert("path").datum(this.mapFeature).attr("class", "land");
    }

    this.mapGraph.insert("path").datum(boundaries).attr("class", "boundary");
  },


  profiles: {
    small: {
      margin: { top: 10, right: 10, left: 10, bottom: 0 },
      infoElHeight: 16,
      minRadius: 0.5,
      maxRadius: 30
    },
    medium: {
      margin: { top: 20, right: 20, left: 20, bottom: 30 },
      infoElHeight: 20,
      minRadius: 1,
      maxRadius: 55
    },
    large: {
      margin: { top: 30, right: 30, left: 30, bottom: 35 },
      infoElHeight: 22,
      minRadius: 1,
      maxRadius: 65
    }
  },

  presentationProfileChanges: {
    medium: {
      infoElHeight: 26
    },
    large: {
      infoElHeight: 32
    }
  },

  /**
   * Executes everytime the container or vizabi is resized
   * Ideally,it contains only operations related to size
   */
  updateSize: function updateSize() {

    this.activeProfile = this.getActiveProfile(this.profiles, this.presentationProfileChanges);
    var margin = this.activeProfile.margin;

    this.height = parseInt(this.element.style("height"), 10) - margin.top - margin.bottom || 0;
    this.width = parseInt(this.element.style("width"), 10) - margin.left - margin.right || 0;

    if (this.height <= 0 || this.width <= 0) return utils.warn("Bubble map updateSize() abort: vizabi container is too little or has display:none");

    this.repositionElements();
    this.rescaleMap();
  },
  repositionElements: function repositionElements() {

    var margin = this.activeProfile.margin;
    var infoElHeight = this.activeProfile.infoElHeight;
    var isRTL = this.model.locale.isRTL();

    this.graph.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    this.year.setConditions({
      widthRatio: 2 / 10
    });
    this.year.resize(this.width, this.height);

    this.yTitleEl.style("font-size", infoElHeight).attr("transform", "translate(" + (isRTL ? this.width : 0) + "," + margin.top + ")");

    var yTitleBB = this.yTitleEl.select("text").node().getBBox();

    //hide the second line about color in large profile or when color is constant
    this.cTitleEl.attr("transform", "translate(" + (isRTL ? this.width : 0) + "," + (margin.top + yTitleBB.height) + ")").classed("vzb-hidden", this.getLayoutProfile() === "large" || this.model.marker.color.use == "constant");

    var warnBB = this.dataWarningEl.select("text").node().getBBox();
    this.dataWarningEl.select("svg").attr("width", warnBB.height * 0.75).attr("height", warnBB.height * 0.75).attr("x", -warnBB.width - warnBB.height * 1.2).attr("y", -warnBB.height * 0.65);

    this.dataWarningEl.attr("transform", "translate(" + this.width + "," + (this.height - warnBB.height * 0.5) + ")").select("text");

    if (this.yInfoEl.select("svg").node()) {
      var titleBBox = this.yTitleEl.node().getBBox();
      var t = utils.transform(this.yTitleEl.node());
      var hTranslate = isRTL ? titleBBox.x + t.translateX - infoElHeight * 1.4 : titleBBox.x + t.translateX + titleBBox.width + infoElHeight * 0.4;

      this.yInfoEl.select("svg").attr("width", infoElHeight).attr("height", infoElHeight);
      this.yInfoEl.attr("transform", "translate(" + hTranslate + "," + (t.translateY - infoElHeight * 0.8) + ")");
    }

    this.cInfoEl.classed("vzb-hidden", this.cTitleEl.classed("vzb-hidden"));

    if (!this.cInfoEl.classed("vzb-hidden") && this.cInfoEl.select("svg").node()) {
      var _titleBBox = this.cTitleEl.node().getBBox();
      var _t = utils.transform(this.cTitleEl.node());
      var _hTranslate = isRTL ? _titleBBox.x + _t.translateX - infoElHeight * 1.4 : _titleBBox.x + _t.translateX + _titleBBox.width + infoElHeight * 0.4;

      this.cInfoEl.select("svg").attr("width", infoElHeight).attr("height", infoElHeight);
      this.cInfoEl.attr("transform", "translate(" + _hTranslate + "," + (_t.translateY - infoElHeight * 0.8) + ")");
    }
  },
  rescaleMap: function rescaleMap() {

    var offset = this.model.ui.map.offset;
    var margin = this.activeProfile.margin;

    // scale to aspect ratio
    // http://bl.ocks.org/mbostock/4707858
    var s = this.model.ui.map.scale / Math.max((this.mapBounds[1][0] - this.mapBounds[0][0]) / this.width, (this.mapBounds[1][1] - this.mapBounds[0][1]) / this.height);

    // dimensions of the map itself (regardless of cropping)
    var mapWidth = s * (this.mapBounds[1][0] - this.mapBounds[0][0]);
    var mapHeight = s * (this.mapBounds[1][1] - this.mapBounds[0][1]);

    // dimensions of the viewport in which the map is shown (can be bigger or smaller than map)
    var viewPortHeight = mapHeight * (1 + offset.top + offset.bottom);
    var viewPortWidth = mapWidth * (1 + offset.left + offset.right);
    var mapTopOffset = mapHeight * offset.top;
    var mapLeftOffset = mapWidth * offset.left;

    // translate projection to the middle of map
    var t = [(mapWidth - s * (this.mapBounds[1][0] + this.mapBounds[0][0])) / 2, (mapHeight - s * (this.mapBounds[1][1] + this.mapBounds[0][1])) / 2];

    this.projection.scale(s).translate(t);

    this.mapGraph.selectAll("path").attr("d", this.mapPath);

    // handle scale to fit case
    var widthScale = void 0,
        heightScale = void 0;
    if (!this.model.ui.map.preserveAspectRatio) {

      // wrap viewBox around viewport so map scales to fit viewport
      var viewBoxHeight = viewPortHeight;
      var viewBoxWidth = viewPortWidth;

      // viewport is complete area (apart from scaling)
      viewPortHeight = this.height * this.model.ui.map.scale;
      viewPortWidth = this.width * this.model.ui.map.scale;

      this.mapSvg.attr("preserveAspectRatio", "none").attr("viewBox", [0, 0, viewBoxWidth, viewBoxHeight].join(" "));

      //            ratio between map, viewport and offset (for bubbles)
      widthScale = viewPortWidth / mapWidth / (1 + offset.left + offset.right);
      heightScale = viewPortHeight / mapHeight / (1 + offset.top + offset.bottom);
    } else {

      // no scaling needed
      widthScale = 1;
      heightScale = 1;
    }

    // internal offset against parent container (mapSvg)
    this.mapGraph.attr("transform", "translate(" + mapLeftOffset + "," + mapTopOffset + ")");

    // resize and put in center
    this.mapSvg.style("transform", "translate3d(" + (margin.left + (this.width - viewPortWidth) / 2) + "px," + (margin.top + (this.height - viewPortHeight) / 2) + "px,0)").attr("width", viewPortWidth).attr("height", viewPortHeight);

    // set skew function used for bubbles in chart
    var _this = this;
    this.skew = function () {
      var w = _this.width;
      var h = _this.height;
      //input pixel loc after projection, return pixel loc after skew;
      return function (points) {
        //      input       scale         translate                    translate offset
        var x = points[0] * widthScale + (w - viewPortWidth) / 2 + mapLeftOffset * widthScale;
        var y = points[1] * heightScale + (h - viewPortHeight) / 2 + mapTopOffset * heightScale;
        return [x, y];
      };
    }();
  },
  updateMarkerSizeLimits: function updateMarkerSizeLimits() {
    var _this = this;
    var extent = this.model.marker.size.extent || [0, 1];

    var minRadius = this.activeProfile.minRadius;
    var maxRadius = this.activeProfile.maxRadius;

    this.minRadius = Math.max(maxRadius * extent[0], minRadius);
    this.maxRadius = Math.max(maxRadius * extent[1], minRadius);

    if (this.model.marker.size.scaleType !== "ordinal") {
      this.sScale.range([utils.radiusToArea(_this.minRadius), utils.radiusToArea(_this.maxRadius)]);
    } else {
      this.sScale.rangePoints([utils.radiusToArea(_this.minRadius), utils.radiusToArea(_this.maxRadius)], 0).range();
    }
  },
  _interact: function _interact() {
    var _this = this;

    return {
      _mouseover: function _mouseover(d, i) {
        if (_this.model.time.dragging) return;

        _this.model.marker.highlightMarker(d);

        _this.hovered = d;
        //put the exact value in the size title
        _this.updateTitleNumbers();
        _this.fitSizeOfTitles();

        if (_this.model.marker.isSelected(d)) {
          // if selected, not show hover tooltip
          _this._setTooltip();
        } else {
          //position tooltip
          _this._setTooltip(d);
        }
      },
      _mouseout: function _mouseout(d, i) {
        if (_this.model.time.dragging) return;
        _this._setTooltip();
        _this.hovered = null;
        _this.updateTitleNumbers();
        _this.fitSizeOfTitles();
        _this.model.marker.clearHighlighted();
      },
      _click: function _click(d, i) {
        _this.model.marker.selectMarker(d);
      }
    };
  },
  highlightMarkers: function highlightMarkers() {
    var _this = this;
    this.someHighlighted = this.model.marker.highlight.length > 0;

    if (utils.isTouchDevice()) {
      if (this.someHighlighted) {
        _this.hovered = this.model.marker.highlight[0];
      } else {
        _this.hovered = null;
      }
      _this.updateTitleNumbers();
      _this.fitSizeOfTitles();
    }

    //      if (!this.selectList || !this.someSelected) return;
    //      this.selectList.classed("vzb-highlight", function (d) {
    //          return _this.model.entities.isHighlighted(d);
    //      });
    //      this.selectList.each(function (d, i) {
    //        d3.select(this).selectAll(".vzb-bmc-label-x")
    //          .classed("vzb-invisible", function(n) {
    //            return !_this.model.entities.isHighlighted(d);
    //          });
    //
    //      });
  },
  _updateLabel: function _updateLabel(d, index, valueX, valueY, valueS, valueC, valueL, duration) {
    var _this = this;
    var KEY = this.KEY;
    if (d[KEY] == _this.druging) return;
    if (duration == null) duration = _this.duration;

    // only for selected entities
    if (_this.model.marker.isSelected(d)) {

      var showhide = d.hidden !== d.hidden_1;
      var valueLST = null;
      var cache = {};
      cache.labelX0 = valueX / this.width;
      cache.labelY0 = valueY / this.height;
      cache.scaledS0 = valueS ? utils.areaToRadius(_this.sScale(valueS)) : null;
      cache.scaledC0 = valueC != null ? _this.cScale(valueC) : _this.COLOR_WHITEISH;

      this._labels.updateLabel(d, index, cache, valueX / this.width, valueY / this.height, valueS, valueC, valueL, valueLST, duration, showhide);
    }
  },
  selectMarkers: function selectMarkers() {
    var _this = this;
    var KEY = this.KEY;
    this.someSelected = this.model.marker.select.length > 0;

    //      this._selectlist.rebuild();
    if (utils.isTouchDevice()) {
      _this._labels.showCloseCross(null, false);
      if (_this.someHighlighted) {
        _this.model.marker.clearHighlighted();
      } else {
        _this.updateTitleNumbers();
        _this.fitSizeOfTitles();
      }
    } else {
      // hide recent hover tooltip
      if (!_this.hovered || _this.model.marker.isSelected(_this.hovered)) {
        _this._setTooltip();
      }
    }

    this.nonSelectedOpacityZero = false;
  },
  _setTooltip: function _setTooltip(d) {
    var _this = this;
    if (d) {
      var tooltipText = d.label;
      var x = d.cLoc[0];
      var y = d.cLoc[1];
      var offset = d.r;
      var mouse = d3.mouse(this.graph.node()).map(function (d) {
        return parseInt(d);
      });
      var xPos = void 0,
          yPos = void 0,
          xSign = -1,
          ySign = -1,
          xOffset = 0,
          yOffset = 0;

      if (offset) {
        xOffset = offset * 0.71; // .71 - sin and cos for 315
        yOffset = offset * 0.71;
      }
      //position tooltip
      this.tooltip.classed("vzb-hidden", false)
      //.attr("style", "left:" + (mouse[0] + 50) + "px;top:" + (mouse[1] + 50) + "px")
      .selectAll("text").text(tooltipText);

      var contentBBox = this.tooltip.select("text").node().getBBox();
      if (x - xOffset - contentBBox.width < 0) {
        xSign = 1;
        x += contentBBox.width + 5; // corrective to the block Radius and text padding
      } else {
        x -= 5; // corrective to the block Radius and text padding
      }
      if (y - yOffset - contentBBox.height < 0) {
        ySign = 1;
        y += contentBBox.height;
      } else {
        y -= 11; // corrective to the block Radius and text padding
      }
      if (offset) {
        xPos = x + xOffset * xSign;
        yPos = y + yOffset * ySign; // 5 and 11 - corrective to the block Radius and text padding
      } else {
        xPos = x + xOffset * xSign; // .71 - sin and cos for 315
        yPos = y + yOffset * ySign; // 5 and 11 - corrective to the block Radius and text padding
      }
      this.tooltip.attr("transform", "translate(" + (xPos ? xPos : mouse[0]) + "," + (yPos ? yPos : mouse[1]) + ")");

      this.tooltip.select("rect").attr("width", contentBBox.width + 8).attr("height", contentBBox.height * 1.2).attr("x", -contentBBox.width - 4).attr("y", -contentBBox.height * 0.85).attr("rx", contentBBox.height * 0.2).attr("ry", contentBBox.height * 0.2);
    } else {

      this.tooltip.classed("vzb-hidden", true);
    }
  },
  preload: function preload() {
    var _this = this;

    var shape_path = this.model.ui.map.topology.path || _globals2.default.ext_resources.host + _globals2.default.ext_resources.preloadPath + "world-50m.json";

    return new Promise(function (resolve, reject) {
      d3.json(shape_path, function (error, json) {
        if (error) return console.warn("Failed loading json " + shape_path + ". " + error);
        _this.topology = json;
        resolve();
      });
    });
  }
});

exports.default = BubbleMapComponent;

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _labels = __webpack_require__(73);

var _labels2 = _interopRequireDefault(_labels);

var _iconset = __webpack_require__(10);

var _d = __webpack_require__(89);

var _d2 = _interopRequireDefault(_d);

var _d3 = __webpack_require__(60);

var _d4 = _interopRequireDefault(_d3);

var _globals = __webpack_require__(34);

var _globals2 = _interopRequireDefault(_globals);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//import Selectlist from 'bubblemap-selectlist';

//BUBBLE MAP CHART COMPONENT
var CartogramComponent = _component2.default.extend({
  /**
   * Initializes the component (Bubble Map Chart).
   * Executed once before any template is rendered.
   * @param {Object} config The config passed to the component
   * @param {Object} context The component's parent
   */
  init: function init(config, context) {
    this.name = "cartogram";
    this.template = __webpack_require__(463);

    this.isMobile = utils.isMobileOrTablet();

    //define expected models for this component
    this.model_expects = [{
      name: "time",
      type: "time"
    }, {
      name: "entities",
      type: "entities"
    }, {
      name: "marker",
      type: "model"
    }, {
      name: "locale",
      type: "locale"
    }, {
      name: "ui",
      type: "ui"
    }];

    var _this = this;
    this.model_binds = {
      "change:time.value": function changeTimeValue(evt) {
        if (!_this._readyOnce) return;
        if (!_this.calculationQueue) {
          // collect timestamp that we request
          _this.calculationQueue = [_this.model.time.value.toString()];
        } else {
          _this.calculationQueue.push(_this.model.time.value.toString());
        }
        (function (time) {
          // isolate timestamp
          _this.model.marker.getFrame(time, function (frame, time) {
            var index = _this.calculationQueue.indexOf(time.toString()); //
            if (index == -1) {
              // we was receive more recent frame before so we pass this frame
              return;
            }
            _this.calculationQueue.splice(0, index + 1); // remove timestamps that added to queue before current timestamp
            _this.frameChanged(frame, time);
          });
        })(_this.model.time.value);
      },
      "change:marker.size.extent": function changeMarkerSizeExtent(evt, path) {
        //console.log("EVENT change:marker:size:max");
        if (!_this._readyOnce) return;
        _this.updateMarkerSizeLimits();
        _this.updateEntities();
      },
      "change:marker.color.scaleType": function changeMarkerColorScaleType(evt, path) {
        _this.updateIndicators();
        _this.updateEntitityColor();
      },

      "change:marker.size.use": function changeMarkerSizeUse(evt, path) {
        _this.model.ui.chart.lockActive = _this.model.marker.size.use != "constant";
      },
      "change:marker.color.palette": function changeMarkerColorPalette(evt, path) {
        _this.updateEntitityColor();
      },
      "change:ui.chart.lockNonSelected": function changeUiChartLockNonSelected(evt) {
        _this.updateEntities(900);
      },
      "change:entities.select": function changeEntitiesSelect() {
        if (!_this._readyOnce) return;
        _this.updateLandOpacity();
      },
      "change:entities.highlight": function changeEntitiesHighlight() {
        if (!_this._readyOnce) return;
        //console.log("EVENT change:entities:highlight");
        _this.updateLandOpacity();
      },
      "change:entities.opacitySelectDim": function changeEntitiesOpacitySelectDim() {
        _this.updateLandOpacity();
      },
      "change:entities.opacityRegular": function changeEntitiesOpacityRegular() {
        _this.updateLandOpacity();
      }
    };
    //this._selectlist = new Selectlist(this);

    //contructor is the same as any component
    this._super(config, context);

    _this.COLOR_LAND_DEFAULT = "#fdfdfd";

    this.lands = null;
    this.features = null;
    this.topo_features = null;
    this.borderArcs = null;
    this.defaultWidth = 700;
    this.defaultHeight = 550;
    this.updateEntitiesQueue = [];
    this.boundBox = [[0.05, 0.0], [0.95, 1.0]]; // two points to set box bound on 960 * 500 image;
    (0, _d2.default)();
    this.cached = [];
    this.projection = d3.geo.mercator().center([25, -29]).scale(1900).translate([this.defaultWidth / 2, this.defaultHeight / 2]).precision(0.1);

    this.cartogram = d3.cartogram().projection(this.projection).properties(function (d) {
      return d.properties;
    });

    this._labels = new _labels2.default(this);
    this._labels.config({
      CSS_PREFIX: "vzb-ct",
      LABELS_CONTAINER_CLASS: "vzb-ct-labels",
      LINES_CONTAINER_CLASS: "vzb-ct-lines"
    });
  },
  afterPreload: function afterPreload() {
    var _this = this;
    if (!this.world) utils.warn("cartogram afterPreload: missing country shapes " + this.world);
    if (!this.geometries) utils.warn("cartogram afterPreload: missing country shapes " + this.geometries);

    // http://bl.ocks.org/mbostock/d4021aa4dccfd65edffd patterson
    // http://bl.ocks.org/mbostock/3710566 robinson
    // map background

    this.borderArcs = _this.cartogram.meshArcs(this.world, this.world.objects.topo, function (a, b) {
      return a.properties.MN_NAME && a.properties.PR_NAME !== b.properties.PR_NAME;
    });
  },
  _getKey: function _getKey(d) {
    return d.properties[this.id_lookup] ? d.properties[this.id_lookup].toString() : d.id.toString();
  },

  /**
   * DOM is ready
   */
  readyOnce: function readyOnce() {
    var _this2 = this;

    this.element = d3.select(this.element);

    this.graph = this.element.select(".vzb-ct-graph");
    this.mapSvg = this.element.select(".vzb-ct-map-background");

    this.labelsContainerCrop = this.graph.select(".vzb-ct-labels-crop");
    this.labelsContainer = this.graph.select(".vzb-ct-labels");

    this.yTitleEl = this.graph.select(".vzb-ct-axis-y-title");
    this.sTitleEl = this.graph.select(".vzb-ct-axis-c-title");
    this.yInfoEl = this.graph.select(".vzb-ct-axis-y-info");
    this.sInfoEl = this.graph.select(".vzb-ct-axis-c-info");
    this.dataWarningEl = this.graph.select(".vzb-data-warning");
    this.entityBubbles = null;
    this.tooltip = this.element.select(".vzb-ct-tooltip");

    // year background
    this.yearEl = this.graph.select(".vzb-ct-year");
    this.year = new _d4.default(this.yearEl);
    this.year.setConditions({ xAlign: "left", yAlign: "bottom", bottomOffset: 5 });
    this.mapGraph = this.element.select(".vzb-ct-map-graph").attr("width", this.defaultWidth).attr("height", this.defaultHeight);
    this.mapGraph.html("");

    this.KEY = this.model.entities.getDimension();
    this.TIMEDIM = this.model.time.getDimension();

    var _this = this;
    this.updateUIStrings();
    this.on("resize", function () {
      return _this2.updateSize();
    });
    this.wScale = d3.scale.linear().domain(this.model.ui.datawarning.doubtDomain).range(this.model.ui.datawarning.doubtRange);

    this.cartogram.iterations(0);
    this.redrawInProgress = true;

    this.cartogram(this.world, this.geometries).then(function (response) {
      _this.redrawInProgress = false;

      _this.features = _this.topo_features = response.features;
      _this.lands = _this.mapGraph.selectAll(".land").data(_this.topo_features).enter().append("path").attr("class", function (d) {
        return "land " + (d.properties[_this.id_lookup] ? d.properties[_this.id_lookup] : d.id);
      }).attr("d", _this.cartogram.path).on("mouseover", function (d, i) {
        if (utils.isTouchDevice()) return;
        _this._interact()._mouseover(d, i);
      }).on("mouseout", function (d, i) {
        if (utils.isTouchDevice()) return;
        _this._interact()._mouseout(d, i);
      }).on("click", function (d, i) {
        if (utils.isTouchDevice()) return;
        _this._interact()._click(d, i);
      }).each(function (d) {
        d[_this.KEY] = _this._getKey(d);
      });

      if (_this.borderArcs) {
        var data = _this.cartogram.stitchArcs(response, _this.borderArcs);
        _this.borders = _this.mapGraph.append("path").datum(data).attr("class", "boundary").attr("d", _this.cartogram.path);
      }
    });
  },
  frameChanged: function frameChanged(frame, time) {
    if (time.toString() != this.model.time.value.toString()) return; // frame is outdated
    if (!frame) return;
    this.values = frame;
    this.updateTime();
    this.updateTitleNumbers();
    this.updateEntities(this.duration);
  },


  /*
   * Both model and DOM are ready
   */
  ready: function ready() {
    var _this = this;
    this.cached = [];
    this.updateIndicators();
    this.updateUIStrings();
    this.updateMarkerSizeLimits();
    this.updateSize();
    this.model.marker.getFrame(_this.model.time.value, _this.frameChanged.bind(_this));
  },


  /**
   * Changes labels for indicators
   */
  updateIndicators: function updateIndicators() {
    this.sScale = this.model.marker.size.getScale();
    this.cScale = this.model.marker.color.getScale();
  },
  updateMarkerSizeLimits: function updateMarkerSizeLimits() {
    var _this = this;
    var extent = this.model.marker.size.extent || [0, 1];
    this.minRadius = Math.max(100 * extent[0], 0);
    this.maxRadius = Math.max(100 * extent[1], 0);

    this.sScale.domain([0, this.sScale.domain()[1]]);
    if (this.model.marker.size.scaleType !== "ordinal") {
      this.sScale.range([this.minRadius, this.maxRadius]);
    } else {
      this.sScale.rangePoints([this.minRadius, this.maxRadius], 0).range();
    }
  },
  _calculateTotalSize: function _calculateTotalSize(year, frame) {
    if (this.cached[year]) {
      return this.cached[year];
    }
    var _this = this;
    this.cached[year] = 0;
    utils.forEach(frame, function (val) {
      _this.cached[year] += _this.sScale(val);
    });
    return this.cached[year];
  },
  _redrawEntities: function _redrawEntities() {
    var _this = this;
    if (this.updateEntitiesQueue.length == 0) return;
    if (this.redrawInProgress) {
      setTimeout(function () {
        _this._redrawEntities();
      }, 100);
      return;
    }
    this.redrawInProgress = true;
    var time = this.updateEntitiesQueue[this.updateEntitiesQueue.length - 1].time;
    var duration = this.updateEntitiesQueue[this.updateEntitiesQueue.length - 1].duration;
    this.updateEntitiesQueue = [];
    if (this.model.ui.chart.lockNonSelected) {
      time = this.model.time.parse("" + this.model.ui.chart.lockNonSelected);
    }
    this.model.marker.getFrame(time, function (lockedFrame) {
      var totValue = null;
      if (_this.model.marker.size.use == "constant") {
        _this.cartogram.iterations(0);
      } else {
        _this.cartogram.iterations(8);
        //var areas = _this.topo_features.map(d3.geo.path().projection(null).area);
        _this.cartogram.value(function (d) {
          if (_this.model.ui.chart.lockNonSelected) {
            var size1 = _this.sScale(lockedFrame.size[_this._getKey(d)]); /* * _this._calculateTotalSize(_this.model.time.value, _this.values.size)*/
            var size2 = _this.sScale(_this.values.size[_this._getKey(d)]); /* * _this._calculateTotalSize(time, lockedFrame.size)*/
            return d3.geo.path().projection(null).area(d) * Math.pow(size2 / size1, 2);
          }
          return _this.sScale(_this.values.size[_this._getKey(d)]);
        });
        /*
         if (_this.model.ui.chart.lockNonSelected) {
         totValue = d3.sum(areas);
         }
         */
      }
      var calcDuration = 0;
      var start = new Date().getTime();
      _this.cartogram(_this.world, _this.geometries, totValue).then(function (response) {
        var end = new Date().getTime();
        if (duration) {
          // increale duration for prevent gaps between frames
          duration = Math.max(duration, end - start);
        }
        _this.features = response.features;
        if (_this.borderArcs) {
          var data = _this.cartogram.stitchArcs(response, _this.borderArcs);
          _this.borders.datum(data).transition().duration(duration).ease(d3.easeLinear).attr("d", _this.cartogram.path);
        }
        _this.lands.data(_this.features).each(function (d) {
          d[_this.KEY] = _this._getKey(d);
        });
        if (duration) {
          _this.lands.interrupt().transition().duration(duration).ease(d3.easeLinear).style("fill", function (d) {
            return _this.values.color[_this._getKey(d)] != null ? _this.cScale(_this.values.color[_this._getKey(d)]) : _this.COLOR_LAND_DEFAULT;
          }).attr("d", _this.cartogram.path);
          if (_this.borderArcs) {
            _this.borders.interrupt().transition().duration(duration).ease(d3.easeLinear).attr("d", _this.cartogram.path);
          }
        } else {
          _this.borders.attr("d", _this.cartogram.path);

          _this.lands.style("fill", function (d) {
            return _this.values.color[_this._getKey(d)] != null ? _this.cScale(_this.values.color[_this._getKey(d)]) : _this.COLOR_LAND_DEFAULT;
          }).attr("d", _this.cartogram.path);
        }
        _this.updateLandOpacity();
        _this.redrawInProgress = false;
        _this._redrawEntities();
      });
    });
  },
  updateEntities: function updateEntities(duration) {
    var time = this.model.time.value;

    this.updateEntitiesQueue.push({ time: time, duration: duration });
    this._redrawEntities();
  },
  updateEntitityColor: function updateEntitityColor() {
    var _this = this;
    this.lands.transition().duration(_this.duration).ease(d3.easeLinear).style("fill", function (d) {
      return _this.values.color[_this._getKey(d)] != null ? _this.cScale(_this.values.color[_this._getKey(d)]) : _this.COLOR_LAND_DEFAULT;
    });
  },
  updateUIStrings: function updateUIStrings() {
    var _this = this;

    this.translator = this.model.locale.getTFunction();
    var sizeConceptprops = this.model.marker.size.getConceptprops();
    this.strings = {
      title: {
        C: (_this.model.marker.size.use !== "constant" ? this.translator("buttons/color") + ": " : "") + this.translator("indicator/" + _this.model.marker.color.which),
        S: this.translator("buttons/size") + ": " + this.translator("indicator/" + _this.model.marker.size.which)
      }
    };

    this.yTitleEl.select("text")
    //don't show "Color:" when the size is constant and we are only showing color
    .text(this.strings.title.C).on("click", function () {
      _this.parent.findChildByName("gapminder-treemenu").markerID("color").alignX("left").alignY("top").updateView().toggle();
    });

    this.sTitleEl.select("text").text(this.strings.title.S).on("click", function () {
      _this.parent.findChildByName("gapminder-treemenu").markerID("size").alignX("left").alignY("top").updateView().toggle();
    });

    utils.setIcon(this.dataWarningEl, _iconset.warn).select("svg").attr("width", "0px").attr("height", "0px");
    this.dataWarningEl.append("text").attr("text-anchor", "end").text(this.translator("hints/dataWarning"));

    this.dataWarningEl.on("click", function () {
      _this.parent.findChildByName("gapminder-datawarning").toggle();
    }).on("mouseover", function () {
      _this.updateDoubtOpacity(1);
    }).on("mouseout", function () {
      _this.updateDoubtOpacity();
    });

    this.yInfoEl.html(_iconset.question).select("svg").attr("width", "0px").attr("height", "0px");

    //TODO: move away from UI strings, maybe to ready or ready once
    this.yInfoEl.on("click", function () {
      _this.parent.findChildByName("gapminder-datanotes").pin();
    });
    this.yInfoEl.on("mouseover", function () {
      var rect = this.getBBox();
      var coord = utils.makeAbsoluteContext(this, this.farthestViewportElement)(rect.x - 10, rect.y + rect.height + 10);
      _this.parent.findChildByName("gapminder-datanotes").setHook("size").show().setPos(coord.x, coord.y);
    });
    this.yInfoEl.on("mouseout", function () {
      _this.parent.findChildByName("gapminder-datanotes").hide();
    });

    this.sInfoEl.html(_iconset.question).select("svg").attr("width", "0px").attr("height", "0px");

    //TODO: move away from UI strings, maybe to ready or ready once
    this.sInfoEl.on("click", function () {
      _this.parent.findChildByName("gapminder-datanotes").pin();
    });
    this.sInfoEl.on("mouseover", function () {
      var rect = this.getBBox();
      var coord = utils.makeAbsoluteContext(this, this.farthestViewportElement)(rect.x - 10, rect.y + rect.height + 10);
      _this.parent.findChildByName("gapminder-datanotes").setHook("color").show().setPos(coord.x, coord.y);
    });
    this.sInfoEl.on("mouseout", function () {
      _this.parent.findChildByName("gapminder-datanotes").hide();
    });
  },
  updateDoubtOpacity: function updateDoubtOpacity(opacity) {
    if (opacity == null) opacity = this.wScale(+this.time.getUTCFullYear().toString());
    if (this.someSelected) opacity = 1;
    this.dataWarningEl.style("opacity", opacity);
  },


  /*
   * UPDATE TIME:
   * Ideally should only update when time or data changes
   */
  updateTime: function updateTime() {
    var _this = this;
    this.time_1 = this.time == null ? this.model.time.value : this.time;
    this.time = this.model.time.value;
    this.duration = this.model.time.playing && this.time - this.time_1 > 0 ? this.model.time.delayAnimations : 0;
    this.year.setText(this.model.time.formatDate(this.time), this.duration);
  },


  /**
   * Executes everytime the container or vizabi is resized
   * Ideally,it contains only operations related to size
   */
  updateSize: function updateSize() {
    var profiles = {
      small: {
        margin: { top: 10, right: 10, left: 10, bottom: 0 },
        infoElHeight: 16
      },
      medium: {
        margin: { top: 20, right: 20, left: 20, bottom: 30 },
        infoElHeight: 20
      },
      large: {
        margin: { top: 30, right: 30, left: 30, bottom: 35 },
        infoElHeight: 22
      }
    };

    var presentationProfileChanges = {
      medium: {
        infoElHeight: 26
      },
      large: {
        infoElHeight: 32
      }
    };

    this.activeProfile = this.getActiveProfile(profiles, presentationProfileChanges);
    var margin = this.activeProfile.margin;
    var infoElHeight = this.activeProfile.infoElHeight;

    //stage

    var height = this.height = parseInt(this.element.style("height"), 10) - margin.top - margin.bottom || 0;
    var width = this.width = parseInt(this.element.style("width"), 10) - margin.left - margin.right || 0;

    if (this.height <= 0 || this.width <= 0) return utils.warn("Bubble map updateSize() abort: vizabi container is too little or has display:none");

    var boundBox = this.boundBox;
    var viewBox = [boundBox[0][0] * this.defaultWidth, boundBox[0][1] * this.defaultHeight, Math.abs(boundBox[1][0] - boundBox[0][0]) * this.defaultWidth, Math.abs(boundBox[1][1] - boundBox[0][1]) * this.defaultHeight];

    this.graph.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    this.year.resize(this.width, this.height);

    this.mapSvg.attr("width", width).attr("height", height).attr("viewBox", viewBox.join(" ")).attr("preserveAspectRatio", "xMidYMid").attr("x", margin.left).attr("y", margin.top).style("transform", "translate3d(" + margin.left + "px," + margin.top + "px,0)");

    this.yTitleEl.style("font-size", infoElHeight).attr("transform", "translate(0," + margin.top + ")");

    var yTitleBB = this.yTitleEl.select("text").node().getBBox();

    this.sTitleEl.attr("transform", "translate(" + 0 + "," + (margin.top + yTitleBB.height) + ")").classed("vzb-hidden", this.model.marker.size.use == "constant");

    var warnBB = this.dataWarningEl.select("text").node().getBBox();
    this.dataWarningEl.select("svg").attr("width", warnBB.height * 0.75).attr("height", warnBB.height * 0.75).attr("x", -warnBB.width - warnBB.height * 1.2).attr("y", -warnBB.height * 0.65);

    this.dataWarningEl.attr("transform", "translate(" + this.width + "," + (this.height - warnBB.height * 0.5) + ")").select("text");

    if (this.yInfoEl.select("svg").node()) {
      var titleBBox = this.yTitleEl.node().getBBox();
      var translate = d3.transform(this.yTitleEl.attr("transform")).translate;

      this.yInfoEl.select("svg").attr("width", infoElHeight).attr("height", infoElHeight);
      this.yInfoEl.attr("transform", "translate(" + (titleBBox.x + translate[0] + titleBBox.width + infoElHeight * 0.4) + "," + (translate[1] - infoElHeight * 0.8) + ")");
    }

    this.sInfoEl.classed("vzb-hidden", this.sTitleEl.classed("vzb-hidden"));

    if (!this.sInfoEl.classed("vzb-hidden") && this.sInfoEl.select("svg").node()) {
      var _titleBBox = this.sTitleEl.node().getBBox();
      var _translate = d3.transform(this.sTitleEl.attr("transform")).translate;

      this.sInfoEl.select("svg").attr("width", infoElHeight).attr("height", infoElHeight);
      this.sInfoEl.attr("transform", "translate(" + (_titleBBox.x + _translate[0] + _titleBBox.width + infoElHeight * 0.4) + "," + (_translate[1] - infoElHeight * 0.8) + ")");
    }
  },
  fitSizeOfTitles: function fitSizeOfTitles() {

    //reset font sizes first to make the measurement consistent
    var yTitleText = this.yTitleEl.select("text").style("font-size", null);
    var sTitleText = this.sTitleEl.select("text").style("font-size", null);

    var yTitleBB = yTitleText.node().getBBox();
    var sTitleBB = this.sTitleEl.classed("vzb-hidden") ? yTitleBB : sTitleText.node().getBBox();

    var font = Math.max(parseInt(yTitleText.style("font-size")), parseInt(sTitleText.style("font-size"))) * this.width / Math.max(yTitleBB.width, sTitleBB.width);

    if (Math.max(yTitleBB.width, sTitleBB.width) > this.width) {
      yTitleText.style("font-size", font + "px");
      sTitleText.style("font-size", font + "px");
    } else {
      // Else - reset the font size to default so it won't get stuck
      yTitleText.style("font-size", null);
      sTitleText.style("font-size", null);
    }
  },
  _interact: function _interact() {
    var _this = this;

    return {
      _mouseover: function _mouseover(d, i) {
        if (_this.model.time.dragging) return;

        _this.model.entities.highlightEntity(d);

        _this.hovered = d;
        //put the exact value in the size title
        _this.updateTitleNumbers();
        _this.fitSizeOfTitles();

        if (_this.model.entities.isSelected(d)) {
          // if selected, not show hover tooltip
          _this._setTooltip();
        } else {
          //position tooltip
          _this._setTooltip(d);
        }
      },
      _mouseout: function _mouseout(d, i) {
        if (_this.model.time.dragging) return;
        _this._setTooltip();
        _this.hovered = null;
        _this.updateTitleNumbers();
        _this.fitSizeOfTitles();
        _this.model.entities.clearHighlighted();
      },
      _click: function _click(d, i) {
        _this.model.entities.selectEntity(d);
      }
    };
  },


  // show size number on title when hovered on a bubble
  updateTitleNumbers: function updateTitleNumbers() {
    var _this = this;

    var mobile = void 0; // if is mobile device and only one bubble is selected, update the ytitle for the bubble
    if (_this.isMobile && _this.model.entities.select && _this.model.entities.select.length === 1) {
      mobile = _this.model.entities.select[0];
    }

    if (_this.hovered || mobile) {
      var hovered = _this.hovered || mobile;
      var formatterC = _this.model.marker.color.getTickFormatter();

      var unitC = _this.translator("unit/" + _this.model.marker.color.which);
      //suppress unit strings that found no translation (returns same thing as requested)
      if (unitC === "unit/" + _this.model.marker.color.which) unitC = "";

      var valueC = _this.values.color[_this._getKey(hovered)];
      _this.yTitleEl.select("text").text(this.strings.title.C + ": " + (valueC || valueC === 0 ? formatterC(valueC) + " " + unitC : _this.translator("hints/nodata")));

      if (this.model.marker.size.use !== "constant") {
        var formatterS = _this.model.marker.size.getTickFormatter();

        var unitS = _this.translator("unit/" + _this.model.marker.size.which);
        //suppress unit strings that found no translation (returns same thing as requested)
        if (unitS === "unit/" + _this.model.marker.size.which) unitS = "";

        var valueS = _this.values.size[_this._getKey(hovered)];
        _this.sTitleEl.select("text").text(this.strings.title.S + ": " + formatterS(valueS) + " " + unitS);
      }

      this.yInfoEl.classed("vzb-hidden", true);
      this.sInfoEl.classed("vzb-hidden", true);
    } else {
      this.yTitleEl.select("text").text(this.strings.title.C);
      this.sTitleEl.select("text").text(this.strings.title.S);

      this.yInfoEl.classed("vzb-hidden", false);
      this.sInfoEl.classed("vzb-hidden", false);
    }
  },
  _setTooltip: function _setTooltip(d) {
    var _this = this;
    if (d) {
      var tooltipText = this.values.label[this._getKey(d)] ? this.values.label[this._getKey(d)] : d.properties.MN_NAME;
      var offset = 10;
      var mouse = d3.mouse(this.graph.node()).map(function (d) {
        return parseInt(d);
      });
      var x = mouse[0];
      var y = mouse[1];
      var xPos = void 0,
          yPos = void 0,
          xSign = -1,
          ySign = -1,
          xOffset = 0,
          yOffset = 0;

      if (offset) {
        xOffset = offset * 0.71; // .71 - sin and cos for 315
        yOffset = offset * 0.71;
      }
      //position tooltip
      this.tooltip.classed("vzb-hidden", false)
      //.attr("style", "left:" + (mouse[0] + 50) + "px;top:" + (mouse[1] + 50) + "px")
      .selectAll("text").text(tooltipText);

      var contentBBox = this.tooltip.select("text").node().getBBox();
      if (x - xOffset - contentBBox.width < 0) {
        xSign = 1;
        x += contentBBox.width + 5; // corrective to the block Radius and text padding
      } else {
        x -= 5; // corrective to the block Radius and text padding
      }
      if (y - yOffset - contentBBox.height < 0) {
        ySign = 1;
        y += contentBBox.height;
      } else {
        y -= 11; // corrective to the block Radius and text padding
      }
      if (offset) {
        xPos = x + xOffset * xSign;
        yPos = y + yOffset * ySign; // 5 and 11 - corrective to the block Radius and text padding
      } else {
        xPos = x + xOffset * xSign; // .71 - sin and cos for 315
        yPos = y + yOffset * ySign; // 5 and 11 - corrective to the block Radius and text padding
      }
      this.tooltip.attr("transform", "translate(" + (xPos ? xPos : mouse[0]) + "," + (yPos ? yPos : mouse[1]) + ")");

      this.tooltip.select("rect").attr("width", contentBBox.width + 8).attr("height", contentBBox.height * 1.2).attr("x", -contentBBox.width - 4).attr("y", -contentBBox.height * 0.85).attr("rx", contentBBox.height * 0.2).attr("ry", contentBBox.height * 0.2);
    } else {

      this.tooltip.classed("vzb-hidden", true);
    }
  },
  updateLandOpacity: function updateLandOpacity() {
    var _this = this;
    //if(!duration)duration = 0;

    var OPACITY_HIGHLT = 0.8;
    var OPACITY_HIGHLT_DIM = 0.3;
    var OPACITY_SELECT = this.model.entities.opacityRegular;
    var OPACITY_REGULAR = this.model.entities.opacityRegular;
    var OPACITY_SELECT_DIM = this.model.entities.opacitySelectDim;
    this.someHighlighted = this.model.entities.highlight.length > 0;
    this.someSelected = this.model.entities.select.length > 0;
    this.lands.style("opacity", function (d) {

      if (_this.someHighlighted) {
        //highlight or non-highlight
        if (_this.model.entities.isHighlighted(d)) return OPACITY_HIGHLT;
      }

      if (_this.someSelected) {
        //selected or non-selected
        return _this.model.entities.isSelected(d) ? OPACITY_SELECT : OPACITY_SELECT_DIM;
      }

      if (_this.someHighlighted) return OPACITY_HIGHLT_DIM;

      return OPACITY_REGULAR;
    });

    var someSelectedAndOpacityZero = _this.someSelected && _this.model.entities.opacitySelectDim < 0.01;

    // when pointer events need update...
    if (someSelectedAndOpacityZero != this.someSelectedAndOpacityZero_1) {
      this.lands.style("pointer-events", function (d) {
        return !someSelectedAndOpacityZero || _this.model.entities.isSelected(d) ? "visible" : "none";
      });
    }

    this.someSelectedAndOpacityZero_1 = _this.someSelected && _this.model.entities.opacitySelectDim < 0.01;
  },
  preload: function preload() {
    var _this = this;
    var shape_path = _globals2.default.ext_resources.shapePath ? _globals2.default.ext_resources.shapePath : _globals2.default.ext_resources.host + _globals2.default.ext_resources.preloadPath + "municipalities.json";

    return new Promise(function (resolve, reject) {
      d3.json(shape_path, function (error, json) {
        if (error) return console.warn("Failed loading json " + shape_path + ". " + error);
        _this.world = json;
        _this.geometries = json.objects.topo.geometries;
        _this.id_lookup = json.objects.id_lookup;
        resolve();
      });
    });
  }
});

exports.default = CartogramComponent;

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//DONUT CHART COMPONENT
/*!
 * VIZABI DONUT CHART
 */

var DonutComponent = _component2.default.extend("donut", {
    init: function init(config, context) {
        var _this = this;

        this.name = "donutchart";
        this.template = '<div class="vzb-donutchart"><svg class="vzb-donutchart-svg"></svg></div>';

        //define expected models for this component
        this.model_expects = [{
            name: "time",
            type: "time"
        }, {
            name: "marker",
            type: "model"
        }];

        //bind the function updateTime() to the change of time value in the model
        this.model_binds = {
            "change:time:value": function changeTimeValue(evt) {
                if (!_this._readyOnce) return;
                //fetch the time from the model and update the text on screen
                _this.time = _this.model.time.value;
                _this.yearEl.text(_this.timeFormatter(_this.time));
                _this.redraw();
            }
        };

        //call the prototype constructor of the component
        this._super(config, context);

        //init variables for d3 pie layout
        this.colorScale = null;
        this.arc = d3.svg.arc();
        this.pie = d3.layout.pie().sort(null).value(function (d) {
            return d.pop;
        });
    },


    /**
     * DOM is ready and the model is ready -- happens once on the load and never again
     */
    readyOnce: function readyOnce() {
        var _this = this;

        //link DOM elements to the variables
        this.element = d3.select(this.element);
        this.svgEl = this.element.select("svg").append("g");
        this.yearEl = this.svgEl.append("text").attr("class", "year").style({ "font-size": "4em" });
        this.titleEl = this.svgEl.append("text").attr("class", "title").style({ "font-size": "2em" });

        //bind the resize() and updateTime() events to container resize
        this.on("resize", function () {
            _this.resize();
            _this.redraw();
        });

        //run a startup sequence
        this.resize();
        this.update();
        this.redraw();
    },


    /**
     * Populate the visuals according to the number of entities
     */
    update: function update() {
        this.timeFormatter = this.model.time.formatters.data("%Y");
        this.colorScale = this.model.marker.color.getScale();

        this.titleEl.text("Population");
        this.keys = this.model.marker.getKeys();

        this.entities = this.svgEl.selectAll(".vzb-dc-entity").data(this.keys);

        //exit selection
        this.entities.exit().remove();

        //enter selection
        this.entities.enter().append("g").attr("class", "vzb-dc-entity").each(function () {
            d3.select(this).append("path");
            d3.select(this).append("text").attr("class", "label").style({ "font-size": "1.2em" });
        });
    },


    /**
     * Updates the visuals
     */
    redraw: function redraw() {
        var _this = this;

        //request the values for the current time from the model
        this.values = this.model.marker.getValues({ time: _this.time }, ["geo"]);

        //prepare the data
        var data = this.keys.map(function (d) {
            return {
                geo: d.geo,
                pop: _this.values.axis[d.geo],
                color: _this.values.color[d.geo],
                label: _this.values.label[d.geo]
            };
        });

        data = this.pie(data);

        //set the properties of the donuts and text labels
        this.entities.data(data).select("path").attr("d", this.arc).style("fill", function (d) {
            return _this.colorScale(d.data.color);
        }).style("stroke", "white");

        this.entities.select("text").style({
            "text-transform": "capitalize"
        }).attr("transform", function (d) {
            return "translate(" + _this.arc.centroid(d) + ")";
        }).text(function (d) {
            return d.data.geo;
        });
    },


    /**
     * Executes every time the container or vizabi is resized
     */
    resize: function resize() {

        var height = parseInt(this.element.style("height"), 10) || 0;
        var width = parseInt(this.element.style("width"), 10) || 0;
        var min = Math.min(height, width);

        if (height <= 0 || width <= 0) return utils.warn("Donut chart resize() abort: vizabi container is too little or has display:none");

        this.svgEl.attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");
        this.titleEl.attr("y", "-0.1em");
        this.yearEl.attr("y", "0.1em");

        this.arc.outerRadius(min / 2 * 0.9).innerRadius(min / 2 - min * 0.1);
    }
});

exports.default = DonutComponent;

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _labels = __webpack_require__(73);

var _labels2 = _interopRequireDefault(_labels);

var _iconset = __webpack_require__(10);

var _d = __webpack_require__(60);

var _d2 = _interopRequireDefault(_d);

var _globals = __webpack_require__(34);

var _globals2 = _interopRequireDefault(_globals);

var _bubblemapMap = __webpack_require__(226);

var _bubblemapMap2 = _interopRequireDefault(_bubblemapMap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//import Selectlist from 'bubblemap-selectlist';

//BUBBLE MAP CHART COMPONENT
var LBubbleMapComponent = _component2.default.extend({
  /**
   * Initializes the component (Bubble Map Chart).
   * Executed once before any template is rendered.
   * @param {Object} config The config passed to the component
   * @param {Object} context The component's parent
   */
  init: function init(config, context) {
    this.name = "bubblemap";
    this.template = __webpack_require__(464);
    this.bubblesDrawing = null;

    this.isMobile = utils.isMobileOrTablet();

    //define expected models for this component
    this.model_expects = [{
      name: "time",
      type: "time"
    }, {
      name: "entities",
      type: "entities"
    }, {
      name: "marker",
      type: "model"
    }, {
      name: "locale",
      type: "locale"
    }, {
      name: "ui",
      type: "ui"
    }];

    var _this = this;
    this.model_binds = {
      "change:time.value": function changeTimeValue(evt) {
        if (!_this._readyOnce) return;
        _this.model.marker.getFrame(_this.model.time.value, _this.frameChanged.bind(_this));
      },
      "change:marker.highlight": function changeMarkerHighlight(evt) {
        if (!_this._readyOnce) return;
        _this.highlightMarkers();
        _this.updateOpacity();
      },
      "change:marker": function changeMarker(evt, path) {
        // bubble size change is processed separately
        if (!_this._readyOnce) return;

        if (path.indexOf("scaleType") > -1) {
          _this.ready();
        }
      },
      "change:marker.size.extent": function changeMarkerSizeExtent(evt, path) {
        //console.log("EVENT change:marker:size:max");
        if (!_this._readyOnce || !_this.entityBubbles) return;
        _this.updateMarkerSizeLimits();
        _this.redrawDataPoints(null, false);
      },
      "change:marker.color.palette": function changeMarkerColorPalette(evt, path) {
        if (!_this._readyOnce) return;
        _this.redrawDataPoints(null, false);
      },
      "change:marker.select": function changeMarkerSelect(evt) {
        if (!_this._readyOnce) return;
        _this.selectMarkers();
        _this.redrawDataPoints(null, false);
        _this.updateOpacity();
        _this.updateDoubtOpacity();
      },
      "change:marker.opacitySelectDim": function changeMarkerOpacitySelectDim(evt) {
        _this.updateOpacity();
      },
      "change:marker.opacityRegular": function changeMarkerOpacityRegular(evt) {
        _this.updateOpacity();
      },
      "change:ui.map.mapLayer": function changeUiMapMapLayer(evt) {
        _this.map.layerChanged();
      }
    };

    //this._selectlist = new Selectlist(this);

    //contructor is the same as any component
    this._super(config, context);

    this.sScale = null;
    this.cScale = d3.scaleOrdinal(d3.schemeCategory10);

    _this.COLOR_WHITEISH = "#fdfdfd";

    this._labels = new _labels2.default(this);

    this._labels.config({
      CSS_PREFIX: "vzb-bmc",
      LABELS_CONTAINER_CLASS: "vzb-bmc-labels",
      LINES_CONTAINER_CLASS: "vzb-bmc-lines",
      SUPPRESS_HIGHLIGHT_DURING_PLAY: false
    });
  },


  /**
   * DOM is ready
   */
  readyOnce: function readyOnce() {
    this.element = d3.select(this.element);

    this.graph = this.element.select(".vzb-bmc-graph");

    this.bubbleContainerCrop = this.graph.select(".vzb-bmc-bubbles-crop");
    this.bubbleContainer = this.graph.select(".vzb-bmc-bubbles");
    this.labelListContainer = this.graph.select(".vzb-bmc-bubble-labels");
    this.dataWarningEl = this.graph.select(".vzb-data-warning");

    this.yTitleEl = this.graph.select(".vzb-bmc-axis-y-title");
    this.cTitleEl = this.graph.select(".vzb-bmc-axis-c-title");
    this.yInfoEl = this.graph.select(".vzb-bmc-axis-y-info");
    this.cInfoEl = this.graph.select(".vzb-bmc-axis-c-info");

    this.entityBubbles = null;
    this.tooltip = this.element.select(".vzb-bmc-tooltip");

    // year background
    this.yearEl = this.graph.select(".vzb-bmc-year");
    this.year = new _d2.default(this.yearEl);
    this.year.setConditions({ xAlign: "left", yAlign: "bottom" });

    var _this = this;
    this.on("resize", function () {
      //return if updatesize exists with error
      if (_this.updateSize()) return;
      _this.map.rescaleMap();
    });

    this.KEY = this.model.entities.getDimension();
    this.TIMEDIM = this.model.time.getDimension();

    this.updateUIStrings();

    this.wScale = d3.scale.linear().domain(this.model.ui.datawarning.doubtDomain).range(this.model.ui.datawarning.doubtRange);

    this._labels.readyOnce();
  },


  /*
   * Both model and DOM are ready
   */
  ready: function ready() {
    var _this = this;
    this.updateUIStrings();
    this.updateIndicators();
    this.updateSize();
    this.map.rescaleMap();
    this.updateMarkerSizeLimits();
    this.model.marker.getFrame(this.model.time.value, function (values, time) {
      // TODO: temporary fix for case when after data loading time changed on validation
      if (time.toString() != _this.model.time.value.toString()) {
        utils.defer(function () {
          _this.ready();
        });
        return;
      } // frame is outdated

      if (!values) return;
      _this.values = values;
      _this.updateEntities();
      _this.updateTime();
      _this._labels.ready();
      _this.redrawDataPoints();
      _this.highlightMarkers();
      _this.selectMarkers();
      //    this._selectlist.redraw();
      _this.updateDoubtOpacity();
      _this.updateOpacity();
    });
  },
  frameChanged: function frameChanged(frame, time) {
    if (time.toString() != this.model.time.value.toString()) return; // frame is outdated
    if (!frame) return;

    this.values = frame;
    this.updateTime();
    this.updateDoubtOpacity();
    this.redrawDataPoints(null, false);
  },
  updateUIStrings: function updateUIStrings() {
    var _this = this;

    this.translator = this.model.locale.getTFunction();
    var conceptPropsS = _this.model.marker.size.getConceptprops();
    var conceptPropsC = _this.model.marker.color.getConceptprops();

    this.strings = {
      title: {
        S: conceptPropsS.name,
        C: conceptPropsC.name
      }
    };

    this.yTitleEl.select("text").text(this.translator("buttons/size") + ": " + this.strings.title.S).on("click", function () {
      _this.parent.findChildByName("gapminder-treemenu").markerID("size").alignX(_this.model.locale.isRTL() ? "right" : "left").alignY("top").updateView().toggle();
    });

    this.cTitleEl.select("text").text(this.translator("buttons/color") + ": " + this.strings.title.C).on("click", function () {
      _this.parent.findChildByName("gapminder-treemenu").markerID("color").alignX(_this.model.locale.isRTL() ? "right" : "left").alignY("top").updateView().toggle();
    });

    utils.setIcon(this.dataWarningEl, _iconset.warn).select("svg").attr("width", "0px").attr("height", "0px");
    this.dataWarningEl.append("text").attr("text-anchor", "end").text(this.translator("hints/dataWarning"));

    this.dataWarningEl.on("click", function () {
      _this.parent.findChildByName("gapminder-datawarning").toggle();
    }).on("mouseover", function () {
      _this.updateDoubtOpacity(1);
    }).on("mouseout", function () {
      _this.updateDoubtOpacity();
    });

    this.yInfoEl.html(_iconset.question).select("svg").attr("width", "0px").attr("height", "0px");

    //TODO: move away from UI strings, maybe to ready or ready once
    this.yInfoEl.on("click", function () {
      _this.parent.findChildByName("gapminder-datanotes").pin();
    });
    this.yInfoEl.on("mouseover", function () {
      var rect = this.getBBox();
      var coord = utils.makeAbsoluteContext(this, this.farthestViewportElement)(rect.x - 10, rect.y + rect.height + 10);
      var toolRect = _this.root.element.getBoundingClientRect();
      var chartRect = _this.element.node().getBoundingClientRect();
      _this.parent.findChildByName("gapminder-datanotes").setHook("size").show().setPos(coord.x + chartRect.left - toolRect.left, coord.y);
    });
    this.yInfoEl.on("mouseout", function () {
      _this.parent.findChildByName("gapminder-datanotes").hide();
    });

    this.cInfoEl.html(_iconset.question).select("svg").attr("width", "0px").attr("height", "0px");

    //TODO: move away from UI strings, maybe to ready or ready once
    this.cInfoEl.on("click", function () {
      _this.parent.findChildByName("gapminder-datanotes").pin();
    });
    this.cInfoEl.on("mouseover", function () {
      var rect = this.getBBox();
      var coord = utils.makeAbsoluteContext(this, this.farthestViewportElement)(rect.x - 10, rect.y + rect.height + 10);
      var toolRect = _this.root.element.getBoundingClientRect();
      var chartRect = _this.element.node().getBoundingClientRect();
      _this.parent.findChildByName("gapminder-datanotes").setHook("color").show().setPos(coord.x + chartRect.left - toolRect.left, coord.y);
    });
    this.cInfoEl.on("mouseout", function () {
      _this.parent.findChildByName("gapminder-datanotes").hide();
    });
  },


  // show size number on title when hovered on a bubble
  updateTitleNumbers: function updateTitleNumbers() {
    var _this = this;

    var mobile = void 0; // if is mobile device and only one bubble is selected, update the ytitle for the bubble
    if (_this.isMobile && _this.model.marker.select && _this.model.marker.select.length === 1) {
      mobile = _this.model.marker.select[0];
    }

    if (_this.hovered || mobile) {
      var conceptPropsS = _this.model.marker.size.getConceptprops();
      var conceptPropsC = _this.model.marker.color.getConceptprops();

      var hovered = _this.hovered || mobile;
      var formatterS = _this.model.marker.size.getTickFormatter();
      var formatterC = _this.model.marker.color.getTickFormatter();

      var unitS = conceptPropsS.unit || "";
      var unitC = conceptPropsC.unit || "";

      var valueS = _this.values.size[hovered[_this.KEY]];
      var valueC = _this.values.color[hovered[_this.KEY]];

      //resolve value for color from the color legend model
      if (_this.model.marker.color.isDiscrete() && valueC) {
        valueC = this.model.marker.color.getColorlegendMarker().label.getItems()[valueC] || "";
      }

      _this.yTitleEl.select("text").text(_this.translator("buttons/size") + ": " + formatterS(valueS) + " " + unitS);

      _this.cTitleEl.select("text").text(_this.translator("buttons/color") + ": " + (valueC || valueC === 0 ? formatterC(valueC) + " " + unitC : _this.translator("hints/nodata")));

      this.yInfoEl.classed("vzb-hidden", true);
      this.cInfoEl.classed("vzb-hidden", true);
    } else {
      this.yTitleEl.select("text").text(this.translator("buttons/size") + ": " + this.strings.title.S);
      this.cTitleEl.select("text").text(this.translator("buttons/color") + ": " + this.strings.title.C);

      this.yInfoEl.classed("vzb-hidden", false);
      this.cInfoEl.classed("vzb-hidden", false || this.cTitleEl.classed("vzb-hidden"));
    }
  },
  updateDoubtOpacity: function updateDoubtOpacity(opacity) {
    if (opacity == null) opacity = this.wScale(+this.time.getUTCFullYear().toString());
    if (this.someSelected) opacity = 1;
    this.dataWarningEl.style("opacity", opacity);
  },
  updateOpacity: function updateOpacity() {
    var _this = this;
    /*
     this.entityBubbles.classed("vzb-selected", function (d) {
     return _this.model.marker.isSelected(d);
     });
     */

    var OPACITY_HIGHLT = 1.0;
    var OPACITY_HIGHLT_DIM = 0.3;
    var OPACITY_SELECT = this.model.marker.opacityRegular;
    var OPACITY_REGULAR = this.model.marker.opacityRegular;
    var OPACITY_SELECT_DIM = this.model.marker.opacitySelectDim;

    this.entityBubbles.style("opacity", function (d) {

      if (_this.someHighlighted) {
        //highlight or non-highlight
        if (_this.model.marker.isHighlighted(d)) return OPACITY_HIGHLT;
      }

      if (_this.someSelected) {
        //selected or non-selected
        return _this.model.marker.isSelected(d) ? OPACITY_SELECT : OPACITY_SELECT_DIM;
      }

      if (_this.someHighlighted) return OPACITY_HIGHLT_DIM;

      return OPACITY_REGULAR;
    });

    this.entityBubbles.classed("vzb-selected", function (d) {
      return _this.model.marker.isSelected(d);
    });

    var nonSelectedOpacityZero = _this.model.marker.opacitySelectDim < 0.01;

    // when pointer events need update...
    if (nonSelectedOpacityZero !== this.nonSelectedOpacityZero) {
      this.entityBubbles.style("pointer-events", function (d) {
        return !_this.someSelected || !nonSelectedOpacityZero || _this.model.marker.isSelected(d) ? "visible" : "none";
      });
    }

    this.nonSelectedOpacityZero = _this.model.marker.opacitySelectDim < 0.01;
  },


  /**
   * Changes labels for indicators
   */
  updateIndicators: function updateIndicators() {
    this.sScale = this.model.marker.size.getScale();
    this.cScale = this.model.marker.color.getScale();
  },


  /**
   * Updates entities
   */
  updateEntities: function updateEntities() {

    var _this = this;
    var KEY = this.KEY;
    var TIMEDIM = this.TIMEDIM;

    var getKeys = function getKeys(prefix) {
      prefix = prefix || "";
      return _this.model.marker.getKeys().map(function (d) {
        var pointer = {};
        pointer[KEY] = d[KEY];
        pointer[TIMEDIM] = endTime;
        pointer.sortValue = _this.values.size[d[KEY]] || 0;
        pointer[KEY] = prefix + d[KEY];
        return pointer;
      }).sort(function (a, b) {
        return b.sortValue - a.sortValue;
      });
    };

    // get array of GEOs, sorted by the size hook
    // that makes larger bubbles go behind the smaller ones
    var endTime = this.model.time.end;
    this.model.marker.setVisible(getKeys.call(this));

    //unselecting bubbles with no data is used for the scenario when
    //some bubbles are selected and user would switch indicator.
    //bubbles would disappear but selection would stay
    if (!this.model.time.splash) {
      this.unselectBubblesWithNoData();
    }

    // TODO: add to csv
    //Africa 9.1021° N, 18.2812°E
    //Europe 53.0000° N, 9.0000° E
    //Asia 49.8380° N, 105.8203° E
    //north American 48.1667° N and longitude 100.1667° W
    /*
     var pos = {
     "afr": {lat: 9.1, lng: 18.3},
     "eur": {lat: 53.0, lng: 9.0},
     "asi": {lat: 49.8, lng: 105.8},
     "ame": {lat: 48.2, lng: -100.2},
     };
     */

    this.entityBubbles = this.bubbleContainer.selectAll(".vzb-bmc-bubble").data(this.model.marker.getVisible(), function (d) {
      return d[KEY];
    }).order();

    //exit selection
    this.entityBubbles.exit().remove();

    //enter selection -- init circles
    this.entityBubbles = this.entityBubbles.enter().append("circle").attr("class", "vzb-bmc-bubble").on("mouseover", function (d, i) {
      if (utils.isTouchDevice()) return;
      _this._interact()._mouseover(d, i);
    }).on("mouseout", function (d, i) {
      if (utils.isTouchDevice()) return;
      _this._interact()._mouseout(d, i);
    }).on("click", function (d, i) {
      if (utils.isTouchDevice()) return;
      _this._interact()._click(d, i);
      _this.highlightMarkers();
    }).onTap(function (d, i) {
      _this._interact()._click(d, i);
      d3.event.stopPropagation();
    }).onLongTap(function (d, i) {}).merge(this.entityBubbles);
  },
  unselectBubblesWithNoData: function unselectBubblesWithNoData(frame) {
    var _this = this;
    var KEY = this.KEY;
    if (!frame) frame = this.values;

    if (!frame || !frame.size) return;

    this.model.marker.select.forEach(function (d) {
      if (!frame.size[d[KEY]] && frame.size[d[KEY]] !== 0) _this.model.marker.selectMarker(d);
    });
  },
  redrawDataPoints: function redrawDataPoints(duration, reposition) {
    var _this = this;
    if (!duration) duration = this.duration;
    if (!reposition) reposition = true;
    if (!this.entityBubbles) return utils.warn("redrawDataPoints(): no entityBubbles defined. likely a premature call, fix it!");
    this.entityBubbles.each(function (d, index) {
      var view = d3.select(this);
      var geo = d3.select("#" + d[_this.KEY]);

      var valueX = _this.values.hook_lng[d[_this.KEY]];
      var valueY = _this.values.hook_lat[d[_this.KEY]];
      var valueS = _this.values.size[d[_this.KEY]];
      var valueC = _this.values.color[d[_this.KEY]];
      var valueL = _this.values.label[d[_this.KEY]];

      d.hidden_1 = d.hidden;
      d.hidden = !valueS && valueS !== 0 || valueX == null || valueY == null;

      if (d.hidden !== d.hidden_1) {
        if (duration) {
          view.transition().duration(duration).ease(d3.easeLinear).style("opacity", 0).on("end", function () {
            return view.classed("vzb-hidden", d.hidden).style("opacity", _this.model.marker.opacityRegular);
          });
        } else {
          view.classed("vzb-hidden", d.hidden);
        }
      }
      if (!d.hidden) {

        d.r = utils.areaToRadius(_this.sScale(valueS || 0));
        d.label = valueL;

        view.classed("vzb-hidden", false).attr("fill", valueC != null ? _this.cScale(valueC) : _this.COLOR_WHITEISH);

        if (_this.model.ui.map.colorGeo) geo.style("fill", valueC != null ? _this.cScale(valueC) : "#999");

        if (reposition) {
          d.cLoc = _this.map.invert(valueX, valueY);

          view.attr("cx", d.cLoc[0]).attr("cy", d.cLoc[1]);
        }

        if (duration) {
          view.transition().duration(duration).ease(d3.easeLinear).attr("r", d.r);
        } else {
          view.interrupt().attr("r", d.r).transition();
        }

        _this._updateLabel(d, index, d.cLoc[0], d.cLoc[1], valueS, valueC, d.label, duration);
      } else {
        _this._updateLabel(d, index, 0, 0, valueS, valueC, valueL, duration);
      }
    });
  },


  /*
   * UPDATE TIME:
   * Ideally should only update when time or data changes
   */
  updateTime: function updateTime() {
    var _this = this;

    this.time_1 = this.time == null ? this.model.time.value : this.time;
    this.time = this.model.time.value;
    this.duration = this.model.time.playing && this.time - this.time_1 > 0 ? this.model.time.delayAnimations : 0;
    this.year.setText(this.model.time.formatDate(this.time), this.duration);

    //possibly update the exact value in size title
    this.updateTitleNumbers();
  },
  fitSizeOfTitles: function fitSizeOfTitles() {
    // reset font sizes first to make the measurement consistent
    var yTitleText = this.yTitleEl.select("text");
    yTitleText.style("font-size", null);

    var cTitleText = this.cTitleEl.select("text");
    cTitleText.style("font-size", null);

    var yTitleBB = yTitleText.node().getBBox();
    var cTitleBB = this.cTitleEl.classed("vzb-hidden") ? yTitleBB : cTitleText.node().getBBox();

    var font = Math.max(parseInt(yTitleText.style("font-size")), parseInt(cTitleText.style("font-size"))) * this.width / Math.max(yTitleBB.width, cTitleBB.width);

    if (Math.max(yTitleBB.width, cTitleBB.width) > this.width) {
      yTitleText.style("font-size", font + "px");
      cTitleText.style("font-size", font + "px");
    } else {

      // Else - reset the font size to default so it won't get stuck
      yTitleText.style("font-size", null);
      cTitleText.style("font-size", null);
    }
  },


  profiles: {
    small: {
      margin: { top: 10, right: 10, left: 10, bottom: 0 },
      infoElHeight: 16,
      minRadius: 0.5,
      maxRadius: 30
    },
    medium: {
      margin: { top: 20, right: 20, left: 20, bottom: 30 },
      infoElHeight: 20,
      minRadius: 1,
      maxRadius: 55
    },
    large: {
      margin: { top: 30, right: 30, left: 30, bottom: 35 },
      infoElHeight: 22,
      minRadius: 1,
      maxRadius: 65
    }
  },

  presentationProfileChanges: {
    medium: {
      infoElHeight: 26
    },
    large: {
      infoElHeight: 32
    }
  },

  /**
   * Executes everytime the container or vizabi is resized
   * Ideally,it contains only operations related to size
   */
  updateSize: function updateSize() {

    this.activeProfile = this.getActiveProfile(this.profiles, this.presentationProfileChanges);
    var margin = this.activeProfile.margin;

    this.height = parseInt(this.element.style("height"), 10) - margin.top - margin.bottom || 0;
    this.width = parseInt(this.element.style("width"), 10) - margin.left - margin.right || 0;

    if (this.height <= 0 || this.width <= 0) return utils.warn("Bubble map updateSize() abort: vizabi container is too little or has display:none");

    this.repositionElements();
  },
  mapBoundsChanged: function mapBoundsChanged() {
    this.updateMarkerSizeLimits();
    this._labels.updateSize();
    this.redrawDataPoints();
    //_this._selectlist.redraw();
  },
  repositionElements: function repositionElements() {
    var margin = this.activeProfile.margin;
    var infoElHeight = this.activeProfile.infoElHeight;
    var isRTL = this.model.locale.isRTL();

    this.graph.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    this.year.setConditions({
      widthRatio: 2 / 10
    });
    this.year.resize(this.width, this.height);

    this.yTitleEl.style("font-size", infoElHeight).attr("transform", "translate(" + (isRTL ? this.width : 0) + "," + margin.top + ")");

    var yTitleBB = this.yTitleEl.select("text").node().getBBox();

    //hide the second line about color in large profile or when color is constant
    this.cTitleEl.attr("transform", "translate(" + (isRTL ? this.width : 0) + "," + (margin.top + yTitleBB.height) + ")").classed("vzb-hidden", this.getLayoutProfile() === "large" || this.model.marker.color.use == "constant");

    var warnBB = this.dataWarningEl.select("text").node().getBBox();
    this.dataWarningEl.select("svg").attr("width", warnBB.height * 0.75).attr("height", warnBB.height * 0.75).attr("x", -warnBB.width - warnBB.height * 1.2).attr("y", -warnBB.height * 0.65);

    this.dataWarningEl.attr("transform", "translate(" + this.width + "," + (this.height - warnBB.height * 0.5) + ")").select("text");

    if (this.yInfoEl.select("svg").node()) {
      var titleBBox = this.yTitleEl.node().getBBox();
      var t = utils.transform(this.yTitleEl.node());
      var hTranslate = isRTL ? titleBBox.x + t.translateX - infoElHeight * 1.4 : titleBBox.x + t.translateX + titleBBox.width + infoElHeight * 0.4;

      this.yInfoEl.select("svg").attr("width", infoElHeight).attr("height", infoElHeight);
      this.yInfoEl.attr("transform", "translate(" + hTranslate + "," + (t.translateY - infoElHeight * 0.8) + ")");
    }

    this.cInfoEl.classed("vzb-hidden", this.cTitleEl.classed("vzb-hidden"));

    if (!this.cInfoEl.classed("vzb-hidden") && this.cInfoEl.select("svg").node()) {
      var _titleBBox = this.cTitleEl.node().getBBox();
      var _t = utils.transform(this.cTitleEl.node());
      var _hTranslate = isRTL ? _titleBBox.x + _t.translateX - infoElHeight * 1.4 : _titleBBox.x + _t.translateX + _titleBBox.width + infoElHeight * 0.4;

      this.cInfoEl.select("svg").attr("width", infoElHeight).attr("height", infoElHeight);
      this.cInfoEl.attr("transform", "translate(" + _hTranslate + "," + (_t.translateY - infoElHeight * 0.8) + ")");
    }
  },
  updateMarkerSizeLimits: function updateMarkerSizeLimits() {
    var _this = this;
    var extent = this.model.marker.size.extent || [0, 1];

    var minRadius = this.activeProfile.minRadius;
    var maxRadius = this.activeProfile.maxRadius;

    this.minRadius = Math.max(maxRadius * extent[0], minRadius);
    this.maxRadius = Math.max(maxRadius * extent[1], minRadius);

    if (this.model.marker.size.scaleType !== "ordinal") {
      this.sScale.range([utils.radiusToArea(_this.minRadius), utils.radiusToArea(_this.maxRadius)]);
    } else {
      this.sScale.rangePoints([utils.radiusToArea(_this.minRadius), utils.radiusToArea(_this.maxRadius)], 0).range();
    }
  },
  _interact: function _interact() {
    var _this = this;

    return {
      _mouseover: function _mouseover(d, i) {
        if (_this.model.time.dragging) return;

        _this.model.marker.highlightMarker(d);

        _this.hovered = d;
        //put the exact value in the size title
        _this.updateTitleNumbers();
        _this.fitSizeOfTitles();

        if (_this.model.marker.isSelected(d)) {
          // if selected, not show hover tooltip
          _this._setTooltip();
        } else {
          //position tooltip
          _this._setTooltip(d);
        }
      },
      _mouseout: function _mouseout(d, i) {
        if (_this.model.time.dragging) return;
        _this._setTooltip();
        _this.hovered = null;
        _this.updateTitleNumbers();
        _this.fitSizeOfTitles();
        _this.model.marker.clearHighlighted();
      },
      _click: function _click(d, i) {
        _this.model.marker.selectMarker(d);
      }
    };
  },
  highlightMarkers: function highlightMarkers() {
    var _this = this;
    this.someHighlighted = this.model.marker.highlight.length > 0;

    if (utils.isTouchDevice()) {
      if (this.someHighlighted) {
        _this.hovered = this.model.marker.highlight[0];
      } else {
        _this.hovered = null;
      }
      _this.updateTitleNumbers();
      _this.fitSizeOfTitles();
    }

    //      if (!this.selectList || !this.someSelected) return;
    //      this.selectList.classed("vzb-highlight", function (d) {
    //          return _this.model.entities.isHighlighted(d);
    //      });
    //      this.selectList.each(function (d, i) {
    //        d3.select(this).selectAll(".vzb-bmc-label-x")
    //          .classed("vzb-invisible", function(n) {
    //            return !_this.model.entities.isHighlighted(d);
    //          });
    //
    //      });
  },
  _updateLabel: function _updateLabel(d, index, valueX, valueY, valueS, valueC, valueL, duration) {
    var _this = this;
    var KEY = this.KEY;
    if (d[KEY] == _this.druging) return;
    if (duration == null) duration = _this.duration;

    // only for selected entities
    if (_this.model.marker.isSelected(d)) {

      var showhide = d.hidden !== d.hidden_1;
      var valueLST = null;
      var cache = {};
      cache.labelX0 = valueX / this.width;
      cache.labelY0 = valueY / this.height;
      cache.scaledS0 = valueS ? utils.areaToRadius(_this.sScale(valueS)) : null;
      cache.scaledC0 = valueC != null ? _this.cScale(valueC) : _this.COLOR_WHITEISH;

      this._labels.updateLabel(d, index, cache, valueX / this.width, valueY / this.height, valueS, valueC, valueL, valueLST, duration, showhide);
    }
  },
  selectMarkers: function selectMarkers() {
    var _this = this;
    var KEY = this.KEY;
    this.someSelected = this.model.marker.select.length > 0;

    //      this._selectlist.rebuild();
    if (utils.isTouchDevice()) {
      _this._labels.showCloseCross(null, false);
      if (_this.someHighlighted) {
        _this.model.marker.clearHighlighted();
      } else {
        _this.updateTitleNumbers();
        _this.fitSizeOfTitles();
      }
    } else {
      // hide recent hover tooltip
      if (!_this.hovered || _this.model.marker.isSelected(_this.hovered)) {
        _this._setTooltip();
      }
    }

    this.nonSelectedOpacityZero = false;
  },
  _setTooltip: function _setTooltip(d) {
    var _this = this;
    if (d) {
      var tooltipText = d.label;
      var x = d.cLoc[0];
      var y = d.cLoc[1];
      var offset = d.r;
      var mouse = d3.mouse(this.graph.node()).map(function (d) {
        return parseInt(d);
      });
      var xPos = void 0,
          yPos = void 0,
          xSign = -1,
          ySign = -1,
          xOffset = 0,
          yOffset = 0;

      if (offset) {
        xOffset = offset * 0.71; // .71 - sin and cos for 315
        yOffset = offset * 0.71;
      }
      //position tooltip
      this.tooltip.classed("vzb-hidden", false)
      //.attr("style", "left:" + (mouse[0] + 50) + "px;top:" + (mouse[1] + 50) + "px")
      .selectAll("text").text(tooltipText);

      var contentBBox = this.tooltip.select("text").node().getBBox();
      if (x - xOffset - contentBBox.width < 0) {
        xSign = 1;
        x += contentBBox.width + 5; // corrective to the block Radius and text padding
      } else {
        x -= 5; // corrective to the block Radius and text padding
      }
      if (y - yOffset - contentBBox.height < 0) {
        ySign = 1;
        y += contentBBox.height;
      } else {
        y -= 11; // corrective to the block Radius and text padding
      }
      if (offset) {
        xPos = x + xOffset * xSign;
        yPos = y + yOffset * ySign; // 5 and 11 - corrective to the block Radius and text padding
      } else {
        xPos = x + xOffset * xSign; // .71 - sin and cos for 315
        yPos = y + yOffset * ySign; // 5 and 11 - corrective to the block Radius and text padding
      }
      this.tooltip.attr("transform", "translate(" + (xPos ? xPos : mouse[0]) + "," + (yPos ? yPos : mouse[1]) + ")");

      this.tooltip.select("rect").attr("width", contentBBox.width + 8).attr("height", contentBBox.height * 1.2).attr("x", -contentBBox.width - 4).attr("y", -contentBBox.height * 0.85).attr("rx", contentBBox.height * 0.2).attr("ry", contentBBox.height * 0.2);
    } else {

      this.tooltip.classed("vzb-hidden", true);
    }
  },
  preload: function preload() {
    this.initMap();
  },
  initMap: function initMap() {
    this.map = new _bubblemapMap2.default(this, "#vzb-map-background").getMap();
    return this.map.initMap();
  }
});

exports.default = LBubbleMapComponent;

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _class = __webpack_require__(16);

var _class2 = _interopRequireDefault(_class);

var _globals = __webpack_require__(34);

var _globals2 = _interopRequireDefault(_globals);

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _topojson = __webpack_require__(139);

var _topojson2 = _interopRequireDefault(_topojson);

var _d = __webpack_require__(89);

var _d2 = _interopRequireDefault(_d);

var _mapboxGl = __webpack_require__(469);

var _mapboxGl2 = _interopRequireDefault(_mapboxGl);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var GoogleMapsLoader = __webpack_require__(434);

var MapLayer = _class2.default.extend({
  init: function init(context, parent) {
    this.shapes = null;
    this.parent = parent;
    this.context = context;
    (0, _d2.default)();
  },
  initMap: function initMap() {
    var _this2 = this;

    this.mapGraph = this.parent.mapSvg.html("").append("g").attr("class", "vzb-bmc-map-graph");

    var _this = this;
    var shape_path = this.context.model.ui.map.topology.path || _globals2.default.ext_resources.host + _globals2.default.ext_resources.preloadPath + "world-50m.json";

    var projection = "geo" + utils.capitalize(this.context.model.ui.map.projection);

    this.zeroProjection = d3[projection]();
    this.zeroProjection.scale(1).translate([0, 0]);

    this.projection = d3[projection]();
    this.projection.scale(1).translate([0, 0]);

    this.mapPath = d3.geoPath().projection(this.projection);

    this.context.model.ui.map.scale = 1;
    return this._loadShapes(shape_path).then(function (shapes) {
      _this.shapes = shapes;
      _this.mapFeature = _topojson2.default.feature(_this.shapes, _this.shapes.objects[_this2.context.model.ui.map.topology.objects.geo]);
      _this.mapBounds = _this.mapPath.bounds(_this.mapFeature);

      var boundaries = _topojson2.default.mesh(_this.shapes, _this.shapes.objects[_this.context.model.ui.map.topology.objects.boundaries], function (a, b) {
        return a !== b;
      });
      if (_this.mapFeature.features) {
        _this.mapGraph.selectAll(".land").data(_this.mapFeature.features).enter().insert("path").attr("d", _this.mapPath).attr("id", function (d) {
          return d.properties[_this.context.model.ui.map.topology.geoIdProperty] ? d.properties[_this.context.model.ui.map.topology.geoIdProperty].toLowerCase() : d.id;
        }).attr("class", "land");
      } else {
        _this.mapGraph.insert("path").datum(_this.mapFeature).attr("class", "land");
      }
      _this.mapGraph.insert("path").datum(boundaries).attr("class", "boundary");
    });
  },
  _loadShapes: function _loadShapes(shape_path) {
    return new Promise(function (resolve, reject) {
      d3.json(shape_path, function (error, json) {
        if (error) return console.warn("Failed loading json " + shape_path + ". " + error);
        resolve(json);
      });
    });
  },
  rescaleMap: function rescaleMap(canvas) {
    //var topoCanvas =
    var emitEvent = false;
    var margin = this.context.activeProfile.margin;

    var currentNW = this.zeroProjection([this.context.model.ui.map.bounds.west, this.context.model.ui.map.bounds.north]);
    var currentSE = this.zeroProjection([this.context.model.ui.map.bounds.east, this.context.model.ui.map.bounds.south]);
    var scaleDelta = 1,
        mapTopOffset = 0,
        mapLeftOffset = 0;

    if (!canvas) {
      emitEvent = true;
      canvas = [[0, 0], [this.context.width, this.context.height]];
      var scaleX = (canvas[1][0] - canvas[0][0]) / (currentSE[0] - currentNW[0]);
      var scaleY = (canvas[1][1] - canvas[0][1]) / (currentSE[1] - currentNW[1]);
      if (scaleX != scaleY) {
        if (scaleX > scaleY) {
          scaleDelta = scaleY;
          mapLeftOffset = (this.context.width - Math.abs(scaleDelta * (currentNW[1] - currentSE[1]))) / 2;
        } else {
          scaleDelta = scaleX;
          mapTopOffset = (this.context.height - Math.abs(scaleDelta * (currentNW[0] - currentSE[0]))) / 2;
        }
      }
    } else {
      scaleDelta = (canvas[1][0] - canvas[0][0]) / (currentSE[0] - currentNW[0]);
    }
    // translate projection to the middle of map
    this.projection.translate([canvas[0][0] - currentNW[0] * scaleDelta + mapLeftOffset, canvas[0][1] - currentNW[1] * scaleDelta + mapTopOffset]).scale(scaleDelta).precision(0.1);

    this.mapGraph.selectAll("path").attr("d", this.mapPath);

    // resize and put in center
    this.parent.mapSvg.style("transform", "translate(" + margin.left + "px," + margin.top + "px)").attr("width", this.context.width).attr("height", this.context.height);

    // set skew function used for bubbles in chart
    var _this = this;

    // if canvas not received this map is main and shound trigger redraw points on tool
    if (emitEvent) {
      this.parent.boundsChanged();
    }
  },
  invert: function invert(x, y) {
    return this.projection([x || 0, y || 0]);
  }
});

var GoogleMapLayer = _class2.default.extend({
  init: function init(context, parent) {
    this.context = context;
    this.parent = parent;
  },
  initMap: function initMap(domSelector) {
    var _this = this;
    this.mapCanvas = this.parent.mapRoot.append("div");

    GoogleMapsLoader.KEY = "AIzaSyAP0vMZwYojifwGYHTnEtYV40v6-MdLGFM";
    return new Promise(function (resolve, reject) {
      GoogleMapsLoader.load(function (google) {
        _this.map = new google.maps.Map(_this.mapCanvas.node(), {
          disableDefaultUI: true,
          backgroundColor: "#FFFFFF",
          mapTypeId: _this.context.model.ui.map.mapLayer
        });

        _this.overlay = new google.maps.OverlayView();
        _this.overlay.draw = function () {};
        _this.overlay.setMap(_this.map);

        google.maps.event.addListener(_this.map, "bounds_changed", function () {
          if (_this.map.getBounds()) {
            _this.parent.boundsChanged();
          }
        });
        resolve();
      });
    });
  },
  updateLayer: function updateLayer() {
    if (this.map) {
      this.map.setMapTypeId(this.context.model.ui.map.mapLayer);
    }
  },
  rescaleMap: function rescaleMap() {
    var _this = this;
    var margin = this.context.activeProfile.margin;

    this.mapCanvas.style("width", this.context.width + "px").style("height", this.context.height + "px");
    this.parent.mapRoot.attr("width", this.context.width).attr("height", this.context.height).style("position", "absolute").style("left", margin.left + "px").style("right", margin.right + "px").style("top", margin.top + "px").style("bottom", margin.bottom + "px");
    google.maps.event.trigger(this.map, "resize");

    var rectBounds = new google.maps.LatLngBounds(new google.maps.LatLng(this.context.model.ui.map.bounds.north, this.context.model.ui.map.bounds.west), new google.maps.LatLng(this.context.model.ui.map.bounds.south, this.context.model.ui.map.bounds.east));
    this.map.fitBounds(rectBounds);
  },
  invert: function invert(x, y) {
    var projection = this.overlay.getProjection();
    if (!projection) {
      return [0, 0];
    }
    var coords = projection.fromLatLngToContainerPixel(new google.maps.LatLng(y, x));
    return [coords.x, coords.y];
  },
  getZoom: function getZoom() {
    return this.map.getZoom();
  },
  getCanvas: function getCanvas() {
    return [this.invert(this.context.model.ui.map.bounds.west, this.context.model.ui.map.bounds.north), this.invert(this.context.model.ui.map.bounds.east, this.context.model.ui.map.bounds.south)];
  },
  getCenter: function getCenter() {
    var center = this.map.getCenter();
    this.centerMapker.setPosition(center);
    return { lat: center.lat(), lng: center.lng() };
  }
});

var MapboxLayer = _class2.default.extend({
  init: function init(context, parent) {
    _mapboxGl2.default.accessToken = "pk.eyJ1Ijoic2VyZ2V5ZiIsImEiOiJjaXlqeWo5YnYwMDBzMzJwZnlwZXJ2bnA2In0.e711ku9KzcFW_x5wmOZTag";
    this.context = context;
    this.parent = parent;
  },
  initMap: function initMap(domSelector) {
    var _this3 = this;

    var _this = this;
    this.mapCanvas = this.parent.mapRoot.append("div");
    return new Promise(function (resolve, reject) {
      _this.map = new _mapboxGl2.default.Map({
        container: _this.mapCanvas.node(),
        interactive: false,
        style: _this3.context.model.ui.map.mapLayer,
        hash: false
      });
      _this.bounds = [[_this.context.model.ui.map.bounds.west, _this.context.model.ui.map.bounds.south], [_this.context.model.ui.map.bounds.east, _this.context.model.ui.map.bounds.north]];
      _this.map.fitBounds(_this.bounds);
      resolve();
    });
  },
  rescaleMap: function rescaleMap() {
    var _this = this;
    var offset = this.context.model.ui.map.offset;
    var margin = this.context.activeProfile.margin;
    var viewPortHeight = this.context.height * this.context.model.ui.map.scale;
    var viewPortWidth = this.context.width * this.context.model.ui.map.scale;

    this.mapCanvas.style("width", viewPortWidth + "px").style("height", viewPortHeight + "px");

    this.parent.mapRoot.attr("width", viewPortWidth).attr("height", viewPortHeight).style("position", "absolute").style("left", margin.left + "px").style("right", margin.right + "px").style("top", margin.top + "px").style("bottom", margin.bottom + "px");

    utils.defer(function () {
      _this.map.fitBounds(_this.bounds, { duration: 0 });
      _this.map.resize();
      _this.parent.boundsChanged();
    });
  },
  updateLayer: function updateLayer() {
    if (this.map) {
      this.map.setStyle(this.context.model.ui.map.mapLayer);
    }
  },
  getCanvas: function getCanvas() {
    return [this.invert(this.context.model.ui.map.bounds.west, this.context.model.ui.map.bounds.north), this.invert(this.context.model.ui.map.bounds.east, this.context.model.ui.map.bounds.south)];
  },
  invert: function invert(x, y) {
    var coords = this.map.project([x, y]);
    return [coords.x, coords.y];
  }
});

exports.default = _class2.default.extend({
  init: function init(context, domSelector) {
    this.context = context;
    this.domSelector = domSelector;
    this.topojsonMap = null;
    this.mapEngine = this.context.model.ui.map.mapEngine;
    this.mapInstance = null;
    if (this.context.element instanceof d3.selection) {
      this.mapRoot = this.context.element.select(domSelector);
      this.mapSvg = this.context.element.select(".vzb-bmc-map-background");
    } else {
      this.mapRoot = d3.select(this.context.element).select(domSelector);
      this.mapSvg = d3.select(this.context.element).select(".vzb-bmc-map-background");
    }
    this.mapRoot.html("");
    this.mapSvg.html("");
    return this;
  },
  getMap: function getMap() {
    if (!this.mapInstance) {
      switch (this.context.model.ui.map.mapEngine) {
        case "google":
          this.mapInstance = new GoogleMapLayer(this.context, this);
          break;
        case "mapbox":
          this.mapInstance = new MapboxLayer(this.context, this);
          break;
      }
      if (this.mapInstance) {
        this.topojsonMap = new MapLayer(this.context, this);
      } else {
        this.mapInstance = new MapLayer(this.context, this);
      }
      return this;
    }
  },
  layerChanged: function layerChanged() {
    var _this4 = this;

    if (this.mapEngine == this.context.model.ui.map.mapEngine) {
      this.mapInstance.updateLayer();
    } else {
      this.mapEngine = this.context.model.ui.map.mapEngine;
      this.topojsonMap = null;
      this.mapInstance = null;
      this.mapRoot.html("");
      this.mapSvg.html("");
      this.getMap();
      this.initMap().then(function (map) {
        _this4.rescaleMap();
      });
    }
  },
  initMap: function initMap() {
    if (!this.topojsonMap) {
      return this.mapInstance.initMap(this.domSelector);
    } else if (!this.mapInstance) {
      return this.topojsonMap.initMap(this.domSelector);
    }
    return Promise.all([this.mapInstance.initMap(this.domSelector), this.topojsonMap.initMap(this.domSelector)]);
  },
  rescaleMap: function rescaleMap() {
    if (this.mapInstance) {
      this.mapInstance.rescaleMap();
    } else {
      this.topojsonMap.rescaleMap();
    }
  },
  boundsChanged: function boundsChanged() {
    if (this.topojsonMap) {
      this.topojsonMap.rescaleMap(this.mapInstance.getCanvas());
    }
    this.context.mapBoundsChanged();
  },
  invert: function invert(x, y) {
    if (this.mapInstance) {
      return this.mapInstance.invert(x, y);
    }
    return this.topojsonMap.invert(x, y);
  }
});

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _d = __webpack_require__(41);

var _d2 = _interopRequireDefault(_d);

var _d3 = __webpack_require__(209);

var _d4 = _interopRequireDefault(_d3);

var _iconset = __webpack_require__(10);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//LINE CHART COMPONENT
var LCComponent = _component2.default.extend({
  init: function init(config, context) {
    var _this = this;
    this.name = "linechart";
    this.template = __webpack_require__(465);

    //define expected models for this component
    this.model_expects = [{
      name: "time",
      type: "time"
    }, {
      name: "entities",
      type: "entities"
    }, {
      name: "marker",
      type: "model"
    }, {
      name: "locale",
      type: "locale"
    }, {
      name: "ui",
      type: "ui"
    }];

    this.model_binds = {
      "change:time.value": function changeTimeValue() {
        if (!_this._readyOnce) return;
        _this.model.marker.getFrame(_this.model.time.value, function (frame, time) {
          if (!_this._frameIsValid(frame)) return utils.warn("change:time.value: empty data received from marker.getFrame(). doing nothing");
          _this.frameChanged(frame, time);
        });
      },
      "change:time.playing": function changeTimePlaying() {
        // hide tooltip on touch devices when playing
        if (_this.model.time.playing && utils.isTouchDevice() && !_this.tooltip.classed("vzb-hidden")) _this.tooltip.classed("vzb-hidden", true);
      },
      "change:time.start": function changeTimeStart() {
        if (!_this._readyOnce) return;
        _this.updateShow();
      },
      "change:time.end": function changeTimeEnd() {
        if (!_this._readyOnce) return;
        _this.updateShow();
      },
      "change:marker": function changeMarker(evt, path) {
        if (!_this._readyOnce) return;
        if (path.indexOf("domainMin") > -1 || path.indexOf("domainMax") > -1 || path.indexOf("zoomedMin") > -1 || path.indexOf("zoomedMax") > -1) {
          if (!_this.yScale || !_this.xScale) return; //abort if building of the scale is in progress
          _this.updateShow();
          _this.zoomToMaxMin();
          _this.updateSize();
          _this.updateTime();
          _this.redrawDataPoints();
          return;
        }
        if (path.indexOf("scaleType") > -1) {
          _this.updateShow();
          _this.zoomToMaxMin();
          _this.updateSize();
          _this.redrawDataPoints();
        }
      },
      "change:marker.highlight": function changeMarkerHighlight() {
        if (!_this._readyOnce) return;
        _this.highlightLines();
      },
      "change:marker.select": function changeMarkerSelect() {
        if (!_this._readyOnce) return;
        _this.updateDoubtOpacity();
        _this.highlightLines();
      },
      "change:marker.opacitySelectDim": function changeMarkerOpacitySelectDim() {
        if (!_this._readyOnce) return;
        _this.highlightLines();
      },
      "change:marker.opacityRegular": function changeMarkerOpacityRegular() {
        if (!_this._readyOnce) return;
        _this.highlightLines();
      }
    };

    this._super(config, context);

    this.xScale = null;
    this.yScale = null;

    this.rangeXRatio = 1;
    this.rangeXShift = 0;

    this.rangeYRatio = 1;
    this.rangeYShift = 0;
    this.lineWidthScale = d3.scale.linear().domain([0, 20]).range([7, 1]).clamp(true);
    this.xAxis = (0, _d2.default)("bottom");
    this.yAxis = (0, _d2.default)("left");

    this.isDataPreprocessed = false;
    this.timeUpdatedOnce = false;
    this.sizeUpdatedOnce = false;

    this.getNearestKey = utils.memoize(this.getNearestKey);
  },


  /*
   * domReady:
   * Executed after template is loaded
   * Ideally, it contains instantiations related to template
   */
  readyOnce: function readyOnce() {
    var _this = this;

    this.element = d3.select(this.element);
    this.graph = this.element.select(".vzb-lc-graph");

    this.yAxisElContainer = this.graph.select(".vzb-lc-axis-y");
    this.yAxisEl = this.yAxisElContainer.select("g");

    this.xAxisElContainer = this.graph.select(".vzb-lc-axis-x");
    this.xAxisEl = this.xAxisElContainer.select("g");

    this.xTitleEl = this.graph.select(".vzb-lc-axis-x-title");
    this.yTitleEl = this.graph.select(".vzb-lc-axis-y-title");
    this.yInfoEl = this.graph.select(".vzb-lc-axis-y-info");
    this.linesContainerCrop = this.graph.select(".vzb-lc-lines-crop");
    this.linesContainer = this.graph.select(".vzb-lc-lines");
    this.labelsContainerCrop = this.graph.select(".vzb-lc-labels-crop");
    this.labelsContainer = this.graph.select(".vzb-lc-labels");

    this.dataWarningEl = this.graph.select(".vzb-data-warning");

    this.verticalNow = this.labelsContainer.select(".vzb-lc-vertical-now");
    this.tooltip = this.element.select(".vzb-tooltip");
    //            this.filterDropshadowEl = this.element.select('#vzb-lc-filter-dropshadow');
    this.projectionX = this.graph.select(".vzb-lc-projection-x");
    this.projectionY = this.graph.select(".vzb-lc-projection-y");

    this.entityLines = null;
    this.entityLabels = null;
    this.totalLength_1 = {};

    this.KEY = this.model.entities.getDimension();
    this.collisionResolver = (0, _d4.default)().selector(".vzb-lc-label").value("valueY");

    //component events

    utils.setIcon(this.yInfoEl, _iconset.question).select("svg").attr("width", "0px").attr("height", "0px");

    this.yInfoEl.on("click", function () {
      _this.parent.findChildByName("gapminder-datanotes").pin();
    });
    this.yInfoEl.on("mouseover", function () {
      var rect = this.getBBox();
      var coord = utils.makeAbsoluteContext(this, this.farthestViewportElement)(rect.x - 10, rect.y + rect.height + 10);
      _this.parent.findChildByName("gapminder-datanotes").setHook("axis_y").show().setPos(coord.x, coord.y);
    });
    this.yInfoEl.on("mouseout", function () {
      _this.parent.findChildByName("gapminder-datanotes").hide();
    });

    this.wScale = d3.scale.linear().domain(this.model.ui.datawarning.doubtDomain).range(this.model.ui.datawarning.doubtRange);

    this.on("resize", function () {
      //return if updatesize exists with error
      if (_this.updateSize()) return;
      _this.updateTime();
      _this.redrawDataPoints();
    });
  },
  ready: function ready() {
    this.all_steps = this.model.time.getAllSteps();
    this.all_values = this.values = null;
    this.updateTime();
    this.updateUIStrings();
    this.updateShow();
    var _this = this;
    //null means we need to calculate all frames before we get to the callback
    this.model.marker.getFrame(null, function (allValues) {
      _this.all_values = allValues;
      _this.model.marker.getFrame(_this.model.time.value, function (values) {
        if (!_this._frameIsValid(values)) return;
        _this.values = values;
        _this.updateShow();
        _this.updateSize();
        _this.updateDoubtOpacity();
        _this.zoomToMaxMin();
        _this.redrawDataPoints();
        _this.linesContainerCrop.on("mousemove", _this.entityMousemove.bind(_this, null, null, _this)).on("mouseleave", _this.entityMouseout.bind(_this, null, null, _this));
      });
    });
  },
  _frameIsValid: function _frameIsValid(frame) {
    return !(!frame || Object.keys(frame.axis_y).length === 0 || Object.keys(frame.axis_x).length === 0 || Object.keys(frame.color).length === 0);
  },
  frameChanged: function frameChanged(frame, time) {
    //    if (time.toString() != this.model.time.value.toString()) return; // frame is outdated
    this.frame = frame;
    this.updateTime();
    if (!this.all_values) return;
    this.redrawDataPoints();
  },
  updateUIStrings: function updateUIStrings() {
    var _this = this;
    var conceptPropsY = _this.model.marker.axis_y.getConceptprops();
    var conceptPropsX = _this.model.marker.axis_x.getConceptprops();
    var conceptPropsC = _this.model.marker.color.getConceptprops();
    this.translator = this.model.locale.getTFunction();

    this.strings = {
      title: {
        Y: conceptPropsY.name,
        X: conceptPropsX.name,
        C: conceptPropsC.name
      },
      unit: {
        Y: conceptPropsY.unit || "",
        X: conceptPropsX.unit || "",
        C: conceptPropsC.unit || ""
      }
    };

    if (this.strings.unit.Y === "unit/" + this.model.marker.axis_y.which) this.strings.unit.Y = "";
    if (this.strings.unit.X === "unit/" + this.model.marker.axis_x.which) this.strings.unit.X = "";
    if (this.strings.unit.C === "unit/" + this.model.marker.color.which) this.strings.unit.C = "";

    if (this.strings.unit.Y) this.strings.unit.Y = ", " + this.strings.unit.Y;
    if (this.strings.unit.X) this.strings.unit.X = ", " + this.strings.unit.X;
    if (this.strings.unit.C) this.strings.unit.C = ", " + this.strings.unit.C;

    utils.setIcon(this.dataWarningEl, _iconset.warn).select("svg").attr("width", "0px").attr("height", "0px");
    this.dataWarningEl.append("text").attr("text-anchor", "end").text(this.translator("hints/dataWarning"));

    this.dataWarningEl.on("click", function () {
      _this.parent.findChildByName("gapminder-datawarning").toggle();
    }).on("mouseover", function () {
      _this.updateDoubtOpacity(1);
    }).on("mouseout", function () {
      _this.updateDoubtOpacity();
    });

    var xTitle = this.xTitleEl.selectAll("text").data([0]);
    xTitle = xTitle.enter().append("text").merge(xTitle);

    var yTitle = this.yTitleEl.selectAll("text").data([0]);
    yTitle = yTitle.enter().append("text").merge(yTitle);
    yTitle.on("click", function () {
      _this.parent.findChildByName("gapminder-treemenu").markerID("axis_y").alignX("left").alignY("top").updateView().toggle();
    });
  },
  updateDoubtOpacity: function updateDoubtOpacity(opacity) {
    if (opacity == null) opacity = this.wScale(+this.time.getUTCFullYear().toString());
    if (this.someSelected) opacity = 1;
    this.dataWarningEl.style("opacity", opacity);
  },


  /*
   * UPDATE SHOW:
   * Ideally should only update when show parameters change or data changes
   */
  updateShow: function updateShow() {
    var _this = this;
    var KEY = this.KEY;

    this.cached = {};
    //scales
    this.yScale = this.model.marker.axis_y.getScale();
    if (!this.splash) {
      var limits = this.model.marker.axis_y.getLimits(this.model.marker.axis_y.which);
      this.yScale.domain([limits.min, limits.max]);
    }
    this.xScale = this.model.marker.axis_x.getScale();
    this.cScale = this.model.marker.color.getScale();
    this.yAxis.tickFormat(this.model.marker.axis_y.getTickFormatter());
    this.xAxis.tickFormat(this.model.marker.axis_x.getTickFormatter());

    this.collisionResolver.scale(this.yScale).KEY(KEY);

    this.data = this.model.marker.getKeys();

    this.entityLines = this.linesContainer.selectAll(".vzb-lc-entity").data(this.data);
    this.entityLines.exit().remove();
    this.entityLines = this.entityLines.enter().append("g").attr("class", "vzb-lc-entity").each(function (d, index) {
      var entity = d3.select(this);

      entity.append("path").attr("class", "vzb-lc-line-shadow");

      entity.append("path").attr("class", "vzb-lc-line");
    }).merge(this.entityLines);

    this.entityLabels = this.labelsContainer.selectAll(".vzb-lc-entity").data(this.data);
    this.entityLabels.exit().remove();
    this.entityLabels = this.entityLabels.enter().append("g").attr("class", "vzb-lc-entity").on("mouseover", function (d) {
      _this.model.marker.highlightMarker(d);
    }).on("mouseout", function (d) {
      _this.model.marker.clearHighlighted();
    }).each(function (d, index) {
      var entity = d3.select(this);

      entity.append("circle").attr("class", "vzb-lc-circle").attr("cx", 0);

      var labelGroup = entity.append("g").attr("class", "vzb-lc-label");

      labelGroup.append("text").attr("class", "vzb-lc-labelname").attr("dy", ".35em");

      labelGroup.append("text").attr("class", "vzb-lc-label-value").attr("dy", "1.6em");
    }).merge(this.entityLabels);

    if (this.all_values && this.values) {
      this.entityLabels.each(function (d, index) {
        var entity = d3.select(this);
        var color = _this.cScale(_this.values.color[d[KEY]]);
        var colorShadow = _this.model.marker.color.which == "geo.world_4region" ? _this.model.marker.color.getColorShade({
          colorID: _this.values.color[d[KEY]],
          shadeID: "shade"
        }) : d3.rgb(color).darker(0.5).toString();

        var label = _this.values.label[d[KEY]];
        var value = _this.yAxis.tickFormat()(_this.values.axis_y[d[KEY]]);
        var name = label.length < 13 ? label : label.substring(0, 10) + "...";
        var valueHideLimit = _this.ui.chart.labels.min_number_of_entities_when_values_hide;

        entity.select("circle").style("fill", color);
        entity.select(".vzb-lc-labelname").style("fill", colorShadow).text(name + " " + (_this.data.length < valueHideLimit ? value : ""));

        entity.select(".vzb-lc-label-value").style("fill", colorShadow);
      });
    }

    //line template
    this.line = d3.line()
    //see https://bl.ocks.org/mbostock/4342190
    //"monotone" can also work. "basis" would skip the points on the sharp turns. "linear" is ugly
    .curve(d3.curveCardinal).x(function (d) {
      return _this.xScale(d[0]);
    }).y(function (d) {
      return _this.yScale(d[1]);
    });
  },


  /*
   * UPDATE TIME:
   * Ideally should only update when time or data changes
   */
  updateTime: function updateTime() {
    var _this = this;
    var KEY = this.KEY;
    var time_1 = this.time === null ? this.model.time.value : this.time;
    this.time = this.model.time.value;
    this.duration = this.model.time.playing && this.time - time_1 > 0 ? this.model.time.delayAnimations : 0;

    var timeDim = this.model.time.getDimension();
    var filter = {};

    filter[timeDim] = this.time;

    this.prev_steps = this.all_steps.filter(function (f) {
      return f < _this.time;
    });

    this.timeUpdatedOnce = true;
  },


  profiles: {
    "small": {
      margin: {
        top: 30,
        right: 20,
        left: 40,
        bottom: 20
      },
      infoElHeight: 16,
      yAxisTitleBottomMargin: 6,
      tick_spacing: 60,
      text_padding: 12,
      lollipopRadius: 6,
      limitMaxTickNumberX: 5
    },
    "medium": {
      margin: {
        top: 40,
        right: 60,
        left: 60,
        bottom: 25
      },
      infoElHeight: 20,
      yAxisTitleBottomMargin: 6,
      tick_spacing: 80,
      text_padding: 15,
      lollipopRadius: 7,
      limitMaxTickNumberX: 10
    },
    "large": {
      margin: {
        top: 50,
        right: 60,
        left: 60,
        bottom: 30
      },
      infoElHeight: 22,
      yAxisTitleBottomMargin: 6,
      tick_spacing: 100,
      text_padding: 20,
      lollipopRadius: 9,
      limitMaxTickNumberX: 0 // unlimited
    }
  },
  presentationProfileChanges: {
    "medium": {
      margin: { top: 70, bottom: 40, left: 70 },
      yAxisTitleBottomMargin: 20,
      xAxisTitleBottomMargin: 20,
      infoElHeight: 26,
      text_padding: 30
    },
    "large": {
      margin: { top: 70, bottom: 50, left: 70 },
      yAxisTitleBottomMargin: 20,
      xAxisTitleBottomMargin: 20,
      infoElHeight: 32,
      text_padding: 36,
      hideSTitle: true
    }
  },

  timeSliderProfiles: {
    small: {
      margin: {
        top: 9,
        right: 15,
        bottom: 10,
        left: 10
      }
    },
    medium: {
      margin: {
        top: 9,
        right: 15,
        bottom: 10,
        left: 20
      }
    },
    large: {
      margin: {
        top: 9,
        right: 15,
        bottom: 10,
        left: 25
      }
    }
  },

  /*
   * RESIZE:
   * Executed whenever the container is resized
   * Ideally, it contains only operations related to size
   */
  updateSize: function updateSize() {

    var _this = this;
    var values = this.values;
    var KEY = this.KEY;

    var padding = 2;

    this.activeProfile = this.getActiveProfile(this.profiles, this.presentationProfileChanges);
    this.margin = this.activeProfile.margin;
    this.tick_spacing = this.activeProfile.tick_spacing;

    var infoElHeight = this.activeProfile.infoElHeight;

    //adjust right this.margin according to biggest label

    var longestLabelWidth = 0;

    this.entityLabels.selectAll(".vzb-lc-labelname").attr("dx", _this.activeProfile.text_padding).each(function (d, index) {
      var width = this.getComputedTextLength();
      if (width > longestLabelWidth) longestLabelWidth = width;
    });

    this.entityLabels.selectAll(".vzb-lc-circle").attr("r", _this.activeProfile.lollipopRadius);

    this.margin.right = Math.max(this.margin.right, longestLabelWidth + this.activeProfile.text_padding + 20);

    //stage
    this.height = parseInt(this.element.style("height"), 10) - this.margin.top - this.margin.bottom || 0;
    this.width = parseInt(this.element.style("width"), 10) - this.margin.left - this.margin.right || 0;
    this.linesContainerCrop.attr("width", this.width).attr("height", Math.max(0, this.height));

    this.labelsContainerCrop.attr("width", this.width + this.margin.right).attr("height", Math.max(0, this.height));

    if (this.height <= 0 || this.width <= 0) return utils.warn("Line chart updateSize() abort: vizabi container is too little or has display:none");

    this.collisionResolver.height(this.height);

    this.graph.attr("transform", "translate(" + this.margin.left + "," + this.margin.top + ")");

    this.yScale.range([this.height - this.activeProfile.lollipopRadius, this.activeProfile.lollipopRadius]);
    this.xScale.range([this.rangeXShift, this.width * this.rangeXRatio + this.rangeXShift]);

    this.yAxis.scale(this.yScale).tickSizeInner(-this.width).tickSizeOuter(0).tickPadding(6).tickSizeMinor(-this.width, 0).labelerOptions({
      scaleType: this.model.marker.axis_y.scaleType,
      toolMargin: this.margin,
      limitMaxTickNumber: 6,
      viewportLength: this.height,
      formatter: this.model.marker.axis_y.getTickFormatter()
    });

    this.xAxis.scale(this.xScale).tickSizeInner(-this.height).tickSizeOuter(0).tickSizeMinor(-this.height, 0).tickPadding(6).labelerOptions({
      scaleType: this.model.marker.axis_x.scaleType,
      limitMaxTickNumber: this.activeProfile.limitMaxTickNumberX,
      toolMargin: this.margin,
      bump: this.activeProfile.text_padding * 2,
      formatter: this.model.marker.axis_x.getTickFormatter()
      //showOuter: true
    });

    this.xAxisElContainer.attr("width", this.width + this.activeProfile.text_padding * 2).attr("height", this.activeProfile.margin.bottom + this.height).attr("y", -1).attr("x", -this.activeProfile.text_padding);

    this.xAxisEl.attr("transform", "translate(" + (this.activeProfile.text_padding - 1) + "," + (this.height + 1) + ")");

    this.yAxisElContainer.attr("width", this.activeProfile.margin.left + this.width).attr("height", Math.max(0, this.height)).attr("x", -this.activeProfile.margin.left);
    this.yAxisEl.attr("transform", "translate(" + (this.activeProfile.margin.left - 1) + "," + 0 + ")");

    this.yAxisEl.call(this.yAxis);
    this.xAxisEl.call(this.xAxis);

    this.yTitleEl.style("font-size", infoElHeight + "px").attr("transform", "translate(" + (10 - this.activeProfile.margin.left) + ", -" + this.activeProfile.yAxisTitleBottomMargin + ")");

    var yTitleText = this.yTitleEl.select("text").text(this.strings.title.Y + this.strings.unit.Y);
    if (yTitleText.node().getBBox().width > this.width) yTitleText.text(this.strings.title.Y);

    if (this.yInfoEl.select("svg").node()) {
      var titleBBox = this.yTitleEl.node().getBBox();
      var t = utils.transform(this.yTitleEl.node());

      this.yInfoEl.select("svg").attr("width", infoElHeight + "px").attr("height", infoElHeight + "px");
      this.yInfoEl.attr("transform", "translate(" + (titleBBox.x + t.translateX + titleBBox.width + infoElHeight * 0.4) + "," + (t.translateY - infoElHeight * 0.8) + ")");
    }

    var warnBB = this.dataWarningEl.select("text").node().getBBox();
    this.dataWarningEl.select("svg").attr("width", warnBB.height * 0.75).attr("height", warnBB.height * 0.75).attr("x", -warnBB.width - warnBB.height * 1.2).attr("y", -warnBB.height * 0.65);

    this.dataWarningEl.attr("transform", "translate(" + (this.width + warnBB.width + warnBB.height * 2) + ",-" + this.activeProfile.yAxisTitleBottomMargin + ")").select("text");

    var xTitleText = this.xTitleEl.select("text").text(this.strings.title.X + this.strings.unit.X);

    this.xTitleEl.style("font-size", infoElHeight + "px").attr("transform", "translate(" + (this.width + this.activeProfile.text_padding + this.activeProfile.yAxisTitleBottomMargin) + "," + (this.height + xTitleText.node().getBBox().height * 0.72) + ")");

    if (xTitleText.node().getBBox().width > this.width - 100) xTitleText.text(this.strings.title.X);

    // adjust the vertical dashed line
    this.verticalNow.attr("y1", this.yScale.range()[0]).attr("y2", this.yScale.range()[1]).attr("x1", 0).attr("x2", 0);
    this.projectionX.attr("y1", _this.yScale.range()[0]);
    this.projectionY.attr("x2", _this.xScale.range()[0]);

    if (utils.isTouchDevice()) {
      _this.tooltip.classed("vzb-hidden", true);
      _this.verticalNow.style("opacity", 1);
      _this.projectionX.style("opacity", 0);
      _this.projectionY.style("opacity", 0);
      _this.xAxisEl.call(_this.xAxis.highlightValue(_this.time));
      _this.yAxisEl.call(_this.yAxis.highlightValue("none"));
      _this.graph.selectAll(".vzb-lc-entity").each(function () {
        d3.select(this).classed("vzb-dimmed", false).classed("vzb-hovered", false);
      });

      _this.hoveringNow = null;
    }
    var opts = {
      rangeMax: this.xScale.range()[1],
      mRight: this.margin.right,
      profile: this.timeSliderProfiles[this.getLayoutProfile()]
    };
    this.parent.trigger("myEvent", opts);

    this.sizeUpdatedOnce = true;
  },


  /*
   * REDRAW DATA POINTS:
   * Here plotting happens
   */
  redrawDataPoints: function redrawDataPoints() {
    var _this = this;
    var KEY = this.KEY;
    //    var values = this.values;

    if (!_this.all_values) return;
    this.model.marker.getFrame(this.time, function (values, time) {
      if (!_this._frameIsValid(values)) return;
      _this.values = values;
      if (!_this.timeUpdatedOnce) {
        _this.updateTime();
      }
      if (!_this.sizeUpdatedOnce) {
        _this.updateSize();
      }
      _this.updateDoubtOpacity();

      _this.lineWidth = _this.lineWidthScale(_this.data.length);
      _this.shadowWidth = _this.lineWidth * 1.3;
      _this.entityLines.each(function (d, index) {
        var entity = d3.select(this);
        var label = values.label[d[KEY]];

        var color = _this.cScale(values.color[d[KEY]]);
        var colorShadow = _this.model.marker.color.which == "geo.world_4region" ? _this.model.marker.color.getColorShade({
          colorID: values.color[d[KEY]],
          shadeID: "shade"
        }) : d3.rgb(color).darker(0.5).toString();

        //TODO: optimization is possible if getValues would return both x and time
        //TODO: optimization is possible if getValues would return a limited number of points, say 1 point per screen pixel

        var xy = _this.prev_steps.map(function (frame, i) {
          return [frame, _this.all_values[frame] ? _this.all_values[frame].axis_y[d[KEY]] : null];
        }).filter(function (d) {
          return d[1] || d[1] === 0;
        });

        // add last point
        if (values.axis_y[d[KEY]]) {
          xy.push([values.axis_x[d[KEY]], values.axis_y[d[KEY]]]);
        }

        if (xy.length > 0) {
          _this.cached[d[KEY]] = {
            valueX: xy[xy.length - 1][0],
            valueY: xy[xy.length - 1][1]
          };
        } else {
          delete _this.cached[d[KEY]];
        }

        // the following fixes the ugly line butts sticking out of the axis line
        //if(x[0]!=null && x[1]!=null) xy.splice(1, 0, [(+x[0]*0.99+x[1]*0.01), y[0]]);
        var path2 = entity.select(".vzb-lc-line");

        if (_this.model.time.playing && _this.totalLength_1[d[KEY]] === null) {
          _this.totalLength_1[d[KEY]] = path2.node().getTotalLength();
        }

        var path1 = entity.select(".vzb-lc-line-shadow").style("stroke", colorShadow).style("stroke-width", _this.shadowWidth + "px").attr("transform", "translate(0, " + (_this.shadowWidth - _this.lineWidth) + ")").attr("d", _this.line(xy));
        path2
        //.style("filter", "none")
        .style("stroke", color).style("stroke-width", _this.lineWidth + "px").attr("d", _this.line(xy));
        var totalLength = path2.node().getTotalLength();

        // this section ensures the smooth transition while playing and not needed otherwise
        if (_this.model.time.playing) {

          path1.interrupt().attr("stroke-dasharray", totalLength).attr("stroke-dashoffset", totalLength - _this.totalLength_1[d[KEY]]).transition().delay(0).duration(_this.duration).ease(d3.easeLinear).attr("stroke-dashoffset", 0);
          path2.interrupt().attr("stroke-dasharray", totalLength).attr("stroke-dashoffset", totalLength - _this.totalLength_1[d[KEY]]).transition().delay(0).duration(_this.duration).ease(d3.easeLinear).attr("stroke-dashoffset", 0);

          _this.totalLength_1[d[KEY]] = totalLength;
        } else {
          //reset saved line lengths
          _this.totalLength_1[d[KEY]] = null;

          path1.attr("stroke-dasharray", "none").attr("stroke-dashoffset", "none");

          path2.attr("stroke-dasharray", "none").attr("stroke-dashoffset", "none");
        }
      });

      _this.entityLabels.each(function (d, index) {
        var entity = d3.select(this);
        if (_this.cached[d[KEY]]) {
          entity.classed("vzb-hidden", false).transition().duration(_this.duration).ease(d3.easeLinear).attr("transform", "translate(" + _this.xScale(d3.min([_this.cached[d[KEY]]["valueX"]])) + ",0)");

          entity.select(".vzb-lc-circle").transition().duration(_this.duration).ease(d3.easeLinear).attr("cy", _this.yScale(_this.cached[d[KEY]]["valueY"]) + 1);

          entity.select(".vzb-lc-label").transition().duration(_this.duration).ease(d3.easeLinear).attr("transform", "translate(0," + _this.yScale(_this.cached[d[KEY]]["valueY"]) + ")");
        } else {
          entity.classed("vzb-hidden", true);
        }
      });
      _this.verticalNow.transition().duration(_this.duration).ease(d3.easeLinear).attr("transform", "translate(" + _this.xScale(d3.min([_this.model.marker.axis_x.zoomedMax, _this.time])) + ",0)");

      if (!_this.hoveringNow && _this.time - _this.model.time.start !== 0) {
        if (!_this.ui.chart.hideXAxisValue) _this.xAxisEl.call(_this.xAxis.highlightTransDuration(_this.duration).highlightValue(_this.time));
        _this.verticalNow.style("opacity", 1);
      } else {
        _this.verticalNow.style("opacity", 0);
      }

      // Call flush() after any zero-duration transitions to synchronously flush the timer queue
      // and thus make transition instantaneous. See https://github.com/mbostock/d3/issues/1951
      if (_this.duration == 0) {
        d3.timerFlush();
      }

      // cancel previously queued simulation if we just ordered a new one
      // then order a new collision resolving
      clearTimeout(_this.collisionTimeout);
      _this.collisionTimeout = setTimeout(function () {
        _this.entityLabels.call(_this.collisionResolver.data(_this.cached));
      }, _this.model.time.delayAnimations * 1.5);
    });
  },
  entityMousemove: function entityMousemove(me, index, context, closestToMouse) {
    var _this = context;
    var KEY = _this.KEY;
    var values = _this.values;

    var mouse = d3.mouse(_this.element.node()).map(function (d) {
      return parseInt(d);
    });

    var resolvedTime = _this.xScale.invert(mouse[0] - _this.margin.left);
    if (_this.time - resolvedTime < 0) {
      resolvedTime = _this.time;
    } else if (resolvedTime < this.model.time["start"]) {
      resolvedTime = this.model.time["start"];
    }
    var resolvedValue = void 0;
    var timeDim = _this.model.time.getDimension();

    var mousePos = mouse[1] - _this.margin.top;

    if (!utils.isDate(resolvedTime)) resolvedTime = this.model.time.parse(resolvedTime);

    this.model.marker.getFrame(resolvedTime, function (data) {
      if (!_this._frameIsValid(data)) return;
      var nearestKey = _this.getNearestKey(mousePos, data.axis_y, _this.yScale.bind(_this));
      resolvedValue = data.axis_y[nearestKey];
      if (!me) me = {};
      me[KEY] = nearestKey;
      if (!_this.model.marker.isHighlighted(me)) {
        _this.model.marker.clearHighlighted();
        _this.model.marker.highlightMarker(me);
      }
      _this.hoveringNow = me;

      if (utils.isNaN(resolvedValue)) return;

      var scaledTime = _this.xScale(resolvedTime);
      var scaledValue = _this.yScale(resolvedValue);

      if (_this.ui.chart.whenHovering.showTooltip) {
        //position tooltip
        _this.tooltip
        //.style("right", (_this.width - scaledTime + _this.margin.right ) + "px")
        .style("left", scaledTime + _this.margin.left + "px").style("bottom", _this.height - scaledValue + _this.margin.bottom + "px").text(_this.yAxis.tickFormat()(resolvedValue)).classed("vzb-hidden", false);
      }

      // bring the projection lines to the hovering point
      if (_this.ui.chart.whenHovering.hideVerticalNow) {
        _this.verticalNow.style("opacity", 0);
      }

      if (_this.ui.chart.whenHovering.showProjectionLineX) {
        _this.projectionX.style("opacity", 1).attr("y2", scaledValue).attr("x1", scaledTime).attr("x2", scaledTime);
      }
      if (_this.ui.chart.whenHovering.showProjectionLineY) {
        _this.projectionY.style("opacity", 1).attr("y1", scaledValue).attr("y2", scaledValue).attr("x1", scaledTime);
      }

      if (_this.ui.chart.whenHovering.higlightValueX) _this.xAxisEl.call(_this.xAxis.highlightValue(resolvedTime).highlightTransDuration(0));

      if (_this.ui.chart.whenHovering.higlightValueY) _this.yAxisEl.call(_this.yAxis.highlightValue(resolvedValue).highlightTransDuration(0));

      clearTimeout(_this.unhoverTimeout);
    });
  },
  entityMouseout: function entityMouseout(me, index, context) {
    var _this = context;
    if (d3.event.relatedTarget && d3.select(d3.event.relatedTarget).classed("vzb-tooltip")) return;

    // hide and show things like it was before hovering
    _this.unhoverTimeout = setTimeout(function () {
      _this.tooltip.classed("vzb-hidden", true);
      _this.verticalNow.style("opacity", 1);
      _this.projectionX.style("opacity", 0);
      _this.projectionY.style("opacity", 0);
      _this.xAxisEl.call(_this.xAxis.highlightValue(_this.time));
      _this.yAxisEl.call(_this.yAxis.highlightValue("none"));

      _this.model.marker.clearHighlighted();

      _this.hoveringNow = null;
    }, 300);
  },


  /*
   * Highlights all hovered lines
   */
  highlightLines: function highlightLines() {
    var _this = this;

    var OPACITY_HIGHLT = 1.0;
    var OPACITY_HIGHLT_DIM = 0.3;
    var OPACITY_SELECT = this.model.marker.opacityRegular;
    var OPACITY_REGULAR = this.model.marker.opacityRegular;
    var OPACITY_SELECT_DIM = this.model.marker.opacitySelectDim;

    var someHighlighted = this.model.marker.highlight.length > 0;
    var someSelected = this.model.marker.select.length > 0;
    this.graph.selectAll(".vzb-lc-entity").each(function () {
      d3.select(this).style("opacity", function (d) {
        if (_this.model.marker.isHighlighted(d)) return OPACITY_HIGHLT;
        if (someSelected) {
          return _this.model.marker.isSelected(d) ? OPACITY_SELECT : OPACITY_SELECT_DIM;
        }
        if (someHighlighted) return OPACITY_HIGHLT_DIM;
        return OPACITY_REGULAR;
      });
    });
  },
  zoomToMaxMin: function zoomToMaxMin() {
    var _this = this;
    //
    /*
        if(this.model.marker.axis_y.zoomedMin == null ) this.model.marker.axis_y.zoomedMin = this.yScale.domain()[0];
        if(this.model.marker.axis_y.zoomedMax == null ) this.model.marker.axis_y.zoomedMax = this.yScale.domain()[1];
    */

    if (this.model.marker.axis_x.zoomedMin != null && this.model.marker.axis_x.zoomedMax != null) {
      this.xScale.domain([this.model.marker.axis_x.zoomedMin, this.model.marker.axis_x.zoomedMax]);
      this.xAxisEl.call(this.xAxis);
    }
    if (this.model.marker.axis_y.zoomedMin != null && this.model.marker.axis_y.zoomedMax != null) {
      if ((this.model.marker.axis_y.zoomedMin <= 0 || this.model.marker.axis_y.zoomedMax <= 0) && this.model.marker.axis_y.scaleType == "log") {
        this.yScale = d3.scale.genericLog().domain([this.model.marker.axis_y.zoomedMin, this.model.marker.axis_y.zoomedMax]).range(this.yScale.range());
        this.model.marker.axis_y.scale = d3.scale.genericLog().domain([this.model.marker.axis_y.zoomedMin, this.model.marker.axis_y.zoomedMax]).range(this.yScale.range());
        this.yScale = this.model.marker.axis_y.scale;
      } else {
        this.yScale.domain([this.model.marker.axis_y.zoomedMin, this.model.marker.axis_y.zoomedMax]);
      }
      this.yAxisEl.call(this.yAxis);
    }
  },


  /**
   * Returns key from obj which value has the smallest difference with val
   */
  getNearestKey: function getNearestKey(val, obj, fn) {
    var keys = Object.keys(obj);
    var resKey = keys[0];
    for (var i = 1; i < keys.length; i++) {
      var key = keys[i];
      if (Math.abs((fn ? fn(obj[key]) : obj[key]) - val) < Math.abs((fn ? fn(obj[resKey]) : obj[resKey]) - val)) {
        resKey = key;
      }
    }
    return resKey;
  }
}); /*!
     * VIZABI LINECHART
     */

exports.default = LCComponent;

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _component = __webpack_require__(2);

var _component2 = _interopRequireDefault(_component);

var _iconset = __webpack_require__(10);

var _svgexport = __webpack_require__(138);

var _svgexport2 = _interopRequireDefault(_svgexport);

var _d = __webpack_require__(41);

var _d2 = _interopRequireDefault(_d);

var _mountainchartMath = __webpack_require__(229);

var _mountainchartMath2 = _interopRequireDefault(_mountainchartMath);

var _mountainchartSelectlist = __webpack_require__(231);

var _mountainchartSelectlist2 = _interopRequireDefault(_mountainchartSelectlist);

var _mountainchartProbe = __webpack_require__(230);

var _mountainchartProbe2 = _interopRequireDefault(_mountainchartProbe);

var _d3 = __webpack_require__(60);

var _d4 = _interopRequireDefault(_d3);

var _globals = __webpack_require__(34);

var _globals2 = _interopRequireDefault(_globals);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
* VIZABI MOUNTAINCHART
* This graph displays income distribution in the world
*
* Original code:
* Angie https://github.com/angieskazka
*
* Contributions:
* IncoCode https://github.com/IncoCode/
* Arthur https://github.com/arthurcamara1
*
* Developed in Gapminder Foundation, 2015
*/

var THICKNESS_THRESHOLD = 0.001;
var COLOR_WHITEISH = "#d3d3d3";

//MOUNTAIN CHART COMPONENT
var MountainChartComponent = _component2.default.extend({

  /**
   * Initialize the component
   * Executed once before any template is rendered.
   * @param {Object} config The config passed to the component
   * @param {Object} context The component's parent
   */
  init: function init(config, context) {

    var _this = this;
    this.name = "mountainchart";
    this.template = __webpack_require__(466);

    //define expected models for this component
    this.model_expects = [{ name: "time", type: "time" }, { name: "entities", type: "entities" }, { name: "marker", type: "model" }, { name: "locale", type: "locale" }, { name: "ui", type: "ui" }];

    //attach event listeners to the model items
    this.model_binds = {
      "change:time.value": function changeTimeValue(evt) {
        if (!_this._readyOnce) return;
        _this.model.marker.getFrame(_this.model.time.value, _this.frameChanged.bind(_this));
      },
      "change:time.playing": function changeTimePlaying(evt) {
        // this listener is a patch for fixing #1228. time.js doesn't produce the last event
        // with playing == false when paused softly
        if (!_this.model.time.playing) {
          _this.redrawDataPoints();
        }
      },
      "change:marker.axis_x.xScaleFactor": function changeMarkerAxis_xXScaleFactor() {
        _this.ready();
      },
      "change:marker.axis_x.xScaleShift": function changeMarkerAxis_xXScaleShift() {
        _this.ready();
      },
      "change:marker.axis_x.tailFatX": function changeMarkerAxis_xTailFatX() {
        _this.ready();
      },
      "change:marker.axis_x.tailCutX": function changeMarkerAxis_xTailCutX() {
        _this.ready();
      },
      "change:marker.axis_x.tailFade": function changeMarkerAxis_xTailFade() {
        _this.ready();
      },
      "change:ui.chart.probeX": function changeUiChartProbeX() {
        _this.ready();
      },
      "change:ui.chart.showProbeX": function changeUiChartShowProbeX() {
        _this.ready();
      },
      "change:ui.chart.xPoints": function changeUiChartXPoints() {
        _this.ready();
      },
      "change:ui.chart.xLogStops": function changeUiChartXLogStops() {
        _this.updateSize();
      },
      "change:ui.chart.yMaxMethod": function changeUiChartYMaxMethod() {
        _this._adjustMaxY({ force: true });
        _this.redrawDataPoints();
      },
      "change:time.record": function changeTimeRecord(evt) {
        if (_this.model.time.record) {
          _this._export.open(this.element, this.name);
        } else {
          _this._export.reset();
        }
      },
      "change:marker.highlight": function changeMarkerHighlight(evt) {
        if (!_this._readyOnce) return;
        _this.highlightMarkers();
        _this.updateOpacity();
      },
      "change:marker.select": function changeMarkerSelect(evt) {
        if (!_this._readyOnce) return;
        _this.selectMarkers();
        _this._selectlist.redraw();
        _this.updateOpacity();
        _this.updateDoubtOpacity();
        _this.redrawDataPoints();
      },
      "change:marker.opacitySelectDim": function changeMarkerOpacitySelectDim(evt) {
        _this.updateOpacity();
      },
      "change:marker.opacityRegular": function changeMarkerOpacityRegular(evt) {
        _this.updateOpacity();
      },
      "change:marker": function changeMarker(evt, path) {
        if (!_this._readyOnce) return;
        if (path.indexOf("scaleType") > -1) {
          _this.ready();
        } else if (path.indexOf("zoomedMin") > -1 || path.indexOf("zoomedMax") > -1) {
          _this.zoomToMaxMin();
          _this.redrawDataPoints();
          _this._probe.redraw();
        }
      },
      "change:marker.group": function changeMarkerGroup(evt, path) {
        if (!_this._readyOnce) return;
        if (path.indexOf("group.merge") > -1) return;
        _this.ready();
      },
      "change:marker.group.merge": function changeMarkerGroupMerge(evt) {
        if (!_this._readyOnce) return;
        _this.updatePointers();
        _this.redrawDataPoints();
      },
      "change:marker.stack": function changeMarkerStack(evt) {
        if (!_this._readyOnce) return;
        _this.ready();
      },
      "change:marker.stack.which": function changeMarkerStackWhich(evt) {
        if (!_this._readyOnce) return;
        if (_this.model.time.playing) {
          _this.model.time.pause();
        }
      },
      "change:marker.stack.use": function changeMarkerStackUse(evt) {
        if (!_this._readyOnce) return;
        if (_this.model.time.playing) {
          _this.model.time.pause();
        }
      },
      "change:marker.color.palette": function changeMarkerColorPalette(evt) {
        if (!_this._readyOnce) return;
        _this.redrawDataPointsOnlyColors();
        _this._selectlist.redraw();
      }
    };

    this._super(config, context);

    this._math = new _mountainchartMath2.default(this);
    this._export = new _svgexport2.default(this);
    this._export.prefix("vzb-mc-").deleteClasses(["vzb-mc-mountains-mergestacked", "vzb-mc-mountains-mergegrouped", "vzb-mc-mountains", "vzb-mc-year", "vzb-mc-mountains-labels", "vzb-mc-axis-labels"]);
    this._probe = new _mountainchartProbe2.default(this);
    this._selectlist = new _mountainchartSelectlist2.default(this);

    // define path generator
    this.area = d3.area().curve(d3.curveBasis).x(function (d) {
      return _this.xScale(_this._math.rescale(d.x));
    }).y0(function (d) {
      return _this.yScale(d.y0);
    }).y1(function (d) {
      return _this.yScale(d.y0 + d.y);
    });

    //define d3 stack layout
    this.stack = d3.stack().order(d3.stackOrderReverse).value(function (d, key) {
      return _this.cached[key][d].y;
    });

    // init internal variables
    this.xScale = null;
    this.yScale = null;
    this.cScale = null;

    this.xAxis = (0, _d2.default)("bottom");

    this.rangeRatio = 1;
    this.rangeShift = 0;
    this.cached = {};
    this.mesh = [];
    this.yMax = 0;
  },
  domReady: function domReady() {
    var _this = this;

    // reference elements
    this.element = d3.select(this.element);
    this.graph = this.element.select(".vzb-mc-graph");
    this.xAxisEl = this.graph.select(".vzb-mc-axis-x");
    this.xTitleEl = this.graph.select(".vzb-mc-axis-x-title");
    this.yTitleEl = this.graph.select(".vzb-mc-axis-y-title");
    this.infoEl = this.graph.select(".vzb-mc-axis-info");
    this.dataWarningEl = this.graph.select(".vzb-data-warning");

    this.yearEl = this.graph.select(".vzb-mc-year");
    this.year = new _d4.default(this.yearEl);

    this.mountainMergeStackedContainer = this.graph.select(".vzb-mc-mountains-mergestacked");
    this.mountainMergeGroupedContainer = this.graph.select(".vzb-mc-mountains-mergegrouped");
    this.mountainAtomicContainer = this.graph.select(".vzb-mc-mountains");
    this.mountainLabelContainer = this.graph.select(".vzb-mc-mountains-labels");
    this.tooltip = this.element.select(".vzb-mc-tooltip");
    this.eventAreaEl = this.element.select(".vzb-mc-eventarea");
    this.probeEl = this.element.select(".vzb-mc-probe");
    this.probeLineEl = this.probeEl.select("line");
    this.probeTextEl = this.probeEl.selectAll("text");

    this.element.onTap(function (d, i) {
      _this._interact()._mouseout(d, i);
    });
  },
  afterPreload: function afterPreload() {
    var _this = this;

    var yearNow = _this.model.time.formatDate(this.model.time.value);
    var yearEnd = _this.model.time.formatDate(this.model.time.end);

    this._math.xScaleFactor = this.model.marker.axis_x.xScaleFactor;
    this._math.xScaleShift = this.model.marker.axis_x.xScaleShift;

    if (!this.precomputedShapes || !this.precomputedShapes[yearNow] || !this.precomputedShapes[yearEnd]) return;

    var yMax = this.precomputedShapes[this.model.ui.chart.yMaxMethod == "immediate" ? yearNow : yearEnd].yMax;
    var shape = this.precomputedShapes[yearNow].shape;

    if (!yMax || !shape || shape.length === 0) return;

    this.xScale = d3.scale.log().domain([this.model.marker.axis_x.domainMin, this.model.marker.axis_x.domainMax]);
    this.yScale = d3.scale.linear().domain([0, Math.round(yMax)]);

    _this.updateSize(shape.length);
    _this.zoomToMaxMin();

    shape = shape.map(function (m, i) {
      return { x: _this.mesh[i], y0: 0, y: +m };
    });

    this.mountainAtomicContainer.selectAll(".vzb-mc-prerender").data([0]).enter().append("path").attr("class", "vzb-mc-prerender").style("fill", "pink").style("opacity", 0).attr("d", _this.area(shape)).transition().duration(1000).ease(d3.easeLinear).style("opacity", 1);
  },
  readyOnce: function readyOnce() {

    this.eventAreaEl.on("mousemove", function () {
      if (_this.model.time.dragging) return;
      if (!_this.model.ui.chart.showProbeX) return;
      _this._probe.redraw({
        level: _this.xScale.invert(d3.mouse(this)[0]),
        full: true
      });
    }).on("mouseout", function () {
      if (_this.model.time.dragging) return;
      if (!_this.model.ui.chart.showProbeX) return;
      _this._probe.redraw();
    });

    var _this = this;
    this.on("resize", function () {
      //console.log("acting on resize");
      //return if updatesize exists with error
      if (_this.updateSize()) return;
      _this.updatePointers(); // respawn is needed
      _this.redrawDataPoints();
      _this._selectlist.redraw();
      _this._probe.redraw();
    });

    this.KEY = this.model.entities.getDimension();
    this.TIMEDIM = this.model.time.getDimension();

    this.mountainAtomicContainer.select(".vzb-mc-prerender").remove();
    this.year.setText(this.model.time.formatDate(this.model.time.value));
    this.wScale = d3.scale.linear().domain(this.model.ui.datawarning.doubtDomain).range(this.model.ui.datawarning.doubtRange);
  },
  ready: function ready() {
    //console.log("ready")
    var _this = this;

    this._math.xScaleFactor = this.model.marker.axis_x.xScaleFactor;
    this._math.xScaleShift = this.model.marker.axis_x.xScaleShift;

    this.updateUIStrings();
    this.updateIndicators();
    this.model.marker.getFrame(this.model.time.value, function (values) {
      if (!values) return;
      _this.values = values;
      _this.updateEntities();
      _this.updateSize();
      _this.zoomToMaxMin();
      _this._spawnMasks();
      _this.updateTime();
      _this.updatePointers();
      _this._adjustMaxY({ force: true });
      _this.redrawDataPoints();
      _this.redrawDataPointsOnlyColors();
      _this.highlightMarkers();
      _this.selectMarkers();
      _this._selectlist.redraw();
      _this.updateOpacity();
      _this.updateDoubtOpacity();
      _this._probe.redraw();
    });
  },
  frameChanged: function frameChanged(frame, time) {
    if (!frame) return utils.warn("change:time.value: empty data received from marker.getFrame(). doing nothing");
    if (time.toString() != this.model.time.value.toString()) return; // frame is outdated
    this.values = frame;
    this.updateTime();
    this.updatePointers();
    this.redrawDataPoints();
    this._selectlist.redraw();
    this._probe.redraw();
    this.updateDoubtOpacity();
  },
  updateSize: function updateSize(meshLength) {
    var profiles = {
      small: {
        margin: { top: 10, right: 10, left: 10, bottom: 18 },
        infoElHeight: 16
      },
      medium: {
        margin: { top: 20, right: 20, left: 20, bottom: 30 },
        infoElHeight: 20
      },
      large: {
        margin: { top: 30, right: 30, left: 30, bottom: 35 },
        infoElHeight: 22
      }
    };

    var presentationProfileChanges = {
      medium: {
        margin: { top: 20, right: 20, left: 20, bottom: 50 },
        infoElHeight: 26
      },
      large: {
        margin: { top: 30, right: 30, left: 30, bottom: 50 },
        infoElHeight: 32
      }
    };

    this.activeProfile = this.getActiveProfile(profiles, presentationProfileChanges);
    var margin = this.activeProfile.margin;
    var infoElHeight = this.activeProfile.infoElHeight;

    //mesure width and height

    this.height = parseInt(this.element.style("height"), 10) - margin.top - margin.bottom || 0;
    this.width = parseInt(this.element.style("width"), 10) - margin.left - margin.right || 0;

    if (this.height <= 0 || this.width <= 0) return utils.warn("Mountain chart updateSize() abort: vizabi container is too little or has display:none");

    //graph group is shifted according to margins (while svg element is at 100 by 100%)
    this.graph.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    var isRTL = this.model.locale.isRTL();

    var yearLabelOptions = {
      topOffset: this.getLayoutProfile() === "large" ? margin.top * 2 : 0,
      xAlign: this.getLayoutProfile() === "large" ? isRTL ? "left" : "right" : "center",
      yAlign: this.getLayoutProfile() === "large" ? "top" : "center",
      widthRatio: this.getLayoutProfile() === "large" ? 3 / 8 : 8 / 10
    };

    //year is centered and resized
    this.year.setConditions(yearLabelOptions).resize(this.width, this.height);

    //update scales to the new range
    this.yScale.range([this.height, 0]);
    this.xScale.range([this.rangeShift, this.width * this.rangeRatio + this.rangeShift]);

    //need to know scale type of X to move on
    var scaleType = this._readyOnce ? this.model.marker.axis_x.scaleType : "log";

    //axis is updated
    this.xAxis.scale(this.xScale).tickSizeOuter(0).tickPadding(9).tickSizeMinor(3, 0).labelerOptions({
      scaleType: scaleType,
      toolMargin: margin,
      pivotingLimit: margin.bottom * 1.5,
      method: this.xAxis.METHOD_REPEATING,
      stops: this._readyOnce ? this.model.ui.chart.xLogStops : [1],
      formatter: this.model.marker.axis_x.getTickFormatter()
    });

    this.xAxisEl.attr("transform", "translate(0," + this.height + ")").call(this.xAxis);

    this.xTitleEl.select("text").attr("transform", "translate(" + this.width + "," + this.height + ")").attr("dy", "-0.36em");

    this.yTitleEl.style("font-size", infoElHeight + "px").attr("transform", "translate(" + (isRTL ? this.width : 0) + "," + margin.top + ")");

    var warnBB = this.dataWarningEl.select("text").node().getBBox();
    this.dataWarningEl.select("svg").attr("width", warnBB.height).attr("height", warnBB.height).attr("x", warnBB.height * 0.1).attr("y", -warnBB.height * 1.0 + 1);

    this.dataWarningEl.attr("transform", "translate(" + (isRTL ? this.width - warnBB.width - warnBB.height * 2 : 0) + "," + (margin.top + warnBB.height * 1.5) + ")").select("text").attr("dx", warnBB.height * 1.5);

    if (this.infoEl.select("svg").node()) {
      var titleBBox = this.yTitleEl.node().getBBox();
      var t = utils.transform(this.yTitleEl.node());
      var hTranslate = isRTL ? titleBBox.x + t.translateX - infoElHeight * 1.4 : titleBBox.x + t.translateX + titleBBox.width + infoElHeight * 0.4;

      this.infoEl.select("svg").attr("width", infoElHeight + "px").attr("height", infoElHeight + "px");
      this.infoEl.attr("transform", "translate(" + hTranslate + "," + (t.translateY - infoElHeight * 0.8) + ")");
    }

    this.eventAreaEl.attr("y", this.height).attr("width", this.width).attr("height", margin.bottom);

    if (!meshLength) meshLength = this.model.ui.chart.xPoints;
    this.mesh = this._math.generateMesh(meshLength, scaleType, this.xScale.domain());
  },
  zoomToMaxMin: function zoomToMaxMin() {
    var _this = this;

    if (this.model.marker.axis_x.zoomedMin == null || this.model.marker.axis_x.zoomedMax == null) return;

    var x1 = this.xScale(this.model.marker.axis_x.zoomedMin);
    var x2 = this.xScale(this.model.marker.axis_x.zoomedMax);

    this.rangeRatio = this.width / (x2 - x1) * this.rangeRatio;
    this.rangeShift = (this.rangeShift - x1) / (x2 - x1) * this.width;

    this.xScale.range([this.rangeShift, this.width * this.rangeRatio + this.rangeShift]);

    this.xAxisEl.call(this.xAxis);
  },
  updateUIStrings: function updateUIStrings() {
    var _this = this;

    this.translator = this.model.locale.getTFunction();
    var xConceptprops = this.model.marker.axis_x.getConceptprops();

    this.xTitleEl.select("text").text(this.translator("unit/mountainchart_hardcoded_income_per_day"));

    this.yTitleEl.select("text").text(this.translator("mount/title"));

    utils.setIcon(this.dataWarningEl, _iconset.warn).select("svg").attr("width", "0px").attr("height", "0px");
    this.dataWarningEl.append("text").text(this.translator("hints/dataWarning"));

    utils.setIcon(this.infoEl, _iconset.question).select("svg").attr("width", "0px").attr("height", "0px");

    //TODO: move away from UI strings, maybe to ready or ready once
    this.infoEl.on("click", function () {
      _this.parent.findChildByName("gapminder-datanotes").pin();
    });
    this.infoEl.on("mouseover", function () {
      var rect = this.getBBox();
      var coord = utils.makeAbsoluteContext(this, this.farthestViewportElement)(rect.x - 10, rect.y + rect.height + 10);
      var toolRect = _this.root.element.getBoundingClientRect();
      var chartRect = _this.element.node().getBoundingClientRect();
      _this.parent.findChildByName("gapminder-datanotes").setHook("axis_y").show().setPos(coord.x + chartRect.left - toolRect.left, coord.y);
    });
    this.infoEl.on("mouseout", function () {
      _this.parent.findChildByName("gapminder-datanotes").hide();
    });

    this.dataWarningEl.on("click", function () {
      _this.parent.findChildByName("gapminder-datawarning").toggle();
    }).on("mouseover", function () {
      _this.updateDoubtOpacity(1);
    }).on("mouseout", function () {
      _this.updateDoubtOpacity();
    });
  },
  updateDoubtOpacity: function updateDoubtOpacity(opacity) {
    if (opacity == null) opacity = this.wScale(+this.time.getUTCFullYear().toString());
    if (this.someSelected) opacity = 1;
    this.dataWarningEl.style("opacity", opacity);
  },
  updateIndicators: function updateIndicators() {
    var _this = this;

    //fetch scales, or rebuild scales if there are none, then fetch
    this.yScale = this.model.marker.axis_y.getScale();
    this.xScale = this.model.marker.axis_x.getScale();
    this.cScale = this.model.marker.color.getScale();

    this.xAxis.tickFormat(_this.model.marker.axis_x.getTickFormatter());
  },
  updateEntities: function updateEntities() {
    var _this = this;

    // construct pointers
    this.mountainPointers = this.model.marker.getKeys().filter(function (d) {
      return 1 && _this.values.axis_x[d[_this.KEY]] && _this.values.axis_y[d[_this.KEY]] && _this.values.axis_s[d[_this.KEY]];
    }).map(function (d) {
      var pointer = {};
      pointer[_this.KEY] = d[_this.KEY];
      pointer.KEY = function () {
        return this[_this.KEY];
      };
      pointer.sortValue = [_this.values.axis_y[pointer.KEY()] || 0, 0];
      pointer.aggrLevel = 0;
      return pointer;
    });

    //TODO: optimise this!
    this.groupedPointers = d3.nest().key(function (d) {
      return _this.model.marker.stack.use === "property" ? _this.values.stack[d.KEY()] : _this.values.group[d.KEY()];
    }).sortValues(function (a, b) {
      return b.sortValue[0] - a.sortValue[0];
    }).entries(this.mountainPointers);

    var groupManualSort = this.model.marker.group.manualSorting;
    this.groupedPointers.forEach(function (group) {
      var groupSortValue = d3.sum(group.values.map(function (m) {
        return m.sortValue[0];
      }));

      if (groupManualSort && groupManualSort.length > 1) groupSortValue = groupManualSort.length - 1 - groupManualSort.indexOf(group.key);

      group.values.forEach(function (d) {
        d.sortValue[1] = groupSortValue;
      });

      group[_this.model.entities.getDimension()] = group.key; // hack to get highlihgt and selection work
      group.KEY = function () {
        return this.key;
      };
      group.aggrLevel = 1;
    });

    var sortGroupKeys = {};
    _this.groupedPointers.forEach(function (m) {
      sortGroupKeys[m.key] = m.values[0].sortValue[1];
    });

    // update the stacked pointers
    if (_this.model.marker.stack.which === "none") {
      this.stackedPointers = [];
      this.mountainPointers.sort(function (a, b) {
        return b.sortValue[0] - a.sortValue[0];
      });
    } else {
      this.stackedPointers = d3.nest().key(function (d) {
        return _this.values.stack[d.KEY()];
      }).key(function (d) {
        return _this.values.group[d.KEY()];
      }).sortKeys(function (a, b) {
        return sortGroupKeys[b] - sortGroupKeys[a];
      }).sortValues(function (a, b) {
        return b.sortValue[0] - a.sortValue[0];
      }).entries(this.mountainPointers);

      this.mountainPointers.sort(function (a, b) {
        return b.sortValue[1] - a.sortValue[1];
      });

      this.stackedPointers.forEach(function (stack) {
        stack.KEY = function () {
          return this.key;
        };
        stack[_this.model.entities.getDimension()] = stack.key; // hack to get highlihgt and selection work
        stack.aggrLevel = 2;
      });
    }

    //bind the data to DOM elements
    this.mountainsMergeStacked = this.mountainAtomicContainer.selectAll(".vzb-mc-mountain.vzb-mc-aggrlevel2").data(this.stackedPointers);
    this.mountainsMergeGrouped = this.mountainAtomicContainer.selectAll(".vzb-mc-mountain.vzb-mc-aggrlevel1").data(this.groupedPointers);
    this.mountainsAtomic = this.mountainAtomicContainer.selectAll(".vzb-mc-mountain.vzb-mc-aggrlevel0").data(this.mountainPointers);

    //exit selection -- remove shapes
    this.mountainsMergeStacked.exit().remove();
    this.mountainsMergeGrouped.exit().remove();
    this.mountainsAtomic.exit().remove();

    //enter selection -- add shapes
    this.mountainsMergeStacked = this.mountainsMergeStacked.enter().append("path").attr("class", "vzb-mc-mountain vzb-mc-aggrlevel2").merge(this.mountainsMergeStacked);
    this.mountainsMergeGrouped = this.mountainsMergeGrouped.enter().append("path").attr("class", "vzb-mc-mountain vzb-mc-aggrlevel1").merge(this.mountainsMergeGrouped);
    this.mountainsAtomic = this.mountainsAtomic.enter().append("path").attr("class", "vzb-mc-mountain vzb-mc-aggrlevel0").merge(this.mountainsAtomic);

    //add interaction
    this.mountains = this.mountainAtomicContainer.selectAll(".vzb-mc-mountain");

    this.mountains.on("mousemove", function (d, i) {
      if (utils.isTouchDevice()) return;
      _this._interact()._mousemove(d, i);
    }).on("mouseout", function (d, i) {
      if (utils.isTouchDevice()) return;
      _this._interact()._mouseout(d, i);
    }).on("click", function (d, i) {
      if (utils.isTouchDevice()) return;
      _this._interact()._click(d, i);
      _this.highlightMarkers();
    }).onTap(function (d, i) {
      _this._interact()._click(d, i);
      d3.event.stopPropagation();
    }).onLongTap(function (d, i) {});
  },
  _interact: function _interact() {
    var _this = this;

    return {
      _mousemove: function _mousemove(d, i) {
        if (_this.model.time.dragging || _this.model.time.playing) return;

        _this.model.marker.highlightMarker(d);

        var mouse = d3.mouse(_this.graph.node()).map(function (d) {
          return parseInt(d);
        });

        //position tooltip
        _this._setTooltip(d.key ? _this.model.marker.color.getColorlegendMarker().label.getItems()[d.key] : _this.values.label[d.KEY()]);
        _this._selectlist.showCloseCross(d, true);
      },
      _mouseout: function _mouseout(d, i) {
        if (_this.model.time.dragging || _this.model.time.playing) return;

        _this._setTooltip("");
        _this.model.marker.clearHighlighted();
        _this._selectlist.showCloseCross(d, false);
      },
      _click: function _click(d, i) {
        if (_this.model.time.dragging || _this.model.time.playing) return;

        _this.model.marker.selectMarker(d);
      }
    };
  },
  highlightMarkers: function highlightMarkers() {
    var _this = this;
    this.someHighlighted = this.model.marker.highlight.length > 0;

    if (!this.selectList || !this.someSelected) return;
    this.selectList.classed("vzb-highlight", function (d) {
      return _this.model.marker.isHighlighted(d);
    });
  },
  selectMarkers: function selectMarkers() {
    var _this = this;
    this.someSelected = this.model.marker.select.length > 0;

    this._selectlist.rebuild();
    this.nonSelectedOpacityZero = false;
  },
  _sumLeafPointersByMarker: function _sumLeafPointersByMarker(branch, marker) {
    var _this = this;
    if (!branch.key) return _this.values[marker][branch.KEY()];
    return d3.sum(branch.values.map(function (m) {
      return _this._sumLeafPointersByMarker(m, marker);
    }));
  },
  updateOpacity: function updateOpacity() {
    var _this = this;
    //if(!duration)duration = 0;

    var OPACITY_HIGHLT = 1.0;
    var OPACITY_HIGHLT_DIM = 0.3;
    var OPACITY_SELECT = this.model.marker.opacityRegular;
    var OPACITY_REGULAR = this.model.marker.opacityRegular;
    var OPACITY_SELECT_DIM = this.model.marker.opacitySelectDim;

    this.mountains.style("opacity", function (d) {

      if (_this.someHighlighted) {
        //highlight or non-highlight
        if (_this.model.marker.isHighlighted(d)) return OPACITY_HIGHLT;
      }

      if (_this.someSelected) {
        //selected or non-selected
        return _this.model.marker.isSelected(d) ? OPACITY_SELECT : OPACITY_SELECT_DIM;
      }

      if (_this.someHighlighted) return OPACITY_HIGHLT_DIM;

      return OPACITY_REGULAR;
    });

    this.mountains.classed("vzb-selected", function (d) {
      return _this.model.marker.isSelected(d);
    });

    var nonSelectedOpacityZero = _this.model.marker.opacitySelectDim < 0.01;

    // when pointer events need update...
    if (nonSelectedOpacityZero !== this.nonSelectedOpacityZero) {
      this.mountainsAtomic.style("pointer-events", function (d) {
        return !_this.someSelected || !nonSelectedOpacityZero || _this.model.marker.isSelected(d) ? "visible" : "none";
      });
    }

    this.nonSelectedOpacityZero = _this.model.marker.opacitySelectDim < 0.01;
  },
  updateTime: function updateTime() {
    var _this = this;

    this.time_1 = this.time == null ? this.model.time.value : this.time;
    this.time = this.model.time.value;
    this.duration = this.model.time.playing && this.time - this.time_1 > 0 ? this.model.time.delayAnimations : 0;
    this.year.setText(this.model.time.formatDate(this.time), this.duration);
  },
  updatePointers: function updatePointers() {
    var _this = this;
    this.yMax = 0;

    //spawn the original mountains
    this.mountainPointers.forEach(function (d, i) {
      var vertices = _this._spawn(_this.values, d);
      _this.cached[d.KEY()] = vertices;
      d.hidden = vertices.length === 0;
    });

    //recalculate stacking
    if (_this.model.marker.stack.which !== "none") {
      this.stackedPointers.forEach(function (group) {
        var toStack = [];
        group.values.forEach(function (subgroup) {
          toStack = toStack.concat(subgroup.values.filter(function (f) {
            return !f.hidden;
          }));
        });
        _this.stack.keys(toStack.map(function (d) {
          return d.KEY();
        }))(d3.range(_this.mesh.length)).forEach(function (vertices, keyIndex) {
          var key = toStack[keyIndex].KEY();
          vertices.forEach(function (d, verticesIndex) {
            _this.cached[key][verticesIndex].y0 = d[0];
          });
        });
      });
    }

    this.mountainPointers.forEach(function (d) {
      d.yMax = d3.max(_this.cached[d.KEY()].map(function (m) {
        return m.y0 + m.y;
      }));
      if (_this.yMax < d.yMax) _this.yMax = d.yMax;
    });

    var mergeGrouped = _this.model.marker.group.merge;
    var mergeStacked = _this.model.marker.stack.merge;
    //var dragOrPlay = (_this.model.time.dragging || _this.model.time.playing) && this.model.marker.stack.which !== "none";

    //if(mergeStacked){
    this.stackedPointers.forEach(function (d) {
      var firstLast = _this._getFirstLastPointersInStack(d);
      _this.cached[d.key] = _this._getVerticesOfaMergedShape(firstLast);
      _this.values.color[d.key] = "_default";
      _this.values.axis_y[d.key] = _this._sumLeafPointersByMarker(d, "axis_y");
      d.yMax = firstLast.first.yMax;
    });
    //} else if (mergeGrouped || dragOrPlay){
    this.groupedPointers.forEach(function (d) {
      var firstLast = _this._getFirstLastPointersInStack(d);
      _this.cached[d.key] = _this._getVerticesOfaMergedShape(firstLast);
      _this.values.color[d.key] = _this.values.color[firstLast.first.KEY()];
      _this.values.axis_y[d.key] = _this._sumLeafPointersByMarker(d, "axis_y");
      d.yMax = firstLast.first.yMax;
    });
    //}

    if (!mergeStacked && !mergeGrouped && this.model.marker.stack.use === "property") {
      this.groupedPointers.forEach(function (d) {
        var visible = d.values.filter(function (f) {
          return !f.hidden;
        });
        d.yMax = visible[0].yMax;
        d.values.forEach(function (e) {
          e.yMaxGroup = d.yMax;
        });
      });
    }
  },
  _getFirstLastPointersInStack: function _getFirstLastPointersInStack(group) {
    var visible = void 0,
        visible2 = void 0;
    var first = void 0,
        last = void 0;

    if (group.values[0].values) {
      visible = group.values[0].values.filter(function (f) {
        return !f.hidden;
      });
      visible2 = group.values[group.values.length - 1].values.filter(function (f) {
        return !f.hidden;
      });
      first = visible[0];
      last = visible2[visible2.length - 1];
    } else {
      visible = group.values.filter(function (f) {
        return !f.hidden;
      });
      first = visible[0];
      last = visible[visible.length - 1];
    }

    if (!visible.length || visible2 && !visible2.length) utils.warn("mountain chart failed to generate shapes. check the incoming data");

    return {
      first: first,
      last: last
    };
  },
  _getVerticesOfaMergedShape: function _getVerticesOfaMergedShape(arg) {
    var _this = this;

    var first = arg.first.KEY();
    var last = arg.last.KEY();

    return _this.mesh.map(function (m, i) {
      var y = _this.cached[first][i].y0 + _this.cached[first][i].y - _this.cached[last][i].y0;
      var y0 = _this.cached[last][i].y0;
      return {
        x: m,
        y0: y0,
        y: y
      };
    });
  },
  _spawnMasks: function _spawnMasks() {
    var _this = this;

    var tailFatX = this._math.unscale(this.model.marker.axis_x.tailFatX);
    var tailCutX = this._math.unscale(this.model.marker.axis_x.tailCutX);
    var tailFade = this.model.marker.axis_x.tailFade;
    var k = 2 * Math.PI / (Math.log(tailFatX) - Math.log(tailCutX));
    var m = Math.PI - Math.log(tailFatX) * k;

    this.spawnMask = [];
    this.cosineShape = [];
    this.cosineArea = 0;

    this.mesh.forEach(function (dX, i) {
      _this.spawnMask[i] = dX < tailCutX ? 1 : dX > tailFade * 7 ? 0 : Math.exp((tailCutX - dX) / tailFade);
      _this.cosineShape[i] = dX > tailCutX && dX < tailFatX ? 1 + Math.cos(Math.log(dX) * k + m) : 0;
      _this.cosineArea += _this.cosineShape[i];
    });
  },
  _spawn: function _spawn(values, d) {
    var _this = this;

    var norm = values.axis_y[d.KEY()];
    var sigma = _this._math.giniToSigma(values.axis_s[d.KEY()]);
    var mu = _this._math.gdpToMu(values.axis_x[d.KEY()], sigma);

    if (!norm || !mu || !sigma) return [];

    var distribution = [];
    var acc = 0;

    this.mesh.forEach(function (dX, i) {
      distribution[i] = _this._math.pdf.lognormal(dX, mu, sigma);
      acc += _this.spawnMask[i] * distribution[i];
    });

    var result = this.mesh.map(function (dX, i) {
      return {
        x: dX,
        y0: 0,
        y: norm * (distribution[i] * (1 - _this.spawnMask[i]) + _this.cosineShape[i] / _this.cosineArea * acc)
      };
    });

    return result;
  },
  _adjustMaxY: function _adjustMaxY(options) {
    if (!options) options = {};
    var _this = this;
    var method = this.model.ui.chart.yMaxMethod;

    if (method !== "immediate" && !options.force) return;
    if (method === "latest") {
      var prevValues = _this.values;
      _this.model.marker.getFrame(_this.model.time.end, function (values) {
        if (!values) return;

        //below is a complicated issue when updatePointers() is first calculated for one set of values (at the end of time series), then yMax is taken from that data (assuming that population always grows, so the last year has the highest mountain)
        _this.values = values;
        _this.updatePointers();

        //after that updatePointers() is called with the actual data of the current time point
        _this.values = prevValues;
        _this.yScale.domain([0, Math.round(_this.yMax)]);
        _this.updatePointers();
        _this.redrawDataPoints();
      });
    } else {
      if (!_this.yMax) utils.warn("Setting yMax to " + _this.yMax + ". You failed again :-/");
      _this.yScale.domain([0, Math.round(_this.yMax)]);
    }
  },
  redrawDataPoints: function redrawDataPoints() {
    var _this = this;
    var mergeGrouped = this.model.marker.group.merge;
    var mergeStacked = this.model.marker.stack.merge;
    var stackMode = this.model.marker.stack.which;
    //it's important to know if the chart is dragging or playing at the moment.
    //because if that is the case, the mountain chart will merge the stacked entities to save performance
    var dragOrPlay = (this.model.time.dragging || this.model.time.playing) &&
    //never merge when no entities are stacked
    stackMode !== "none";

    this._adjustMaxY();

    this.mountainsMergeStacked.each(function (d) {
      var view = d3.select(this);
      var hidden = !mergeStacked;
      _this._renderShape(view, d.KEY(), hidden);
    });

    this.mountainsMergeGrouped.each(function (d) {
      var view = d3.select(this);
      var hidden = !mergeGrouped && !dragOrPlay || mergeStacked && !_this.model.marker.isSelected(d);
      _this._renderShape(view, d.KEY(), hidden);
    });

    this.mountainsAtomic.each(function (d, i) {
      var view = d3.select(this);
      var hidden = d.hidden || (mergeGrouped || mergeStacked || dragOrPlay) && !_this.model.marker.isSelected(d);
      _this._renderShape(view, d.KEY(), hidden);
    });

    if (stackMode === "none") {
      this.mountainsAtomic.sort(function (a, b) {
        return b.yMax - a.yMax;
      });
    } else if (stackMode === "all") {
      // do nothing if everything is stacked

    } else {
      if (mergeGrouped || dragOrPlay) {
        // this.mountainsMergeGrouped.sort(function (a, b) {
        //     return b.yMax - a.yMax;
        // });
      } else {
        this.mountainsAtomic.sort(function (a, b) {
          return b.yMaxGroup - a.yMaxGroup;
        });
      }
    }

    // exporting shapes for shape preloader. is needed once in a while
    // if (!this.shapes) this.shapes = {}
    // this.shapes[this.model.time.value.getUTCFullYear()] = {
    //     yMax: d3.format(".2e")(_this.yMax),
    //     shape: _this.cached["all"].map(function (d) {return d3.format(".2e")(d.y);})
    // }
  },
  redrawDataPointsOnlyColors: function redrawDataPointsOnlyColors() {
    var _this = this;
    if (!this.mountains) return utils.warn("redrawDataPointsOnlyColors(): no mountains  defined. likely a premature call, fix it!");
    var isColorUseIndicator = this.model.marker.color.use === "indicator";
    this.mountains.style("fill", function (d) {
      return _this.values.color[d.KEY()] ? isColorUseIndicator && _this.values.color[d.KEY()] == "_default" ? _this.model.marker.color.palette["_default"] : _this.cScale(_this.values.color[d.KEY()]) : COLOR_WHITEISH;
    });
  },
  _renderShape: function _renderShape(view, key, hidden) {
    var stack = this.model.marker.stack.which;
    var _this = this;

    view.classed("vzb-hidden", hidden);

    if (hidden) {
      if (stack !== "none") view.style("stroke-opacity", 0);
      return;
    }

    var filter = {};
    filter[this.KEY] = key;
    if (this.model.marker.isSelected(filter)) {
      view.attr("d", this.area(this.cached[key].filter(function (f) {
        return f.y > _this.values.axis_y[key] * THICKNESS_THRESHOLD;
      })));
    } else {
      view.attr("d", this.area(this.cached[key]));
    }

    //color use indicator suggests that this should be updated on every timeframe
    if (this.model.marker.color.use === "indicator") {
      view.style("fill", _this.values.color[key] ? _this.values.color[key] !== "_default" ? _this.cScale(_this.values.color[key]) : _this.model.marker.color.palette["_default"] : COLOR_WHITEISH);
    }

    if (stack !== "none") view.transition().duration(Math.random() * 900 + 100).ease(d3.easeCircle).style("stroke-opacity", 0.5);

    if (this.model.time.record) this._export.write({
      type: "path",
      id: key,
      time: this.model.time.value.getUTCFullYear(),
      fill: this.cScale(this.values.color[key]),
      d: this.area(this.cached[key])
    });
  },
  _setTooltip: function _setTooltip(tooltipText) {
    if (tooltipText) {
      var mouse = d3.mouse(this.graph.node()).map(function (d) {
        return parseInt(d);
      });

      //position tooltip
      this.tooltip.classed("vzb-hidden", false).attr("transform", "translate(" + mouse[0] + "," + mouse[1] + ")").selectAll("text").attr("text-anchor", "middle").attr("alignment-baseline", "middle").text(tooltipText);

      var contentBBox = this.tooltip.select("text").node().getBBox();

      this.tooltip.select("rect").attr("width", contentBBox.width + 8).attr("height", contentBBox.height + 8).attr("x", -contentBBox.width - 25).attr("y", -contentBBox.height - 25).attr("rx", contentBBox.height * 0.2).attr("ry", contentBBox.height * 0.2);

      this.tooltip.selectAll("text").attr("x", -contentBBox.width - 25 + (contentBBox.width + 8) / 2).attr("y", -contentBBox.height - 25 + (contentBBox.height + 11) / 2); // 11 is 8 for margin + 3 for strokes
      var translateX = mouse[0] - contentBBox.width - 25 > 0 ? mouse[0] : contentBBox.width + 25;
      var translateY = mouse[1] - contentBBox.height - 25 > 0 ? mouse[1] : contentBBox.height + 25;
      this.tooltip.attr("transform", "translate(" + translateX + "," + translateY + ")");
    } else {

      this.tooltip.classed("vzb-hidden", true);
    }
  },
  preload: function preload() {
    var shape_path = _globals2.default.ext_resources.shapePath ? _globals2.default.ext_resources.shapePath : _globals2.default.ext_resources.host + _globals2.default.ext_resources.preloadPath + "mc_precomputed_shapes.json";

    var _this = this;

    return new Promise(function (resolve, reject) {

      d3.json(shape_path, function (error, json) {
        if (error) return console.warn("Failed loading json " + shape_path + ". " + error);
        _this.precomputedShapes = json;
        resolve();
      });
    });
  }
});

exports.default = MountainChartComponent;

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _class = __webpack_require__(16);

var _class2 = _interopRequireDefault(_class);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var MCMath = _class2.default.extend({
  init: function init(context) {
    this.context = context;

    this.xScaleFactor = 1;
    this.xScaleShift = 0;
  },
  rescale: function rescale(x) {
    return Math.exp(this.xScaleFactor * Math.log(x) + this.xScaleShift);
  },
  unscale: function unscale(x) {
    return Math.exp((Math.log(x) - this.xScaleShift) / this.xScaleFactor);
  },
  generateMesh: function generateMesh(length, scaleType, domain) {
    // span a uniform mesh across the entire X scale
    // if the scale is log, the mesh would be exponentially distorted to look uniform

    var rangeFrom = scaleType === "linear" ? domain[0] : Math.log(this.unscale(domain[0]));

    var rangeTo = scaleType === "linear" ? domain[1] : Math.log(this.unscale(domain[1]));

    var rangeStep = (rangeTo - rangeFrom) / length;

    var mesh = d3.range(rangeFrom, rangeTo, rangeStep).concat(rangeTo);

    if (scaleType !== "linear") {
      mesh = mesh.map(function (dX) {
        return Math.exp(dX);
      });
    } else {
      mesh = mesh.filter(function (dX) {
        return dX > 0;
      });
    }

    return mesh;
  },
  gdpToMu: function gdpToMu(gdp, sigma, xScaleFactor, xScaleShift) {
    // converting gdp per capita per day into MU for lognormal distribution
    // see https://en.wikipedia.org/wiki/Log-normal_distribution
    return Math.log(gdp / 365) - sigma * sigma / 2;
  },
  giniToSigma: function giniToSigma(gini) {
    // The ginis are turned into std deviation.
    // Mattias uses this formula in Excel: stddev = NORMSINV( ((gini/100)+1)/2 )*2^0.5
    return this.normsinv((gini / 100 + 1) / 2) * Math.pow(2, 0.5);
  },


  // this function returns PDF values for a specified distribution
  pdf: {
    normal: function normal(x, mu, sigma) {
      return Math.exp(-0.5 * Math.log(2 * Math.PI) - Math.log(sigma) - Math.pow(x - mu, 2) / (2 * sigma * sigma));
    },
    lognormal: function lognormal(x, mu, sigma) {
      return Math.exp(-0.5 * Math.log(2 * Math.PI) //should not be different for the two scales- (scaleType=="linear"?Math.log(x):0)
      - Math.log(sigma) - Math.pow(Math.log(x) - mu, 2) / (2 * sigma * sigma));
    }
  },

  normsinv: function normsinv(p) {
    //
    // Lower tail quantile for standard normal distribution function.
    //
    // This function returns an approximation of the inverse cumulative
    // standard normal distribution function.  I.e., given P, it returns
    // an approximation to the X satisfying P = Pr{Z <= X} where Z is a
    // random variable from the standard normal distribution.
    //
    // The algorithm uses a minimax approximation by rational functions
    // and the result has a relative error whose absolute value is less
    // than 1.15e-9.
    //
    // Author:      Peter John Acklam
    // (Javascript version by Alankar Misra @ Digital Sutras (alankar@digitalsutras.com))
    // Time-stamp:  2003-05-05 05:15:14
    // E-mail:      pjacklam@online.no
    // WWW URL:     http://home.online.no/~pjacklam

    // Taken from http://home.online.no/~pjacklam/notes/invnorm/index.html
    // adapted from Java code

    // An algorithm with a relative error less than 1.15*10-9 in the entire region.

    // Coefficients in rational approximations
    var a = [-3.969683028665376e+01, 2.209460984245205e+02, -2.759285104469687e+02, 1.383577518672690e+02, -3.066479806614716e+01, 2.506628277459239e+00];
    var b = [-5.447609879822406e+01, 1.615858368580409e+02, -1.556989798598866e+02, 6.680131188771972e+01, -1.328068155288572e+01];
    var c = [-7.784894002430293e-03, -3.223964580411365e-01, -2.400758277161838e+00, -2.549732539343734e+00, 4.374664141464968e+00, 2.938163982698783e+00];
    var d = [7.784695709041462e-03, 3.224671290700398e-01, 2.445134137142996e+00, 3.754408661907416e+00];

    // Define break-points.
    var plow = 0.02425;
    var phigh = 1 - plow;

    // Rational approximation for lower region:
    if (p < plow) {
      var _q = Math.sqrt(-2 * Math.log(p));
      return (((((c[0] * _q + c[1]) * _q + c[2]) * _q + c[3]) * _q + c[4]) * _q + c[5]) / ((((d[0] * _q + d[1]) * _q + d[2]) * _q + d[3]) * _q + 1);
    }

    // Rational approximation for upper region:
    if (phigh < p) {
      var _q2 = Math.sqrt(-2 * Math.log(1 - p));
      return -(((((c[0] * _q2 + c[1]) * _q2 + c[2]) * _q2 + c[3]) * _q2 + c[4]) * _q2 + c[5]) / ((((d[0] * _q2 + d[1]) * _q2 + d[2]) * _q2 + d[3]) * _q2 + 1);
    }

    // Rational approximation for central region:
    var q = p - 0.5;
    var r = q * q;
    return (((((a[0] * r + a[1]) * r + a[2]) * r + a[3]) * r + a[4]) * r + a[5]) * q / (((((b[0] * r + b[1]) * r + b[2]) * r + b[3]) * r + b[4]) * r + 1);
  }
});

exports.default = MCMath;

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _class = __webpack_require__(16);

var _class2 = _interopRequireDefault(_class);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var MCProbe = _class2.default.extend({
  init: function init(context) {
    this.context = context;
  },
  redraw: function redraw(options) {
    var _this = this.context;
    if (!options) options = {};

    if (!options.level) options.level = _this.model.ui.chart.probeX;

    _this.probeEl.classed("vzb-hidden", !options.level || !_this.model.ui.chart.showProbeX);
    if (!options.level) return;

    _this.xAxisEl.call(_this.xAxis.highlightValue(options.full ? options.level : "none"));

    var sumValue = 0;
    var totalArea = 0;
    var leftArea = 0;

    var _computeAreas = function _computeAreas(d) {
      sumValue += _this.values.axis_y[d.KEY()];
      _this.cached[d.KEY()].forEach(function (d) {
        totalArea += d.y;
        if (_this._math.rescale(d.x) < options.level) leftArea += d.y;
      });
    };

    if (_this.model.marker.stack.which === "all") {
      _this.stackedPointers.forEach(_computeAreas);
    } else if (_this.model.marker.stack.which === "none") {
      _this.mountainPointers.forEach(_computeAreas);
    } else {
      _this.groupedPointers.forEach(_computeAreas);
    }

    var formatter1 = d3.format(".3r");
    var formatter2 = _this.model.marker.axis_y.getTickFormatter();
    _this.heightOfLabels = _this.heightOfLabels || 0.66 * _this.height;

    _this.probeTextEl.each(function (d, i) {
      if (i !== 8) return;
      var view = d3.select(this);

      if (!options.full && _this.model.ui.chart.probeX == _this.model.marker.axis_x.tailFatX) {

        view.text(_this.translator("mount/extremepoverty")).classed("vzb-hidden", false).attr("x", -_this.height).attr("y", _this.xScale(options.level)).attr("dy", "-1.15em").attr("dx", "0.5em").attr("transform", "rotate(-90)");

        _this.heightOfLabels = _this.height - view.node().getBBox().width - view.node().getBBox().height * 1.75;
      } else {
        view.classed("vzb-hidden", true);
      }
    });

    _this.probeTextEl.each(function (d, i) {
      if (i === 8) return;
      var view = d3.select(this);

      var string = void 0;
      if (i === 0 || i === 4) string = formatter1(leftArea / totalArea * 100) + "%";
      if (i === 1 || i === 5) string = formatter1(100 - leftArea / totalArea * 100) + "%";
      if (i === 2 || i === 6) string = formatter2(sumValue * leftArea / totalArea);
      if (i === 3 || i === 7) string = formatter2(sumValue * (1 - leftArea / totalArea)) + " " + _this.translator("mount/people");

      view.text(string).classed("vzb-hidden", !options.full && i !== 0 && i !== 4).attr("x", _this.xScale(options.level) + ([0, 4, 2, 6].indexOf(i) > -1 ? -6 : +5)).attr("y", _this.heightOfLabels).attr("dy", [0, 1, 4, 5].indexOf(i) > -1 ? 0 : "1.5em");
    });

    _this.probeLineEl.attr("x1", _this.xScale(options.level)).attr("x2", _this.xScale(options.level)).attr("y1", _this.height + 6).attr("y2", 0);
  }
});

exports.default = MCProbe;

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _class = __webpack_require__(16);

var _class2 = _interopRequireDefault(_class);

var _iconset = __webpack_require__(10);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var MCSelectList = _class2.default.extend({
  init: function init(context) {
    this.context = context;
  },
  rebuild: function rebuild(data) {
    var _this = this.context;
    var _local = this;

    var listData = _this.mountainPointers.concat(_this.groupedPointers).concat(_this.stackedPointers).filter(function (f) {
      return _this.model.marker.isSelected(f);
    }).sort(function (a, b) {
      if (a.sortValue && b.sortValue) {
        if (a.sortValue[1] === b.sortValue[1]) {
          return d3.descending(a.sortValue[0], b.sortValue[0]);
        }
        return d3.descending(a.sortValue[1], b.sortValue[1]);
      }

      if (a.aggrLevel != b.aggrLevel) {
        return d3.descending(a.aggrLevel, b.aggrLevel);
      } else if (a.aggrLevel && b.aggrLevel) {
        return d3.descending(a.yMax, b.yMax);
      }

      return 0;
    });
    _this.selectList = _this.mountainLabelContainer.selectAll("g.vzb-mc-label").data(utils.unique(listData, function (d) {
      return d.KEY();
    }));
    _this.selectList.exit().remove();
    _this.selectList = _this.selectList.enter().append("g").attr("class", "vzb-mc-label").each(function (d, i) {
      var label = d3.select(this);
      label.append("circle").attr("class", "vzb-mc-label-legend");
      label.append("text").attr("class", "vzb-mc-label-shadow vzb-mc-label-text");
      label.append("text").attr("class", "vzb-mc-label-text");
      label.append("g").attr("class", "vzb-mc-label-x vzb-label-shadow vzb-invisible").on("click", function (d, i) {
        if (utils.isTouchDevice()) return;
        d3.event.stopPropagation();
        _this.model.marker.clearHighlighted();
        _this.model.marker.selectMarker(d);
        d3.event.stopPropagation();
      }).onTap(function (d, i) {
        d3.select("#" + d.geo + "-label-" + _this._id).remove();
        _this.model.marker.clearHighlighted();
        _this.model.marker.selectMarker(d);
      });
      var labelCloseGroup = label.select("g.vzb-mc-label-x");
      if (!utils.isTouchDevice()) {
        utils.setIcon(labelCloseGroup, _iconset.close).select("svg").attr("class", "vzb-mc-label-x-icon").attr("width", "0px").attr("height", "0px");

        labelCloseGroup.insert("circle", "svg");
      } else {
        labelCloseGroup.append("rect");
        labelCloseGroup.append("text").attr("class", "vzb-mc-label-x-text").text("Deselect");
      }
    }).on("mousemove", function (d, i) {
      if (utils.isTouchDevice()) return;
      _local.showCloseCross(d, true);
      _this.model.marker.highlightMarker(d);
    }).on("mouseout", function (d, i) {
      if (utils.isTouchDevice()) return;
      _local.showCloseCross(d, false);
      _this.model.marker.clearHighlighted();
    }).on("click", function (d, i) {
      if (utils.isTouchDevice()) return;
      _this.model.marker.clearHighlighted();
      _this.model.marker.selectMarker(d);
    }).merge(_this.selectList);
  },
  redraw: function redraw() {
    var _this = this.context;
    if (!_this.selectList || !_this.someSelected) return;

    var sample = _this.mountainLabelContainer.append("g").attr("class", "vzb-mc-label").append("text").text("0");
    var fontHeight = sample.node().getBBox().height * 1.2;
    var fontSizeToFontHeight = parseFloat(sample.style("font-size")) / fontHeight;
    d3.select(sample.node().parentNode).remove();
    var formatter = _this.model.marker.axis_y.getTickFormatter();

    var titleHeight = _this.yTitleEl.select("text").node().getBBox().height || 0;

    var maxFontHeight = (_this.height - titleHeight * 3) / (_this.selectList.data().length + 2);
    if (fontHeight > maxFontHeight) fontHeight = maxFontHeight;

    var currentAggrLevel = "null";
    var aggrLevelSpacing = 0;

    var groupLabels = _this.model.marker.color.getColorlegendMarker().label.getItems();

    var isRTL = _this.model.locale.isRTL();

    _this.selectList.attr("transform", function (d, i) {
      if (d.aggrLevel != currentAggrLevel) aggrLevelSpacing += fontHeight;
      var spacing = fontHeight * i + titleHeight * 1.5 + aggrLevelSpacing;
      currentAggrLevel = d.aggrLevel;
      return "translate(" + (isRTL ? _this.width : 0) + "," + spacing + ")";
    }).each(function (d, i) {

      var view = d3.select(this).attr("id", d.geo + "-label-" + _this._id);
      var name = "";
      if (d.key) {
        name = d.key === "all" ? _this.translator("mount/merging/world") : groupLabels[d.key];
      } else {
        name = _this.values.label[d.KEY()];
      }

      var number = _this.values.axis_y[d.KEY()];

      var string = name + ": " + formatter(number) + (i === 0 ? " " + _this.translator("mount/people") : "");

      var text = view.selectAll(".vzb-mc-label-text").attr("x", (isRTL ? -1 : 1) * fontHeight).attr("y", fontHeight).text(string).style("font-size", fontHeight === maxFontHeight ? fontHeight * fontSizeToFontHeight + "px" : null);

      var contentBBox = text.node().getBBox();

      var closeGroup = view.select(".vzb-mc-label-x");

      if (utils.isTouchDevice()) {
        var closeTextBBox = closeGroup.select("text").node().getBBox();
        closeGroup.classed("vzb-revert-color", true).select(".vzb-mc-label-x-text").classed("vzb-revert-color", true).attr("x", contentBBox.width + contentBBox.height * 1.12 + closeTextBBox.width * 0.5).attr("y", contentBBox.height * 0.55);

        closeGroup.select("rect").attr("width", closeTextBBox.width + contentBBox.height * 0.6).attr("height", contentBBox.height).attr("x", contentBBox.width + contentBBox.height * 0.9).attr("y", 0).attr("rx", contentBBox.height * 0.25).attr("ry", contentBBox.height * 0.25);
      } else {
        closeGroup.attr("x", contentBBox.width + contentBBox.height * 1.1).attr("y", contentBBox.height / 3);

        closeGroup.select("circle").attr("r", contentBBox.height * 0.4).attr("cx", (isRTL ? -1 : 1) * (contentBBox.width + contentBBox.height * 1.1)).attr("cy", contentBBox.height / 3);

        closeGroup.select("svg").attr("x", (isRTL ? -1 : 1) * (contentBBox.width + contentBBox.height * (1.1 - (isRTL ? -0.4 : 0.4)))).attr("y", contentBBox.height * (1 / 3 - 0.4)).attr("width", contentBBox.height * 0.8).attr("height", contentBBox.height * 0.8);
      }

      view.select(".vzb-mc-label-legend").attr("r", fontHeight / 3).attr("cx", (isRTL ? -1 : 1) * fontHeight * 0.4).attr("cy", fontHeight / 1.5).style("fill", _this.cScale(_this.values.color[d.KEY()]));

      view.onTap(function (d, i) {
        d3.event.stopPropagation();
        _this.model.marker.highlightMarker(d);
        setTimeout(function () {
          _this.model.marker.unhighlightMarker(d);
        }, 2000);
      });
    });
  },
  showCloseCross: function showCloseCross(d, show) {
    var _this = this.context;
    var KEY = _this.KEY;
    //show the little cross on the selected label
    _this.selectList.filter(function (f) {
      return f[KEY] == d[KEY];
    }).select(".vzb-mc-label-x").classed("vzb-invisible", !show);
  }
});

exports.default = MCSelectList;

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(233)
var ieee754 = __webpack_require__(467)
var isArray = __webpack_require__(468)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(85)))

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, j, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr(len * 3 / 4 - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(243);
module.exports = __webpack_require__(36).RegExp.escape;

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(6)
  , isArray  = __webpack_require__(99)
  , SPECIES  = __webpack_require__(7)('species');

module.exports = function(original){
  var C;
  if(isArray(original)){
    C = original.constructor;
    // cross-realm fallback
    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
    if(isObject(C)){
      C = C[SPECIES];
      if(C === null)C = undefined;
    }
  } return C === undefined ? Array : C;
};

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(235);

module.exports = function(original, length){
  return new (speciesConstructor(original))(length);
};

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var anObject    = __webpack_require__(3)
  , toPrimitive = __webpack_require__(33)
  , NUMBER      = 'number';

module.exports = function(hint){
  if(hint !== 'string' && hint !== NUMBER && hint !== 'default')throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(54)
  , gOPS    = __webpack_require__(82)
  , pIE     = __webpack_require__(70);
module.exports = function(it){
  var result     = getKeys(it)
    , getSymbols = gOPS.f;
  if(getSymbols){
    var symbols = getSymbols(it)
      , isEnum  = pIE.f
      , i       = 0
      , key;
    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
  } return result;
};

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

var getKeys   = __webpack_require__(54)
  , toIObject = __webpack_require__(21);
module.exports = function(object, el){
  var O      = toIObject(object)
    , keys   = getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var path      = __webpack_require__(241)
  , invoke    = __webpack_require__(78)
  , aFunction = __webpack_require__(17);
module.exports = function(/* ...pargs */){
  var fn     = aFunction(this)
    , length = arguments.length
    , pargs  = Array(length)
    , i      = 0
    , _      = path._
    , holder = false;
  while(length > i)if((pargs[i] = arguments[i++]) === _)holder = true;
  return function(/* ...args */){
    var that = this
      , aLen = arguments.length
      , j = 0, k = 0, args;
    if(!holder && !aLen)return invoke(fn, pargs, that);
    args = pargs.slice();
    if(holder)for(;length > j; j++)if(args[j] === _)args[j] = arguments[k++];
    while(aLen > k)args.push(arguments[k++]);
    return invoke(fn, args, that);
  };
};

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(4);

/***/ }),
/* 242 */
/***/ (function(module, exports) {

module.exports = function(regExp, replace){
  var replacer = replace === Object(replace) ? function(part){
    return replace[part];
  } : replace;
  return function(it){
    return String(it).replace(regExp, replacer);
  };
};

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/benjamingr/RexExp.escape
var $export = __webpack_require__(0)
  , $re     = __webpack_require__(242)(/[\\^$*+?.()|[\]{}]/g, '\\$&');

$export($export.S, 'RegExp', {escape: function escape(it){ return $re(it); }});


/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = __webpack_require__(0);

$export($export.P, 'Array', {copyWithin: __webpack_require__(154)});

__webpack_require__(62)('copyWithin');

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0)
  , $every  = __webpack_require__(31)(4);

$export($export.P + $export.F * !__webpack_require__(30)([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn /* , thisArg */){
    return $every(this, callbackfn, arguments[1]);
  }
});

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = __webpack_require__(0);

$export($export.P, 'Array', {fill: __webpack_require__(91)});

__webpack_require__(62)('fill');

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0)
  , $filter = __webpack_require__(31)(2);

$export($export.P + $export.F * !__webpack_require__(30)([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */){
    return $filter(this, callbackfn, arguments[1]);
  }
});

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = __webpack_require__(0)
  , $find   = __webpack_require__(31)(6)
  , KEY     = 'findIndex'
  , forced  = true;
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(62)(KEY);

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = __webpack_require__(0)
  , $find   = __webpack_require__(31)(5)
  , KEY     = 'find'
  , forced  = true;
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(62)(KEY);

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export  = __webpack_require__(0)
  , $forEach = __webpack_require__(31)(0)
  , STRICT   = __webpack_require__(30)([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */){
    return $forEach(this, callbackfn, arguments[1]);
  }
});

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ctx            = __webpack_require__(37)
  , $export        = __webpack_require__(0)
  , toObject       = __webpack_require__(13)
  , call           = __webpack_require__(163)
  , isArrayIter    = __webpack_require__(98)
  , toLength       = __webpack_require__(12)
  , createProperty = __webpack_require__(92)
  , getIterFn      = __webpack_require__(115);

$export($export.S + $export.F * !__webpack_require__(80)(function(iter){ Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
    var O       = toObject(arrayLike)
      , C       = typeof this == 'function' ? this : Array
      , aLen    = arguments.length
      , mapfn   = aLen > 1 ? arguments[1] : undefined
      , mapping = mapfn !== undefined
      , index   = 0
      , iterFn  = getIterFn(O)
      , length, result, step, iterator;
    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for(result = new C(length); length > index; index++){
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export       = __webpack_require__(0)
  , $indexOf      = __webpack_require__(74)(false)
  , $native       = [].indexOf
  , NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(30)($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /*, fromIndex = 0 */){
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = __webpack_require__(0);

$export($export.S, 'Array', {isArray: __webpack_require__(99)});

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.13 Array.prototype.join(separator)
var $export   = __webpack_require__(0)
  , toIObject = __webpack_require__(21)
  , arrayJoin = [].join;

// fallback for not array-like strings
$export($export.P + $export.F * (__webpack_require__(69) != Object || !__webpack_require__(30)(arrayJoin)), 'Array', {
  join: function join(separator){
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export       = __webpack_require__(0)
  , toIObject     = __webpack_require__(21)
  , toInteger     = __webpack_require__(45)
  , toLength      = __webpack_require__(12)
  , $native       = [].lastIndexOf
  , NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(30)($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement /*, fromIndex = @[*-1] */){
    // convert -0 to +0
    if(NEGATIVE_ZERO)return $native.apply(this, arguments) || 0;
    var O      = toIObject(this)
      , length = toLength(O.length)
      , index  = length - 1;
    if(arguments.length > 1)index = Math.min(index, toInteger(arguments[1]));
    if(index < 0)index = length + index;
    for(;index >= 0; index--)if(index in O)if(O[index] === searchElement)return index || 0;
    return -1;
  }
});

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0)
  , $map    = __webpack_require__(31)(1);

$export($export.P + $export.F * !__webpack_require__(30)([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */){
    return $map(this, callbackfn, arguments[1]);
  }
});

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export        = __webpack_require__(0)
  , createProperty = __webpack_require__(92);

// WebKit Array.of isn't generic
$export($export.S + $export.F * __webpack_require__(5)(function(){
  function F(){}
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */){
    var index  = 0
      , aLen   = arguments.length
      , result = new (typeof this == 'function' ? this : Array)(aLen);
    while(aLen > index)createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0)
  , $reduce = __webpack_require__(156);

$export($export.P + $export.F * !__webpack_require__(30)([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn /* , initialValue */){
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0)
  , $reduce = __webpack_require__(156);

$export($export.P + $export.F * !__webpack_require__(30)([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */){
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export    = __webpack_require__(0)
  , html       = __webpack_require__(96)
  , cof        = __webpack_require__(28)
  , toIndex    = __webpack_require__(57)
  , toLength   = __webpack_require__(12)
  , arraySlice = [].slice;

// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * __webpack_require__(5)(function(){
  if(html)arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end){
    var len   = toLength(this.length)
      , klass = cof(this);
    end = end === undefined ? len : end;
    if(klass == 'Array')return arraySlice.call(this, begin, end);
    var start  = toIndex(begin, len)
      , upTo   = toIndex(end, len)
      , size   = toLength(upTo - start)
      , cloned = Array(size)
      , i      = 0;
    for(; i < size; i++)cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0)
  , $some   = __webpack_require__(31)(3);

$export($export.P + $export.F * !__webpack_require__(30)([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */){
    return $some(this, callbackfn, arguments[1]);
  }
});

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export   = __webpack_require__(0)
  , aFunction = __webpack_require__(17)
  , toObject  = __webpack_require__(13)
  , fails     = __webpack_require__(5)
  , $sort     = [].sort
  , test      = [1, 2, 3];

$export($export.P + $export.F * (fails(function(){
  // IE8-
  test.sort(undefined);
}) || !fails(function(){
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !__webpack_require__(30)($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn){
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(56)('Array');

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = __webpack_require__(0);

$export($export.S, 'Date', {now: function(){ return new Date().getTime(); }});

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = __webpack_require__(0)
  , fails   = __webpack_require__(5)
  , getTime = Date.prototype.getTime;

var lz = function(num){
  return num > 9 ? num : '0' + num;
};

// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (fails(function(){
  return new Date(-5e13 - 1).toISOString() != '0385-07-25T07:06:39.999Z';
}) || !fails(function(){
  new Date(NaN).toISOString();
})), 'Date', {
  toISOString: function toISOString(){
    if(!isFinite(getTime.call(this)))throw RangeError('Invalid time value');
    var d = this
      , y = d.getUTCFullYear()
      , m = d.getUTCMilliseconds()
      , s = y < 0 ? '-' : y > 9999 ? '+' : '';
    return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
      '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
      'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
      ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
  }
});

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export     = __webpack_require__(0)
  , toObject    = __webpack_require__(13)
  , toPrimitive = __webpack_require__(33);

$export($export.P + $export.F * __webpack_require__(5)(function(){
  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({toISOString: function(){ return 1; }}) !== 1;
}), 'Date', {
  toJSON: function toJSON(key){
    var O  = toObject(this)
      , pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

var TO_PRIMITIVE = __webpack_require__(7)('toPrimitive')
  , proto        = Date.prototype;

if(!(TO_PRIMITIVE in proto))__webpack_require__(18)(proto, TO_PRIMITIVE, __webpack_require__(237));

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

var DateProto    = Date.prototype
  , INVALID_DATE = 'Invalid Date'
  , TO_STRING    = 'toString'
  , $toString    = DateProto[TO_STRING]
  , getTime      = DateProto.getTime;
if(new Date(NaN) + '' != INVALID_DATE){
  __webpack_require__(19)(DateProto, TO_STRING, function toString(){
    var value = getTime.call(this);
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = __webpack_require__(0);

$export($export.P, 'Function', {bind: __webpack_require__(157)});

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isObject       = __webpack_require__(6)
  , getPrototypeOf = __webpack_require__(25)
  , HAS_INSTANCE   = __webpack_require__(7)('hasInstance')
  , FunctionProto  = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if(!(HAS_INSTANCE in FunctionProto))__webpack_require__(9).f(FunctionProto, HAS_INSTANCE, {value: function(O){
  if(typeof this != 'function' || !isObject(O))return false;
  if(!isObject(this.prototype))return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while(O = getPrototypeOf(O))if(this.prototype === O)return true;
  return false;
}});

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

var dP         = __webpack_require__(9).f
  , createDesc = __webpack_require__(44)
  , has        = __webpack_require__(14)
  , FProto     = Function.prototype
  , nameRE     = /^\s*function ([^ (]*)/
  , NAME       = 'name';

var isExtensible = Object.isExtensible || function(){
  return true;
};

// 19.2.4.2 name
NAME in FProto || __webpack_require__(8) && dP(FProto, NAME, {
  configurable: true,
  get: function(){
    try {
      var that = this
        , name = ('' + that).match(nameRE)[1];
      has(that, NAME) || !isExtensible(that) || dP(that, NAME, createDesc(5, name));
      return name;
    } catch(e){
      return '';
    }
  }
});

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.3 Math.acosh(x)
var $export = __webpack_require__(0)
  , log1p   = __webpack_require__(165)
  , sqrt    = Math.sqrt
  , $acosh  = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN 
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x){
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});

/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.5 Math.asinh(x)
var $export = __webpack_require__(0)
  , $asinh  = Math.asinh;

function asinh(x){
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0 
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {asinh: asinh});

/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.7 Math.atanh(x)
var $export = __webpack_require__(0)
  , $atanh  = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0 
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x){
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.9 Math.cbrt(x)
var $export = __webpack_require__(0)
  , sign    = __webpack_require__(103);

$export($export.S, 'Math', {
  cbrt: function cbrt(x){
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});

/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.11 Math.clz32(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  clz32: function clz32(x){
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});

/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.12 Math.cosh(x)
var $export = __webpack_require__(0)
  , exp     = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x){
    return (exp(x = +x) + exp(-x)) / 2;
  }
});

/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.14 Math.expm1(x)
var $export = __webpack_require__(0)
  , $expm1  = __webpack_require__(102);

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', {expm1: $expm1});

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var $export   = __webpack_require__(0)
  , sign      = __webpack_require__(103)
  , pow       = Math.pow
  , EPSILON   = pow(2, -52)
  , EPSILON32 = pow(2, -23)
  , MAX32     = pow(2, 127) * (2 - EPSILON32)
  , MIN32     = pow(2, -126);

var roundTiesToEven = function(n){
  return n + 1 / EPSILON - 1 / EPSILON;
};


$export($export.S, 'Math', {
  fround: function fround(x){
    var $abs  = Math.abs(x)
      , $sign = sign(x)
      , a, result;
    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
    a = (1 + EPSILON32 / EPSILON) * $abs;
    result = a - (a - $abs);
    if(result > MAX32 || result != result)return $sign * Infinity;
    return $sign * result;
  }
});

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
var $export = __webpack_require__(0)
  , abs     = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2){ // eslint-disable-line no-unused-vars
    var sum  = 0
      , i    = 0
      , aLen = arguments.length
      , larg = 0
      , arg, div;
    while(i < aLen){
      arg = abs(arguments[i++]);
      if(larg < arg){
        div  = larg / arg;
        sum  = sum * div * div + 1;
        larg = arg;
      } else if(arg > 0){
        div  = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.18 Math.imul(x, y)
var $export = __webpack_require__(0)
  , $imul   = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * __webpack_require__(5)(function(){
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y){
    var UINT16 = 0xffff
      , xn = +x
      , yn = +y
      , xl = UINT16 & xn
      , yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});

/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.21 Math.log10(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  log10: function log10(x){
    return Math.log(x) / Math.LN10;
  }
});

/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.20 Math.log1p(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {log1p: __webpack_require__(165)});

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.22 Math.log2(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  log2: function log2(x){
    return Math.log(x) / Math.LN2;
  }
});

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.28 Math.sign(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {sign: __webpack_require__(103)});

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.30 Math.sinh(x)
var $export = __webpack_require__(0)
  , expm1   = __webpack_require__(102)
  , exp     = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * __webpack_require__(5)(function(){
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x){
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});

/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.33 Math.tanh(x)
var $export = __webpack_require__(0)
  , expm1   = __webpack_require__(102)
  , exp     = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x){
    var a = expm1(x = +x)
      , b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});

/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.34 Math.trunc(x)
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  trunc: function trunc(it){
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});

/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global            = __webpack_require__(4)
  , has               = __webpack_require__(14)
  , cof               = __webpack_require__(28)
  , inheritIfRequired = __webpack_require__(97)
  , toPrimitive       = __webpack_require__(33)
  , fails             = __webpack_require__(5)
  , gOPN              = __webpack_require__(53).f
  , gOPD              = __webpack_require__(24).f
  , dP                = __webpack_require__(9).f
  , $trim             = __webpack_require__(66).trim
  , NUMBER            = 'Number'
  , $Number           = global[NUMBER]
  , Base              = $Number
  , proto             = $Number.prototype
  // Opera ~12 has broken Object#toString
  , BROKEN_COF        = cof(__webpack_require__(52)(proto)) == NUMBER
  , TRIM              = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function(argument){
  var it = toPrimitive(argument, false);
  if(typeof it == 'string' && it.length > 2){
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0)
      , third, radix, maxCode;
    if(first === 43 || first === 45){
      third = it.charCodeAt(2);
      if(third === 88 || third === 120)return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if(first === 48){
      switch(it.charCodeAt(1)){
        case 66 : case 98  : radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79 : case 111 : radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default : return +it;
      }
      for(var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++){
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if(code < 48 || code > maxCode)return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if(!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')){
  $Number = function Number(value){
    var it = arguments.length < 1 ? 0 : value
      , that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function(){ proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for(var keys = __webpack_require__(8) ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++){
    if(has(Base, key = keys[j]) && !has($Number, key)){
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  __webpack_require__(19)(global, NUMBER, $Number);
}

/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.1 Number.EPSILON
var $export = __webpack_require__(0);

$export($export.S, 'Number', {EPSILON: Math.pow(2, -52)});

/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.2 Number.isFinite(number)
var $export   = __webpack_require__(0)
  , _isFinite = __webpack_require__(4).isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it){
    return typeof it == 'number' && _isFinite(it);
  }
});

/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var $export = __webpack_require__(0);

$export($export.S, 'Number', {isInteger: __webpack_require__(162)});

/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.4 Number.isNaN(number)
var $export = __webpack_require__(0);

$export($export.S, 'Number', {
  isNaN: function isNaN(number){
    return number != number;
  }
});

/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.5 Number.isSafeInteger(number)
var $export   = __webpack_require__(0)
  , isInteger = __webpack_require__(162)
  , abs       = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number){
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});

/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = __webpack_require__(0);

$export($export.S, 'Number', {MAX_SAFE_INTEGER: 0x1fffffffffffff});

/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = __webpack_require__(0);

$export($export.S, 'Number', {MIN_SAFE_INTEGER: -0x1fffffffffffff});

/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

var $export     = __webpack_require__(0)
  , $parseFloat = __webpack_require__(172);
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', {parseFloat: $parseFloat});

/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

var $export   = __webpack_require__(0)
  , $parseInt = __webpack_require__(173);
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', {parseInt: $parseInt});

/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export      = __webpack_require__(0)
  , toInteger    = __webpack_require__(45)
  , aNumberValue = __webpack_require__(153)
  , repeat       = __webpack_require__(110)
  , $toFixed     = 1..toFixed
  , floor        = Math.floor
  , data         = [0, 0, 0, 0, 0, 0]
  , ERROR        = 'Number.toFixed: incorrect invocation!'
  , ZERO         = '0';

var multiply = function(n, c){
  var i  = -1
    , c2 = c;
  while(++i < 6){
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};
var divide = function(n){
  var i = 6
    , c = 0;
  while(--i >= 0){
    c += data[i];
    data[i] = floor(c / n);
    c = (c % n) * 1e7;
  }
};
var numToString = function(){
  var i = 6
    , s = '';
  while(--i >= 0){
    if(s !== '' || i === 0 || data[i] !== 0){
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  } return s;
};
var pow = function(x, n, acc){
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function(x){
  var n  = 0
    , x2 = x;
  while(x2 >= 4096){
    n += 12;
    x2 /= 4096;
  }
  while(x2 >= 2){
    n  += 1;
    x2 /= 2;
  } return n;
};

$export($export.P + $export.F * (!!$toFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128..toFixed(0) !== '1000000000000000128'
) || !__webpack_require__(5)(function(){
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits){
    var x = aNumberValue(this, ERROR)
      , f = toInteger(fractionDigits)
      , s = ''
      , m = ZERO
      , e, z, j, k;
    if(f < 0 || f > 20)throw RangeError(ERROR);
    if(x != x)return 'NaN';
    if(x <= -1e21 || x >= 1e21)return String(x);
    if(x < 0){
      s = '-';
      x = -x;
    }
    if(x > 1e-21){
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if(e > 0){
        multiply(0, z);
        j = f;
        while(j >= 7){
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while(j >= 23){
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }
    if(f > 0){
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    } return m;
  }
});

/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export      = __webpack_require__(0)
  , $fails       = __webpack_require__(5)
  , aNumberValue = __webpack_require__(153)
  , $toPrecision = 1..toPrecision;

$export($export.P + $export.F * ($fails(function(){
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function(){
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision){
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision); 
  }
});

/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(0);

$export($export.S + $export.F, 'Object', {assign: __webpack_require__(166)});

/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0)
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', {create: __webpack_require__(52)});

/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !__webpack_require__(8), 'Object', {defineProperties: __webpack_require__(167)});

/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(8), 'Object', {defineProperty: __webpack_require__(9).f});

/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.5 Object.freeze(O)
var isObject = __webpack_require__(6)
  , meta     = __webpack_require__(43).onFreeze;

__webpack_require__(32)('freeze', function($freeze){
  return function freeze(it){
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});

/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject                 = __webpack_require__(21)
  , $getOwnPropertyDescriptor = __webpack_require__(24).f;

__webpack_require__(32)('getOwnPropertyDescriptor', function(){
  return function getOwnPropertyDescriptor(it, key){
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 Object.getOwnPropertyNames(O)
__webpack_require__(32)('getOwnPropertyNames', function(){
  return __webpack_require__(168).f;
});

/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject        = __webpack_require__(13)
  , $getPrototypeOf = __webpack_require__(25);

__webpack_require__(32)('getPrototypeOf', function(){
  return function getPrototypeOf(it){
    return $getPrototypeOf(toObject(it));
  };
});

/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.11 Object.isExtensible(O)
var isObject = __webpack_require__(6);

__webpack_require__(32)('isExtensible', function($isExtensible){
  return function isExtensible(it){
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});

/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.12 Object.isFrozen(O)
var isObject = __webpack_require__(6);

__webpack_require__(32)('isFrozen', function($isFrozen){
  return function isFrozen(it){
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});

/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.13 Object.isSealed(O)
var isObject = __webpack_require__(6);

__webpack_require__(32)('isSealed', function($isSealed){
  return function isSealed(it){
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});

/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.10 Object.is(value1, value2)
var $export = __webpack_require__(0);
$export($export.S, 'Object', {is: __webpack_require__(174)});

/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(13)
  , $keys    = __webpack_require__(54);

__webpack_require__(32)('keys', function(){
  return function keys(it){
    return $keys(toObject(it));
  };
});

/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.15 Object.preventExtensions(O)
var isObject = __webpack_require__(6)
  , meta     = __webpack_require__(43).onFreeze;

__webpack_require__(32)('preventExtensions', function($preventExtensions){
  return function preventExtensions(it){
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});

/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.17 Object.seal(O)
var isObject = __webpack_require__(6)
  , meta     = __webpack_require__(43).onFreeze;

__webpack_require__(32)('seal', function($seal){
  return function seal(it){
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});

/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(0);
$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(105).set});

/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.3.6 Object.prototype.toString()
var classof = __webpack_require__(68)
  , test    = {};
test[__webpack_require__(7)('toStringTag')] = 'z';
if(test + '' != '[object z]'){
  __webpack_require__(19)(Object.prototype, 'toString', function toString(){
    return '[object ' + classof(this) + ']';
  }, true);
}

/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

var $export     = __webpack_require__(0)
  , $parseFloat = __webpack_require__(172);
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), {parseFloat: $parseFloat});

/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

var $export   = __webpack_require__(0)
  , $parseInt = __webpack_require__(173);
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), {parseInt: $parseInt});

/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY            = __webpack_require__(51)
  , global             = __webpack_require__(4)
  , ctx                = __webpack_require__(37)
  , classof            = __webpack_require__(68)
  , $export            = __webpack_require__(0)
  , isObject           = __webpack_require__(6)
  , aFunction          = __webpack_require__(17)
  , anInstance         = __webpack_require__(50)
  , forOf              = __webpack_require__(63)
  , speciesConstructor = __webpack_require__(107)
  , task               = __webpack_require__(112).set
  , microtask          = __webpack_require__(104)()
  , PROMISE            = 'Promise'
  , TypeError          = global.TypeError
  , process            = global.process
  , $Promise           = global[PROMISE]
  , process            = global.process
  , isNode             = classof(process) == 'process'
  , empty              = function(){ /* empty */ }
  , Internal, GenericPromiseCapability, Wrapper;

var USE_NATIVE = !!function(){
  try {
    // correct subclassing with @@species support
    var promise     = $Promise.resolve(1)
      , FakePromise = (promise.constructor = {})[__webpack_require__(7)('species')] = function(exec){ exec(empty, empty); };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch(e){ /* empty */ }
}();

// helpers
var sameConstructor = function(a, b){
  // with library wrapper special case
  return a === b || a === $Promise && b === Wrapper;
};
var isThenable = function(it){
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var newPromiseCapability = function(C){
  return sameConstructor($Promise, C)
    ? new PromiseCapability(C)
    : new GenericPromiseCapability(C);
};
var PromiseCapability = GenericPromiseCapability = function(C){
  var resolve, reject;
  this.promise = new C(function($$resolve, $$reject){
    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject  = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject  = aFunction(reject);
};
var perform = function(exec){
  try {
    exec();
  } catch(e){
    return {error: e};
  }
};
var notify = function(promise, isReject){
  if(promise._n)return;
  promise._n = true;
  var chain = promise._c;
  microtask(function(){
    var value = promise._v
      , ok    = promise._s == 1
      , i     = 0;
    var run = function(reaction){
      var handler = ok ? reaction.ok : reaction.fail
        , resolve = reaction.resolve
        , reject  = reaction.reject
        , domain  = reaction.domain
        , result, then;
      try {
        if(handler){
          if(!ok){
            if(promise._h == 2)onHandleUnhandled(promise);
            promise._h = 1;
          }
          if(handler === true)result = value;
          else {
            if(domain)domain.enter();
            result = handler(value);
            if(domain)domain.exit();
          }
          if(result === reaction.promise){
            reject(TypeError('Promise-chain cycle'));
          } else if(then = isThenable(result)){
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch(e){
        reject(e);
      }
    };
    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if(isReject && !promise._h)onUnhandled(promise);
  });
};
var onUnhandled = function(promise){
  task.call(global, function(){
    var value = promise._v
      , abrupt, handler, console;
    if(isUnhandled(promise)){
      abrupt = perform(function(){
        if(isNode){
          process.emit('unhandledRejection', value, promise);
        } else if(handler = global.onunhandledrejection){
          handler({promise: promise, reason: value});
        } else if((console = global.console) && console.error){
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if(abrupt)throw abrupt.error;
  });
};
var isUnhandled = function(promise){
  if(promise._h == 1)return false;
  var chain = promise._a || promise._c
    , i     = 0
    , reaction;
  while(chain.length > i){
    reaction = chain[i++];
    if(reaction.fail || !isUnhandled(reaction.promise))return false;
  } return true;
};
var onHandleUnhandled = function(promise){
  task.call(global, function(){
    var handler;
    if(isNode){
      process.emit('rejectionHandled', promise);
    } else if(handler = global.onrejectionhandled){
      handler({promise: promise, reason: promise._v});
    }
  });
};
var $reject = function(value){
  var promise = this;
  if(promise._d)return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if(!promise._a)promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function(value){
  var promise = this
    , then;
  if(promise._d)return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if(promise === value)throw TypeError("Promise can't be resolved itself");
    if(then = isThenable(value)){
      microtask(function(){
        var wrapper = {_w: promise, _d: false}; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch(e){
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch(e){
    $reject.call({_w: promise, _d: false}, e); // wrap
  }
};

// constructor polyfill
if(!USE_NATIVE){
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor){
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch(err){
      $reject.call(this, err);
    }
  };
  Internal = function Promise(executor){
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(55)($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected){
      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail   = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if(this._a)this._a.push(reaction);
      if(this._s)notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function(onRejected){
      return this.then(undefined, onRejected);
    }
  });
  PromiseCapability = function(){
    var promise  = new Internal;
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject  = ctx($reject, promise, 1);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
__webpack_require__(65)($Promise, PROMISE);
__webpack_require__(56)(PROMISE);
Wrapper = __webpack_require__(36)[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r){
    var capability = newPromiseCapability(this)
      , $$reject   = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x){
    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
    var capability = newPromiseCapability(this)
      , $$resolve  = capability.resolve;
    $$resolve(x);
    return capability.promise;
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(80)(function(iter){
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable){
    var C          = this
      , capability = newPromiseCapability(C)
      , resolve    = capability.resolve
      , reject     = capability.reject;
    var abrupt = perform(function(){
      var values    = []
        , index     = 0
        , remaining = 1;
      forOf(iterable, false, function(promise){
        var $index        = index++
          , alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function(value){
          if(alreadyCalled)return;
          alreadyCalled  = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if(abrupt)reject(abrupt.error);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable){
    var C          = this
      , capability = newPromiseCapability(C)
      , reject     = capability.reject;
    var abrupt = perform(function(){
      forOf(iterable, false, function(promise){
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if(abrupt)reject(abrupt.error);
    return capability.promise;
  }
});

/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export   = __webpack_require__(0)
  , aFunction = __webpack_require__(17)
  , anObject  = __webpack_require__(3)
  , rApply    = (__webpack_require__(4).Reflect || {}).apply
  , fApply    = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !__webpack_require__(5)(function(){
  rApply(function(){});
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList){
    var T = aFunction(target)
      , L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});

/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export    = __webpack_require__(0)
  , create     = __webpack_require__(52)
  , aFunction  = __webpack_require__(17)
  , anObject   = __webpack_require__(3)
  , isObject   = __webpack_require__(6)
  , fails      = __webpack_require__(5)
  , bind       = __webpack_require__(157)
  , rConstruct = (__webpack_require__(4).Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function(){
  function F(){}
  return !(rConstruct(function(){}, [], F) instanceof F);
});
var ARGS_BUG = !fails(function(){
  rConstruct(function(){});
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /*, newTarget*/){
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if(ARGS_BUG && !NEW_TARGET_BUG)return rConstruct(Target, args, newTarget);
    if(Target == newTarget){
      // w/o altered newTarget, optimization for 0-4 arguments
      switch(args.length){
        case 0: return new Target;
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args));
    }
    // with altered newTarget, not support built-in constructors
    var proto    = newTarget.prototype
      , instance = create(isObject(proto) ? proto : Object.prototype)
      , result   = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP          = __webpack_require__(9)
  , $export     = __webpack_require__(0)
  , anObject    = __webpack_require__(3)
  , toPrimitive = __webpack_require__(33);

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * __webpack_require__(5)(function(){
  Reflect.defineProperty(dP.f({}, 1, {value: 1}), 1, {value: 2});
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes){
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch(e){
      return false;
    }
  }
});

/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export  = __webpack_require__(0)
  , gOPD     = __webpack_require__(24).f
  , anObject = __webpack_require__(3);

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey){
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});

/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 26.1.5 Reflect.enumerate(target)
var $export  = __webpack_require__(0)
  , anObject = __webpack_require__(3);
var Enumerate = function(iterated){
  this._t = anObject(iterated); // target
  this._i = 0;                  // next index
  var keys = this._k = []       // keys
    , key;
  for(key in iterated)keys.push(key);
};
__webpack_require__(100)(Enumerate, 'Object', function(){
  var that = this
    , keys = that._k
    , key;
  do {
    if(that._i >= keys.length)return {value: undefined, done: true};
  } while(!((key = keys[that._i++]) in that._t));
  return {value: key, done: false};
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target){
    return new Enumerate(target);
  }
});

/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD     = __webpack_require__(24)
  , $export  = __webpack_require__(0)
  , anObject = __webpack_require__(3);

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey){
    return gOPD.f(anObject(target), propertyKey);
  }
});

/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.8 Reflect.getPrototypeOf(target)
var $export  = __webpack_require__(0)
  , getProto = __webpack_require__(25)
  , anObject = __webpack_require__(3);

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target){
    return getProto(anObject(target));
  }
});

/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD           = __webpack_require__(24)
  , getPrototypeOf = __webpack_require__(25)
  , has            = __webpack_require__(14)
  , $export        = __webpack_require__(0)
  , isObject       = __webpack_require__(6)
  , anObject       = __webpack_require__(3);

function get(target, propertyKey/*, receiver*/){
  var receiver = arguments.length < 3 ? target : arguments[2]
    , desc, proto;
  if(anObject(target) === receiver)return target[propertyKey];
  if(desc = gOPD.f(target, propertyKey))return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if(isObject(proto = getPrototypeOf(target)))return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', {get: get});

/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.9 Reflect.has(target, propertyKey)
var $export = __webpack_require__(0);

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey){
    return propertyKey in target;
  }
});

/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.10 Reflect.isExtensible(target)
var $export       = __webpack_require__(0)
  , anObject      = __webpack_require__(3)
  , $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target){
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});

/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.11 Reflect.ownKeys(target)
var $export = __webpack_require__(0);

$export($export.S, 'Reflect', {ownKeys: __webpack_require__(171)});

/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.12 Reflect.preventExtensions(target)
var $export            = __webpack_require__(0)
  , anObject           = __webpack_require__(3)
  , $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target){
    anObject(target);
    try {
      if($preventExtensions)$preventExtensions(target);
      return true;
    } catch(e){
      return false;
    }
  }
});

/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export  = __webpack_require__(0)
  , setProto = __webpack_require__(105);

if(setProto)$export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto){
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch(e){
      return false;
    }
  }
});

/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP             = __webpack_require__(9)
  , gOPD           = __webpack_require__(24)
  , getPrototypeOf = __webpack_require__(25)
  , has            = __webpack_require__(14)
  , $export        = __webpack_require__(0)
  , createDesc     = __webpack_require__(44)
  , anObject       = __webpack_require__(3)
  , isObject       = __webpack_require__(6);

function set(target, propertyKey, V/*, receiver*/){
  var receiver = arguments.length < 4 ? target : arguments[3]
    , ownDesc  = gOPD.f(anObject(target), propertyKey)
    , existingDescriptor, proto;
  if(!ownDesc){
    if(isObject(proto = getPrototypeOf(target))){
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if(has(ownDesc, 'value')){
    if(ownDesc.writable === false || !isObject(receiver))return false;
    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
    existingDescriptor.value = V;
    dP.f(receiver, propertyKey, existingDescriptor);
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', {set: set});

/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

var global            = __webpack_require__(4)
  , inheritIfRequired = __webpack_require__(97)
  , dP                = __webpack_require__(9).f
  , gOPN              = __webpack_require__(53).f
  , isRegExp          = __webpack_require__(79)
  , $flags            = __webpack_require__(77)
  , $RegExp           = global.RegExp
  , Base              = $RegExp
  , proto             = $RegExp.prototype
  , re1               = /a/g
  , re2               = /a/g
  // "new" creates a new object, old webkit buggy here
  , CORRECT_NEW       = new $RegExp(re1) !== re1;

if(__webpack_require__(8) && (!CORRECT_NEW || __webpack_require__(5)(function(){
  re2[__webpack_require__(7)('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))){
  $RegExp = function RegExp(p, f){
    var tiRE = this instanceof $RegExp
      , piRE = isRegExp(p)
      , fiU  = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function(key){
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function(){ return Base[key]; },
      set: function(it){ Base[key] = it; }
    });
  };
  for(var keys = gOPN(Base), i = 0; keys.length > i; )proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  __webpack_require__(19)(global, 'RegExp', $RegExp);
}

__webpack_require__(56)('RegExp');

/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

// @@match logic
__webpack_require__(76)('match', 1, function(defined, MATCH, $match){
  // 21.1.3.11 String.prototype.match(regexp)
  return [function match(regexp){
    'use strict';
    var O  = defined(this)
      , fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, $match];
});

/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

// @@replace logic
__webpack_require__(76)('replace', 2, function(defined, REPLACE, $replace){
  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
  return [function replace(searchValue, replaceValue){
    'use strict';
    var O  = defined(this)
      , fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined
      ? fn.call(searchValue, O, replaceValue)
      : $replace.call(String(O), searchValue, replaceValue);
  }, $replace];
});

/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

// @@search logic
__webpack_require__(76)('search', 1, function(defined, SEARCH, $search){
  // 21.1.3.15 String.prototype.search(regexp)
  return [function search(regexp){
    'use strict';
    var O  = defined(this)
      , fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, $search];
});

/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

// @@split logic
__webpack_require__(76)('split', 2, function(defined, SPLIT, $split){
  'use strict';
  var isRegExp   = __webpack_require__(79)
    , _split     = $split
    , $push      = [].push
    , $SPLIT     = 'split'
    , LENGTH     = 'length'
    , LAST_INDEX = 'lastIndex';
  if(
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ){
    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
    // based on es5-shim implementation, need to rework it
    $split = function(separator, limit){
      var string = String(this);
      if(separator === undefined && limit === 0)return [];
      // If `separator` is not a regex, use native split
      if(!isRegExp(separator))return _split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var separator2, match, lastIndex, lastLength, i;
      // Doesn't need flags gy, but they don't hurt
      if(!NPCG)separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
      while(match = separatorCopy.exec(string)){
        // `separatorCopy.lastIndex` is not reliable cross-browser
        lastIndex = match.index + match[0][LENGTH];
        if(lastIndex > lastLastIndex){
          output.push(string.slice(lastLastIndex, match.index));
          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
          if(!NPCG && match[LENGTH] > 1)match[0].replace(separator2, function(){
            for(i = 1; i < arguments[LENGTH] - 2; i++)if(arguments[i] === undefined)match[i] = undefined;
          });
          if(match[LENGTH] > 1 && match.index < string[LENGTH])$push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if(output[LENGTH] >= splitLimit)break;
        }
        if(separatorCopy[LAST_INDEX] === match.index)separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if(lastLastIndex === string[LENGTH]){
        if(lastLength || !separatorCopy.test(''))output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if('0'[$SPLIT](undefined, 0)[LENGTH]){
    $split = function(separator, limit){
      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
    };
  }
  // 21.1.3.17 String.prototype.split(separator, limit)
  return [function split(separator, limit){
    var O  = defined(this)
      , fn = separator == undefined ? undefined : separator[SPLIT];
    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
  }, $split];
});

/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

__webpack_require__(178);
var anObject    = __webpack_require__(3)
  , $flags      = __webpack_require__(77)
  , DESCRIPTORS = __webpack_require__(8)
  , TO_STRING   = 'toString'
  , $toString   = /./[TO_STRING];

var define = function(fn){
  __webpack_require__(19)(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if(__webpack_require__(5)(function(){ return $toString.call({source: 'a', flags: 'b'}) != '/a/b'; })){
  define(function toString(){
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if($toString.name != TO_STRING){
  define(function toString(){
    return $toString.call(this);
  });
}

/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.2 String.prototype.anchor(name)
__webpack_require__(20)('anchor', function(createHTML){
  return function anchor(name){
    return createHTML(this, 'a', 'name', name);
  }
});

/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.3 String.prototype.big()
__webpack_require__(20)('big', function(createHTML){
  return function big(){
    return createHTML(this, 'big', '', '');
  }
});

/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.4 String.prototype.blink()
__webpack_require__(20)('blink', function(createHTML){
  return function blink(){
    return createHTML(this, 'blink', '', '');
  }
});

/***/ }),
/* 344 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.5 String.prototype.bold()
__webpack_require__(20)('bold', function(createHTML){
  return function bold(){
    return createHTML(this, 'b', '', '');
  }
});

/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(0)
  , $at     = __webpack_require__(108)(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos){
    return $at(this, pos);
  }
});

/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])

var $export   = __webpack_require__(0)
  , toLength  = __webpack_require__(12)
  , context   = __webpack_require__(109)
  , ENDS_WITH = 'endsWith'
  , $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * __webpack_require__(95)(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /*, endPosition = @length */){
    var that = context(this, searchString, ENDS_WITH)
      , endPosition = arguments.length > 1 ? arguments[1] : undefined
      , len    = toLength(that.length)
      , end    = endPosition === undefined ? len : Math.min(toLength(endPosition), len)
      , search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});

/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.6 String.prototype.fixed()
__webpack_require__(20)('fixed', function(createHTML){
  return function fixed(){
    return createHTML(this, 'tt', '', '');
  }
});

/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.7 String.prototype.fontcolor(color)
__webpack_require__(20)('fontcolor', function(createHTML){
  return function fontcolor(color){
    return createHTML(this, 'font', 'color', color);
  }
});

/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.8 String.prototype.fontsize(size)
__webpack_require__(20)('fontsize', function(createHTML){
  return function fontsize(size){
    return createHTML(this, 'font', 'size', size);
  }
});

/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

var $export        = __webpack_require__(0)
  , toIndex        = __webpack_require__(57)
  , fromCharCode   = String.fromCharCode
  , $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x){ // eslint-disable-line no-unused-vars
    var res  = []
      , aLen = arguments.length
      , i    = 0
      , code;
    while(aLen > i){
      code = +arguments[i++];
      if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});

/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.7 String.prototype.includes(searchString, position = 0)

var $export  = __webpack_require__(0)
  , context  = __webpack_require__(109)
  , INCLUDES = 'includes';

$export($export.P + $export.F * __webpack_require__(95)(INCLUDES), 'String', {
  includes: function includes(searchString /*, position = 0 */){
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});

/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.9 String.prototype.italics()
__webpack_require__(20)('italics', function(createHTML){
  return function italics(){
    return createHTML(this, 'i', '', '');
  }
});

/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at  = __webpack_require__(108)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(101)(String, 'String', function(iterated){
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , index = this._i
    , point;
  if(index >= O.length)return {value: undefined, done: true};
  point = $at(O, index);
  this._i += point.length;
  return {value: point, done: false};
});

/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.10 String.prototype.link(url)
__webpack_require__(20)('link', function(createHTML){
  return function link(url){
    return createHTML(this, 'a', 'href', url);
  }
});

/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

var $export   = __webpack_require__(0)
  , toIObject = __webpack_require__(21)
  , toLength  = __webpack_require__(12);

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite){
    var tpl  = toIObject(callSite.raw)
      , len  = toLength(tpl.length)
      , aLen = arguments.length
      , res  = []
      , i    = 0;
    while(len > i){
      res.push(String(tpl[i++]));
      if(i < aLen)res.push(String(arguments[i]));
    } return res.join('');
  }
});

/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: __webpack_require__(110)
});

/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.11 String.prototype.small()
__webpack_require__(20)('small', function(createHTML){
  return function small(){
    return createHTML(this, 'small', '', '');
  }
});

/***/ }),
/* 358 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])

var $export     = __webpack_require__(0)
  , toLength    = __webpack_require__(12)
  , context     = __webpack_require__(109)
  , STARTS_WITH = 'startsWith'
  , $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * __webpack_require__(95)(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /*, position = 0 */){
    var that   = context(this, searchString, STARTS_WITH)
      , index  = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length))
      , search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});

/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.12 String.prototype.strike()
__webpack_require__(20)('strike', function(createHTML){
  return function strike(){
    return createHTML(this, 'strike', '', '');
  }
});

/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.13 String.prototype.sub()
__webpack_require__(20)('sub', function(createHTML){
  return function sub(){
    return createHTML(this, 'sub', '', '');
  }
});

/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.14 String.prototype.sup()
__webpack_require__(20)('sup', function(createHTML){
  return function sup(){
    return createHTML(this, 'sup', '', '');
  }
});

/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 21.1.3.25 String.prototype.trim()
__webpack_require__(66)('trim', function($trim){
  return function trim(){
    return $trim(this, 3);
  };
});

/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global         = __webpack_require__(4)
  , has            = __webpack_require__(14)
  , DESCRIPTORS    = __webpack_require__(8)
  , $export        = __webpack_require__(0)
  , redefine       = __webpack_require__(19)
  , META           = __webpack_require__(43).KEY
  , $fails         = __webpack_require__(5)
  , shared         = __webpack_require__(83)
  , setToStringTag = __webpack_require__(65)
  , uid            = __webpack_require__(58)
  , wks            = __webpack_require__(7)
  , wksExt         = __webpack_require__(176)
  , wksDefine      = __webpack_require__(114)
  , keyOf          = __webpack_require__(239)
  , enumKeys       = __webpack_require__(238)
  , isArray        = __webpack_require__(99)
  , anObject       = __webpack_require__(3)
  , toIObject      = __webpack_require__(21)
  , toPrimitive    = __webpack_require__(33)
  , createDesc     = __webpack_require__(44)
  , _create        = __webpack_require__(52)
  , gOPNExt        = __webpack_require__(168)
  , $GOPD          = __webpack_require__(24)
  , $DP            = __webpack_require__(9)
  , $keys          = __webpack_require__(54)
  , gOPD           = $GOPD.f
  , dP             = $DP.f
  , gOPN           = gOPNExt.f
  , $Symbol        = global.Symbol
  , $JSON          = global.JSON
  , _stringify     = $JSON && $JSON.stringify
  , PROTOTYPE      = 'prototype'
  , HIDDEN         = wks('_hidden')
  , TO_PRIMITIVE   = wks('toPrimitive')
  , isEnum         = {}.propertyIsEnumerable
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols     = shared('symbols')
  , OPSymbols      = shared('op-symbols')
  , ObjectProto    = Object[PROTOTYPE]
  , USE_NATIVE     = typeof $Symbol == 'function'
  , QObject        = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function(){
  return _create(dP({}, 'a', {
    get: function(){ return dP(this, 'a', {value: 7}).a; }
  })).a != 7;
}) ? function(it, key, D){
  var protoDesc = gOPD(ObjectProto, key);
  if(protoDesc)delete ObjectProto[key];
  dP(it, key, D);
  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function(tag){
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
  return typeof it == 'symbol';
} : function(it){
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D){
  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if(has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = _create(D, {enumerable: createDesc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P){
  anObject(it);
  var keys = enumKeys(P = toIObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P){
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key){
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
  it  = toIObject(it);
  key = toPrimitive(key, true);
  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
  var D = gOPD(it, key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it){
  var names  = gOPN(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
  var IS_OP  = it === ObjectProto
    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if(!USE_NATIVE){
  $Symbol = function Symbol(){
    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function(value){
      if(this === ObjectProto)$set.call(OPSymbols, value);
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f   = $defineProperty;
  __webpack_require__(53).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(70).f  = $propertyIsEnumerable;
  __webpack_require__(82).f = $getOwnPropertySymbols;

  if(DESCRIPTORS && !__webpack_require__(51)){
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function(name){
    return wrap(wks(name));
  }
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});

for(var symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);

for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    if(isSymbol(key))return keyOf(SymbolRegistry, key);
    throw TypeError(key + ' is not a symbol!');
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it){
    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
    var args = [it]
      , i    = 1
      , replacer, $replacer;
    while(arguments.length > i)args.push(arguments[i++]);
    replacer = args[1];
    if(typeof replacer == 'function')$replacer = replacer;
    if($replacer || !isArray(replacer))replacer = function(key, value){
      if($replacer)value = $replacer.call(this, key, value);
      if(!isSymbol(value))return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(18)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export      = __webpack_require__(0)
  , $typed       = __webpack_require__(84)
  , buffer       = __webpack_require__(113)
  , anObject     = __webpack_require__(3)
  , toIndex      = __webpack_require__(57)
  , toLength     = __webpack_require__(12)
  , isObject     = __webpack_require__(6)
  , ArrayBuffer  = __webpack_require__(4).ArrayBuffer
  , speciesConstructor = __webpack_require__(107)
  , $ArrayBuffer = buffer.ArrayBuffer
  , $DataView    = buffer.DataView
  , $isView      = $typed.ABV && ArrayBuffer.isView
  , $slice       = $ArrayBuffer.prototype.slice
  , VIEW         = $typed.VIEW
  , ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), {ArrayBuffer: $ArrayBuffer});

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it){
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * __webpack_require__(5)(function(){
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end){
    if($slice !== undefined && end === undefined)return $slice.call(anObject(this), start); // FF fix
    var len    = anObject(this).byteLength
      , first  = toIndex(start, len)
      , final  = toIndex(end === undefined ? len : end, len)
      , result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first))
      , viewS  = new $DataView(this)
      , viewT  = new $DataView(result)
      , index  = 0;
    while(first < final){
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

__webpack_require__(56)(ARRAY_BUFFER);

/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0);
$export($export.G + $export.W + $export.F * !__webpack_require__(84).ABV, {
  DataView: __webpack_require__(113).DataView
});

/***/ }),
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(39)('Float32', 4, function(init){
  return function Float32Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(39)('Float64', 8, function(init){
  return function Float64Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(39)('Int16', 2, function(init){
  return function Int16Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(39)('Int32', 4, function(init){
  return function Int32Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(39)('Int8', 1, function(init){
  return function Int8Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 371 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(39)('Uint16', 2, function(init){
  return function Uint16Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(39)('Uint32', 4, function(init){
  return function Uint32Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 373 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(39)('Uint8', 1, function(init){
  return function Uint8Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});

/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(39)('Uint8', 1, function(init){
  return function Uint8ClampedArray(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
}, true);

/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var weak = __webpack_require__(160);

// 23.4 WeakSet Objects
__webpack_require__(75)('WeakSet', function(get){
  return function WeakSet(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value){
    return weak.def(this, value, true);
  }
}, weak, false, true);

/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/Array.prototype.includes
var $export   = __webpack_require__(0)
  , $includes = __webpack_require__(74)(true);

$export($export.P, 'Array', {
  includes: function includes(el /*, fromIndex = 0 */){
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(62)('includes');

/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export   = __webpack_require__(0)
  , microtask = __webpack_require__(104)()
  , process   = __webpack_require__(4).process
  , isNode    = __webpack_require__(28)(process) == 'process';

$export($export.G, {
  asap: function asap(fn){
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});

/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/ljharb/proposal-is-error
var $export = __webpack_require__(0)
  , cof     = __webpack_require__(28);

$export($export.S, 'Error', {
  isError: function isError(it){
    return cof(it) === 'Error';
  }
});

/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export  = __webpack_require__(0);

$export($export.P + $export.R, 'Map', {toJSON: __webpack_require__(159)('Map')});

/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  iaddh: function iaddh(x0, x1, y0, y1){
    var $x0 = x0 >>> 0
      , $x1 = x1 >>> 0
      , $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});

/***/ }),
/* 381 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  imulh: function imulh(u, v){
    var UINT16 = 0xffff
      , $u = +u
      , $v = +v
      , u0 = $u & UINT16
      , v0 = $v & UINT16
      , u1 = $u >> 16
      , v1 = $v >> 16
      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});

/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  isubh: function isubh(x0, x1, y0, y1){
    var $x0 = x0 >>> 0
      , $x1 = x1 >>> 0
      , $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});

/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = __webpack_require__(0);

$export($export.S, 'Math', {
  umulh: function umulh(u, v){
    var UINT16 = 0xffff
      , $u = +u
      , $v = +v
      , u0 = $u & UINT16
      , v0 = $v & UINT16
      , u1 = $u >>> 16
      , v1 = $v >>> 16
      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});

/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export         = __webpack_require__(0)
  , toObject        = __webpack_require__(13)
  , aFunction       = __webpack_require__(17)
  , $defineProperty = __webpack_require__(9);

// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
__webpack_require__(8) && $export($export.P + __webpack_require__(81), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter){
    $defineProperty.f(toObject(this), P, {get: aFunction(getter), enumerable: true, configurable: true});
  }
});

/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export         = __webpack_require__(0)
  , toObject        = __webpack_require__(13)
  , aFunction       = __webpack_require__(17)
  , $defineProperty = __webpack_require__(9);

// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
__webpack_require__(8) && $export($export.P + __webpack_require__(81), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter){
    $defineProperty.f(toObject(this), P, {set: aFunction(setter), enumerable: true, configurable: true});
  }
});

/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export  = __webpack_require__(0)
  , $entries = __webpack_require__(170)(true);

$export($export.S, 'Object', {
  entries: function entries(it){
    return $entries(it);
  }
});

/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export        = __webpack_require__(0)
  , ownKeys        = __webpack_require__(171)
  , toIObject      = __webpack_require__(21)
  , gOPD           = __webpack_require__(24)
  , createProperty = __webpack_require__(92);

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object){
    var O       = toIObject(object)
      , getDesc = gOPD.f
      , keys    = ownKeys(O)
      , result  = {}
      , i       = 0
      , key;
    while(keys.length > i)createProperty(result, key = keys[i++], getDesc(O, key));
    return result;
  }
});

/***/ }),
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export                  = __webpack_require__(0)
  , toObject                 = __webpack_require__(13)
  , toPrimitive              = __webpack_require__(33)
  , getPrototypeOf           = __webpack_require__(25)
  , getOwnPropertyDescriptor = __webpack_require__(24).f;

// B.2.2.4 Object.prototype.__lookupGetter__(P)
__webpack_require__(8) && $export($export.P + __webpack_require__(81), 'Object', {
  __lookupGetter__: function __lookupGetter__(P){
    var O = toObject(this)
      , K = toPrimitive(P, true)
      , D;
    do {
      if(D = getOwnPropertyDescriptor(O, K))return D.get;
    } while(O = getPrototypeOf(O));
  }
});

/***/ }),
/* 389 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export                  = __webpack_require__(0)
  , toObject                 = __webpack_require__(13)
  , toPrimitive              = __webpack_require__(33)
  , getPrototypeOf           = __webpack_require__(25)
  , getOwnPropertyDescriptor = __webpack_require__(24).f;

// B.2.2.5 Object.prototype.__lookupSetter__(P)
__webpack_require__(8) && $export($export.P + __webpack_require__(81), 'Object', {
  __lookupSetter__: function __lookupSetter__(P){
    var O = toObject(this)
      , K = toPrimitive(P, true)
      , D;
    do {
      if(D = getOwnPropertyDescriptor(O, K))return D.set;
    } while(O = getPrototypeOf(O));
  }
});

/***/ }),
/* 390 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(0)
  , $values = __webpack_require__(170)(false);

$export($export.S, 'Object', {
  values: function values(it){
    return $values(it);
  }
});

/***/ }),
/* 391 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/zenparsing/es-observable
var $export     = __webpack_require__(0)
  , global      = __webpack_require__(4)
  , core        = __webpack_require__(36)
  , microtask   = __webpack_require__(104)()
  , OBSERVABLE  = __webpack_require__(7)('observable')
  , aFunction   = __webpack_require__(17)
  , anObject    = __webpack_require__(3)
  , anInstance  = __webpack_require__(50)
  , redefineAll = __webpack_require__(55)
  , hide        = __webpack_require__(18)
  , forOf       = __webpack_require__(63)
  , RETURN      = forOf.RETURN;

var getMethod = function(fn){
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function(subscription){
  var cleanup = subscription._c;
  if(cleanup){
    subscription._c = undefined;
    cleanup();
  }
};

var subscriptionClosed = function(subscription){
  return subscription._o === undefined;
};

var closeSubscription = function(subscription){
  if(!subscriptionClosed(subscription)){
    subscription._o = undefined;
    cleanupSubscription(subscription);
  }
};

var Subscription = function(observer, subscriber){
  anObject(observer);
  this._c = undefined;
  this._o = observer;
  observer = new SubscriptionObserver(this);
  try {
    var cleanup      = subscriber(observer)
      , subscription = cleanup;
    if(cleanup != null){
      if(typeof cleanup.unsubscribe === 'function')cleanup = function(){ subscription.unsubscribe(); };
      else aFunction(cleanup);
      this._c = cleanup;
    }
  } catch(e){
    observer.error(e);
    return;
  } if(subscriptionClosed(this))cleanupSubscription(this);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe(){ closeSubscription(this); }
});

var SubscriptionObserver = function(subscription){
  this._s = subscription;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value){
    var subscription = this._s;
    if(!subscriptionClosed(subscription)){
      var observer = subscription._o;
      try {
        var m = getMethod(observer.next);
        if(m)return m.call(observer, value);
      } catch(e){
        try {
          closeSubscription(subscription);
        } finally {
          throw e;
        }
      }
    }
  },
  error: function error(value){
    var subscription = this._s;
    if(subscriptionClosed(subscription))throw value;
    var observer = subscription._o;
    subscription._o = undefined;
    try {
      var m = getMethod(observer.error);
      if(!m)throw value;
      value = m.call(observer, value);
    } catch(e){
      try {
        cleanupSubscription(subscription);
      } finally {
        throw e;
      }
    } cleanupSubscription(subscription);
    return value;
  },
  complete: function complete(value){
    var subscription = this._s;
    if(!subscriptionClosed(subscription)){
      var observer = subscription._o;
      subscription._o = undefined;
      try {
        var m = getMethod(observer.complete);
        value = m ? m.call(observer, value) : undefined;
      } catch(e){
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      } cleanupSubscription(subscription);
      return value;
    }
  }
});

var $Observable = function Observable(subscriber){
  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer){
    return new Subscription(observer, this._f);
  },
  forEach: function forEach(fn){
    var that = this;
    return new (core.Promise || global.Promise)(function(resolve, reject){
      aFunction(fn);
      var subscription = that.subscribe({
        next : function(value){
          try {
            return fn(value);
          } catch(e){
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  }
});

redefineAll($Observable, {
  from: function from(x){
    var C = typeof this === 'function' ? this : $Observable;
    var method = getMethod(anObject(x)[OBSERVABLE]);
    if(method){
      var observable = anObject(method.call(x));
      return observable.constructor === C ? observable : new C(function(observer){
        return observable.subscribe(observer);
      });
    }
    return new C(function(observer){
      var done = false;
      microtask(function(){
        if(!done){
          try {
            if(forOf(x, false, function(it){
              observer.next(it);
              if(done)return RETURN;
            }) === RETURN)return;
          } catch(e){
            if(done)throw e;
            observer.error(e);
            return;
          } observer.complete();
        }
      });
      return function(){ done = true; };
    });
  },
  of: function of(){
    for(var i = 0, l = arguments.length, items = Array(l); i < l;)items[i] = arguments[i++];
    return new (typeof this === 'function' ? this : $Observable)(function(observer){
      var done = false;
      microtask(function(){
        if(!done){
          for(var i = 0; i < items.length; ++i){
            observer.next(items[i]);
            if(done)return;
          } observer.complete();
        }
      });
      return function(){ done = true; };
    });
  }
});

hide($Observable.prototype, OBSERVABLE, function(){ return this; });

$export($export.G, {Observable: $Observable});

__webpack_require__(56)('Observable');

/***/ }),
/* 392 */
/***/ (function(module, exports, __webpack_require__) {

var metadata                  = __webpack_require__(38)
  , anObject                  = __webpack_require__(3)
  , toMetaKey                 = metadata.key
  , ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey){
  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
}});

/***/ }),
/* 393 */
/***/ (function(module, exports, __webpack_require__) {

var metadata               = __webpack_require__(38)
  , anObject               = __webpack_require__(3)
  , toMetaKey              = metadata.key
  , getOrCreateMetadataMap = metadata.map
  , store                  = metadata.store;

metadata.exp({deleteMetadata: function deleteMetadata(metadataKey, target /*, targetKey */){
  var targetKey   = arguments.length < 3 ? undefined : toMetaKey(arguments[2])
    , metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
  if(metadataMap === undefined || !metadataMap['delete'](metadataKey))return false;
  if(metadataMap.size)return true;
  var targetMetadata = store.get(target);
  targetMetadata['delete'](targetKey);
  return !!targetMetadata.size || store['delete'](target);
}});

/***/ }),
/* 394 */
/***/ (function(module, exports, __webpack_require__) {

var Set                     = __webpack_require__(179)
  , from                    = __webpack_require__(155)
  , metadata                = __webpack_require__(38)
  , anObject                = __webpack_require__(3)
  , getPrototypeOf          = __webpack_require__(25)
  , ordinaryOwnMetadataKeys = metadata.keys
  , toMetaKey               = metadata.key;

var ordinaryMetadataKeys = function(O, P){
  var oKeys  = ordinaryOwnMetadataKeys(O, P)
    , parent = getPrototypeOf(O);
  if(parent === null)return oKeys;
  var pKeys  = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

metadata.exp({getMetadataKeys: function getMetadataKeys(target /*, targetKey */){
  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
}});

/***/ }),
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

var metadata               = __webpack_require__(38)
  , anObject               = __webpack_require__(3)
  , getPrototypeOf         = __webpack_require__(25)
  , ordinaryHasOwnMetadata = metadata.has
  , ordinaryGetOwnMetadata = metadata.get
  , toMetaKey              = metadata.key;

var ordinaryGetMetadata = function(MetadataKey, O, P){
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if(hasOwn)return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

metadata.exp({getMetadata: function getMetadata(metadataKey, target /*, targetKey */){
  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
}});

/***/ }),
/* 396 */
/***/ (function(module, exports, __webpack_require__) {

var metadata                = __webpack_require__(38)
  , anObject                = __webpack_require__(3)
  , ordinaryOwnMetadataKeys = metadata.keys
  , toMetaKey               = metadata.key;

metadata.exp({getOwnMetadataKeys: function getOwnMetadataKeys(target /*, targetKey */){
  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
}});

/***/ }),
/* 397 */
/***/ (function(module, exports, __webpack_require__) {

var metadata               = __webpack_require__(38)
  , anObject               = __webpack_require__(3)
  , ordinaryGetOwnMetadata = metadata.get
  , toMetaKey              = metadata.key;

metadata.exp({getOwnMetadata: function getOwnMetadata(metadataKey, target /*, targetKey */){
  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
}});

/***/ }),
/* 398 */
/***/ (function(module, exports, __webpack_require__) {

var metadata               = __webpack_require__(38)
  , anObject               = __webpack_require__(3)
  , getPrototypeOf         = __webpack_require__(25)
  , ordinaryHasOwnMetadata = metadata.has
  , toMetaKey              = metadata.key;

var ordinaryHasMetadata = function(MetadataKey, O, P){
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if(hasOwn)return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

metadata.exp({hasMetadata: function hasMetadata(metadataKey, target /*, targetKey */){
  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
}});

/***/ }),
/* 399 */
/***/ (function(module, exports, __webpack_require__) {

var metadata               = __webpack_require__(38)
  , anObject               = __webpack_require__(3)
  , ordinaryHasOwnMetadata = metadata.has
  , toMetaKey              = metadata.key;

metadata.exp({hasOwnMetadata: function hasOwnMetadata(metadataKey, target /*, targetKey */){
  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
}});

/***/ }),
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

var metadata                  = __webpack_require__(38)
  , anObject                  = __webpack_require__(3)
  , aFunction                 = __webpack_require__(17)
  , toMetaKey                 = metadata.key
  , ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({metadata: function metadata(metadataKey, metadataValue){
  return function decorator(target, targetKey){
    ordinaryDefineOwnMetadata(
      metadataKey, metadataValue,
      (targetKey !== undefined ? anObject : aFunction)(target),
      toMetaKey(targetKey)
    );
  };
}});

/***/ }),
/* 401 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export  = __webpack_require__(0);

$export($export.P + $export.R, 'Set', {toJSON: __webpack_require__(159)('Set')});

/***/ }),
/* 402 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/mathiasbynens/String.prototype.at
var $export = __webpack_require__(0)
  , $at     = __webpack_require__(108)(true);

$export($export.P, 'String', {
  at: function at(pos){
    return $at(this, pos);
  }
});

/***/ }),
/* 403 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/String.prototype.matchAll/
var $export     = __webpack_require__(0)
  , defined     = __webpack_require__(29)
  , toLength    = __webpack_require__(12)
  , isRegExp    = __webpack_require__(79)
  , getFlags    = __webpack_require__(77)
  , RegExpProto = RegExp.prototype;

var $RegExpStringIterator = function(regexp, string){
  this._r = regexp;
  this._s = string;
};

__webpack_require__(100)($RegExpStringIterator, 'RegExp String', function next(){
  var match = this._r.exec(this._s);
  return {value: match, done: match === null};
});

$export($export.P, 'String', {
  matchAll: function matchAll(regexp){
    defined(this);
    if(!isRegExp(regexp))throw TypeError(regexp + ' is not a regexp!');
    var S     = String(this)
      , flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp)
      , rx    = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
    rx.lastIndex = toLength(regexp.lastIndex);
    return new $RegExpStringIterator(rx, S);
  }
});

/***/ }),
/* 404 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-string-pad-start-end
var $export = __webpack_require__(0)
  , $pad    = __webpack_require__(175);

$export($export.P, 'String', {
  padEnd: function padEnd(maxLength /*, fillString = ' ' */){
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});

/***/ }),
/* 405 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-string-pad-start-end
var $export = __webpack_require__(0)
  , $pad    = __webpack_require__(175);

$export($export.P, 'String', {
  padStart: function padStart(maxLength /*, fillString = ' ' */){
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});

/***/ }),
/* 406 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
__webpack_require__(66)('trimLeft', function($trim){
  return function trimLeft(){
    return $trim(this, 1);
  };
}, 'trimStart');

/***/ }),
/* 407 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
__webpack_require__(66)('trimRight', function($trim){
  return function trimRight(){
    return $trim(this, 2);
  };
}, 'trimEnd');

/***/ }),
/* 408 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(114)('asyncIterator');

/***/ }),
/* 409 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(114)('observable');

/***/ }),
/* 410 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/ljharb/proposal-global
var $export = __webpack_require__(0);

$export($export.S, 'System', {global: __webpack_require__(4)});

/***/ }),
/* 411 */
/***/ (function(module, exports, __webpack_require__) {

var $iterators    = __webpack_require__(116)
  , redefine      = __webpack_require__(19)
  , global        = __webpack_require__(4)
  , hide          = __webpack_require__(18)
  , Iterators     = __webpack_require__(64)
  , wks           = __webpack_require__(7)
  , ITERATOR      = wks('iterator')
  , TO_STRING_TAG = wks('toStringTag')
  , ArrayValues   = Iterators.Array;

for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
  var NAME       = collections[i]
    , Collection = global[NAME]
    , proto      = Collection && Collection.prototype
    , key;
  if(proto){
    if(!proto[ITERATOR])hide(proto, ITERATOR, ArrayValues);
    if(!proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    for(key in $iterators)if(!proto[key])redefine(proto, key, $iterators[key], true);
  }
}

/***/ }),
/* 412 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(0)
  , $task   = __webpack_require__(112);
$export($export.G + $export.B, {
  setImmediate:   $task.set,
  clearImmediate: $task.clear
});

/***/ }),
/* 413 */
/***/ (function(module, exports, __webpack_require__) {

// ie9- setTimeout & setInterval additional parameters fix
var global     = __webpack_require__(4)
  , $export    = __webpack_require__(0)
  , invoke     = __webpack_require__(78)
  , partial    = __webpack_require__(240)
  , navigator  = global.navigator
  , MSIE       = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
var wrap = function(set){
  return MSIE ? function(fn, time /*, ...args */){
    return set(invoke(
      partial,
      [].slice.call(arguments, 2),
      typeof fn == 'function' ? fn : Function(fn)
    ), time);
  } : set;
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout:  wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});

/***/ }),
/* 414 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(363);
__webpack_require__(302);
__webpack_require__(304);
__webpack_require__(303);
__webpack_require__(306);
__webpack_require__(308);
__webpack_require__(313);
__webpack_require__(307);
__webpack_require__(305);
__webpack_require__(315);
__webpack_require__(314);
__webpack_require__(310);
__webpack_require__(311);
__webpack_require__(309);
__webpack_require__(301);
__webpack_require__(312);
__webpack_require__(316);
__webpack_require__(317);
__webpack_require__(269);
__webpack_require__(271);
__webpack_require__(270);
__webpack_require__(319);
__webpack_require__(318);
__webpack_require__(289);
__webpack_require__(299);
__webpack_require__(300);
__webpack_require__(290);
__webpack_require__(291);
__webpack_require__(292);
__webpack_require__(293);
__webpack_require__(294);
__webpack_require__(295);
__webpack_require__(296);
__webpack_require__(297);
__webpack_require__(298);
__webpack_require__(272);
__webpack_require__(273);
__webpack_require__(274);
__webpack_require__(275);
__webpack_require__(276);
__webpack_require__(277);
__webpack_require__(278);
__webpack_require__(279);
__webpack_require__(280);
__webpack_require__(281);
__webpack_require__(282);
__webpack_require__(283);
__webpack_require__(284);
__webpack_require__(285);
__webpack_require__(286);
__webpack_require__(287);
__webpack_require__(288);
__webpack_require__(350);
__webpack_require__(355);
__webpack_require__(362);
__webpack_require__(353);
__webpack_require__(345);
__webpack_require__(346);
__webpack_require__(351);
__webpack_require__(356);
__webpack_require__(358);
__webpack_require__(341);
__webpack_require__(342);
__webpack_require__(343);
__webpack_require__(344);
__webpack_require__(347);
__webpack_require__(348);
__webpack_require__(349);
__webpack_require__(352);
__webpack_require__(354);
__webpack_require__(357);
__webpack_require__(359);
__webpack_require__(360);
__webpack_require__(361);
__webpack_require__(264);
__webpack_require__(266);
__webpack_require__(265);
__webpack_require__(268);
__webpack_require__(267);
__webpack_require__(253);
__webpack_require__(251);
__webpack_require__(257);
__webpack_require__(254);
__webpack_require__(260);
__webpack_require__(262);
__webpack_require__(250);
__webpack_require__(256);
__webpack_require__(247);
__webpack_require__(261);
__webpack_require__(245);
__webpack_require__(259);
__webpack_require__(258);
__webpack_require__(252);
__webpack_require__(255);
__webpack_require__(244);
__webpack_require__(246);
__webpack_require__(249);
__webpack_require__(248);
__webpack_require__(263);
__webpack_require__(116);
__webpack_require__(335);
__webpack_require__(340);
__webpack_require__(178);
__webpack_require__(336);
__webpack_require__(337);
__webpack_require__(338);
__webpack_require__(339);
__webpack_require__(320);
__webpack_require__(177);
__webpack_require__(179);
__webpack_require__(180);
__webpack_require__(375);
__webpack_require__(364);
__webpack_require__(365);
__webpack_require__(370);
__webpack_require__(373);
__webpack_require__(374);
__webpack_require__(368);
__webpack_require__(371);
__webpack_require__(369);
__webpack_require__(372);
__webpack_require__(366);
__webpack_require__(367);
__webpack_require__(321);
__webpack_require__(322);
__webpack_require__(323);
__webpack_require__(324);
__webpack_require__(325);
__webpack_require__(328);
__webpack_require__(326);
__webpack_require__(327);
__webpack_require__(329);
__webpack_require__(330);
__webpack_require__(331);
__webpack_require__(332);
__webpack_require__(334);
__webpack_require__(333);
__webpack_require__(376);
__webpack_require__(402);
__webpack_require__(405);
__webpack_require__(404);
__webpack_require__(406);
__webpack_require__(407);
__webpack_require__(403);
__webpack_require__(408);
__webpack_require__(409);
__webpack_require__(387);
__webpack_require__(390);
__webpack_require__(386);
__webpack_require__(384);
__webpack_require__(385);
__webpack_require__(388);
__webpack_require__(389);
__webpack_require__(379);
__webpack_require__(401);
__webpack_require__(410);
__webpack_require__(378);
__webpack_require__(380);
__webpack_require__(382);
__webpack_require__(381);
__webpack_require__(383);
__webpack_require__(392);
__webpack_require__(393);
__webpack_require__(395);
__webpack_require__(394);
__webpack_require__(397);
__webpack_require__(396);
__webpack_require__(398);
__webpack_require__(399);
__webpack_require__(400);
__webpack_require__(377);
__webpack_require__(391);
__webpack_require__(413);
__webpack_require__(412);
__webpack_require__(411);
module.exports = __webpack_require__(36);

/***/ }),
/* 415 */,
/* 416 */,
/* 417 */,
/* 418 */,
/* 419 */,
/* 420 */,
/* 421 */,
/* 422 */,
/* 423 */,
/* 424 */,
/* 425 */,
/* 426 */,
/* 427 */,
/* 428 */,
/* 429 */,
/* 430 */,
/* 431 */,
/* 432 */,
/* 433 */,
/* 434 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {

	if (root === null) {
		throw new Error('Google-maps package can be used only in browser');
	}

	if (true) {
		!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (typeof exports === 'object') {
		module.exports = factory();
	} else {
		root.GoogleMapsLoader = factory();
	}

})(typeof window !== 'undefined' ? window : null, function() {


	'use strict';


	var googleVersion = '3.18';

	var script = null;

	var google = null;

	var loading = false;

	var callbacks = [];

	var onLoadEvents = [];

	var originalCreateLoaderMethod = null;


	var GoogleMapsLoader = {};


	GoogleMapsLoader.URL = 'https://maps.googleapis.com/maps/api/js';

	GoogleMapsLoader.KEY = null;

	GoogleMapsLoader.LIBRARIES = [];

	GoogleMapsLoader.CLIENT = null;

	GoogleMapsLoader.CHANNEL = null;

	GoogleMapsLoader.LANGUAGE = null;

	GoogleMapsLoader.REGION = null;

	GoogleMapsLoader.VERSION = googleVersion;

	GoogleMapsLoader.WINDOW_CALLBACK_NAME = '__google_maps_api_provider_initializator__';


	GoogleMapsLoader._googleMockApiObject = {};


	GoogleMapsLoader.load = function(fn) {
		if (google === null) {
			if (loading === true) {
				if (fn) {
					callbacks.push(fn);
				}
			} else {
				loading = true;

				window[GoogleMapsLoader.WINDOW_CALLBACK_NAME] = function() {
					ready(fn);
				};

				GoogleMapsLoader.createLoader();
			}
		} else if (fn) {
			fn(google);
		}
	};


	GoogleMapsLoader.createLoader = function() {
		script = document.createElement('script');
		script.type = 'text/javascript';
		script.src = GoogleMapsLoader.createUrl();

		document.body.appendChild(script);
	};


	GoogleMapsLoader.isLoaded = function() {
		return google !== null;
	};


	GoogleMapsLoader.createUrl = function() {
		var url = GoogleMapsLoader.URL;

		url += '?callback=' + GoogleMapsLoader.WINDOW_CALLBACK_NAME;

		if (GoogleMapsLoader.KEY) {
			url += '&key=' + GoogleMapsLoader.KEY;
		}

		if (GoogleMapsLoader.LIBRARIES.length > 0) {
			url += '&libraries=' + GoogleMapsLoader.LIBRARIES.join(',');
		}

		if (GoogleMapsLoader.CLIENT) {
			url += '&client=' + GoogleMapsLoader.CLIENT + '&v=' + GoogleMapsLoader.VERSION;
		}

		if (GoogleMapsLoader.CHANNEL) {
			url += '&channel=' + GoogleMapsLoader.CHANNEL;
		}

		if (GoogleMapsLoader.LANGUAGE) {
			url += '&language=' + GoogleMapsLoader.LANGUAGE;
		}

		if (GoogleMapsLoader.REGION) {
			url += '&region=' + GoogleMapsLoader.REGION;
		}

		return url;
	};


	GoogleMapsLoader.release = function(fn) {
		var release = function() {
			GoogleMapsLoader.KEY = null;
			GoogleMapsLoader.LIBRARIES = [];
			GoogleMapsLoader.CLIENT = null;
			GoogleMapsLoader.CHANNEL = null;
			GoogleMapsLoader.LANGUAGE = null;
			GoogleMapsLoader.REGION = null;
			GoogleMapsLoader.VERSION = googleVersion;

			google = null;
			loading = false;
			callbacks = [];
			onLoadEvents = [];

			if (typeof window.google !== 'undefined') {
				delete window.google;
			}

			if (typeof window[GoogleMapsLoader.WINDOW_CALLBACK_NAME] !== 'undefined') {
				delete window[GoogleMapsLoader.WINDOW_CALLBACK_NAME];
			}

			if (originalCreateLoaderMethod !== null) {
				GoogleMapsLoader.createLoader = originalCreateLoaderMethod;
				originalCreateLoaderMethod = null;
			}

			if (script !== null) {
				script.parentElement.removeChild(script);
				script = null;
			}

			if (fn) {
				fn();
			}
		};

		if (loading) {
			GoogleMapsLoader.load(function() {
				release();
			});
		} else {
			release();
		}
	};


	GoogleMapsLoader.onLoad = function(fn) {
		onLoadEvents.push(fn);
	};


	GoogleMapsLoader.makeMock = function() {
		originalCreateLoaderMethod = GoogleMapsLoader.createLoader;

		GoogleMapsLoader.createLoader = function() {
			window.google = GoogleMapsLoader._googleMockApiObject;
			window[GoogleMapsLoader.WINDOW_CALLBACK_NAME]();
		};
	};


	var ready = function(fn) {
		var i;

		loading = false;

		if (google === null) {
			google = window.google;
		}

		for (i = 0; i < onLoadEvents.length; i++) {
			onLoadEvents[i](google);
		}

		if (fn) {
			fn(google);
		}

		for (i = 0; i < callbacks.length; i++) {
			callbacks[i](google);
		}

		callbacks = [];
	};


	return GoogleMapsLoader;

});


/***/ }),
/* 435 */
/***/ (function(module, exports) {

module.exports = "<div class=\"vzb-bs-holder\">\n\t<svg class=\"vzb-bs-svg\">\n\t\t<g class=\"vzb-bs-slider-wrap\">\n\t\t\t<g class=\"vzb-bs-slider\">\n\t\t\t</g>\n\t\t</g>\n\t</svg>\n</div>\n";

/***/ }),
/* 436 */
/***/ (function(module, exports) {

module.exports = "<div class='vzb-dialog-modal'>\n  <div class=\"vzb-dialog-title\"> \n      <%=t (\"buttons/about\") %>\n  </div>\n      \n  <div class=\"vzb-dialog-content\">\n      <p class=\"vzb-about-text0\"></p>\n      <p class=\"vzb-about-text1\"></p>\n      <br/>\n      <p class=\"vzb-about-version\"></p>\n      <p class=\"vzb-about-updated\"></p>\n      <br/>\n      <p class=\"vzb-about-text2\"></p>\n      <br/>\n      <p class=\"vzb-about-report\"></p>\n      <br/>\n      <p class=\"vzb-about-credits\"></p>\n  </div>\n      \n  <div class=\"vzb-dialog-buttons\">\n    <div data-click=\"closeDialog\" class=\"vzb-dialog-button vzb-label-primary\">\n      <%=t (\"buttons/ok\") %>\n    </div>\n  </div>\n      \n\n</div>\n";

/***/ }),
/* 437 */
/***/ (function(module, exports) {

module.exports = "<div class='vzb-dialog-modal'>\n    <span class=\"thumb-tack-class thumb-tack-class-ico-pin fa\" data-dialogtype=\"axes\" data-click=\"pinDialog\"></span>\n    <span class=\"thumb-tack-class thumb-tack-class-ico-drag fa\" data-dialogtype=\"axes\" data-click=\"dragDialog\"></span>\n    <div class=\"vzb-dialog-title\"><%=t (\"buttons/axes\") %></div>\n    <div class=\"vzb-dialog-content\">\n      <p class=\"vzb-dialog-sublabel\"> <%=t (\"buttons/axis_x\") %> <span class=\"vzb-xaxis-selector\"></span> </p>\n      <div class=\"vzb-xaxis-minmax vzb-dialog-paragraph\"></div>\n      <p class=\"vzb-dialog-sublabel\"> <%=t (\"buttons/axis_y\") %> <span class=\"vzb-yaxis-selector\"></span> </p>\n      <div class=\"vzb-yaxis-minmax vzb-dialog-paragraph\"></div>\n    </div>\n    <div class=\"vzb-dialog-buttons\">\n      <div data-click=\"closeDialog\" class=\"vzb-dialog-button vzb-label-primary\"><%=t ( \"buttons/ok\") %></div>\n    </div>\n</div>";

/***/ }),
/* 438 */
/***/ (function(module, exports) {

module.exports = "<div class='vzb-dialog-modal'>\n    <span class=\"thumb-tack-class thumb-tack-class-ico-pin fa\" data-dialogtype=\"axesmc\" data-click=\"pinDialog\"></span>\n    <span class=\"thumb-tack-class thumb-tack-class-ico-drag fa\" data-dialogtype=\"axesmc\" data-click=\"dragDialog\"></span>\n    <div class=\"vzb-dialog-title\">\n        <%=t (\"buttons/axes\") %>\n    </div>\n    <div class=\"vzb-dialog-content\">\n        <div class=\"vzb-yaxis-container\">\n            <p class=\"vzb-dialog-sublabel\"><%=t (\"hints/mount/maxYvalue\") %></p>\n            <form class=\"vzb-dialog-paragraph\">\n                <label><input type=\"radio\" name=\"ymax\" value=\"immediate\"><%=t (\"mount/maxYmode/immediate\") %></label>\n                <label><input type=\"radio\" name=\"ymax\" value=\"latest\"><%=t (\"mount/maxYmode/latest\") %></label>\n            </form>\n        </div>\n        <div class=\"vzb-xaxis-container\">\n            <p class=\"vzb-dialog-sublabel\">\n                <%=t (\"hints/mount/logXstops\") %>\n            </p>\n            <form class=\"vzb-dialog-paragraph\">\n                <input type=\"checkbox\" name=\"logstops\" value=\"1\">1\n                <input type=\"checkbox\" name=\"logstops\" value=\"2\">2\n                <input type=\"checkbox\" name=\"logstops\" value=\"5\">5\n            </form>\n        </div>\n        <p class=\"vzb-dialog-sublabel\">\n            <%=t (\"hints/mount/xlimits\") %>\n        </p>\n        <div class=\"vzb-xlimits-container vzb-dialog-paragraph\"></div>\n        <div class=\"vzb-probe-container\">\n            <p class=\"vzb-dialog-sublabel\">\n              <input type=\"checkbox\" name=\"probe\" class=\"vzb-probe-check\"> <%=t (\"hints/mount/probe\") %>\n            </p>\n            <input type=\"text\" class=\"vzb-probe-field\" name=\"probe\">\n        </div>\n    </div>\n    <div class=\"vzb-dialog-buttons\">\n        <div data-click=\"closeDialog\" class=\"vzb-dialog-button vzb-label-primary\">\n            <%=t (\"buttons/ok\") %>\n        </div>\n    </div>\n</div>";

/***/ }),
/* 439 */
/***/ (function(module, exports) {

module.exports = "<div class='vzb-dialog-modal'>\n  <span class=\"thumb-tack-class thumb-tack-class-ico-pin fa\" data-dialogtype=\"colors\" data-click=\"pinDialog\"></span>\n  <span class=\"thumb-tack-class thumb-tack-class-ico-drag fa\" data-dialogtype=\"colors\" data-click=\"dragDialog\"></span>\n  \n  <div class=\"vzb-dialog-title\">\n      <%=t (\"buttons/colors\") %>\n      <span class=\"vzb-caxis-selector\"></span>\n  </div>\n  \n  \n  \n  <div class=\"vzb-dialog-content vzb-dialog-scrollable\">\n    <div class=\"vzb-clegend-container\"></div>\n  </div>\n\n  <div class=\"vzb-dialog-buttons\">\n    <div data-click=\"closeDialog\" class=\"vzb-dialog-button vzb-label-primary\">\n      <%=t (\"buttons/ok\") %>\n    </div>\n  </div>\n\n</div>\n";

/***/ }),
/* 440 */
/***/ (function(module, exports) {

module.exports = "<div class='vzb-dialog-modal'>\n  <span class=\"thumb-tack-class thumb-tack-class-ico-pin fa\" data-dialogtype=\"find\" data-click=\"pinDialog\"></span>\n  <span class=\"thumb-tack-class thumb-tack-class-ico-drag fa\" data-dialogtype=\"find\" data-click=\"dragDialog\"></span>\n  <div class=\"vzb-dialog-title\">\n    <%=t (\"dialogs/find\") %>\n    <span class=\"vzb-dialog-content vzb-find-filter\">\n      <input class=\"vzb-find-search\" type=\"search\"/>\n    </span>\n  </div>\n  \n  <div class=\"vzb-dialog-content vzb-dialog-content-fixed vzb-dialog-scrollable\">\n    <div class=\"vzb-find-list\">\n      <!-- list will be placed here -->\n    </div>\n  </div>\n\n  <div class=\"vzb-dialog-buttons\">\n    <div class=\"vzb-dialog-bubbleopacity vzb-dialog-control\"></div>\n    <div class=\"vzb-dialog-button vzb-find-deselect\">\n      <%=t (\"buttons/deselect\") %>\n    </div>\n\n    <div data-click=\"closeDialog\" class=\"vzb-dialog-button vzb-label-primary\">\n      <%=t (\"buttons/ok\") %>\n    </div>\n  </div>\n\n</div>\n";

/***/ }),
/* 441 */
/***/ (function(module, exports) {

module.exports = "<div class='vzb-dialog-modal'>\n  <span class=\"thumb-tack-class thumb-tack-class-ico-pin fa\" data-dialogtype=\"label\" data-click=\"pinDialog\"></span>\n  <span class=\"thumb-tack-class thumb-tack-class-ico-drag fa\" data-dialogtype=\"label\" data-click=\"dragDialog\"></span>\n  <div class=\"vzb-dialog-title\"> \n      <%=t (\"buttons/label\") %>\n  </div>\n      \n      \n  <div class=\"vzb-dialog-content\">\n    <span class=\"vzb-saxis-selector\"></span>\n    <div class=\"vzb-dialog-sizeslider\"></div>\n    <div class=\"vzb-removelabelbox-switch\"></div>\n  </div>\n\n  <div class=\"vzb-dialog-buttons\">\n    <div data-click=\"closeDialog\" class=\"vzb-dialog-button vzb-label-primary\">\n      <%=t (\"buttons/ok\") %>\n    </div>\n  </div>\n\n</div>\n";

/***/ }),
/* 442 */
/***/ (function(module, exports) {

module.exports = "<div class='vzb-dialog-modal'>\n    <span class=\"thumb-tack-class thumb-tack-class-ico-pin fa\" data-dialogtype=\"mapoptions\" data-click=\"pinDialog\"></span>\n    <span class=\"thumb-tack-class thumb-tack-class-ico-drag fa\" data-dialogtype=\"mapoptions\" data-click=\"dragDialog\"></span>\n    <div class=\"vzb-dialog-title\">\n        <%=t (\"buttons/mapoptions\") %>\n    </div>\n    <div class=\"vzb-dialog-content\">\n        <div class=\"vzb-lmap-container\">\n            <p class=\"vzb-dialog-sublabel\"><%=t (\"hints/lbubblemap/mapApi\") %></p>\n            <form class=\"vzb-dialog-paragraph map-api\">\n            </form>\n        </div>\n        <div class=\"vzb-lmap-container\">\n            <p class=\"vzb-dialog-sublabel\">\n                <%=t (\"hints/lbubblemap/mapView\") %>\n            </p>\n            <form class=\"vzb-dialog-paragraph  map-layer\">\n            </form>\n        </div>\n    </div>\n    <div class=\"vzb-dialog-buttons\">\n        <div data-click=\"closeDialog\" class=\"vzb-dialog-button vzb-label-primary\">\n            <%=t (\"buttons/ok\") %>\n        </div>\n    </div>\n</div>";

/***/ }),
/* 443 */
/***/ (function(module, exports) {

module.exports = "<div class='vzb-dialog-modal'>\n  <span class=\"thumb-tack-class thumb-tack-class-ico-pin fa\" data-dialogtype=\"moreoptions\" data-click=\"pinDialog\"></span>\n  <span class=\"thumb-tack-class thumb-tack-class-ico-drag fa\" data-dialogtype=\"moreoptions\" data-click=\"dragDialog\"></span>\n\n\n  <div class=\"vzb-dialog-title\">\n    <%=t (\"buttons/more_options\") %>\n  </div>\n\n  <div class=\"vzb-dialog-content vzb-dialog-scrollable\">\n    <div class='vzb-dialog-options-buttonlist'>\n    </div>\n    <div class=\"vzb-accordion\">\n    </div>\n  </div>\n\n  <div class=\"vzb-dialog-buttons\">\n    <div data-click=\"closeDialog\" class=\"vzb-dialog-button vzb-label-primary\">\n      <%=t (\"buttons/ok\") %>\n    </div>\n  </div>\n\n</div>";

/***/ }),
/* 444 */
/***/ (function(module, exports) {

module.exports = "<div class='vzb-dialog-modal'>\n  <div class=\"vzb-dialog-title\"> \n      <%=t (\"buttons/opacity\") %>\n  </div>\n      \n  <div class=\"vzb-dialog-content\">\n      <p class=\"vzb-dialog-sublabel\">\n        <%=t (\"buttons/opacityRegular\") %>\n      </p>\n      <div class=\"vzb-dialog-bubbleopacity-regular\"></div>\n\n      <p class=\"vzb-dialog-sublabel\">\n        <%=t (\"buttons/opacityNonselect\") %>\n      </p>\n      <div class=\"vzb-dialog-bubbleopacity-selectdim\"></div>\n    </div>\n  </div>\n\n</div>\n";

/***/ }),
/* 445 */
/***/ (function(module, exports) {

module.exports = "<div class='vzb-dialog-modal'>\n  <div class=\"vzb-dialog-title\"> \n      <%=t (\"dialogs/presentation\") %>\n  </div>\n      \n  <div class=\"vzb-dialog-content\">\n      <div class=\"vzb-presentationmode-switch\"></div>\n  </div>\n\n</div>\n";

/***/ }),
/* 446 */
/***/ (function(module, exports) {

module.exports = "<div class='vzb-dialog-modal'>\n  <span class=\"thumb-tack-class thumb-tack-class-ico-pin fa\" data-dialogtype=\"show\" data-click=\"pinDialog\"></span>\n  <span class=\"thumb-tack-class thumb-tack-class-ico-drag fa\" data-dialogtype=\"show\" data-click=\"dragDialog\"></span>\n  <div class=\"vzb-dialog-title\">\n    <%=t (\"buttons/show\") %>\n    <span class=\"vzb-dialog-content vzb-show-filter\">\n      <input class=\"vzb-show-search\" type=\"search\"/>\n    </span>\n  </div>\n  \n  <div class=\"vzb-dialog-content vzb-dialog-content-fixed vzb-dialog-scrollable\">\n    <p class=\"vzb-dialog-sublabel\"> <%=t (\"hints/mount/onlyshowthefollowing\") %> </p>\n    <div class=\"vzb-show-list\">\n      <!-- list will be placed here -->\n    </div>\n  </div>\n\n  <div class=\"vzb-dialog-buttons\">\n    <div class=\"vzb-dialog-button vzb-show-deselect\">\n      <%=t (\"buttons/showall\") %>\n    </div>\n\n    <div data-click=\"closeDialog\" class=\"vzb-dialog-button vzb-label-primary\">\n      <%=t (\"buttons/ok\") %>\n    </div>\n  </div>\n\n</div>\n";

/***/ }),
/* 447 */
/***/ (function(module, exports) {

module.exports = "<div class='vzb-dialog-modal'>\n  <span class=\"thumb-tack-class thumb-tack-class-ico-pin fa\" data-dialogtype=\"side\" data-click=\"pinDialog\"></span>\n  <span class=\"thumb-tack-class thumb-tack-class-ico-drag fa\" data-dialogtype=\"side\" data-click=\"dragDialog\"></span>\n  <div class=\"vzb-dialog-title\">\n    <%=t (\"buttons/side\") %>\n    <span class=\"vzb-side-selector\"></span>\n  </div>\n  \n  <div class=\"vzb-dialog-content vzb-dialog-scrollable\">\n    <div class=\"vzb-side-list vzb-side-list-left\">\n      <!-- list will be placed here -->\n    </div>\n    <div class=\"vzb-side-list vzb-side-list-right\">\n      <!-- list will be placed here -->\n    </div>\n  </div>\n\n  <div class=\"vzb-dialog-buttons\">\n    <div class=\"vzb-dialog-button vzb-label-primary vzb-side-switch-sides\">\n      <%=t (\"buttons/leftright\") %>\n    </div>\n\n    <div data-click=\"closeDialog\" class=\"vzb-dialog-button vzb-label-primary\">\n      <%=t (\"buttons/ok\") %>\n    </div>\n  </div>\n\n</div>\n";

/***/ }),
/* 448 */
/***/ (function(module, exports) {

module.exports = "<div class='vzb-dialog-modal'>\n  <span class=\"thumb-tack-class thumb-tack-class-ico-pin fa\" data-dialogtype=\"size\" data-click=\"pinDialog\"></span>\n  <span class=\"thumb-tack-class thumb-tack-class-ico-drag fa\" data-dialogtype=\"size\" data-click=\"dragDialog\"></span>\n  <div class=\"vzb-dialog-title\"> \n      <%=t (\"buttons/size\") %>\n      <span class=\"vzb-saxis-selector\"></span>\n  </div>\n      \n      \n  <div class=\"vzb-dialog-content\">\n    <div class=\"vzb-dialog-bubblesize\"></div>\n  </div>\n\n  <div class=\"vzb-dialog-buttons\">\n    <div data-click=\"closeDialog\" class=\"vzb-dialog-button vzb-label-primary\">\n      <%=t (\"buttons/ok\") %>\n    </div>\n  </div>\n\n</div>\n";

/***/ }),
/* 449 */
/***/ (function(module, exports) {

module.exports = "<div class='vzb-dialog-modal'>\n  <div class=\"vzb-dialog-title\"> \n      <%=t (\"buttons/speed\") %>\n  </div>\n      \n  <div class=\"vzb-dialog-content\">\n    <div class=\"vzb-dialog-placeholder\"></div>\n  </div>\n\n</div>\n";

/***/ }),
/* 450 */
/***/ (function(module, exports) {

module.exports = "<div class='vzb-dialog-modal'>\n    <span class=\"thumb-tack-class thumb-tack-class-ico-pin fa\" data-dialogtype=\"stack\" data-click=\"pinDialog\"></span>\n    <span class=\"thumb-tack-class thumb-tack-class-ico-drag fa\" data-dialogtype=\"stack\" data-click=\"dragDialog\"></span>\n    <div class=\"vzb-dialog-title\"><%=t (\"buttons/stack\") %></div>\n        \n    <div class=\"vzb-dialog-content vzb-dialog-scrollable\">\n        \n        <!--p class=\"vzb-dialog-sublabel\"> <%=t ( \"hints/mount/howtostack\") %></p-->\n        <form class=\"vzb-howtostack vzb-dialog-paragraph\">\n            <label> <input type=\"radio\" name=\"stack\" value=\"none\"> <%=t (\"mount/stacking/none\") %> </label>\n            <label> <input type=\"radio\" name=\"stack\" value=\"bycolor\"> <%=t (\"mount/stacking/color\") %> </label>\n            <label> <input type=\"radio\" name=\"stack\" value=\"all\"> <%=t (\"mount/stacking/world\") %> </label>\n        </form>\n        \n        <form class=\"vzb-howtomerge vzb-dialog-paragraph\">\n            <p class=\"vzb-dialog-sublabel\"> <%=t (\"hints/mount/howtomerge\") %> </p>\n            <label> <input type=\"radio\" name=\"merge\" value=\"none\"> <%=t (\"mount/merging/none\") %> </label>\n            <label> <input type=\"radio\" name=\"merge\" value=\"grouped\"> <%=t (\"mount/merging/color\") %> </label>\n            <label> <input type=\"radio\" name=\"merge\" value=\"stacked\"> <%=t (\"mount/merging/world\") %> </label>\n        </form>\n        \n        <form class=\"vzb-manual-sorting\">\n            <p class=\"vzb-dialog-sublabel\"> <%=t (\"mount/manualSorting\") %> </p>\n            <div class=\"vzb-dialog-draggablelist vzb-dialog-control\"></div>\n        </form>\n                \n    </div>\n\n    <div class=\"vzb-dialog-buttons\">\n        <div data-click=\"closeDialog\" class=\"vzb-dialog-button vzb-label-primary\"><%=t (\"buttons/ok\") %></div>\n    </div>\n\n</div>";

/***/ }),
/* 451 */
/***/ (function(module, exports) {

module.exports = "<div class=\"vzb-dialog-modal\">\n  <div class=\"vzb-dialog-content vzb-dialog-content-fixed\">\n    <svg>\n      <g class=\"vzb-timedisplay\"></g>\n    </svg>\n  </div>\n  <div class=\"vzb-dialog-buttons\"></div>\n</div>\n";

/***/ }),
/* 452 */
/***/ (function(module, exports) {

module.exports = "<div class='vzb-dialog-modal'>\n  <span class=\"thumb-tack-class thumb-tack-class-ico-pin fa\" data-dialogtype=\"label\" data-click=\"pinDialog\"></span>\n  <span class=\"thumb-tack-class thumb-tack-class-ico-drag fa\" data-dialogtype=\"label\" data-click=\"dragDialog\"></span>\n  <div class=\"vzb-dialog-title\"> \n    <%=t (\"buttons/zoom\") %>\n    <div class=\"vzb-dialog-zoom-buttonlist\"></div>\n  </div>\n      \n      \n  <div class=\"vzb-dialog-content\">\n    <div class=\"vzb-panwitharrow-switch\"></div>\n    <div class=\"vzb-zoomonscrolling-switch\"></div>\n    <div class=\"vzb-adaptminmaxzoom-switch\"></div>\n  </div>\n\n  <div class=\"vzb-dialog-buttons\">\n    <div data-click=\"closeDialog\" class=\"vzb-dialog-button vzb-label-primary\">\n      <%=t (\"buttons/ok\") %>\n    </div>\n  </div>\n\n</div>\n";

/***/ }),
/* 453 */
/***/ (function(module, exports) {

module.exports = "<div class=\"vzb-mmi-holder\">\n\n    <span class=\"vzb-mmi-domainmin-label\"></span>\n    <input type=\"text\" class=\"vzb-mmi-domainmin\" name=\"min\">\n    <span class=\"vzb-mmi-domainmax-label\"></span>\n    <input type=\"text\" class=\"vzb-mmi-domainmax\" name=\"max\">\n\n    <br class=\"vzb-mmi-break\"/>\n\n    <span class=\"vzb-mmi-zoomedmin-label\"></span>\n    <input type=\"text\" class=\"vzb-mmi-zoomedmin\" name=\"min\">\n    <span class=\"vzb-mmi-zoomedmax-label\"></span>\n    <input type=\"text\" class=\"vzb-mmi-zoomedmax\" name=\"max\">\n    \n</div>";

/***/ }),
/* 454 */
/***/ (function(module, exports) {

module.exports = "<div class=\"vzb-szs-holder\">\n\t<svg class=\"vzb-szs-svg\">\n\t\t<g class=\"vzb-szs-slider-wrap\">\n\t\t\t<g class=\"vzb-szs-slider\">\n\t\t\t</g>\n\t\t</g>\n\t</svg>\n</div>\n";

/***/ }),
/* 455 */
/***/ (function(module, exports) {

module.exports = "<div class=\"vzb-stepped-speed-slider\">\n  <svg>\n    <g class=\"vzb-stepped-speed-slider-triangle\"></g>\n    <g class=\"vzb-stepped-speed-slider-axis\"></g>\n  </svg>\n</div>\n";

/***/ }),
/* 456 */
/***/ (function(module, exports) {

module.exports = "<div class=\"vzb-timeslider vzb-ts-loading\">\n  <div class=\"vzb-ts-slider-wrapper\">\n    <svg class=\"vzb-ts-slider\">\n      <g>\n        <g class=\"vzb-ts-slider-axis\"></g>\n        <g class=\"vzb-ts-slider-progress\"></g>\n        <g class=\"vzb-ts-slider-select\"></g>\n        <circle class=\"vzb-ts-slider-handle\"></circle>\n        <text class=\"vzb-ts-slider-value\"></text>\n        <line class=\"vzb-ts-slider-slide\"></line>\n      </g>\n      </svg>\n  </div>\n\n  <!-- SVG VIZABI ICONS\n       source: https://github.com/encharm/Font-Awesome-SVG-PNG/ -->\n  <div class=\"vzb-ts-btns\">\n    <button class=\"vzb-ts-btn-loading vzb-ts-btn\">\n      <div class='vzb-loader'></div>\n    </button>\n    <button class=\"vzb-ts-btn-play vzb-ts-btn\">\n      <svg class=\"vzb-icon vzb-icon-play\" viewBox=\"3 3 42 42\"\n           xmlns=\"http://www.w3.org/2000/svg\">\n        <path xmlns=\"http://www.w3.org/2000/svg\" d=\"M24 4C12.95 4 4 12.95 4 24s8.95 20 20 20 20-8.95 20-20S35.05 4 24 4zm-4 29V15l12 9-12 9z\"/>\n      </svg>\n    </button>\n    <button class=\"vzb-ts-btn-pause vzb-ts-btn\">\n      <svg class=\"vzb-icon vzb-icon-pause\" viewBox=\"3 3 42 42\"\n           xmlns=\"http://www.w3.org/2000/svg\">\n        <path xmlns=\"http://www.w3.org/2000/svg\" d=\"M24 4C12.95 4 4 12.95 4 24s8.95 20 20 20 20-8.95 20-20S35.05 4 24 4zm-2 28h-4V16h4v16zm8 0h-4V16h4v16z\"/>\n      </svg>\n    </button>\n  </div>\n</div>\n";

/***/ }),
/* 457 */
/***/ (function(module, exports) {

module.exports = "<!-- Bar Chart Component -->\n<svg class=\"vzb-agepyramid\">\n  <g class=\"vzb-bc-header\">\n    <g class=\"vzb-bc-axis-x-title\"></g>\n    <g class=\"vzb-bc-axis-x-info vzb-noexport\"></g>\n    <text class=\"vzb-bc-title\"></text>\n    <text class=\"vzb-bc-title vzb-bc-title-right\"></text>\n    <text class=\"vzb-bc-year\"></text>\n  </g>\n  <g class=\"vzb-bc-graph\">\n\n    <g class=\"vzb-bc-axis-y-title\"></g>\n\n    <g class=\"vzb-bc-axis-y\"></g>\n\n    <svg class=\"vzb-bc-bars-crop\">\n      <g class=\"vzb-bc-bars\"></g>\n    </svg>\n\n    <g class=\"vzb-bc-axis-x\"></g>\n    <g class=\"vzb-bc-axis-x vzb-bc-axis-x-left\"></g>\n\n    <svg class=\"vzb-bc-labels-crop\">\n      <g class=\"vzb-bc-labels\"></g>        \n    </svg>\n\n    <g class=\"vzb-bc-axis-labels\">\n      <!-- <text class=\"vzb-x_label\">Lifespan</text>\n            <text class=\"vzb-y_label\">Lifespan</text> -->\n    </g>\n  </g>\n</svg>\n";

/***/ }),
/* 458 */
/***/ (function(module, exports) {

module.exports = "<!-- Axis Labeler Component -->\n<svg class=\"vzb-axislabeler\">\n  <g class=\"vzb-al-graph\">\n\n    <g class=\"vzb-al-axis-x\"></g>\n    <g class=\"vzb-al-axis-y\"></g>\n\n  </g>\n</svg>\n";

/***/ }),
/* 459 */
/***/ (function(module, exports) {

module.exports = "<!-- Bar Chart Component -->\n<svg class=\"vzb-barchart\">\n  <g class=\"vzb-bc-graph\">\n    <g class=\"vzb-bc-bars\"></g>\n    <g class=\"vzb-bc-bar-labels\"></g>\n\n    <g class=\"vzb-bc-axis-y-title\"></g>\n    <text class=\"vzb-bc-year\"></text>\n    <g class=\"vzb-bc-axis-x-title\"></g>\n\n    <g class=\"vzb-bc-axis-x\"></g>\n    <g class=\"vzb-bc-axis-y\"></g>\n\n    <g class=\"vzb-bc-axis-labels\">\n      <!-- <text class=\"vzb-x_label\">Lifespan</text>\n            <text class=\"vzb-y_label\">Lifespan</text> -->\n    </g>\n  </g>\n</svg>\n";

/***/ }),
/* 460 */
/***/ (function(module, exports) {

module.exports = "<!-- Bar Chart Component -->\n<div class=\"vzb-barrankchart\">\n  <svg class=\"vzb-br-header\">\n    <g class=\"vzb-br-title\">\n      <text></text>\n    </g>\n    <g class=\"vzb-br-total\">\n      <text></text>\n    </g>\n    <g class=\"vzb-br-axis-info vzb-noexport\"></g>\n  </svg>\n\n  <div class=\"vzb-br-barsviewport vzb-dialog-scrollable\">\n    <svg class=\"vzb-br-bars-svg\">\n      <g class=\"vzb-br-bars\"></g>\n    </svg>\n  </div>\n\n  <svg class=\"vzb-data-warning-svg\">\n    <g class=\"vzb-data-warning vzb-noexport\">\n      <svg></svg>\n      <text></text>\n    </g>\n  </svg>\n</div>\n";

/***/ }),
/* 461 */
/***/ (function(module, exports) {

module.exports = "<!-- Bubble Chart Component -->\n<div class=\"vzb-bubblechart\">\n  <svg class=\"vzb-bubblechart-svg vzb-export\">\n    <g class=\"vzb-bc-graph\">\n      <g class=\"vzb-bc-year\"></g>\n\n      <svg class=\"vzb-bc-axis-x\"><g></g></svg>\n      <svg class=\"vzb-bc-axis-y\"><g></g></svg>\n      <line class=\"vzb-bc-projection-x\"></line>\n      <line class=\"vzb-bc-projection-y\"></line>\n\n      <svg class=\"vzb-bc-bubbles-crop\">\n      <g class=\"vzb-zoom-selection\"></g>\n        <line class=\"vzb-bc-line-equal-xy vzb-invisible\"></line>\n        <rect class=\"vzb-bc-eventarea\"></rect>\n        <g class=\"vzb-bc-trails\"></g>\n        <g class=\"vzb-bc-bubbles\"></g>\n        <g class=\"vzb-bc-lines\"></g>\n        <g class=\"vzb-bc-bubble-crown vzb-hidden\">\n          <circle class=\"vzb-crown-glow\"></circle>\n          <circle class=\"vzb-crown\"></circle>\n        </g>        \n      </svg>        \n\n      <g class=\"vzb-bc-axis-y-title\"></g>\n      <g class=\"vzb-bc-axis-x-title\"></g>\n      <g class=\"vzb-bc-axis-s-title\"></g>\n      <g class=\"vzb-bc-axis-c-title\"></g>\n\n      <g class=\"vzb-bc-axis-y-info vzb-noexport\"></g>\n      <g class=\"vzb-bc-axis-x-info vzb-noexport\"></g>\n      \n      <svg class=\"vzb-bc-labels-crop\">\n        <g class=\"vzb-bc-labels\"></g>        \n      </svg>       \n\n      <g class=\"vzb-data-warning vzb-noexport\">\n        <svg></svg>\n        <text></text>\n      </g>\n\n      <rect class=\"vzb-bc-zoom-rect\"></rect>\n      <g class=\"vzb-bc-tooltip vzb-hidden\">\n        <rect class=\"vzb-tooltip-glow\"></rect>\n        <rect class=\"vzb-tooltip-border\"></rect>\n        <text class=\"vzb-tooltip-text\"></text>\n      </g>\n    </g>\n  </svg>\n  <svg>\n    <defs>\n      <filter id=\"vzb-glow-filter\" x=\"-50%\" y=\"-50%\" width=\"200%\" height=\"200%\">\n        <feGaussianBlur in=\"SourceGraphic\" stdDeviation=\"2\"></feGaussianBlur>\n      </filter>\n    </defs>\n  </svg>\n  <!-- This could possibly be another component -->\n  <div class=\"vzb-tooltip vzb-hidden vzb-tooltip-mobile\"></div>\n</div>\n";

/***/ }),
/* 462 */
/***/ (function(module, exports) {

module.exports = "<!-- Bubble Map Chart Component -->\n<div class=\"vzb-bubblemap\">\n  <svg class=\"vzb-bmc-map-background vzb-export\">\n    <g class=\"vzb-bmc-map-graph\"></g>\n  </svg>\n  <svg class=\"vzb-bubblemap-svg vzb-export\">\n    <g class=\"vzb-bmc-graph\">\n      <g class=\"vzb-bmc-year\"></g>\n\n      <g class=\"vzb-bmc-lines\"></g>\n      <g class=\"vzb-bmc-bubbles\"></g>\n      <g class=\"vzb-bmc-bubble-labels\"></g>\n\n\n      <g class=\"vzb-bmc-axis-y-title\">\n          <text></text>\n      </g>\n        \n      <g class=\"vzb-bmc-axis-c-title\">\n          <text></text>\n      </g>\n\n      <g class=\"vzb-bmc-axis-y-info vzb-noexport\">\n      </g>\n\n      <g class=\"vzb-bmc-axis-c-info vzb-noexport\">\n      </g>\n\n      <g class=\"vzb-data-warning vzb-noexport\">\n        <svg></svg>\n        <text></text>\n      </g>\n      <g class=\"vzb-bmc-labels\"></g>\n\n      <g class=\"vzb-bmc-tooltip vzb-hidden\">\n        <rect class=\"vzb-tooltip-border\"></rect>\n        <text class=\"vzb-tooltip-text\"></text>\n      </g>\n    </g>\n  </svg>\n</div>\n";

/***/ }),
/* 463 */
/***/ (function(module, exports) {

module.exports = "<!-- Cartogram Component -->\n<div class=\"vzb-cartogram\">\n  \n  <svg class=\"vzb-cartogram-svg\">\n    <g class=\"vzb-ct-graph\">\n      <g class=\"vzb-ct-year\"></g>\n      <svg class=\"vzb-ct-map-background vzb-export\">\n        <g class=\"vzb-ct-map-graph\"></g>\n      </svg>\n      <svg class=\"vzb-ct-labels-crop\">\n        <g class=\"vzb-ct-labels\">\n          <line class=\"vzb-ct-vertical-now\"></line>\n        </g>\n      </svg>\n\n      <g class=\"vzb-ct-axis-y-title\"><text></text></g>\n      <g class=\"vzb-ct-axis-c-title\"><text></text></g>\n      <g class=\"vzb-ct-axis-y-info\"></g>\n      <g class=\"vzb-ct-axis-c-info\"></g>\n      <g class=\"vzb-ct-tooltip vzb-hidden\">\n        <rect class=\"vzb-tooltip-border\"></rect>\n        <text class=\"vzb-tooltip-text\"></text>\n\n      </g>\n\n      <g class=\"vzb-data-warning vzb-noexport\">\n        <svg></svg>\n        <text></text>\n      </g>\n    </g>\n  </svg>\n</div>\n";

/***/ }),
/* 464 */
/***/ (function(module, exports) {

module.exports = "<!-- Bubble Map Chart Component -->\n<div class=\"vzb-bubblemap\">\n  <div id=\"vzb-map-background\"></div>\n  <svg class=\"vzb-bmc-map-background vzb-export\"></svg>\n  <svg class=\"vzb-bubblemap-svg vzb-export\">\n    <g class=\"vzb-bmc-graph\">\n      <g class=\"vzb-bmc-year\"></g>\n\n      <g class=\"vzb-bmc-lines\"></g>\n      <g class=\"vzb-bmc-bubbles\"></g>\n      <g class=\"vzb-bmc-bubble-labels\"></g>\n\n\n      <g class=\"vzb-bmc-axis-y-title\">\n          <text></text>\n      </g>\n        \n      <g class=\"vzb-bmc-axis-c-title\">\n          <text></text>\n      </g>\n\n      <g class=\"vzb-bmc-axis-y-info vzb-noexport\">\n      </g>\n\n      <g class=\"vzb-bmc-axis-c-info vzb-noexport\">\n      </g>\n\n      <g class=\"vzb-data-warning vzb-noexport\">\n        <svg></svg>\n        <text></text>\n      </g>\n      <g class=\"vzb-bmc-labels\"></g>\n\n      <g class=\"vzb-bmc-tooltip vzb-hidden\">\n        <rect class=\"vzb-tooltip-border\"></rect>\n        <text class=\"vzb-tooltip-text\"></text>\n      </g>\n    </g>\n  </svg>\n</div>\n";

/***/ }),
/* 465 */
/***/ (function(module, exports) {

module.exports = "<!-- Line Chart Component -->\n<div class=\"vzb-linechart\">\n  <svg class=\"vzb-linechart-svg\">\n    <g class=\"vzb-lc-graph\">\n\n      <svg class=\"vzb-lc-axis-x\"><g></g></svg>\n      <svg class=\"vzb-lc-axis-y\"><g></g></svg>\n      <text class=\"vzb-lc-axis-x-value\"></text>\n      <text class=\"vzb-lc-axis-y-value\"></text>\n      <svg class=\"vzb-lc-lines-crop\">\n        <svg class=\"vzb-lc-lines\"></svg>\n        <line class=\"vzb-lc-projection-x\"></line>\n        <line class=\"vzb-lc-projection-y\"></line>\n      </svg>\n      <svg class=\"vzb-lc-labels-crop\">\n        <g class=\"vzb-lc-labels\">\n          <line class=\"vzb-lc-vertical-now\"></line>\n        </g>\n      </svg>\n\n      <g class=\"vzb-lc-axis-y-title\"></g>\n      <g class=\"vzb-lc-axis-x-title\"></g>\n      <g class=\"vzb-lc-axis-y-info\"></g>\n\n      <g class=\"vzb-data-warning vzb-noexport\">\n        <svg></svg>\n        <text></text>\n      </g>\n\n      \n      <!--filter id=\"vzb-lc-filter-dropshadow\"> \n        <feOffset result=\"offOut\" in=\"SourceGraphic\" dx=\"0\" dy=\"2\" />\n        <feColorMatrix result = \"matrixOut\" in = \"offOut\" type = \"matrix\"\n                       values = \"0.3 .0 .0 .0 .0\n                                 .0 .3 .0 .0 .0\n                                 .0 .0 .3 .0 .0\n                                 1.0 1.0 1.0 1.0 .0\"/>\n        <feGaussianBlur result=\"blurOut\" in=\"matrixOut\" stdDeviation=\"0.8\" />\n        <feBlend in=\"SourceGraphic\" in2=\"blurOut\" mode=\"normal\" />\n      </filter-->\n\n    </g>\n  </svg>\n  <div class=\"vzb-tooltip vzb-hidden\"></div>\n</div>\n";

/***/ }),
/* 466 */
/***/ (function(module, exports) {

module.exports = "<!-- Mountain Chart Template -->\n<div class=\"vzb-mountainchart\">\n  <svg class=\"vzb-mountainchart-svg vzb-export\">\n        <g class=\"vzb-mc-graph\">\n            <rect class=\"vzb-mc-eventarea\"></rect>\n            <g class=\"vzb-mc-year\"></g>\n\n            <g class=\"vzb-mc-mountains-mergestacked\"></g>\n            <g class=\"vzb-mc-mountains-mergegrouped\"></g>\n            <g class=\"vzb-mc-mountains\"></g>\n            <g class=\"vzb-mc-mountains-labels\"></g>\n\n\n            <g class=\"vzb-mc-axis-y-title\">\n                <text></text>\n            </g>\n\n            <g class=\"vzb-mc-axis-x-title\">\n                <text></text>\n            </g>\n\n            <g class=\"vzb-mc-axis-info vzb-noexport\">\n            </g>\n\n            <g class=\"vzb-data-warning vzb-noexport\">\n                <svg></svg>\n                <text></text>\n            </g>\n\n            <g class=\"vzb-mc-axis-x\"></g>\n\n            <g class=\"vzb-mc-axis-labels\"></g>\n            <g class=\"vzb-mc-probe\">\n                <text class=\"vzb-shadow vzb-mc-probe-value-ul\"></text>\n                <text class=\"vzb-shadow vzb-mc-probe-value-ur\"></text>\n                <text class=\"vzb-shadow vzb-mc-probe-value-dl\"></text>\n                <text class=\"vzb-shadow vzb-mc-probe-value-dr\"></text>\n                <text class=\"vzb-mc-probe-value-ul\"></text>\n                <text class=\"vzb-mc-probe-value-ur\"></text>\n                <text class=\"vzb-mc-probe-value-dl\"></text>\n                <text class=\"vzb-mc-probe-value-dr\"></text>\n                <text class=\"vzb-mc-probe-extremepoverty\"></text>\n                <line></line>\n            </g>\n\n            <g class=\"vzb-mc-tooltip vzb-hidden\">\n                <rect class=\"vzb-tooltip-border\"></rect>\n                <text class=\"vzb-tooltip-text\"></text>\n            </g>\n        </g>\n  </svg>\n</div>\n";

/***/ }),
/* 467 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 468 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 469 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer, global) {var require;var require;(function(f){if(true){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.mapboxgl = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";function serializePaintVertexArrays(r,e){var t={};for(var a in r){var n=r[a].paintVertexArray;if(0!==n.length){var i=n.serialize(e),s=n.constructor.serialize();t[a]={array:i,type:s}}}return t}var ProgramConfiguration=require("./program_configuration"),Segment=function(r,e){this.vertexOffset=r,this.primitiveOffset=e,this.vertexLength=0,this.primitiveLength=0},ArrayGroup=function(r,e,t){var a=this;this.globalProperties={zoom:t};var n=r.layoutVertexArrayType;this.layoutVertexArray=new n;var i=r.elementArrayType;i&&(this.elementArray=new i);var s=r.elementArrayType2;s&&(this.elementArray2=new s),this.layerData={};for(var y=0,o=e;y<o.length;y+=1){var l=o[y],h=ProgramConfiguration.createDynamic(r.paintAttributes||[],l,t);a.layerData[l.id]={layer:l,programConfiguration:h,paintVertexArray:new h.PaintVertexArray}}this.segments=[],this.segments2=[]};ArrayGroup.prototype.prepareSegment=function(r){var e=this.segments[this.segments.length-1];return(!e||e.vertexLength+r>ArrayGroup.MAX_VERTEX_ARRAY_LENGTH)&&(e=new Segment(this.layoutVertexArray.length,this.elementArray.length),this.segments.push(e)),e},ArrayGroup.prototype.prepareSegment2=function(r){var e=this.segments2[this.segments2.length-1];return(!e||e.vertexLength+r>ArrayGroup.MAX_VERTEX_ARRAY_LENGTH)&&(e=new Segment(this.layoutVertexArray.length,this.elementArray2.length),this.segments2.push(e)),e},ArrayGroup.prototype.populatePaintArrays=function(r){var e=this;for(var t in this.layerData){var a=e.layerData[t];0!==a.paintVertexArray.bytesPerElement&&a.programConfiguration.populatePaintArray(a.layer,a.paintVertexArray,e.layoutVertexArray.length,e.globalProperties,r)}},ArrayGroup.prototype.isEmpty=function(){return 0===this.layoutVertexArray.length},ArrayGroup.prototype.serialize=function(r){return{layoutVertexArray:this.layoutVertexArray.serialize(r),elementArray:this.elementArray&&this.elementArray.serialize(r),elementArray2:this.elementArray2&&this.elementArray2.serialize(r),paintVertexArrays:serializePaintVertexArrays(this.layerData,r),segments:this.segments,segments2:this.segments2}},ArrayGroup.MAX_VERTEX_ARRAY_LENGTH=Math.pow(2,16)-1,module.exports=ArrayGroup;
},{"./program_configuration":15}],2:[function(require,module,exports){
"use strict";var ArrayGroup=require("./array_group"),BufferGroup=require("./buffer_group"),util=require("../util/util"),Bucket=function(r,e){this.zoom=r.zoom,this.overscaling=r.overscaling,this.layers=r.layers,this.index=r.index,r.arrays?this.buffers=new BufferGroup(e,r.layers,r.zoom,r.arrays):this.arrays=new ArrayGroup(e,r.layers,r.zoom)};Bucket.prototype.populate=function(r,e){for(var t=this,i=0,u=r;i<u.length;i+=1){var a=u[i];t.layers[0].filter(a)&&(t.addFeature(a),e.featureIndex.insert(a,t.index))}},Bucket.prototype.isEmpty=function(){return this.arrays.isEmpty()},Bucket.prototype.serialize=function(r){return{zoom:this.zoom,layerIds:this.layers.map(function(r){return r.id}),arrays:this.arrays.serialize(r)}},Bucket.prototype.destroy=function(){this.buffers&&(this.buffers.destroy(),this.buffers=null)},module.exports=Bucket,Bucket.deserialize=function(r,e){if(e){for(var t={},i=0,u=r;i<u.length;i+=1){var a=u[i],o=a.layerIds.map(function(r){return e.getLayer(r)}).filter(Boolean);if(0!==o.length)for(var s=o[0].createBucket(util.extend({layers:o},a)),n=0,f=o;n<f.length;n+=1){var l=f[n];t[l.id]=s}}return t}};
},{"../util/util":129,"./array_group":1,"./buffer_group":9}],3:[function(require,module,exports){
"use strict";function addCircleVertex(e,r,t,a,p){e.emplaceBack(2*r+(a+1)/2,2*t+(p+1)/2)}var Bucket=require("../bucket"),createVertexArrayType=require("../vertex_array_type"),createElementArrayType=require("../element_array_type"),loadGeometry=require("../load_geometry"),EXTENT=require("../extent"),circleInterface={layoutVertexArrayType:createVertexArrayType([{name:"a_pos",components:2,type:"Int16"}]),elementArrayType:createElementArrayType(),paintAttributes:[{property:"circle-color",type:"Uint8"},{property:"circle-radius",type:"Uint16",multiplier:10},{property:"circle-blur",type:"Uint16",multiplier:10},{property:"circle-opacity",type:"Uint8",multiplier:255},{property:"circle-stroke-color",type:"Uint8"},{property:"circle-stroke-width",type:"Uint16",multiplier:10},{property:"circle-stroke-opacity",type:"Uint8",multiplier:255}]},CircleBucket=function(e){function r(r){e.call(this,r,circleInterface)}return e&&(r.__proto__=e),r.prototype=Object.create(e&&e.prototype),r.prototype.constructor=r,r.prototype.addFeature=function(e){for(var r=this.arrays,t=0,a=loadGeometry(e);t<a.length;t+=1)for(var p=a[t],c=0,i=p;c<i.length;c+=1){var y=i[c],l=y.x,o=y.y;if(!(l<0||l>=EXTENT||o<0||o>=EXTENT)){var n=r.prepareSegment(4),u=n.vertexLength;addCircleVertex(r.layoutVertexArray,l,o,-1,-1),addCircleVertex(r.layoutVertexArray,l,o,1,-1),addCircleVertex(r.layoutVertexArray,l,o,1,1),addCircleVertex(r.layoutVertexArray,l,o,-1,1),r.elementArray.emplaceBack(u,u+1,u+2),r.elementArray.emplaceBack(u,u+3,u+2),n.vertexLength+=4,n.primitiveLength+=2}}r.populatePaintArrays(e.properties)},r}(Bucket);module.exports=CircleBucket;
},{"../bucket":2,"../element_array_type":10,"../extent":11,"../load_geometry":13,"../vertex_array_type":17}],4:[function(require,module,exports){
"use strict";var Bucket=require("../bucket"),createVertexArrayType=require("../vertex_array_type"),createElementArrayType=require("../element_array_type"),loadGeometry=require("../load_geometry"),earcut=require("earcut"),classifyRings=require("../../util/classify_rings"),EARCUT_MAX_RINGS=500,fillInterface={layoutVertexArrayType:createVertexArrayType([{name:"a_pos",components:2,type:"Int16"}]),elementArrayType:createElementArrayType(3),elementArrayType2:createElementArrayType(2),paintAttributes:[{property:"fill-color",type:"Uint8"},{property:"fill-outline-color",type:"Uint8"},{property:"fill-opacity",type:"Uint8",multiplier:255}]},FillBucket=function(e){function r(r){e.call(this,r,fillInterface)}return e&&(r.__proto__=e),r.prototype=Object.create(e&&e.prototype),r.prototype.constructor=r,r.prototype.addFeature=function(e){for(var r=this.arrays,t=0,a=classifyRings(loadGeometry(e),EARCUT_MAX_RINGS);t<a.length;t+=1){for(var l=a[t],p=0,n=0,y=l;n<y.length;n+=1){var o=y[n];p+=o.length}for(var i=r.prepareSegment(p),c=i.vertexLength,u=[],h=[],s=0,g=l;s<g.length;s+=1){var m=g[s];if(0!==m.length){m!==l[0]&&h.push(u.length/2);var f=r.prepareSegment2(m.length),A=f.vertexLength;r.layoutVertexArray.emplaceBack(m[0].x,m[0].y),r.elementArray2.emplaceBack(A+m.length-1,A),u.push(m[0].x),u.push(m[0].y);for(var v=1;v<m.length;v++)r.layoutVertexArray.emplaceBack(m[v].x,m[v].y),r.elementArray2.emplaceBack(A+v-1,A+v),u.push(m[v].x),u.push(m[v].y);f.vertexLength+=m.length,f.primitiveLength+=m.length}}for(var x=earcut(u,h),_=0;_<x.length;_+=3)r.elementArray.emplaceBack(c+x[_],c+x[_+1],c+x[_+2]);i.vertexLength+=p,i.primitiveLength+=x.length/3}r.populatePaintArrays(e.properties)},r}(Bucket);module.exports=FillBucket;
},{"../../util/classify_rings":113,"../bucket":2,"../element_array_type":10,"../load_geometry":13,"../vertex_array_type":17,"earcut":136}],5:[function(require,module,exports){
"use strict";function addVertex(e,r,t,a,n,y,o,i){e.emplaceBack(r,t,2*Math.floor(a*FACTOR)+o,n*FACTOR*2,y*FACTOR*2,Math.round(i))}function isBoundaryEdge(e,r){return e.x===r.x&&(e.x<0||e.x>EXTENT)||e.y===r.y&&(e.y<0||e.y>EXTENT)}var Bucket=require("../bucket"),createVertexArrayType=require("../vertex_array_type"),createElementArrayType=require("../element_array_type"),loadGeometry=require("../load_geometry"),EXTENT=require("../extent"),earcut=require("earcut"),classifyRings=require("../../util/classify_rings"),EARCUT_MAX_RINGS=500,fillExtrusionInterface={layoutVertexArrayType:createVertexArrayType([{name:"a_pos",components:2,type:"Int16"},{name:"a_normal",components:3,type:"Int16"},{name:"a_edgedistance",components:1,type:"Int16"}]),elementArrayType:createElementArrayType(3),paintAttributes:[{property:"fill-extrusion-base",type:"Uint16"},{property:"fill-extrusion-height",type:"Uint16"},{property:"fill-extrusion-color",type:"Uint8"}]},FACTOR=Math.pow(2,13),FillExtrusionBucket=function(e){function r(r){e.call(this,r,fillExtrusionInterface)}return e&&(r.__proto__=e),r.prototype=Object.create(e&&e.prototype),r.prototype.constructor=r,r.prototype.addFeature=function(e){for(var r=this.arrays,t=0,a=classifyRings(loadGeometry(e),EARCUT_MAX_RINGS);t<a.length;t+=1){for(var n=a[t],y=0,o=0,i=n;o<i.length;o+=1){var l=i[o];y+=l.length}for(var p=r.prepareSegment(5*y),u=[],c=[],x=[],s=0,d=n;s<d.length;s+=1){var h=d[s];if(0!==h.length){h!==n[0]&&c.push(u.length/2);for(var m=0,f=0;f<h.length;f++){var A=h[f];if(addVertex(r.layoutVertexArray,A.x,A.y,0,0,1,1,0),x.push(p.vertexLength++),f>=1){var g=h[f-1];if(!isBoundaryEdge(A,g)){var _=A.sub(g)._perp()._unit();addVertex(r.layoutVertexArray,A.x,A.y,_.x,_.y,0,0,m),addVertex(r.layoutVertexArray,A.x,A.y,_.x,_.y,0,1,m),m+=g.dist(A),addVertex(r.layoutVertexArray,g.x,g.y,_.x,_.y,0,0,m),addVertex(r.layoutVertexArray,g.x,g.y,_.x,_.y,0,1,m);var v=p.vertexLength;r.elementArray.emplaceBack(v,v+1,v+2),r.elementArray.emplaceBack(v+1,v+2,v+3),p.vertexLength+=4,p.primitiveLength+=2}}u.push(A.x),u.push(A.y)}}}for(var T=earcut(u,c),E=0;E<T.length;E+=3)r.elementArray.emplaceBack(x[T[E]],x[T[E+1]],x[T[E+2]]);p.primitiveLength+=T.length/3}r.populatePaintArrays(e.properties)},r}(Bucket);module.exports=FillExtrusionBucket;
},{"../../util/classify_rings":113,"../bucket":2,"../element_array_type":10,"../extent":11,"../load_geometry":13,"../vertex_array_type":17,"earcut":136}],6:[function(require,module,exports){
"use strict";function addLineVertex(e,t,r,i,a,n,d){e.emplaceBack(t.x<<1|i,t.y<<1|a,Math.round(EXTRUDE_SCALE*r.x)+128,Math.round(EXTRUDE_SCALE*r.y)+128,(0===n?0:n<0?-1:1)+1|(d*LINE_DISTANCE_SCALE&63)<<2,d*LINE_DISTANCE_SCALE>>6)}var Bucket=require("../bucket"),createVertexArrayType=require("../vertex_array_type"),createElementArrayType=require("../element_array_type"),loadGeometry=require("../load_geometry"),EXTENT=require("../extent"),EXTRUDE_SCALE=63,COS_HALF_SHARP_CORNER=Math.cos(37.5*(Math.PI/180)),SHARP_CORNER_OFFSET=15,LINE_DISTANCE_BUFFER_BITS=15,LINE_DISTANCE_SCALE=.5,MAX_LINE_DISTANCE=Math.pow(2,LINE_DISTANCE_BUFFER_BITS-1)/LINE_DISTANCE_SCALE,lineInterface={layoutVertexArrayType:createVertexArrayType([{name:"a_pos",components:2,type:"Int16"},{name:"a_data",components:4,type:"Uint8"}]),paintAttributes:[{property:"line-color",type:"Uint8"},{property:"line-blur",multiplier:10,type:"Uint8"},{property:"line-opacity",multiplier:10,type:"Uint8"},{property:"line-gap-width",multiplier:10,type:"Uint8",name:"a_gapwidth"},{property:"line-offset",multiplier:1,type:"Int8"}],elementArrayType:createElementArrayType()},LineBucket=function(e){function t(t){e.call(this,t,lineInterface)}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.addFeature=function(e){for(var t=this,r=this.layers[0].layout,i=r["line-join"],a=r["line-cap"],n=r["line-miter-limit"],d=r["line-round-limit"],s=0,u=loadGeometry(e,LINE_DISTANCE_BUFFER_BITS);s<u.length;s+=1){var l=u[s];t.addLine(l,e.properties,i,a,n,d)}},t.prototype.addLine=function(e,t,r,i,a,n){for(var d=this,s=e.length;s>2&&e[s-1].equals(e[s-2]);)s--;if(!(e.length<2)){"bevel"===r&&(a=1.05);var u=SHARP_CORNER_OFFSET*(EXTENT/(512*this.overscaling)),l=e[0],p=e[s-1],o=l.equals(p),c=this.arrays,_=c.prepareSegment(10*s);if(2!==s||!o){this.distance=0;var h,y,m,E,x,C,A,v=i,f=o?"butt":i,L=!0;this.e1=this.e2=this.e3=-1,o&&(h=e[s-2],x=l.sub(h)._unit()._perp());for(var S=0;S<s;S++)if(m=o&&S===s-1?e[1]:e[S+1],!m||!e[S].equals(m)){x&&(E=x),h&&(y=h),h=e[S],x=m?m.sub(h)._unit()._perp():E,E=E||x;var V=E.add(x);0===V.x&&0===V.y||V._unit();var T=V.x*x.x+V.y*x.y,I=0!==T?1/T:1/0,N=T<COS_HALF_SHARP_CORNER&&y&&m;if(N&&S>0){var b=h.dist(y);if(b>2*u){var R=h.sub(h.sub(y)._mult(u/b)._round());d.distance+=R.dist(y),d.addCurrentVertex(R,d.distance,E.mult(1),0,0,!1,_),y=R}}var g=y&&m,B=g?r:m?v:f;if(g&&"round"===B&&(I<n?B="miter":I<=2&&(B="fakeround")),"miter"===B&&I>a&&(B="bevel"),"bevel"===B&&(I>2&&(B="flipbevel"),I<a&&(B="miter")),y&&(d.distance+=h.dist(y)),"miter"===B)V._mult(I),d.addCurrentVertex(h,d.distance,V,0,0,!1,_);else if("flipbevel"===B){if(I>100)V=x.clone().mult(-1);else{var F=E.x*x.y-E.y*x.x>0?-1:1,k=I*E.add(x).mag()/E.sub(x).mag();V._perp()._mult(k*F)}d.addCurrentVertex(h,d.distance,V,0,0,!1,_),d.addCurrentVertex(h,d.distance,V.mult(-1),0,0,!1,_)}else if("bevel"===B||"fakeround"===B){var D=E.x*x.y-E.y*x.x>0,U=-Math.sqrt(I*I-1);if(D?(A=0,C=U):(C=0,A=U),L||d.addCurrentVertex(h,d.distance,E,C,A,!1,_),"fakeround"===B){for(var q,P=Math.floor(8*(.5-(T-.5))),M=0;M<P;M++)q=x.mult((M+1)/(P+1))._add(E)._unit(),d.addPieSliceVertex(h,d.distance,q,D,_);d.addPieSliceVertex(h,d.distance,V,D,_);for(var O=P-1;O>=0;O--)q=E.mult((O+1)/(P+1))._add(x)._unit(),d.addPieSliceVertex(h,d.distance,q,D,_)}m&&d.addCurrentVertex(h,d.distance,x,-C,-A,!1,_)}else"butt"===B?(L||d.addCurrentVertex(h,d.distance,E,0,0,!1,_),m&&d.addCurrentVertex(h,d.distance,x,0,0,!1,_)):"square"===B?(L||(d.addCurrentVertex(h,d.distance,E,1,1,!1,_),d.e1=d.e2=-1),m&&d.addCurrentVertex(h,d.distance,x,-1,-1,!1,_)):"round"===B&&(L||(d.addCurrentVertex(h,d.distance,E,0,0,!1,_),d.addCurrentVertex(h,d.distance,E,1,1,!0,_),d.e1=d.e2=-1),m&&(d.addCurrentVertex(h,d.distance,x,-1,-1,!0,_),d.addCurrentVertex(h,d.distance,x,0,0,!1,_)));if(N&&S<s-1){var X=h.dist(m);if(X>2*u){var H=h.add(m.sub(h)._mult(u/X)._round());d.distance+=H.dist(h),d.addCurrentVertex(H,d.distance,x.mult(1),0,0,!1,_),h=H}}L=!1}c.populatePaintArrays(t)}}},t.prototype.addCurrentVertex=function(e,t,r,i,a,n,d){var s,u=n?1:0,l=this.arrays,p=l.layoutVertexArray,o=l.elementArray;s=r.clone(),i&&s._sub(r.perp()._mult(i)),addLineVertex(p,e,s,u,0,i,t),this.e3=d.vertexLength++,this.e1>=0&&this.e2>=0&&(o.emplaceBack(this.e1,this.e2,this.e3),d.primitiveLength++),this.e1=this.e2,this.e2=this.e3,s=r.mult(-1),a&&s._sub(r.perp()._mult(a)),addLineVertex(p,e,s,u,1,-a,t),this.e3=d.vertexLength++,this.e1>=0&&this.e2>=0&&(o.emplaceBack(this.e1,this.e2,this.e3),d.primitiveLength++),this.e1=this.e2,this.e2=this.e3,t>MAX_LINE_DISTANCE/2&&(this.distance=0,this.addCurrentVertex(e,this.distance,r,i,a,n,d))},t.prototype.addPieSliceVertex=function(e,t,r,i,a){var n=i?1:0;r=r.mult(i?-1:1);var d=this.arrays,s=d.layoutVertexArray,u=d.elementArray;addLineVertex(s,e,r,0,n,0,t),this.e3=a.vertexLength++,this.e1>=0&&this.e2>=0&&(u.emplaceBack(this.e1,this.e2,this.e3),a.primitiveLength++),i?this.e2=this.e3:this.e1=this.e3},t}(Bucket);module.exports=LineBucket;
},{"../bucket":2,"../element_array_type":10,"../extent":11,"../load_geometry":13,"../vertex_array_type":17}],7:[function(require,module,exports){
"use strict";function addVertex(e,t,o,a,r,i,n,s,l,y,c){e.emplaceBack(t,o,Math.round(64*a),Math.round(64*r),i/4,n/4,10*(y||0),c,10*(s||0),10*Math.min(l||25,25))}function addCollisionBoxVertex(e,t,o,a,r){return e.emplaceBack(t.x,t.y,Math.round(o.x),Math.round(o.y),10*a,10*r)}var Point=require("point-geometry"),ArrayGroup=require("../array_group"),BufferGroup=require("../buffer_group"),createVertexArrayType=require("../vertex_array_type"),createElementArrayType=require("../element_array_type"),EXTENT=require("../extent"),Anchor=require("../../symbol/anchor"),getAnchors=require("../../symbol/get_anchors"),resolveTokens=require("../../util/token"),Quads=require("../../symbol/quads"),Shaping=require("../../symbol/shaping"),resolveText=require("../../symbol/resolve_text"),mergeLines=require("../../symbol/mergelines"),clipLine=require("../../symbol/clip_line"),util=require("../../util/util"),scriptDetection=require("../../util/script_detection"),loadGeometry=require("../load_geometry"),CollisionFeature=require("../../symbol/collision_feature"),findPoleOfInaccessibility=require("../../util/find_pole_of_inaccessibility"),classifyRings=require("../../util/classify_rings"),VectorTileFeature=require("vector-tile").VectorTileFeature,rtlTextPlugin=require("../../source/rtl_text_plugin"),shapeText=Shaping.shapeText,shapeIcon=Shaping.shapeIcon,WritingMode=Shaping.WritingMode,getGlyphQuads=Quads.getGlyphQuads,getIconQuads=Quads.getIconQuads,elementArrayType=createElementArrayType(),layoutVertexArrayType=createVertexArrayType([{name:"a_pos",components:2,type:"Int16"},{name:"a_offset",components:2,type:"Int16"},{name:"a_texture_pos",components:2,type:"Uint16"},{name:"a_data",components:4,type:"Uint8"}]),symbolInterfaces={glyph:{layoutVertexArrayType:layoutVertexArrayType,elementArrayType:elementArrayType},icon:{layoutVertexArrayType:layoutVertexArrayType,elementArrayType:elementArrayType},collisionBox:{layoutVertexArrayType:createVertexArrayType([{name:"a_pos",components:2,type:"Int16"},{name:"a_extrude",components:2,type:"Int16"},{name:"a_data",components:2,type:"Uint8"}]),elementArrayType:createElementArrayType(2)}},SymbolBucket=function(e){var t=this;if(this.collisionBoxArray=e.collisionBoxArray,this.symbolQuadsArray=e.symbolQuadsArray,this.symbolInstancesArray=e.symbolInstancesArray,this.zoom=e.zoom,this.overscaling=e.overscaling,this.layers=e.layers,this.index=e.index,this.sdfIcons=e.sdfIcons,this.iconsNeedLinear=e.iconsNeedLinear,this.adjustedTextSize=e.adjustedTextSize,this.adjustedIconSize=e.adjustedIconSize,this.fontstack=e.fontstack,e.arrays){this.buffers={};for(var o in e.arrays)e.arrays[o]&&(t.buffers[o]=new BufferGroup(symbolInterfaces[o],e.layers,e.zoom,e.arrays[o]))}};SymbolBucket.prototype.populate=function(e,t){var o=this,a=this.layers[0].layout,r=a["text-field"],i=a["text-font"],n=a["icon-image"],s=r&&i,l=n;if(this.features=[],s||l){for(var y=t.iconDependencies,c=t.glyphDependencies,d=c[i]=c[i]||{},h=0;h<e.length;h++){var x=e[h];if(o.layers[0].filter(x)){var u;s&&(u=rtlTextPlugin.applyArabicShaping?rtlTextPlugin.applyArabicShaping(resolveText(x,a)):resolveText(x,a));var m;if(l&&(m=resolveTokens(x.properties,n)),(u||m)&&(o.features.push({text:u,icon:m,index:h,sourceLayerIndex:x.sourceLayerIndex,geometry:loadGeometry(x),properties:x.properties,type:VectorTileFeature.types[x.type]}),m&&(y[m]=!0),u))for(var p=0;p<u.length;p++)d[u.charCodeAt(p)]=!0}}"line"===a["symbol-placement"]&&(this.features=mergeLines(this.features))}},SymbolBucket.prototype.isEmpty=function(){return this.arrays.icon.isEmpty()&&this.arrays.glyph.isEmpty()&&this.arrays.collisionBox.isEmpty()},SymbolBucket.prototype.serialize=function(e){return{zoom:this.zoom,layerIds:this.layers.map(function(e){return e.id}),sdfIcons:this.sdfIcons,iconsNeedLinear:this.iconsNeedLinear,adjustedTextSize:this.adjustedTextSize,adjustedIconSize:this.adjustedIconSize,fontstack:this.fontstack,arrays:util.mapObject(this.arrays,function(t){return t.isEmpty()?null:t.serialize(e)})}},SymbolBucket.prototype.destroy=function(){this.buffers&&(this.buffers.icon&&this.buffers.icon.destroy(),this.buffers.glyph&&this.buffers.glyph.destroy(),this.buffers.collisionBox&&this.buffers.collisionBox.destroy(),this.buffers=null)},SymbolBucket.prototype.createArrays=function(){var e=this;this.arrays=util.mapObject(symbolInterfaces,function(t){return new ArrayGroup(t,e.layers,e.zoom)})},SymbolBucket.prototype.prepare=function(e,t){var o=this;this.createArrays(),this.adjustedTextMaxSize=this.layers[0].getLayoutValue("text-size",{zoom:18}),this.adjustedTextSize=this.layers[0].getLayoutValue("text-size",{zoom:this.zoom+1}),this.adjustedIconMaxSize=this.layers[0].getLayoutValue("icon-size",{zoom:18}),this.adjustedIconSize=this.layers[0].getLayoutValue("icon-size",{zoom:this.zoom+1});var a=512*this.overscaling;this.tilePixelRatio=EXTENT/a,this.compareText={},this.iconsNeedLinear=!1,this.symbolInstancesStartIndex=this.symbolInstancesArray.length;var r=this.layers[0].layout,i=.5,n=.5;switch(r["text-anchor"]){case"right":case"top-right":case"bottom-right":i=1;break;case"left":case"top-left":case"bottom-left":i=0}switch(r["text-anchor"]){case"bottom":case"bottom-right":case"bottom-left":n=1;break;case"top":case"top-right":case"top-left":n=0}for(var s="right"===r["text-justify"]?1:"left"===r["text-justify"]?0:.5,l=24,y=r["text-line-height"]*l,c="line"!==r["symbol-placement"]?r["text-max-width"]*l:0,d=r["text-letter-spacing"]*l,h=[r["text-offset"][0]*l,r["text-offset"][1]*l],x=this.fontstack=r["text-font"].join(","),u="map"===r["text-rotation-alignment"]&&"line"===r["symbol-placement"],m=0,p=this.features;m<p.length;m+=1){var g,f=p[m];if(f.text){var b=scriptDetection.allowsVerticalWritingMode(f.text);g={},g[WritingMode.horizontal]=shapeText(f.text,e[x],c,y,i,n,s,d,h,l,WritingMode.horizontal),g[WritingMode.vertical]=b&&u&&shapeText(f.text,e[x],c,y,i,n,s,d,h,l,WritingMode.vertical)}else g={};var I;if(f.icon){var v=t[f.icon],S=o.layers[0].getLayoutValue("icon-offset",{zoom:o.zoom},f.properties);I=shapeIcon(v,S),v&&(void 0===o.sdfIcons?o.sdfIcons=v.sdf:o.sdfIcons!==v.sdf&&util.warnOnce("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"),1!==v.pixelRatio?o.iconsNeedLinear=!0:0===r["icon-rotate"]&&o.layers[0].isLayoutValueFeatureConstant("icon-rotate")||(o.iconsNeedLinear=!0))}(g[WritingMode.horizontal]||I)&&o.addFeature(f,g,I)}this.symbolInstancesEndIndex=this.symbolInstancesArray.length},SymbolBucket.prototype.addFeature=function(e,t,o){var a=this,r=this.layers[0].layout,i=24,n=this.adjustedTextSize/i,s=void 0!==this.adjustedTextMaxSize?this.adjustedTextMaxSize:this.adjustedTextSize,l=this.tilePixelRatio*n,y=this.tilePixelRatio*s/i,c=this.tilePixelRatio*this.adjustedIconSize,d=this.tilePixelRatio*r["symbol-spacing"],h=r["symbol-avoid-edges"],x=r["text-padding"]*this.tilePixelRatio,u=r["icon-padding"]*this.tilePixelRatio,m=r["text-max-angle"]/180*Math.PI,p="map"===r["text-rotation-alignment"]&&"line"===r["symbol-placement"],g="map"===r["icon-rotation-alignment"]&&"line"===r["symbol-placement"],f=r["text-allow-overlap"]||r["icon-allow-overlap"]||r["text-ignore-placement"]||r["icon-ignore-placement"],b=r["symbol-placement"],I=d/2,v=function(r,i){var n=!(i.x<0||i.x>EXTENT||i.y<0||i.y>EXTENT);if(!h||n){var s=n||f;a.addSymbolInstance(i,r,t,o,a.layers[0],s,a.symbolInstancesArray.length,a.collisionBoxArray,e.index,e.sourceLayerIndex,a.index,l,x,p,c,u,g,{zoom:a.zoom},e.properties)}};if("line"===b)for(var S=0,A=clipLine(e.geometry,0,0,EXTENT,EXTENT);S<A.length;S+=1)for(var M=A[S],T=getAnchors(M,d,m,t[WritingMode.vertical]||t[WritingMode.horizontal],o,i,y,a.overscaling,EXTENT),B=0,z=T;B<z.length;B+=1){var E=z[B],k=t[WritingMode.horizontal];k&&a.anchorIsTooClose(k.text,I,E)||v(M,E)}else if("Polygon"===e.type)for(var P=0,_=classifyRings(e.geometry,0);P<_.length;P+=1){var L=_[P],w=findPoleOfInaccessibility(L,16);v(L[0],new Anchor(w.x,w.y,0))}else if("LineString"===e.type)for(var V=0,Q=e.geometry;V<Q.length;V+=1){var j=Q[V];v(j,new Anchor(j[0].x,j[0].y,0))}else if("Point"===e.type)for(var q=0,C=e.geometry;q<C.length;q+=1)for(var F=C[q],N=0,W=F;N<W.length;N+=1){var X=W[N];v([X],new Anchor(X.x,X.y,0))}},SymbolBucket.prototype.anchorIsTooClose=function(e,t,o){var a=this.compareText;if(e in a){for(var r=a[e],i=r.length-1;i>=0;i--)if(o.dist(r[i])<t)return!0}else a[e]=[];return a[e].push(o),!1},SymbolBucket.prototype.place=function(e,t){var o=this;this.createArrays();var a=this.layers[0].layout,r=e.maxScale,i="map"===a["text-rotation-alignment"]&&"line"===a["symbol-placement"],n="map"===a["icon-rotation-alignment"]&&"line"===a["symbol-placement"],s=a["text-allow-overlap"]||a["icon-allow-overlap"]||a["text-ignore-placement"]||a["icon-ignore-placement"];if(s){var l=this.symbolInstancesArray.toArray(this.symbolInstancesStartIndex,this.symbolInstancesEndIndex),y=e.angle,c=Math.sin(y),d=Math.cos(y);this.sortedSymbolInstances=l.sort(function(e,t){var o=c*e.anchorPointX+d*e.anchorPointY|0,a=c*t.anchorPointX+d*t.anchorPointY|0;return o-a||t.index-e.index})}for(var h=this.symbolInstancesStartIndex;h<this.symbolInstancesEndIndex;h++){var x=o.sortedSymbolInstances?o.sortedSymbolInstances[h-o.symbolInstancesStartIndex]:o.symbolInstancesArray.get(h),u={boxStartIndex:x.textBoxStartIndex,boxEndIndex:x.textBoxEndIndex},m={boxStartIndex:x.iconBoxStartIndex,boxEndIndex:x.iconBoxEndIndex},p=!(x.textBoxStartIndex===x.textBoxEndIndex),g=!(x.iconBoxStartIndex===x.iconBoxEndIndex),f=a["text-optional"]||!p,b=a["icon-optional"]||!g,I=p?e.placeCollisionFeature(u,a["text-allow-overlap"],a["symbol-avoid-edges"]):e.minScale,v=g?e.placeCollisionFeature(m,a["icon-allow-overlap"],a["symbol-avoid-edges"]):e.minScale;f||b?!b&&I?I=Math.max(v,I):!f&&v&&(v=Math.max(v,I)):v=I=Math.max(v,I),p&&(e.insertCollisionFeature(u,I,a["text-ignore-placement"]),I<=r&&o.addSymbols(o.arrays.glyph,x.glyphQuadStartIndex,x.glyphQuadEndIndex,I,a["text-keep-upright"],i,e.angle,x.writingModes)),g&&(e.insertCollisionFeature(m,v,a["icon-ignore-placement"]),v<=r&&o.addSymbols(o.arrays.icon,x.iconQuadStartIndex,x.iconQuadEndIndex,v,a["icon-keep-upright"],n,e.angle))}t&&this.addToDebugBuffers(e)},SymbolBucket.prototype.addSymbols=function(e,t,o,a,r,i,n,s){for(var l=this,y=e.elementArray,c=e.layoutVertexArray,d=this.zoom,h=Math.max(Math.log(a)/Math.LN2+d,0),x=t;x<o;x++){var u=l.symbolQuadsArray.get(x).SymbolQuad,m=(u.anchorAngle+n+Math.PI)%(2*Math.PI);if(s&WritingMode.vertical){if(i&&u.writingMode===WritingMode.vertical){if(r&&i&&m<=5*Math.PI/4||m>7*Math.PI/4)continue}else if(r&&i&&m<=3*Math.PI/4||m>5*Math.PI/4)continue}else if(r&&i&&(m<=Math.PI/2||m>3*Math.PI/2))continue;var p=u.tl,g=u.tr,f=u.bl,b=u.br,I=u.tex,v=u.anchorPoint,S=Math.max(d+Math.log(u.minScale)/Math.LN2,h),A=Math.min(d+Math.log(u.maxScale)/Math.LN2,25);if(!(A<=S)){S===h&&(S=0);var M=Math.round(u.glyphAngle/(2*Math.PI)*256),T=e.prepareSegment(4),B=T.vertexLength;addVertex(c,v.x,v.y,p.x,p.y,I.x,I.y,S,A,h,M),addVertex(c,v.x,v.y,g.x,g.y,I.x+I.w,I.y,S,A,h,M),addVertex(c,v.x,v.y,f.x,f.y,I.x,I.y+I.h,S,A,h,M),addVertex(c,v.x,v.y,b.x,b.y,I.x+I.w,I.y+I.h,S,A,h,M),y.emplaceBack(B,B+1,B+2),y.emplaceBack(B+1,B+2,B+3),T.vertexLength+=4,T.primitiveLength+=2}}},SymbolBucket.prototype.addToDebugBuffers=function(e){for(var t=this,o=this.arrays.collisionBox,a=o.layoutVertexArray,r=o.elementArray,i=-e.angle,n=e.yStretch,s=this.symbolInstancesStartIndex;s<this.symbolInstancesEndIndex;s++){var l=t.symbolInstancesArray.get(s);l.textCollisionFeature={boxStartIndex:l.textBoxStartIndex,boxEndIndex:l.textBoxEndIndex},l.iconCollisionFeature={boxStartIndex:l.iconBoxStartIndex,boxEndIndex:l.iconBoxEndIndex};for(var y=0;y<2;y++){var c=l[0===y?"textCollisionFeature":"iconCollisionFeature"];if(c)for(var d=c.boxStartIndex;d<c.boxEndIndex;d++){var h=t.collisionBoxArray.get(d),x=h.anchorPoint,u=new Point(h.x1,h.y1*n)._rotate(i),m=new Point(h.x2,h.y1*n)._rotate(i),p=new Point(h.x1,h.y2*n)._rotate(i),g=new Point(h.x2,h.y2*n)._rotate(i),f=Math.max(0,Math.min(25,t.zoom+Math.log(h.maxScale)/Math.LN2)),b=Math.max(0,Math.min(25,t.zoom+Math.log(h.placementScale)/Math.LN2)),I=o.prepareSegment(4),v=I.vertexLength;addCollisionBoxVertex(a,x,u,f,b),addCollisionBoxVertex(a,x,m,f,b),addCollisionBoxVertex(a,x,g,f,b),addCollisionBoxVertex(a,x,p,f,b),r.emplaceBack(v,v+1),r.emplaceBack(v+1,v+2),r.emplaceBack(v+2,v+3),r.emplaceBack(v+3,v),I.vertexLength+=4,I.primitiveLength+=4}}}},SymbolBucket.prototype.addSymbolInstance=function(e,t,o,a,r,i,n,s,l,y,c,d,h,x,u,m,p,g,f){var b,I,v,S=this,A=[];for(var M in o){var T=parseInt(M,10);o[T]&&(A=A.concat(i?getGlyphQuads(e,o[T],d,t,r,x,T):[]),b=new CollisionFeature(s,t,e,l,y,c,o[T],d,h,x,!1))}var B=this.symbolQuadsArray.length;if(A&&A.length)for(var z=0;z<A.length;z++)S.addSymbolQuad(A[z]);var E=this.symbolQuadsArray.length,k=b?b.boxStartIndex:this.collisionBoxArray.length,P=b?b.boxEndIndex:this.collisionBoxArray.length;a&&(v=i?getIconQuads(e,a,u,t,r,p,o[WritingMode.horizontal],g,f):[],I=new CollisionFeature(s,t,e,l,y,c,a,u,m,p,!0));var _=this.symbolQuadsArray.length;v&&1===v.length&&this.addSymbolQuad(v[0]);var L=this.symbolQuadsArray.length,w=I?I.boxStartIndex:this.collisionBoxArray.length,V=I?I.boxEndIndex:this.collisionBoxArray.length;L>SymbolBucket.MAX_QUADS&&util.warnOnce("Too many symbols being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"),E>SymbolBucket.MAX_QUADS&&util.warnOnce("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907");var Q=(o[WritingMode.vertical]?WritingMode.vertical:0)|(o[WritingMode.horizontal]?WritingMode.horizontal:0);return this.symbolInstancesArray.emplaceBack(k,P,w,V,B,E,_,L,e.x,e.y,n,Q)},SymbolBucket.prototype.addSymbolQuad=function(e){return this.symbolQuadsArray.emplaceBack(e.anchorPoint.x,e.anchorPoint.y,e.tl.x,e.tl.y,e.tr.x,e.tr.y,e.bl.x,e.bl.y,e.br.x,e.br.y,e.tex.h,e.tex.w,e.tex.x,e.tex.y,e.anchorAngle,e.glyphAngle,e.maxScale,e.minScale,e.writingMode)},SymbolBucket.MAX_QUADS=65535,module.exports=SymbolBucket;
},{"../../source/rtl_text_plugin":49,"../../symbol/anchor":75,"../../symbol/clip_line":77,"../../symbol/collision_feature":79,"../../symbol/get_anchors":81,"../../symbol/mergelines":84,"../../symbol/quads":85,"../../symbol/resolve_text":86,"../../symbol/shaping":87,"../../util/classify_rings":113,"../../util/find_pole_of_inaccessibility":119,"../../util/script_detection":126,"../../util/token":128,"../../util/util":129,"../array_group":1,"../buffer_group":9,"../element_array_type":10,"../extent":11,"../load_geometry":13,"../vertex_array_type":17,"point-geometry":197,"vector-tile":206}],8:[function(require,module,exports){
"use strict";var AttributeType={Int8:"BYTE",Uint8:"UNSIGNED_BYTE",Int16:"SHORT",Uint16:"UNSIGNED_SHORT"},Buffer=function(e,t,r){this.arrayBuffer=e.arrayBuffer,this.length=e.length,this.attributes=t.members,this.itemSize=t.bytesPerElement,this.type=r,this.arrayType=t};Buffer.fromStructArray=function(e,t){return new Buffer(e.serialize(),e.constructor.serialize(),t)},Buffer.prototype.bind=function(e){var t=e[this.type];this.buffer?e.bindBuffer(t,this.buffer):(this.gl=e,this.buffer=e.createBuffer(),e.bindBuffer(t,this.buffer),e.bufferData(t,this.arrayBuffer,e.STATIC_DRAW),this.arrayBuffer=null)},Buffer.prototype.setVertexAttribPointers=function(e,t,r){for(var f=this,i=0;i<this.attributes.length;i++){var u=f.attributes[i],s=t[u.name];void 0!==s&&e.vertexAttribPointer(s,u.components,e[AttributeType[u.type]],!1,f.arrayType.bytesPerElement,u.offset+(f.arrayType.bytesPerElement*r||0))}},Buffer.prototype.destroy=function(){this.buffer&&this.gl.deleteBuffer(this.buffer)},Buffer.BufferType={VERTEX:"ARRAY_BUFFER",ELEMENT:"ELEMENT_ARRAY_BUFFER"},module.exports=Buffer;
},{}],9:[function(require,module,exports){
"use strict";var util=require("../util/util"),Buffer=require("./buffer"),ProgramConfiguration=require("./program_configuration"),VertexArrayObject=require("../render/vertex_array_object"),BufferGroup=function(e,r,t,a){var f=this;this.layoutVertexBuffer=new Buffer(a.layoutVertexArray,e.layoutVertexArrayType.serialize(),Buffer.BufferType.VERTEX),a.elementArray&&(this.elementBuffer=new Buffer(a.elementArray,e.elementArrayType.serialize(),Buffer.BufferType.ELEMENT)),a.elementArray2&&(this.elementBuffer2=new Buffer(a.elementArray2,e.elementArrayType2.serialize(),Buffer.BufferType.ELEMENT)),this.layerData={};for(var i=0,n=r;i<n.length;i+=1){var u=n[i],s=a.paintVertexArrays&&a.paintVertexArrays[u.id],o=ProgramConfiguration.createDynamic(e.paintAttributes||[],u,t),y=s?new Buffer(s.array,s.type,Buffer.BufferType.VERTEX):null;f.layerData[u.id]={programConfiguration:o,paintVertexBuffer:y}}this.segments=a.segments,this.segments2=a.segments2;for(var l=0,m=[this.segments,this.segments2];l<m.length;l+=1)for(var B=m[l],h=0,p=B||[];h<p.length;h+=1){var g=p[h];g.vaos=util.mapObject(f.layerData,function(){return new VertexArrayObject})}};BufferGroup.prototype.destroy=function(){var e=this;this.layoutVertexBuffer.destroy(),this.elementBuffer&&this.elementBuffer.destroy(),this.elementBuffer2&&this.elementBuffer2.destroy();for(var r in this.layerData){var t=e.layerData[r].paintVertexBuffer;t&&t.destroy()}for(var a=0,f=[this.segments,this.segments2];a<f.length;a+=1)for(var i=f[a],n=0,u=i||[];n<u.length;n+=1){var s=u[n];for(var o in s.vaos)s.vaos[o].destroy()}},module.exports=BufferGroup;
},{"../render/vertex_array_object":39,"../util/util":129,"./buffer":8,"./program_configuration":15}],10:[function(require,module,exports){
"use strict";function createElementArrayType(e){return createStructArrayType({members:[{type:"Uint16",name:"vertices",components:e||3}]})}var createStructArrayType=require("../util/struct_array");module.exports=createElementArrayType;
},{"../util/struct_array":127}],11:[function(require,module,exports){
"use strict";module.exports=8192;
},{}],12:[function(require,module,exports){
"use strict";function translateDistance(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1])}function topDownFeatureComparator(e,t){return t-e}function getLineWidth(e){return e["line-gap-width"]>0?e["line-gap-width"]+2*e["line-width"]:e["line-width"]}function translate(e,t,r,i,n){if(!t[0]&&!t[1])return e;t=Point.convert(t),"viewport"===r&&t._rotate(-i);for(var a=[],o=0;o<e.length;o++){for(var s=e[o],l=[],u=0;u<s.length;u++)l.push(s[u].sub(t._mult(n)));a.push(l)}return a}function offsetLine(e,t){for(var r=[],i=new Point(0,0),n=0;n<e.length;n++){for(var a=e[n],o=[],s=0;s<a.length;s++){var l=a[s-1],u=a[s],c=a[s+1],y=0===s?i:u.sub(l)._unit()._perp(),f=s===a.length-1?i:c.sub(u)._unit()._perp(),d=y._add(f)._unit(),h=d.x*f.x+d.y*f.y;d._mult(1/h),o.push(d._mult(t)._add(u))}r.push(o)}return r}var Point=require("point-geometry"),loadGeometry=require("./load_geometry"),EXTENT=require("./extent"),featureFilter=require("feature-filter"),createStructArrayType=require("../util/struct_array"),Grid=require("grid-index"),DictionaryCoder=require("../util/dictionary_coder"),vt=require("vector-tile"),Protobuf=require("pbf"),GeoJSONFeature=require("../util/vectortile_to_geojson"),arraysIntersect=require("../util/util").arraysIntersect,intersection=require("../util/intersection_tests"),multiPolygonIntersectsBufferedMultiPoint=intersection.multiPolygonIntersectsBufferedMultiPoint,multiPolygonIntersectsMultiPolygon=intersection.multiPolygonIntersectsMultiPolygon,multiPolygonIntersectsBufferedMultiLine=intersection.multiPolygonIntersectsBufferedMultiLine,FeatureIndexArray=createStructArrayType({members:[{type:"Uint32",name:"featureIndex"},{type:"Uint16",name:"sourceLayerIndex"},{type:"Uint16",name:"bucketIndex"}]}),FeatureIndex=function(e,t,r){if(e.grid){var i=e,n=t;e=i.coord,t=i.overscaling,this.grid=new Grid(i.grid),this.featureIndexArray=new FeatureIndexArray(i.featureIndexArray),this.rawTileData=n,this.bucketLayerIDs=i.bucketLayerIDs}else this.grid=new Grid(EXTENT,16,0),this.featureIndexArray=new FeatureIndexArray;this.coord=e,this.overscaling=t,this.x=e.x,this.y=e.y,this.z=e.z-Math.log(t)/Math.LN2,this.setCollisionTile(r)};FeatureIndex.prototype.insert=function(e,t){var r=this,i=this.featureIndexArray.length;this.featureIndexArray.emplaceBack(e.index,e.sourceLayerIndex,t);for(var n=loadGeometry(e),a=0;a<n.length;a++){for(var o=n[a],s=[1/0,1/0,-(1/0),-(1/0)],l=0;l<o.length;l++){var u=o[l];s[0]=Math.min(s[0],u.x),s[1]=Math.min(s[1],u.y),s[2]=Math.max(s[2],u.x),s[3]=Math.max(s[3],u.y)}r.grid.insert(i,s[0],s[1],s[2],s[3])}},FeatureIndex.prototype.setCollisionTile=function(e){this.collisionTile=e},FeatureIndex.prototype.serialize=function(e){var t=this.grid.toArrayBuffer();return e&&e.push(t),{coord:this.coord,overscaling:this.overscaling,grid:t,featureIndexArray:this.featureIndexArray.serialize(e),bucketLayerIDs:this.bucketLayerIDs}},FeatureIndex.prototype.query=function(e,t){this.vtLayers||(this.vtLayers=new vt.VectorTile(new Protobuf(this.rawTileData)).layers,this.sourceLayerCoder=new DictionaryCoder(this.vtLayers?Object.keys(this.vtLayers).sort():["_geojsonTileLayer"]));var r={},i=e.params||{},n=EXTENT/e.tileSize/e.scale,a=featureFilter(i.filter),o=0;for(var s in t){var l=t[s],u=l.paint,c=0;"line"===l.type?c=getLineWidth(u)/2+Math.abs(u["line-offset"])+translateDistance(u["line-translate"]):"fill"===l.type?c=translateDistance(u["fill-translate"]):"fill-extrusion"===l.type?c=translateDistance(u["fill-extrusion-translate"]):"circle"===l.type&&(c=u["circle-radius"]+translateDistance(u["circle-translate"])),o=Math.max(o,c*n)}for(var y=e.queryGeometry.map(function(e){return e.map(function(e){return new Point(e.x,e.y)})}),f=1/0,d=1/0,h=-(1/0),g=-(1/0),p=0;p<y.length;p++)for(var v=y[p],x=0;x<v.length;x++){var I=v[x];f=Math.min(f,I.x),d=Math.min(d,I.y),h=Math.max(h,I.x),g=Math.max(g,I.y)}var m=this.grid.query(f-o,d-o,h+o,g+o);m.sort(topDownFeatureComparator),this.filterMatching(r,m,this.featureIndexArray,y,a,i.layers,t,e.bearing,n);var L=this.collisionTile.queryRenderedSymbols(y,e.scale);return L.sort(),this.filterMatching(r,L,this.collisionTile.collisionBoxArray,y,a,i.layers,t,e.bearing,n),r},FeatureIndex.prototype.filterMatching=function(e,t,r,i,n,a,o,s,l){for(var u,c=this,y=0;y<t.length;y++){var f=t[y];if(f!==u){u=f;var d=r.get(f),h=c.bucketLayerIDs[d.bucketIndex];if(!a||arraysIntersect(a,h)){var g=c.sourceLayerCoder.decode(d.sourceLayerIndex),p=c.vtLayers[g],v=p.feature(d.featureIndex);if(n(v))for(var x=null,I=0;I<h.length;I++){var m=h[I];if(!(a&&a.indexOf(m)<0)){var L=o[m];if(L){var M;if("symbol"!==L.type){x||(x=loadGeometry(v));var P=L.paint;if("line"===L.type){M=translate(i,P["line-translate"],P["line-translate-anchor"],s,l);var b=getLineWidth(P)/2*l;if(P["line-offset"]&&(x=offsetLine(x,P["line-offset"]*l)),!multiPolygonIntersectsBufferedMultiLine(M,x,b))continue}else if("fill"===L.type||"fill-extrusion"===L.type){var w=L.type;if(M=translate(i,P[w+"-translate"],P[w+"-translate-anchor"],s,l),!multiPolygonIntersectsMultiPolygon(M,x))continue}else if("circle"===L.type){M=translate(i,P["circle-translate"],P["circle-translate-anchor"],s,l);var _=P["circle-radius"]*l;if(!multiPolygonIntersectsBufferedMultiPoint(M,x,_))continue}}var q=new GeoJSONFeature(v,c.z,c.x,c.y);q.layer=L.serialize();var T=e[m];void 0===T&&(T=e[m]=[]),T.push(q)}}}}}}},module.exports=FeatureIndex;
},{"../util/dictionary_coder":115,"../util/intersection_tests":122,"../util/struct_array":127,"../util/util":129,"../util/vectortile_to_geojson":130,"./extent":11,"./load_geometry":13,"feature-filter":138,"grid-index":149,"pbf":196,"point-geometry":197,"vector-tile":206}],13:[function(require,module,exports){
"use strict";function createBounds(e){return{min:-1*Math.pow(2,e-1),max:Math.pow(2,e-1)-1}}var util=require("../util/util"),EXTENT=require("./extent"),boundsLookup={15:createBounds(15),16:createBounds(16)};module.exports=function(e,t){for(var r=boundsLookup[t||16],o=EXTENT/e.extent,u=e.loadGeometry(),n=0;n<u.length;n++)for(var a=u[n],i=0;i<a.length;i++){var d=a[i];d.x=Math.round(d.x*o),d.y=Math.round(d.y*o),(d.x<r.min||d.x>r.max||d.y<r.min||d.y>r.max)&&util.warnOnce("Geometry exceeds allowed extent, reduce your vector tile buffer size")}return u};
},{"../util/util":129,"./extent":11}],14:[function(require,module,exports){
"use strict";var createStructArrayType=require("../util/struct_array"),PosArray=createStructArrayType({members:[{name:"a_pos",type:"Int16",components:2}]});module.exports=PosArray;
},{"../util/struct_array":127}],15:[function(require,module,exports){
"use strict";function getPaintAttributeValue(t,e,r,i){if(!t.zoomStops)return e.getPaintValue(t.property,r,i);var a=t.zoomStops.map(function(a){return e.getPaintValue(t.property,util.extend({},r,{zoom:a}),i)});return 1===a.length?a[0]:a}function normalizePaintAttribute(t,e){var r=t.property.replace(e.type+"-","").replace(/-/g,"_"),i="color"===e._paintSpecifications[t.property].type;return util.extend({name:"a_"+r,components:i?4:1,multiplier:i?255:1},t)}var createVertexArrayType=require("./vertex_array_type"),util=require("../util/util"),ProgramConfiguration=function(){this.attributes=[],this.uniforms=[],this.interpolationUniforms=[],this.pragmas={vertex:{},fragment:{}},this.cacheKey=""};ProgramConfiguration.createDynamic=function(t,e,r){for(var i=new ProgramConfiguration,a=0,n=t;a<n.length;a+=1){var o=n[a],p=normalizePaintAttribute(o,e),u=p.name.slice(2);e.isPaintValueFeatureConstant(p.property)?i.addZoomAttribute(u,p):e.isPaintValueZoomConstant(p.property)?i.addPropertyAttribute(u,p):i.addZoomAndPropertyAttribute(u,p,e,r)}return i.PaintVertexArray=createVertexArrayType(i.attributes),i},ProgramConfiguration.createStatic=function(t){for(var e=new ProgramConfiguration,r=0,i=t;r<i.length;r+=1){var a=i[r];e.addUniform(a,"u_"+a)}return e},ProgramConfiguration.prototype.addUniform=function(t,e){var r=this.getPragmas(t);r.define.push("uniform {precision} {type} "+e+";"),r.initialize.push("{precision} {type} "+t+" = "+e+";"),this.cacheKey+="/u_"+t},ProgramConfiguration.prototype.addZoomAttribute=function(t,e){this.uniforms.push(e),this.addUniform(t,e.name)},ProgramConfiguration.prototype.addPropertyAttribute=function(t,e){var r=this.getPragmas(t);this.attributes.push(e),r.define.push("varying {precision} {type} "+t+";"),r.vertex.define.push("attribute {precision} {type} "+e.name+";"),r.vertex.initialize.push(t+" = "+e.name+" / "+e.multiplier+".0;"),this.cacheKey+="/a_"+t},ProgramConfiguration.prototype.addZoomAndPropertyAttribute=function(t,e,r,i){var a=this,n=this.getPragmas(t);n.define.push("varying {precision} {type} "+t+";");for(var o=0,p=r.getPaintValueStopZoomLevels(e.property);o<p.length&&p[o]<i;)o++;var u=Math.max(0,Math.min(p.length-4,o-2)),s="u_"+t+"_t";n.vertex.define.push("uniform lowp float "+s+";"),this.interpolationUniforms.push({name:s,property:e.property,stopOffset:u});for(var m=[],f=0;f<4;f++)m.push(p[Math.min(u+f,p.length-1)]);var g=[];if(1===e.components)this.attributes.push(util.extend({},e,{components:4,zoomStops:m})),n.vertex.define.push("attribute {precision} vec4 "+e.name+";"),g.push(e.name);else for(var h=0;h<4;h++){var l=e.name+h;g.push(l),a.attributes.push(util.extend({},e,{name:l,zoomStops:[m[h]]})),n.vertex.define.push("attribute {precision} {type} "+l+";")}n.vertex.initialize.push(t+" = evaluate_zoom_function_"+e.components+"(            "+g.join(", ")+", "+s+") / "+e.multiplier+".0;"),this.cacheKey+="/z_"+t},ProgramConfiguration.prototype.getPragmas=function(t){return this.pragmas[t]||(this.pragmas[t]={define:[],initialize:[]},this.pragmas[t].fragment={define:[],initialize:[]},this.pragmas[t].vertex={define:[],initialize:[]}),this.pragmas[t]},ProgramConfiguration.prototype.applyPragmas=function(t,e){var r=this;return t.replace(/#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g,function(t,i,a,n,o){return r.pragmas[o][i].concat(r.pragmas[o][e][i]).join("\n").replace(/{type}/g,n).replace(/{precision}/g,a)})},ProgramConfiguration.prototype.populatePaintArray=function(t,e,r,i,a){var n=e.length;e.resize(r);for(var o=0,p=this.attributes;o<p.length;o+=1)for(var u=p[o],s=getPaintAttributeValue(u,t,i,a),m=n;m<r;m++){var f=e.get(m);if(4===u.components)for(var g=0;g<4;g++)f[u.name+g]=s[g]*u.multiplier;else f[u.name]=s*u.multiplier}},ProgramConfiguration.prototype.setUniforms=function(t,e,r,i){for(var a=0,n=this.uniforms;a<n.length;a+=1){var o=n[a],p=r.getPaintValue(o.property,i);4===o.components?t.uniform4fv(e[o.name],p):t.uniform1f(e[o.name],p)}for(var u=0,s=this.interpolationUniforms;u<s.length;u+=1){var m=s[u],f=r.getPaintInterpolationT(m.property,i);t.uniform1f(e[m.name],Math.max(0,Math.min(4,f-m.stopOffset)))}},module.exports=ProgramConfiguration;
},{"../util/util":129,"./vertex_array_type":17}],16:[function(require,module,exports){
"use strict";var createStructArrayType=require("../util/struct_array"),RasterBoundsArray=createStructArrayType({members:[{name:"a_pos",type:"Int16",components:2},{name:"a_texture_pos",type:"Int16",components:2}]});module.exports=RasterBoundsArray;
},{"../util/struct_array":127}],17:[function(require,module,exports){
"use strict";function createVertexArrayType(r){return createStructArrayType({members:r,alignment:4})}var createStructArrayType=require("../util/struct_array");module.exports=createVertexArrayType;
},{"../util/struct_array":127}],18:[function(require,module,exports){
"use strict";var Coordinate=function(o,t,n){this.column=o,this.row=t,this.zoom=n};Coordinate.prototype.clone=function(){return new Coordinate(this.column,this.row,this.zoom)},Coordinate.prototype.zoomTo=function(o){return this.clone()._zoomTo(o)},Coordinate.prototype.sub=function(o){return this.clone()._sub(o)},Coordinate.prototype._zoomTo=function(o){var t=Math.pow(2,o-this.zoom);return this.column*=t,this.row*=t,this.zoom=o,this},Coordinate.prototype._sub=function(o){return o=o.zoomTo(this.zoom),this.column-=o.column,this.row-=o.row,this},module.exports=Coordinate;
},{}],19:[function(require,module,exports){
"use strict";var wrap=require("../util/util").wrap,LngLat=function(t,n){if(isNaN(t)||isNaN(n))throw new Error("Invalid LngLat object: ("+t+", "+n+")");if(this.lng=+t,this.lat=+n,this.lat>90||this.lat<-90)throw new Error("Invalid LngLat latitude value: must be between -90 and 90")};LngLat.prototype.wrap=function(){return new LngLat(wrap(this.lng,-180,180),this.lat)},LngLat.prototype.toArray=function(){return[this.lng,this.lat]},LngLat.prototype.toString=function(){return"LngLat("+this.lng+", "+this.lat+")"},LngLat.convert=function(t){if(t instanceof LngLat)return t;if(t&&t.hasOwnProperty("lng")&&t.hasOwnProperty("lat"))return new LngLat(t.lng,t.lat);if(Array.isArray(t)&&2===t.length)return new LngLat(t[0],t[1]);throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]")},module.exports=LngLat;
},{"../util/util":129}],20:[function(require,module,exports){
"use strict";var LngLat=require("./lng_lat"),LngLatBounds=function(t,n){t&&(n?this.setSouthWest(t).setNorthEast(n):4===t.length?this.setSouthWest([t[0],t[1]]).setNorthEast([t[2],t[3]]):this.setSouthWest(t[0]).setNorthEast(t[1]))};LngLatBounds.prototype.setNorthEast=function(t){return this._ne=LngLat.convert(t),this},LngLatBounds.prototype.setSouthWest=function(t){return this._sw=LngLat.convert(t),this},LngLatBounds.prototype.extend=function(t){var n,e,s=this._sw,o=this._ne;if(t instanceof LngLat)n=t,e=t;else{if(!(t instanceof LngLatBounds))return Array.isArray(t)?t.every(Array.isArray)?this.extend(LngLatBounds.convert(t)):this.extend(LngLat.convert(t)):this;if(n=t._sw,e=t._ne,!n||!e)return this}return s||o?(s.lng=Math.min(n.lng,s.lng),s.lat=Math.min(n.lat,s.lat),o.lng=Math.max(e.lng,o.lng),o.lat=Math.max(e.lat,o.lat)):(this._sw=new LngLat(n.lng,n.lat),this._ne=new LngLat(e.lng,e.lat)),this},LngLatBounds.prototype.getCenter=function(){return new LngLat((this._sw.lng+this._ne.lng)/2,(this._sw.lat+this._ne.lat)/2)},LngLatBounds.prototype.getSouthWest=function(){return this._sw},LngLatBounds.prototype.getNorthEast=function(){return this._ne},LngLatBounds.prototype.getNorthWest=function(){return new LngLat(this.getWest(),this.getNorth())},LngLatBounds.prototype.getSouthEast=function(){return new LngLat(this.getEast(),this.getSouth())},LngLatBounds.prototype.getWest=function(){return this._sw.lng},LngLatBounds.prototype.getSouth=function(){return this._sw.lat},LngLatBounds.prototype.getEast=function(){return this._ne.lng},LngLatBounds.prototype.getNorth=function(){return this._ne.lat},LngLatBounds.prototype.toArray=function(){return[this._sw.toArray(),this._ne.toArray()]},LngLatBounds.prototype.toString=function(){return"LngLatBounds("+this._sw.toString()+", "+this._ne.toString()+")"},LngLatBounds.convert=function(t){return!t||t instanceof LngLatBounds?t:new LngLatBounds(t)},module.exports=LngLatBounds;
},{"./lng_lat":19}],21:[function(require,module,exports){
"use strict";var LngLat=require("./lng_lat"),Point=require("point-geometry"),Coordinate=require("./coordinate"),util=require("../util/util"),interp=require("../util/interpolate"),TileCoord=require("../source/tile_coord"),EXTENT=require("../data/extent"),glmatrix=require("@mapbox/gl-matrix"),vec4=glmatrix.vec4,mat4=glmatrix.mat4,mat2=glmatrix.mat2,Transform=function(t,i,o){this.tileSize=512,this._renderWorldCopies=void 0===o||o,this._minZoom=t||0,this._maxZoom=i||22,this.latRange=[-85.05113,85.05113],this.width=0,this.height=0,this._center=new LngLat(0,0),this.zoom=0,this.angle=0,this._fov=.6435011087932844,this._pitch=0,this._unmodified=!0},prototypeAccessors={minZoom:{},maxZoom:{},worldSize:{},centerPoint:{},size:{},bearing:{},pitch:{},fov:{},zoom:{},center:{},unmodified:{},x:{},y:{},point:{}};prototypeAccessors.minZoom.get=function(){return this._minZoom},prototypeAccessors.minZoom.set=function(t){this._minZoom!==t&&(this._minZoom=t,this.zoom=Math.max(this.zoom,t))},prototypeAccessors.maxZoom.get=function(){return this._maxZoom},prototypeAccessors.maxZoom.set=function(t){this._maxZoom!==t&&(this._maxZoom=t,this.zoom=Math.min(this.zoom,t))},prototypeAccessors.worldSize.get=function(){return this.tileSize*this.scale},prototypeAccessors.centerPoint.get=function(){return this.size._div(2)},prototypeAccessors.size.get=function(){return new Point(this.width,this.height)},prototypeAccessors.bearing.get=function(){return-this.angle/Math.PI*180},prototypeAccessors.bearing.set=function(t){var i=-util.wrap(t,-180,180)*Math.PI/180;this.angle!==i&&(this._unmodified=!1,this.angle=i,this._calcMatrices(),this.rotationMatrix=mat2.create(),mat2.rotate(this.rotationMatrix,this.rotationMatrix,this.angle))},prototypeAccessors.pitch.get=function(){return this._pitch/Math.PI*180},prototypeAccessors.pitch.set=function(t){var i=util.clamp(t,0,60)/180*Math.PI;this._pitch!==i&&(this._unmodified=!1,this._pitch=i,this._calcMatrices())},prototypeAccessors.fov.get=function(){return this._fov/Math.PI*180},prototypeAccessors.fov.set=function(t){t=Math.max(.01,Math.min(60,t)),this._fov!==t&&(this._unmodified=!1,this._fov=t/180*Math.PI,this._calcMatrices())},prototypeAccessors.zoom.get=function(){return this._zoom},prototypeAccessors.zoom.set=function(t){var i=Math.min(Math.max(t,this.minZoom),this.maxZoom);this._zoom!==i&&(this._unmodified=!1,this._zoom=i,this.scale=this.zoomScale(i),this.tileZoom=Math.floor(i),this.zoomFraction=i-this.tileZoom,this._constrain(),this._calcMatrices())},prototypeAccessors.center.get=function(){return this._center},prototypeAccessors.center.set=function(t){t.lat===this._center.lat&&t.lng===this._center.lng||(this._unmodified=!1,this._center=t,this._constrain(),this._calcMatrices())},Transform.prototype.coveringZoomLevel=function(t){return(t.roundZoom?Math.round:Math.floor)(this.zoom+this.scaleZoom(this.tileSize/t.tileSize))},Transform.prototype.coveringTiles=function(t){var i=this.coveringZoomLevel(t),o=i;if(i<t.minzoom)return[];i>t.maxzoom&&(i=t.maxzoom);var e=this.pointCoordinate(this.centerPoint,i),r=new Point(e.column-.5,e.row-.5),n=[this.pointCoordinate(new Point(0,0),i),this.pointCoordinate(new Point(this.width,0),i),this.pointCoordinate(new Point(this.width,this.height),i),this.pointCoordinate(new Point(0,this.height),i)];return TileCoord.cover(i,n,t.reparseOverscaled?o:i,this._renderWorldCopies).sort(function(t,i){return r.dist(t)-r.dist(i)})},Transform.prototype.resize=function(t,i){this.width=t,this.height=i,this.pixelsToGLUnits=[2/t,-2/i],this._constrain(),this._calcMatrices()},prototypeAccessors.unmodified.get=function(){return this._unmodified},Transform.prototype.zoomScale=function(t){return Math.pow(2,t)},Transform.prototype.scaleZoom=function(t){return Math.log(t)/Math.LN2},Transform.prototype.project=function(t){return new Point(this.lngX(t.lng),this.latY(t.lat))},Transform.prototype.unproject=function(t){return new LngLat(this.xLng(t.x),this.yLat(t.y))},prototypeAccessors.x.get=function(){return this.lngX(this.center.lng)},prototypeAccessors.y.get=function(){return this.latY(this.center.lat)},prototypeAccessors.point.get=function(){return new Point(this.x,this.y)},Transform.prototype.lngX=function(t){return(180+t)*this.worldSize/360},Transform.prototype.latY=function(t){var i=180/Math.PI*Math.log(Math.tan(Math.PI/4+t*Math.PI/360));return(180-i)*this.worldSize/360},Transform.prototype.xLng=function(t){return 360*t/this.worldSize-180},Transform.prototype.yLat=function(t){var i=180-360*t/this.worldSize;return 360/Math.PI*Math.atan(Math.exp(i*Math.PI/180))-90},Transform.prototype.setLocationAtPoint=function(t,i){var o=this.pointCoordinate(i)._sub(this.pointCoordinate(this.centerPoint));this.center=this.coordinateLocation(this.locationCoordinate(t)._sub(o))},Transform.prototype.locationPoint=function(t){return this.coordinatePoint(this.locationCoordinate(t))},Transform.prototype.pointLocation=function(t){return this.coordinateLocation(this.pointCoordinate(t))},Transform.prototype.locationCoordinate=function(t){return new Coordinate(this.lngX(t.lng)/this.tileSize,this.latY(t.lat)/this.tileSize,this.zoom).zoomTo(this.tileZoom)},Transform.prototype.coordinateLocation=function(t){var i=t.zoomTo(this.zoom);return new LngLat(this.xLng(i.column*this.tileSize),this.yLat(i.row*this.tileSize))},Transform.prototype.pointCoordinate=function(t,i){void 0===i&&(i=this.tileZoom);var o=0,e=[t.x,t.y,0,1],r=[t.x,t.y,1,1];vec4.transformMat4(e,e,this.pixelMatrixInverse),vec4.transformMat4(r,r,this.pixelMatrixInverse);var n=e[3],s=r[3],a=e[0]/n,h=r[0]/s,c=e[1]/n,m=r[1]/s,p=e[2]/n,l=r[2]/s,u=p===l?0:(o-p)/(l-p);return new Coordinate(interp(a,h,u)/this.tileSize,interp(c,m,u)/this.tileSize,this.zoom)._zoomTo(i)},Transform.prototype.coordinatePoint=function(t){var i=t.zoomTo(this.zoom),o=[i.column*this.tileSize,i.row*this.tileSize,0,1];return vec4.transformMat4(o,o,this.pixelMatrix),new Point(o[0]/o[3],o[1]/o[3])},Transform.prototype.calculatePosMatrix=function(t,i){var o=t.toCoordinate(i),e=this.worldSize/this.zoomScale(o.zoom),r=mat4.identity(new Float64Array(16));return mat4.translate(r,r,[o.column*e,o.row*e,0]),mat4.scale(r,r,[e/EXTENT,e/EXTENT,1]),mat4.multiply(r,this.projMatrix,r),new Float32Array(r)},Transform.prototype._constrain=function(){if(this.center&&this.width&&this.height&&!this._constraining){this._constraining=!0;var t,i,o,e,r,n,s,a,h=this.size,c=this._unmodified;this.latRange&&(t=this.latY(this.latRange[1]),i=this.latY(this.latRange[0]),r=i-t<h.y?h.y/(i-t):0),this.lngRange&&(o=this.lngX(this.lngRange[0]),e=this.lngX(this.lngRange[1]),n=e-o<h.x?h.x/(e-o):0);var m=Math.max(n||0,r||0);if(m)return this.center=this.unproject(new Point(n?(e+o)/2:this.x,r?(i+t)/2:this.y)),this.zoom+=this.scaleZoom(m),this._unmodified=c,void(this._constraining=!1);if(this.latRange){var p=this.y,l=h.y/2;p-l<t&&(a=t+l),p+l>i&&(a=i-l)}if(this.lngRange){var u=this.x,f=h.x/2;u-f<o&&(s=o+f),u+f>e&&(s=e-f)}void 0===s&&void 0===a||(this.center=this.unproject(new Point(void 0!==s?s:this.x,void 0!==a?a:this.y))),this._unmodified=c,this._constraining=!1}},Transform.prototype._calcMatrices=function(){if(this.height){this.cameraToCenterDistance=.5/Math.tan(this._fov/2)*this.height;var t=this._fov/2,i=Math.PI/2+this._pitch,o=Math.sin(t)*this.cameraToCenterDistance/Math.sin(Math.PI-i-t),e=Math.cos(Math.PI/2-this._pitch)*o+this.cameraToCenterDistance,r=1.01*e,n=new Float64Array(16);mat4.perspective(n,this._fov,this.width/this.height,1,r),mat4.scale(n,n,[1,-1,1]),mat4.translate(n,n,[0,0,-this.cameraToCenterDistance]),mat4.rotateX(n,n,this._pitch),mat4.rotateZ(n,n,this.angle),mat4.translate(n,n,[-this.x,-this.y,0]);var s=this.worldSize/(2*Math.PI*6378137*Math.abs(Math.cos(this.center.lat*(Math.PI/180))));if(mat4.scale(n,n,[1,1,s,1]),this.projMatrix=n,n=mat4.create(),mat4.scale(n,n,[this.width/2,-this.height/2,1]),mat4.translate(n,n,[1,-1,0]),this.pixelMatrix=mat4.multiply(new Float64Array(16),n,this.projMatrix),n=mat4.invert(new Float64Array(16),this.pixelMatrix),!n)throw new Error("failed to invert matrix");this.pixelMatrixInverse=n}},Object.defineProperties(Transform.prototype,prototypeAccessors),module.exports=Transform;
},{"../data/extent":11,"../source/tile_coord":53,"../util/interpolate":121,"../util/util":129,"./coordinate":18,"./lng_lat":19,"@mapbox/gl-matrix":133,"point-geometry":197}],22:[function(require,module,exports){
"use strict";var WorkerPool=require("./util/worker_pool"),globalWorkerPool;module.exports=function(){return globalWorkerPool||(globalWorkerPool=new WorkerPool),globalWorkerPool};
},{"./util/worker_pool":132}],23:[function(require,module,exports){
"use strict";var simplexFont={" ":[16,[]],"!":[10,[5,21,5,7,-1,-1,5,2,4,1,5,0,6,1,5,2]],'"':[16,[4,21,4,14,-1,-1,12,21,12,14]],"#":[21,[11,25,4,-7,-1,-1,17,25,10,-7,-1,-1,4,12,18,12,-1,-1,3,6,17,6]],$:[20,[8,25,8,-4,-1,-1,12,25,12,-4,-1,-1,17,18,15,20,12,21,8,21,5,20,3,18,3,16,4,14,5,13,7,12,13,10,15,9,16,8,17,6,17,3,15,1,12,0,8,0,5,1,3,3]],"%":[24,[21,21,3,0,-1,-1,8,21,10,19,10,17,9,15,7,14,5,14,3,16,3,18,4,20,6,21,8,21,10,20,13,19,16,19,19,20,21,21,-1,-1,17,7,15,6,14,4,14,2,16,0,18,0,20,1,21,3,21,5,19,7,17,7]],"&":[26,[23,12,23,13,22,14,21,14,20,13,19,11,17,6,15,3,13,1,11,0,7,0,5,1,4,2,3,4,3,6,4,8,5,9,12,13,13,14,14,16,14,18,13,20,11,21,9,20,8,18,8,16,9,13,11,10,16,3,18,1,20,0,22,0,23,1,23,2]],"'":[10,[5,19,4,20,5,21,6,20,6,18,5,16,4,15]],"(":[14,[11,25,9,23,7,20,5,16,4,11,4,7,5,2,7,-2,9,-5,11,-7]],")":[14,[3,25,5,23,7,20,9,16,10,11,10,7,9,2,7,-2,5,-5,3,-7]],"*":[16,[8,21,8,9,-1,-1,3,18,13,12,-1,-1,13,18,3,12]],"+":[26,[13,18,13,0,-1,-1,4,9,22,9]],",":[10,[6,1,5,0,4,1,5,2,6,1,6,-1,5,-3,4,-4]],"-":[26,[4,9,22,9]],".":[10,[5,2,4,1,5,0,6,1,5,2]],"/":[22,[20,25,2,-7]],0:[20,[9,21,6,20,4,17,3,12,3,9,4,4,6,1,9,0,11,0,14,1,16,4,17,9,17,12,16,17,14,20,11,21,9,21]],1:[20,[6,17,8,18,11,21,11,0]],2:[20,[4,16,4,17,5,19,6,20,8,21,12,21,14,20,15,19,16,17,16,15,15,13,13,10,3,0,17,0]],3:[20,[5,21,16,21,10,13,13,13,15,12,16,11,17,8,17,6,16,3,14,1,11,0,8,0,5,1,4,2,3,4]],4:[20,[13,21,3,7,18,7,-1,-1,13,21,13,0]],5:[20,[15,21,5,21,4,12,5,13,8,14,11,14,14,13,16,11,17,8,17,6,16,3,14,1,11,0,8,0,5,1,4,2,3,4]],6:[20,[16,18,15,20,12,21,10,21,7,20,5,17,4,12,4,7,5,3,7,1,10,0,11,0,14,1,16,3,17,6,17,7,16,10,14,12,11,13,10,13,7,12,5,10,4,7]],7:[20,[17,21,7,0,-1,-1,3,21,17,21]],8:[20,[8,21,5,20,4,18,4,16,5,14,7,13,11,12,14,11,16,9,17,7,17,4,16,2,15,1,12,0,8,0,5,1,4,2,3,4,3,7,4,9,6,11,9,12,13,13,15,14,16,16,16,18,15,20,12,21,8,21]],9:[20,[16,14,15,11,13,9,10,8,9,8,6,9,4,11,3,14,3,15,4,18,6,20,9,21,10,21,13,20,15,18,16,14,16,9,15,4,13,1,10,0,8,0,5,1,4,3]],":":[10,[5,14,4,13,5,12,6,13,5,14,-1,-1,5,2,4,1,5,0,6,1,5,2]],";":[10,[5,14,4,13,5,12,6,13,5,14,-1,-1,6,1,5,0,4,1,5,2,6,1,6,-1,5,-3,4,-4]],"<":[24,[20,18,4,9,20,0]],"=":[26,[4,12,22,12,-1,-1,4,6,22,6]],">":[24,[4,18,20,9,4,0]],"?":[18,[3,16,3,17,4,19,5,20,7,21,11,21,13,20,14,19,15,17,15,15,14,13,13,12,9,10,9,7,-1,-1,9,2,8,1,9,0,10,1,9,2]],"@":[27,[18,13,17,15,15,16,12,16,10,15,9,14,8,11,8,8,9,6,11,5,14,5,16,6,17,8,-1,-1,12,16,10,14,9,11,9,8,10,6,11,5,-1,-1,18,16,17,8,17,6,19,5,21,5,23,7,24,10,24,12,23,15,22,17,20,19,18,20,15,21,12,21,9,20,7,19,5,17,4,15,3,12,3,9,4,6,5,4,7,2,9,1,12,0,15,0,18,1,20,2,21,3,-1,-1,19,16,18,8,18,6,19,5]],A:[18,[9,21,1,0,-1,-1,9,21,17,0,-1,-1,4,7,14,7]],B:[21,[4,21,4,0,-1,-1,4,21,13,21,16,20,17,19,18,17,18,15,17,13,16,12,13,11,-1,-1,4,11,13,11,16,10,17,9,18,7,18,4,17,2,16,1,13,0,4,0]],C:[21,[18,16,17,18,15,20,13,21,9,21,7,20,5,18,4,16,3,13,3,8,4,5,5,3,7,1,9,0,13,0,15,1,17,3,18,5]],D:[21,[4,21,4,0,-1,-1,4,21,11,21,14,20,16,18,17,16,18,13,18,8,17,5,16,3,14,1,11,0,4,0]],E:[19,[4,21,4,0,-1,-1,4,21,17,21,-1,-1,4,11,12,11,-1,-1,4,0,17,0]],F:[18,[4,21,4,0,-1,-1,4,21,17,21,-1,-1,4,11,12,11]],G:[21,[18,16,17,18,15,20,13,21,9,21,7,20,5,18,4,16,3,13,3,8,4,5,5,3,7,1,9,0,13,0,15,1,17,3,18,5,18,8,-1,-1,13,8,18,8]],H:[22,[4,21,4,0,-1,-1,18,21,18,0,-1,-1,4,11,18,11]],I:[8,[4,21,4,0]],J:[16,[12,21,12,5,11,2,10,1,8,0,6,0,4,1,3,2,2,5,2,7]],K:[21,[4,21,4,0,-1,-1,18,21,4,7,-1,-1,9,12,18,0]],L:[17,[4,21,4,0,-1,-1,4,0,16,0]],M:[24,[4,21,4,0,-1,-1,4,21,12,0,-1,-1,20,21,12,0,-1,-1,20,21,20,0]],N:[22,[4,21,4,0,-1,-1,4,21,18,0,-1,-1,18,21,18,0]],O:[22,[9,21,7,20,5,18,4,16,3,13,3,8,4,5,5,3,7,1,9,0,13,0,15,1,17,3,18,5,19,8,19,13,18,16,17,18,15,20,13,21,9,21]],P:[21,[4,21,4,0,-1,-1,4,21,13,21,16,20,17,19,18,17,18,14,17,12,16,11,13,10,4,10]],Q:[22,[9,21,7,20,5,18,4,16,3,13,3,8,4,5,5,3,7,1,9,0,13,0,15,1,17,3,18,5,19,8,19,13,18,16,17,18,15,20,13,21,9,21,-1,-1,12,4,18,-2]],R:[21,[4,21,4,0,-1,-1,4,21,13,21,16,20,17,19,18,17,18,15,17,13,16,12,13,11,4,11,-1,-1,11,11,18,0]],S:[20,[17,18,15,20,12,21,8,21,5,20,3,18,3,16,4,14,5,13,7,12,13,10,15,9,16,8,17,6,17,3,15,1,12,0,8,0,5,1,3,3]],T:[16,[8,21,8,0,-1,-1,1,21,15,21]],U:[22,[4,21,4,6,5,3,7,1,10,0,12,0,15,1,17,3,18,6,18,21]],V:[18,[1,21,9,0,-1,-1,17,21,9,0]],W:[24,[2,21,7,0,-1,-1,12,21,7,0,-1,-1,12,21,17,0,-1,-1,22,21,17,0]],X:[20,[3,21,17,0,-1,-1,17,21,3,0]],Y:[18,[1,21,9,11,9,0,-1,-1,17,21,9,11]],Z:[20,[17,21,3,0,-1,-1,3,21,17,21,-1,-1,3,0,17,0]],"[":[14,[4,25,4,-7,-1,-1,5,25,5,-7,-1,-1,4,25,11,25,-1,-1,4,-7,11,-7]],"\\":[14,[0,21,14,-3]],"]":[14,[9,25,9,-7,-1,-1,10,25,10,-7,-1,-1,3,25,10,25,-1,-1,3,-7,10,-7]],"^":[16,[6,15,8,18,10,15,-1,-1,3,12,8,17,13,12,-1,-1,8,17,8,0]],_:[16,[0,-2,16,-2]],"`":[10,[6,21,5,20,4,18,4,16,5,15,6,16,5,17]],a:[19,[15,14,15,0,-1,-1,15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3]],b:[19,[4,21,4,0,-1,-1,4,11,6,13,8,14,11,14,13,13,15,11,16,8,16,6,15,3,13,1,11,0,8,0,6,1,4,3]],c:[18,[15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3]],d:[19,[15,21,15,0,-1,-1,15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3]],e:[18,[3,8,15,8,15,10,14,12,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3]],f:[12,[10,21,8,21,6,20,5,17,5,0,-1,-1,2,14,9,14]],g:[19,[15,14,15,-2,14,-5,13,-6,11,-7,8,-7,6,-6,-1,-1,15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3]],h:[19,[4,21,4,0,-1,-1,4,10,7,13,9,14,12,14,14,13,15,10,15,0]],i:[8,[3,21,4,20,5,21,4,22,3,21,-1,-1,4,14,4,0]],j:[10,[5,21,6,20,7,21,6,22,5,21,-1,-1,6,14,6,-3,5,-6,3,-7,1,-7]],k:[17,[4,21,4,0,-1,-1,14,14,4,4,-1,-1,8,8,15,0]],l:[8,[4,21,4,0]],m:[30,[4,14,4,0,-1,-1,4,10,7,13,9,14,12,14,14,13,15,10,15,0,-1,-1,15,10,18,13,20,14,23,14,25,13,26,10,26,0]],n:[19,[4,14,4,0,-1,-1,4,10,7,13,9,14,12,14,14,13,15,10,15,0]],o:[19,[8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3,16,6,16,8,15,11,13,13,11,14,8,14]],p:[19,[4,14,4,-7,-1,-1,4,11,6,13,8,14,11,14,13,13,15,11,16,8,16,6,15,3,13,1,11,0,8,0,6,1,4,3]],q:[19,[15,14,15,-7,-1,-1,15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3]],r:[13,[4,14,4,0,-1,-1,4,8,5,11,7,13,9,14,12,14]],s:[17,[14,11,13,13,10,14,7,14,4,13,3,11,4,9,6,8,11,7,13,6,14,4,14,3,13,1,10,0,7,0,4,1,3,3]],t:[12,[5,21,5,4,6,1,8,0,10,0,-1,-1,2,14,9,14]],u:[19,[4,14,4,4,5,1,7,0,10,0,12,1,15,4,-1,-1,15,14,15,0]],v:[16,[2,14,8,0,-1,-1,14,14,8,0]],w:[22,[3,14,7,0,-1,-1,11,14,7,0,-1,-1,11,14,15,0,-1,-1,19,14,15,0]],x:[17,[3,14,14,0,-1,-1,14,14,3,0]],y:[16,[2,14,8,0,-1,-1,14,14,8,0,6,-4,4,-6,2,-7,1,-7]],z:[17,[14,14,3,0,-1,-1,3,14,14,14,-1,-1,3,0,14,0]],"{":[14,[9,25,7,24,6,23,5,21,5,19,6,17,7,16,8,14,8,12,6,10,-1,-1,7,24,6,22,6,20,7,18,8,17,9,15,9,13,8,11,4,9,8,7,9,5,9,3,8,1,7,0,6,-2,6,-4,7,-6,-1,-1,6,8,8,6,8,4,7,2,6,1,5,-1,5,-3,6,-5,7,-6,9,-7]],"|":[8,[4,25,4,-7]],"}":[14,[5,25,7,24,8,23,9,21,9,19,8,17,7,16,6,14,6,12,8,10,-1,-1,7,24,8,22,8,20,7,18,6,17,5,15,5,13,6,11,10,9,6,7,5,5,5,3,6,1,7,0,8,-2,8,-4,7,-6,-1,-1,8,8,6,6,6,4,7,2,8,1,9,-1,9,-3,8,-5,7,-6,5,-7]],"~":[24,[3,6,3,8,4,11,6,12,8,12,10,11,14,8,16,7,18,7,20,8,21,10,-1,-1,3,8,4,10,6,11,8,11,10,10,14,7,16,6,18,6,20,7,21,10,21,12]]};module.exports=function(l,n,t,e){e=e||1;var r,o,u,s,i,x,f,p,h=[];for(r=0,o=l.length;r<o;r++)if(i=simplexFont[l[r]]){for(p=null,u=0,s=i[1].length;u<s;u+=2)i[1][u]===-1&&i[1][u+1]===-1?p=null:(x=n+i[1][u]*e,f=t-i[1][u+1]*e,p&&h.push(p.x,p.y,x,f),p={x:x,y:f});n+=i[0]*e}return h};
},{}],24:[function(require,module,exports){
"use strict";var browser=require("./util/browser"),mapboxgl=module.exports={};mapboxgl.version=require("../package.json").version,mapboxgl.workerCount=Math.max(Math.floor(browser.hardwareConcurrency/2),1),mapboxgl.Map=require("./ui/map"),mapboxgl.NavigationControl=require("./ui/control/navigation_control"),mapboxgl.GeolocateControl=require("./ui/control/geolocate_control"),mapboxgl.AttributionControl=require("./ui/control/attribution_control"),mapboxgl.ScaleControl=require("./ui/control/scale_control"),mapboxgl.Popup=require("./ui/popup"),mapboxgl.Marker=require("./ui/marker"),mapboxgl.Style=require("./style/style"),mapboxgl.LngLat=require("./geo/lng_lat"),mapboxgl.LngLatBounds=require("./geo/lng_lat_bounds"),mapboxgl.Point=require("point-geometry"),mapboxgl.Evented=require("./util/evented"),mapboxgl.util=require("./util/util"),mapboxgl.supported=require("./util/browser").supported;var ajax=require("./util/ajax");mapboxgl.util.getJSON=ajax.getJSON,mapboxgl.util.getArrayBuffer=ajax.getArrayBuffer;var config=require("./util/config");mapboxgl.config=config;var rtlTextPlugin=require("./source/rtl_text_plugin");mapboxgl.setRTLTextPlugin=rtlTextPlugin.setRTLTextPlugin,Object.defineProperty(mapboxgl,"accessToken",{get:function(){return config.ACCESS_TOKEN},set:function(e){config.ACCESS_TOKEN=e}});
},{"../package.json":216,"./geo/lng_lat":19,"./geo/lng_lat_bounds":20,"./source/rtl_text_plugin":49,"./style/style":63,"./ui/control/attribution_control":93,"./ui/control/geolocate_control":94,"./ui/control/navigation_control":95,"./ui/control/scale_control":96,"./ui/map":105,"./ui/marker":106,"./ui/popup":107,"./util/ajax":109,"./util/browser":110,"./util/config":114,"./util/evented":118,"./util/util":129,"point-geometry":197}],25:[function(require,module,exports){
"use strict";function drawBackground(r,t,e){var a=r.gl,i=r.transform,n=i.tileSize,o=e.paint["background-color"],l=e.paint["background-pattern"],u=e.paint["background-opacity"],f=!l&&1===o[3]&&1===u;if(r.isOpaquePass===f){a.disable(a.STENCIL_TEST),r.setDepthSublayer(0);var s;l?(s=r.useProgram("fillPattern",r.basicFillProgramConfiguration),pattern.prepare(l,r,s),r.tileExtentPatternVAO.bind(a,s,r.tileExtentBuffer)):(s=r.useProgram("fill",r.basicFillProgramConfiguration),a.uniform4fv(s.u_color,o),r.tileExtentVAO.bind(a,s,r.tileExtentBuffer)),a.uniform1f(s.u_opacity,u);for(var c=i.coveringTiles({tileSize:n}),g=0,p=c;g<p.length;g+=1){var d=p[g];l&&pattern.setTile({coord:d,tileSize:n},r,s),a.uniformMatrix4fv(s.u_matrix,!1,r.transform.calculatePosMatrix(d)),a.drawArrays(a.TRIANGLE_STRIP,0,r.tileExtentBuffer.length)}}}var pattern=require("./pattern");module.exports=drawBackground;
},{"./pattern":37}],26:[function(require,module,exports){
"use strict";function drawCircles(e,r,t,a){if(!e.isOpaquePass){var i=e.gl;e.setDepthSublayer(0),e.depthMask(!1),i.disable(i.STENCIL_TEST);for(var s=0;s<a.length;s++){var o=a[s],n=r.getTile(o),f=n.getBucket(t);if(f){var l=f.buffers,m=l.layerData[t.id],u=m.programConfiguration,c=e.useProgram("circle",u);u.setUniforms(i,c,t,{zoom:e.transform.zoom}),"map"===t.paint["circle-pitch-scale"]?(i.uniform1i(c.u_scale_with_map,!0),i.uniform2f(c.u_extrude_scale,e.transform.pixelsToGLUnits[0]*e.transform.cameraToCenterDistance,e.transform.pixelsToGLUnits[1]*e.transform.cameraToCenterDistance)):(i.uniform1i(c.u_scale_with_map,!1),i.uniform2fv(c.u_extrude_scale,e.transform.pixelsToGLUnits)),i.uniform1f(c.u_devicepixelratio,browser.devicePixelRatio),i.uniformMatrix4fv(c.u_matrix,!1,e.translatePosMatrix(o.posMatrix,n,t.paint["circle-translate"],t.paint["circle-translate-anchor"]));for(var p=0,v=l.segments;p<v.length;p+=1){var x=v[p];x.vaos[t.id].bind(i,c,l.layoutVertexBuffer,l.elementBuffer,m.paintVertexBuffer,x.vertexOffset),i.drawElements(i.TRIANGLES,3*x.primitiveLength,i.UNSIGNED_SHORT,3*x.primitiveOffset*2)}}}}}var browser=require("../util/browser");module.exports=drawCircles;
},{"../util/browser":110}],27:[function(require,module,exports){
"use strict";function drawCollisionDebug(e,o,r,i){var t=e.gl;t.enable(t.STENCIL_TEST);for(var f=e.useProgram("collisionBox"),l=0;l<i.length;l++){var n=i[l],a=o.getTile(n),s=a.getBucket(r);if(s){var u=s.buffers.collisionBox;if(u){t.uniformMatrix4fv(f.u_matrix,!1,n.posMatrix),e.enableTileClippingMask(n),e.lineWidth(1),t.uniform1f(f.u_scale,Math.pow(2,e.transform.zoom-a.coord.z)),t.uniform1f(f.u_zoom,10*e.transform.zoom),t.uniform1f(f.u_maxzoom,10*(a.coord.z+1));for(var m=0,g=u.segments;m<g.length;m+=1){var v=g[m];v.vaos[r.id].bind(t,f,u.layoutVertexBuffer,u.elementBuffer,null,v.vertexOffset),t.drawElements(t.LINES,2*v.primitiveLength,t.UNSIGNED_SHORT,2*v.primitiveOffset*2)}}}}}module.exports=drawCollisionDebug;
},{}],28:[function(require,module,exports){
"use strict";function drawDebug(r,e,a){for(var t=0;t<a.length;t++)drawDebugTile(r,e,a[t])}function drawDebugTile(r,e,a){var t=r.gl;t.disable(t.STENCIL_TEST),r.lineWidth(1*browser.devicePixelRatio);var i=a.posMatrix,u=r.useProgram("debug");t.uniformMatrix4fv(u.u_matrix,!1,i),t.uniform4f(u.u_color,1,0,0,1),r.debugVAO.bind(t,u,r.debugBuffer),t.drawArrays(t.LINE_STRIP,0,r.debugBuffer.length);for(var o=textVertices(a.toString(),50,200,5),f=new PosArray,n=0;n<o.length;n+=2)f.emplaceBack(o[n],o[n+1]);var l=Buffer.fromStructArray(f,Buffer.BufferType.VERTEX),b=new VertexArrayObject;b.bind(t,u,l),t.uniform4f(u.u_color,1,1,1,1);for(var d=e.getTile(a).tileSize,g=EXTENT/(Math.pow(2,r.transform.zoom-a.z)*d),m=[[-1,-1],[-1,1],[1,-1],[1,1]],s=0;s<m.length;s++){var x=m[s];t.uniformMatrix4fv(u.u_matrix,!1,mat4.translate([],i,[g*x[0],g*x[1],0])),t.drawArrays(t.LINES,0,l.length)}t.uniform4f(u.u_color,0,0,0,1),t.uniformMatrix4fv(u.u_matrix,!1,i),t.drawArrays(t.LINES,0,l.length)}var textVertices=require("../lib/debugtext"),browser=require("../util/browser"),mat4=require("@mapbox/gl-matrix").mat4,EXTENT=require("../data/extent"),Buffer=require("../data/buffer"),VertexArrayObject=require("./vertex_array_object"),PosArray=require("../data/pos_array");module.exports=drawDebug;
},{"../data/buffer":8,"../data/extent":11,"../data/pos_array":14,"../lib/debugtext":23,"../util/browser":110,"./vertex_array_object":39,"@mapbox/gl-matrix":133}],29:[function(require,module,exports){
"use strict";function drawFill(t,e,r,i){var a=t.gl;a.enable(a.STENCIL_TEST);var l=!r.paint["fill-pattern"]&&r.isPaintValueFeatureConstant("fill-color")&&r.isPaintValueFeatureConstant("fill-opacity")&&1===r.paint["fill-color"][3]&&1===r.paint["fill-opacity"];t.isOpaquePass===l&&(t.setDepthSublayer(1),drawFillTiles(t,e,r,i,drawFillTile)),!t.isOpaquePass&&r.paint["fill-antialias"]&&(t.lineWidth(2),t.depthMask(!1),t.setDepthSublayer(r.getPaintProperty("fill-outline-color")?2:0),drawFillTiles(t,e,r,i,drawStrokeTile))}function drawFillTiles(t,e,r,i,a){for(var l=!0,n=0,o=i;n<o.length;n+=1){var f=o[n],s=e.getTile(f),u=s.getBucket(r);u&&(t.enableTileClippingMask(f),a(t,e,r,s,f,u.buffers,l),l=!1)}}function drawFillTile(t,e,r,i,a,l,n){for(var o=t.gl,f=l.layerData[r.id],s=setFillProgram("fill",r.paint["fill-pattern"],t,f,r,i,a,n),u=0,p=l.segments;u<p.length;u+=1){var g=p[u];g.vaos[r.id].bind(o,s,l.layoutVertexBuffer,l.elementBuffer,f.paintVertexBuffer,g.vertexOffset),o.drawElements(o.TRIANGLES,3*g.primitiveLength,o.UNSIGNED_SHORT,3*g.primitiveOffset*2)}}function drawStrokeTile(t,e,r,i,a,l,n){var o=t.gl,f=l.layerData[r.id],s=r.paint["fill-pattern"]&&!r.getPaintProperty("fill-outline-color"),u=setFillProgram("fillOutline",s,t,f,r,i,a,n);o.uniform2f(u.u_world,o.drawingBufferWidth,o.drawingBufferHeight);for(var p=0,g=l.segments2;p<g.length;p+=1){var m=g[p];m.vaos[r.id].bind(o,u,l.layoutVertexBuffer,l.elementBuffer2,f.paintVertexBuffer,m.vertexOffset),o.drawElements(o.LINES,2*m.primitiveLength,o.UNSIGNED_SHORT,2*m.primitiveOffset*2)}}function setFillProgram(t,e,r,i,a,l,n,o){var f,s=r.currentProgram;return e?(f=r.useProgram(t+"Pattern",i.programConfiguration),(o||f!==s)&&(i.programConfiguration.setUniforms(r.gl,f,a,{zoom:r.transform.zoom}),pattern.prepare(a.paint["fill-pattern"],r,f)),pattern.setTile(l,r,f)):(f=r.useProgram(t,i.programConfiguration),(o||f!==s)&&i.programConfiguration.setUniforms(r.gl,f,a,{zoom:r.transform.zoom})),r.gl.uniformMatrix4fv(f.u_matrix,!1,r.translatePosMatrix(n.posMatrix,l,a.paint["fill-translate"],a.paint["fill-translate-anchor"])),f}var pattern=require("./pattern");module.exports=drawFill;
},{"./pattern":37}],30:[function(require,module,exports){
"use strict";function draw(t,e,r,i){if(0!==r.paint["fill-extrusion-opacity"]){var a=t.gl;a.disable(a.STENCIL_TEST),a.enable(a.DEPTH_TEST),t.depthMask(!0);var s=new ExtrusionTexture(a,t,r);s.bindFramebuffer(),a.clearColor(0,0,0,0),a.clear(a.COLOR_BUFFER_BIT|a.DEPTH_BUFFER_BIT);for(var u=0;u<i.length;u++)drawExtrusion(t,e,r,i[u]);s.unbindFramebuffer(),s.renderToMap()}}function ExtrusionTexture(t,e,r){this.gl=t,this.width=e.width,this.height=e.height,this.painter=e,this.layer=r,this.texture=null,this.fbo=null,this.fbos=this.painter.preFbos[this.width]&&this.painter.preFbos[this.width][this.height]}function drawExtrusion(t,e,r,i){if(!t.isOpaquePass){var a=e.getTile(i),s=a.getBucket(r);if(s){var u=s.buffers,f=t.gl,h=r.paint["fill-extrusion-pattern"],n=u.layerData[r.id],o=n.programConfiguration,E=t.useProgram(h?"fillExtrusionPattern":"fillExtrusion",o);o.setUniforms(f,E,r,{zoom:t.transform.zoom}),h&&(pattern.prepare(h,t,E),pattern.setTile(a,t,E),f.uniform1f(E.u_height_factor,-Math.pow(2,i.z)/a.tileSize/8)),t.gl.uniformMatrix4fv(E.u_matrix,!1,t.translatePosMatrix(i.posMatrix,a,r.paint["fill-extrusion-translate"],r.paint["fill-extrusion-translate-anchor"])),setLight(E,t);for(var T=0,l=u.segments;T<l.length;T+=1){var R=l[T];R.vaos[r.id].bind(f,E,u.layoutVertexBuffer,u.elementBuffer,n.paintVertexBuffer,R.vertexOffset),f.drawElements(f.TRIANGLES,3*R.primitiveLength,f.UNSIGNED_SHORT,3*R.primitiveOffset*2)}}}}function setLight(t,e){var r=e.gl,i=e.style.light,a=i.calculated.position,s=[a.x,a.y,a.z],u=mat3.create();"viewport"===i.calculated.anchor&&mat3.fromRotation(u,-e.transform.angle),vec3.transformMat3(s,s,u),r.uniform3fv(t.u_lightpos,s),r.uniform1f(t.u_lightintensity,i.calculated.intensity),r.uniform3fv(t.u_lightcolor,i.calculated.color.slice(0,3))}var glMatrix=require("@mapbox/gl-matrix"),Buffer=require("../data/buffer"),VertexArrayObject=require("./vertex_array_object"),PosArray=require("../data/pos_array"),pattern=require("./pattern"),mat3=glMatrix.mat3,mat4=glMatrix.mat4,vec3=glMatrix.vec3;module.exports=draw,ExtrusionTexture.prototype.bindFramebuffer=function(){var t=this.gl;if(this.texture=this.painter.getViewportTexture(this.width,this.height),t.activeTexture(t.TEXTURE1),this.texture?t.bindTexture(t.TEXTURE_2D,this.texture):(this.texture=t.createTexture(),t.bindTexture(t.TEXTURE_2D,this.texture),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.LINEAR),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,this.width,this.height,0,t.RGBA,t.UNSIGNED_BYTE,null),this.texture.width=this.width,this.texture.height=this.height),this.fbos)this.fbo=this.fbos.pop(),t.bindFramebuffer(t.FRAMEBUFFER,this.fbo),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,this.texture,0);else{this.fbo=t.createFramebuffer();var e=t.createRenderbuffer(),r=t.createRenderbuffer();t.bindRenderbuffer(t.RENDERBUFFER,e),t.bindRenderbuffer(t.RENDERBUFFER,r),t.renderbufferStorage(t.RENDERBUFFER,t.RGBA4,this.width,this.height),t.renderbufferStorage(t.RENDERBUFFER,t.DEPTH_COMPONENT16,this.width,this.height),t.bindFramebuffer(t.FRAMEBUFFER,this.fbo),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.RENDERBUFFER,e),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.RENDERBUFFER,r),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,this.texture,0)}},ExtrusionTexture.prototype.unbindFramebuffer=function(){this.painter.bindDefaultFramebuffer(),this.fbos?this.fbos.push(this.fbo):(this.painter.preFbos[this.width]||(this.painter.preFbos[this.width]={}),this.painter.preFbos[this.width][this.height]=[this.fbo]),this.painter.saveViewportTexture(this.texture)},ExtrusionTexture.prototype.renderToMap=function(){var t=this.gl,e=this.painter,r=e.useProgram("extrusionTexture");t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,this.texture),t.uniform1f(r.u_opacity,this.layer.paint["fill-extrusion-opacity"]),t.uniform1i(r.u_texture,1),t.uniformMatrix4fv(r.u_matrix,!1,mat4.ortho(mat4.create(),0,e.width,e.height,0,0,1)),t.disable(t.DEPTH_TEST),t.uniform1i(r.u_xdim,e.width),t.uniform1i(r.u_ydim,e.height);var i=new PosArray;i.emplaceBack(0,0),i.emplaceBack(e.width,0),i.emplaceBack(0,e.height),i.emplaceBack(e.width,e.height);var a=Buffer.fromStructArray(i,Buffer.BufferType.VERTEX),s=new VertexArrayObject;s.bind(t,r,a),t.drawArrays(t.TRIANGLE_STRIP,0,4),t.enable(t.DEPTH_TEST)};
},{"../data/buffer":8,"../data/pos_array":14,"./pattern":37,"./vertex_array_object":39,"@mapbox/gl-matrix":133}],31:[function(require,module,exports){
"use strict";function drawLineTile(e,i,t,r,a,n,o,f,s){var l,u,m,_,p=i.gl,g=a.paint["line-dasharray"],d=a.paint["line-pattern"];if(f||s){var v=1/pixelsToTileUnits(t,1,i.transform.tileZoom);if(g){l=i.lineAtlas.getDash(g.from,"round"===a.layout["line-cap"]),u=i.lineAtlas.getDash(g.to,"round"===a.layout["line-cap"]);var T=l.width*g.fromScale,h=u.width*g.toScale;p.uniform2f(e.u_patternscale_a,v/T,-l.height/2),p.uniform2f(e.u_patternscale_b,v/h,-u.height/2),p.uniform1f(e.u_sdfgamma,i.lineAtlas.width/(256*Math.min(T,h)*browser.devicePixelRatio)/2)}else if(d){if(m=i.spriteAtlas.getPosition(d.from,!0),_=i.spriteAtlas.getPosition(d.to,!0),!m||!_)return;p.uniform2f(e.u_pattern_size_a,m.size[0]*d.fromScale/v,_.size[1]),p.uniform2f(e.u_pattern_size_b,_.size[0]*d.toScale/v,_.size[1])}p.uniform2f(e.u_gl_units_to_pixels,1/i.transform.pixelsToGLUnits[0],1/i.transform.pixelsToGLUnits[1])}f&&(g?(p.uniform1i(e.u_image,0),p.activeTexture(p.TEXTURE0),i.lineAtlas.bind(p),p.uniform1f(e.u_tex_y_a,l.y),p.uniform1f(e.u_tex_y_b,u.y),p.uniform1f(e.u_mix,g.t)):d&&(p.uniform1i(e.u_image,0),p.activeTexture(p.TEXTURE0),i.spriteAtlas.bind(p,!0),p.uniform2fv(e.u_pattern_tl_a,m.tl),p.uniform2fv(e.u_pattern_br_a,m.br),p.uniform2fv(e.u_pattern_tl_b,_.tl),p.uniform2fv(e.u_pattern_br_b,_.br),p.uniform1f(e.u_fade,d.t)),p.uniform1f(e.u_width,a.paint["line-width"])),i.enableTileClippingMask(n);var x=i.translatePosMatrix(n.posMatrix,t,a.paint["line-translate"],a.paint["line-translate-anchor"]);p.uniformMatrix4fv(e.u_matrix,!1,x),p.uniform1f(e.u_ratio,1/pixelsToTileUnits(t,1,i.transform.zoom));for(var b=0,c=r.segments;b<c.length;b+=1){var w=c[b];w.vaos[a.id].bind(p,e,r.layoutVertexBuffer,r.elementBuffer,o.paintVertexBuffer,w.vertexOffset),p.drawElements(p.TRIANGLES,3*w.primitiveLength,p.UNSIGNED_SHORT,3*w.primitiveOffset*2)}}var browser=require("../util/browser"),pixelsToTileUnits=require("../source/pixels_to_tile_units");module.exports=function(e,i,t,r){if(!e.isOpaquePass){e.setDepthSublayer(0),e.depthMask(!1);var a=e.gl;if(a.enable(a.STENCIL_TEST),!(t.paint["line-width"]<=0))for(var n,o=t.paint["line-dasharray"]?"lineSDF":t.paint["line-pattern"]?"linePattern":"line",f=!0,s=0,l=r;s<l.length;s+=1){var u=l[s],m=i.getTile(u),_=m.getBucket(t);if(_){var p=_.buffers.layerData[t.id],g=e.currentProgram,d=e.useProgram(o,p.programConfiguration),v=f||d!==g,T=n!==m.coord.z;v&&p.programConfiguration.setUniforms(e.gl,d,t,{zoom:e.transform.zoom}),drawLineTile(d,e,m,_.buffers,t,u,p,v,T),n=m.coord.z,f=!1}}}};
},{"../source/pixels_to_tile_units":46,"../util/browser":110}],32:[function(require,module,exports){
"use strict";function drawRaster(r,t,a,e){if(!r.isOpaquePass){var i=r.gl;i.enable(i.DEPTH_TEST),r.depthMask(!0),i.depthFunc(i.LESS);for(var o=e.length&&e[0].z,n=0;n<e.length;n++){var u=e[n];r.setDepthSublayer(u.z-o),drawRasterTile(r,t,a,u)}i.depthFunc(i.LEQUAL)}}function drawRasterTile(r,t,a,e){var i=r.gl;i.disable(i.STENCIL_TEST);var o=t.getTile(e),n=r.transform.calculatePosMatrix(e,t.getSource().maxzoom);o.registerFadeDuration(r.style.animationLoop,a.paint["raster-fade-duration"]);var u=r.useProgram("raster");i.uniformMatrix4fv(u.u_matrix,!1,n),i.uniform1f(u.u_brightness_low,a.paint["raster-brightness-min"]),i.uniform1f(u.u_brightness_high,a.paint["raster-brightness-max"]),i.uniform1f(u.u_saturation_factor,saturationFactor(a.paint["raster-saturation"])),i.uniform1f(u.u_contrast_factor,contrastFactor(a.paint["raster-contrast"])),i.uniform3fv(u.u_spin_weights,spinWeights(a.paint["raster-hue-rotate"]));var s,c,f=o.sourceCache&&o.sourceCache.findLoadedParent(e,0,{}),d=getFadeValues(o,f,a,r.transform);i.activeTexture(i.TEXTURE0),i.bindTexture(i.TEXTURE_2D,o.texture),i.activeTexture(i.TEXTURE1),f?(i.bindTexture(i.TEXTURE_2D,f.texture),s=Math.pow(2,f.coord.z-o.coord.z),c=[o.coord.x*s%1,o.coord.y*s%1]):i.bindTexture(i.TEXTURE_2D,o.texture),i.uniform2fv(u.u_tl_parent,c||[0,0]),i.uniform1f(u.u_scale_parent,s||1),i.uniform1f(u.u_buffer_scale,1),i.uniform1f(u.u_fade_t,d.mix),i.uniform1f(u.u_opacity,d.opacity*a.paint["raster-opacity"]),i.uniform1i(u.u_image0,0),i.uniform1i(u.u_image1,1);var m=o.boundsBuffer||r.rasterBoundsBuffer,h=o.boundsVAO||r.rasterBoundsVAO;h.bind(i,u,m),i.drawArrays(i.TRIANGLE_STRIP,0,m.length)}function spinWeights(r){r*=Math.PI/180;var t=Math.sin(r),a=Math.cos(r);return[(2*a+1)/3,(-Math.sqrt(3)*t-a+1)/3,(Math.sqrt(3)*t-a+1)/3]}function contrastFactor(r){return r>0?1/(1-r):1+r}function saturationFactor(r){return r>0?1-1/(1.001-r):-r}function getFadeValues(r,t,a,e){var i=a.paint["raster-fade-duration"];if(r.sourceCache&&i>0){var o=Date.now(),n=(o-r.timeAdded)/i,u=t?(o-t.timeAdded)/i:-1,s=r.sourceCache.getSource(),c=e.coveringZoomLevel({tileSize:s.tileSize,roundZoom:s.roundZoom}),f=!t||Math.abs(t.coord.z-c)>Math.abs(r.coord.z-c),d=util.clamp(f?n:1-u,0,1);return t?{opacity:1,mix:1-d}:{opacity:d,mix:0}}return{opacity:1,mix:0}}var util=require("../util/util");module.exports=drawRaster;
},{"../util/util":129}],33:[function(require,module,exports){
"use strict";function drawSymbols(t,e,i,a){if(!t.isOpaquePass){var o=!(i.layout["text-allow-overlap"]||i.layout["icon-allow-overlap"]||i.layout["text-ignore-placement"]||i.layout["icon-ignore-placement"]),r=t.gl;o?r.disable(r.STENCIL_TEST):r.enable(r.STENCIL_TEST),t.setDepthSublayer(0),t.depthMask(!1),drawLayerSymbols(t,e,i,a,!1,i.paint["icon-translate"],i.paint["icon-translate-anchor"],i.layout["icon-rotation-alignment"],i.layout["icon-rotation-alignment"],i.layout["icon-size"],i.paint["icon-halo-width"],i.paint["icon-halo-color"],i.paint["icon-halo-blur"],i.paint["icon-opacity"],i.paint["icon-color"]),drawLayerSymbols(t,e,i,a,!0,i.paint["text-translate"],i.paint["text-translate-anchor"],i.layout["text-rotation-alignment"],i.layout["text-pitch-alignment"],i.layout["text-size"],i.paint["text-halo-width"],i.paint["text-halo-color"],i.paint["text-halo-blur"],i.paint["text-opacity"],i.paint["text-color"]),e.map.showCollisionBoxes&&drawCollisionDebug(t,e,i,a)}}function drawLayerSymbols(t,e,i,a,o,r,n,l,s,u,f,m,c,p,d){if(o||!t.style.sprite||t.style.sprite.loaded()){var h=t.gl,b="map"===l,x="map"===s,g=x;g?h.enable(h.DEPTH_TEST):h.disable(h.DEPTH_TEST);for(var _,y,T=0,v=a;T<v.length;T+=1){var w=v[T],S=e.getTile(w),E=S.getBucket(i);if(E){var P=o?E.buffers.glyph:E.buffers.icon;if(P&&P.segments.length){var D=o||E.sdfIcons;_&&E.fontstack===y||(_=t.useProgram(D?"symbolSDF":"symbolIcon"),setSymbolDrawState(_,t,o,D,b,x,E.fontstack,u,E.iconsNeedLinear,o?E.adjustedTextSize:E.adjustedIconSize,p)),t.enableTileClippingMask(w),h.uniformMatrix4fv(_.u_matrix,!1,t.translatePosMatrix(w.posMatrix,S,r,n)),drawTileSymbols(_,t,i,S,P,o,D,x,u,f,m,c,d),y=E.fontstack}}}g||h.enable(h.DEPTH_TEST)}}function setSymbolDrawState(t,e,i,a,o,r,n,l,s,u,f){var m=e.gl,c=e.transform;if(m.uniform1i(t.u_rotate_with_map,o),m.uniform1i(t.u_pitch_with_map,r),m.activeTexture(m.TEXTURE0),m.uniform1i(t.u_texture,0),i){var p=n&&e.glyphSource.getGlyphAtlas(n);if(!p)return;p.updateTexture(m),m.uniform2f(t.u_texsize,p.width/4,p.height/4)}else{var d=e.options.rotating||e.options.zooming,h=1!==l||browser.devicePixelRatio!==e.spriteAtlas.pixelRatio||s,b=r||c.pitch;e.spriteAtlas.bind(m,a||d||h||b),m.uniform2f(t.u_texsize,e.spriteAtlas.width/4,e.spriteAtlas.height/4)}m.activeTexture(m.TEXTURE1),e.frameHistory.bind(m),m.uniform1i(t.u_fadetexture,1);var x=Math.log(l/u)/Math.LN2||0;m.uniform1f(t.u_zoom,10*(c.zoom-x)),m.uniform1f(t.u_pitch,c.pitch/360*2*Math.PI),m.uniform1f(t.u_bearing,c.bearing/360*2*Math.PI),m.uniform1f(t.u_aspect_ratio,c.width/c.height),m.uniform1f(t.u_opacity,f)}function drawTileSymbols(t,e,i,a,o,r,n,l,s,u,f,m,c){var p=e.gl,d=e.transform,h=s/(r?24:1);if(l){var b=pixelsToTileUnits(a,h,d.zoom);p.uniform2f(t.u_extrude_scale,b,b)}else{var x=d.cameraToCenterDistance*h;p.uniform2f(t.u_extrude_scale,d.pixelsToGLUnits[0]*x,d.pixelsToGLUnits[1]*x)}if(n){var g=h*(l?Math.cos(d._pitch):1)*d.cameraToCenterDistance;u&&(p.uniform1f(t.u_gamma,(m*blurOffset/sdfPx+gamma)/g),p.uniform4fv(t.u_color,f),p.uniform1f(t.u_buffer,(haloOffset-u/h)/sdfPx),drawSymbolElements(o,i,p,t)),p.uniform1f(t.u_gamma,gamma/g),p.uniform4fv(t.u_color,c),p.uniform1f(t.u_buffer,.75)}drawSymbolElements(o,i,p,t)}function drawSymbolElements(t,e,i,a){for(var o=0,r=t.segments;o<r.length;o+=1){var n=r[o];n.vaos[e.id].bind(i,a,t.layoutVertexBuffer,t.elementBuffer,null,n.vertexOffset),i.drawElements(i.TRIANGLES,3*n.primitiveLength,i.UNSIGNED_SHORT,3*n.primitiveOffset*2)}}var browser=require("../util/browser"),drawCollisionDebug=require("./draw_collision_debug"),pixelsToTileUnits=require("../source/pixels_to_tile_units");module.exports=drawSymbols;var sdfPx=8,blurOffset=1.19,haloOffset=6,gamma=.105/browser.devicePixelRatio;
},{"../source/pixels_to_tile_units":46,"../util/browser":110,"./draw_collision_debug":27}],34:[function(require,module,exports){
"use strict";var FrameHistory=function(){this.changeTimes=new Float64Array(256),this.changeOpacities=new Uint8Array(256),this.opacities=new Uint8ClampedArray(256),this.array=new Uint8Array(this.opacities.buffer),this.previousZoom=0,this.firstFrame=!0};FrameHistory.prototype.record=function(e,t,i){var r=this;this.firstFrame&&(e=0,this.firstFrame=!1),t=Math.floor(10*t);var a;if(t<this.previousZoom)for(a=t+1;a<=this.previousZoom;a++)r.changeTimes[a]=e,r.changeOpacities[a]=r.opacities[a];else for(a=t;a>this.previousZoom;a--)r.changeTimes[a]=e,r.changeOpacities[a]=r.opacities[a];for(a=0;a<256;a++){var s=e-r.changeTimes[a],o=255*(i?s/i:1);a<=t?r.opacities[a]=r.changeOpacities[a]+o:r.opacities[a]=r.changeOpacities[a]-o}this.changed=!0,this.previousZoom=t},FrameHistory.prototype.bind=function(e){this.texture?(e.bindTexture(e.TEXTURE_2D,this.texture),this.changed&&(e.texSubImage2D(e.TEXTURE_2D,0,0,0,256,1,e.ALPHA,e.UNSIGNED_BYTE,this.array),this.changed=!1)):(this.texture=e.createTexture(),e.bindTexture(e.TEXTURE_2D,this.texture),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texImage2D(e.TEXTURE_2D,0,e.ALPHA,256,1,0,e.ALPHA,e.UNSIGNED_BYTE,this.array))},module.exports=FrameHistory;
},{}],35:[function(require,module,exports){
"use strict";var util=require("../util/util"),LineAtlas=function(t,i){this.width=t,this.height=i,this.nextRow=0,this.bytes=4,this.data=new Uint8Array(this.width*this.height*this.bytes),this.positions={}};LineAtlas.prototype.setSprite=function(t){this.sprite=t},LineAtlas.prototype.getDash=function(t,i){var e=t.join(",")+i;return this.positions[e]||(this.positions[e]=this.addDash(t,i)),this.positions[e]},LineAtlas.prototype.addDash=function(t,i){var e=this,h=i?7:0,s=2*h+1,a=128;if(this.nextRow+s>this.height)return util.warnOnce("LineAtlas out of space"),null;for(var r=0,n=0;n<t.length;n++)r+=t[n];for(var E=this.width/r,o=E/2,T=t.length%2===1,R=-h;R<=h;R++)for(var u=e.nextRow+h+R,d=e.width*u,l=T?-t[t.length-1]:0,x=t[0],A=1,_=0;_<this.width;_++){for(;x<_/E;)l=x,x+=t[A],T&&A===t.length-1&&(x+=t[0]),A++;var p,g=Math.abs(_-l*E),w=Math.abs(_-x*E),D=Math.min(g,w),U=A%2===1;if(i){var f=h?R/h*(o+1):0;if(U){var X=o-Math.abs(f);p=Math.sqrt(D*D+X*X)}else p=o-Math.sqrt(D*D+f*f)}else p=(U?1:-1)*D;e.data[3+4*(d+_)]=Math.max(0,Math.min(255,p+a))}var y={y:(this.nextRow+h+.5)/this.height,height:2*h/this.height,width:r};return this.nextRow+=s,this.dirty=!0,y},LineAtlas.prototype.bind=function(t){this.texture?(t.bindTexture(t.TEXTURE_2D,this.texture),this.dirty&&(this.dirty=!1,t.texSubImage2D(t.TEXTURE_2D,0,0,0,this.width,this.height,t.RGBA,t.UNSIGNED_BYTE,this.data))):(this.texture=t.createTexture(),t.bindTexture(t.TEXTURE_2D,this.texture),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.REPEAT),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.REPEAT),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.LINEAR),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,this.width,this.height,0,t.RGBA,t.UNSIGNED_BYTE,this.data))},module.exports=LineAtlas;
},{"../util/util":129}],36:[function(require,module,exports){
"use strict";var browser=require("../util/browser"),mat4=require("@mapbox/gl-matrix").mat4,FrameHistory=require("./frame_history"),SourceCache=require("../source/source_cache"),EXTENT=require("../data/extent"),pixelsToTileUnits=require("../source/pixels_to_tile_units"),util=require("../util/util"),Buffer=require("../data/buffer"),VertexArrayObject=require("./vertex_array_object"),RasterBoundsArray=require("../data/raster_bounds_array"),PosArray=require("../data/pos_array"),ProgramConfiguration=require("../data/program_configuration"),shaders=require("./shaders"),draw={symbol:require("./draw_symbol"),circle:require("./draw_circle"),line:require("./draw_line"),fill:require("./draw_fill"),"fill-extrusion":require("./draw_fill_extrusion"),raster:require("./draw_raster"),background:require("./draw_background"),debug:require("./draw_debug")},Painter=function(e,r){this.gl=e,this.transform=r,this.reusableTextures={tiles:{},viewport:null},this.preFbos={},this.frameHistory=new FrameHistory,this.setup(),this.numSublayers=SourceCache.maxUnderzooming+SourceCache.maxOverzooming+1,this.depthEpsilon=1/Math.pow(2,16),this.lineWidthRange=e.getParameter(e.ALIASED_LINE_WIDTH_RANGE),this.basicFillProgramConfiguration=ProgramConfiguration.createStatic(["color","opacity"]),this.emptyProgramConfiguration=new ProgramConfiguration};Painter.prototype.resize=function(e,r){var t=this.gl;this.width=e*browser.devicePixelRatio,this.height=r*browser.devicePixelRatio,t.viewport(0,0,this.width,this.height)},Painter.prototype.setup=function(){var e=this.gl;e.verbose=!0,e.enable(e.BLEND),e.blendFunc(e.ONE,e.ONE_MINUS_SRC_ALPHA),e.enable(e.STENCIL_TEST),e.enable(e.DEPTH_TEST),e.depthFunc(e.LEQUAL),this._depthMask=!1,e.depthMask(!1);var r=new PosArray;r.emplaceBack(0,0),r.emplaceBack(EXTENT,0),r.emplaceBack(0,EXTENT),r.emplaceBack(EXTENT,EXTENT),this.tileExtentBuffer=Buffer.fromStructArray(r,Buffer.BufferType.VERTEX),this.tileExtentVAO=new VertexArrayObject,this.tileExtentPatternVAO=new VertexArrayObject;var t=new PosArray;t.emplaceBack(0,0),t.emplaceBack(EXTENT,0),t.emplaceBack(EXTENT,EXTENT),t.emplaceBack(0,EXTENT),t.emplaceBack(0,0),this.debugBuffer=Buffer.fromStructArray(t,Buffer.BufferType.VERTEX),this.debugVAO=new VertexArrayObject;var i=new RasterBoundsArray;i.emplaceBack(0,0,0,0),i.emplaceBack(EXTENT,0,32767,0),i.emplaceBack(0,EXTENT,0,32767),i.emplaceBack(EXTENT,EXTENT,32767,32767),this.rasterBoundsBuffer=Buffer.fromStructArray(i,Buffer.BufferType.VERTEX),this.rasterBoundsVAO=new VertexArrayObject},Painter.prototype.clearColor=function(){var e=this.gl;e.clearColor(0,0,0,0),e.clear(e.COLOR_BUFFER_BIT)},Painter.prototype.clearStencil=function(){var e=this.gl;e.clearStencil(0),e.stencilMask(255),e.clear(e.STENCIL_BUFFER_BIT)},Painter.prototype.clearDepth=function(){var e=this.gl;e.clearDepth(1),this.depthMask(!0),e.clear(e.DEPTH_BUFFER_BIT)},Painter.prototype._renderTileClippingMasks=function(e){var r=this,t=this.gl;t.colorMask(!1,!1,!1,!1),this.depthMask(!1),t.disable(t.DEPTH_TEST),t.enable(t.STENCIL_TEST),t.stencilMask(248),t.stencilOp(t.KEEP,t.KEEP,t.REPLACE);var i=1;this._tileClippingMaskIDs={};for(var a=0,s=e;a<s.length;a+=1){var o=s[a],n=r._tileClippingMaskIDs[o.id]=i++<<3;t.stencilFunc(t.ALWAYS,n,248);var l=r.useProgram("fill",r.basicFillProgramConfiguration);t.uniformMatrix4fv(l.u_matrix,!1,o.posMatrix),r.tileExtentVAO.bind(t,l,r.tileExtentBuffer),t.drawArrays(t.TRIANGLE_STRIP,0,r.tileExtentBuffer.length)}t.stencilMask(0),t.colorMask(!0,!0,!0,!0),this.depthMask(!0),t.enable(t.DEPTH_TEST)},Painter.prototype.enableTileClippingMask=function(e){var r=this.gl;r.stencilFunc(r.EQUAL,this._tileClippingMaskIDs[e.id],248)},Painter.prototype.prepareBuffers=function(){},Painter.prototype.bindDefaultFramebuffer=function(){var e=this.gl;e.bindFramebuffer(e.FRAMEBUFFER,null)},Painter.prototype.render=function(e,r){if(this.style=e,this.options=r,this.lineAtlas=e.lineAtlas,this.spriteAtlas=e.spriteAtlas,this.spriteAtlas.setSprite(e.sprite),this.glyphSource=e.glyphSource,this.frameHistory.record(Date.now(),this.transform.zoom,e.getTransition().duration),this.prepareBuffers(),this.clearColor(),this.clearDepth(),this.showOverdrawInspector(r.showOverdrawInspector),this.depthRange=(e._order.length+2)*this.numSublayers*this.depthEpsilon,this.isOpaquePass=!0,this.renderPass(),this.isOpaquePass=!1,this.renderPass(),this.options.showTileBoundaries){var t=this.style.sourceCaches[Object.keys(this.style.sourceCaches)[0]];t&&draw.debug(this,t,t.getVisibleCoordinates())}},Painter.prototype.renderPass=function(){var e,r,t=this,i=this.style._order;this.currentLayer=this.isOpaquePass?i.length-1:0,this.isOpaquePass?this._showOverdrawInspector||this.gl.disable(this.gl.BLEND):this.gl.enable(this.gl.BLEND);for(var a=0;a<i.length;a++){var s=t.style._layers[i[t.currentLayer]];s.source!==(e&&e.id)&&(e=t.style.sourceCaches[s.source],r=[],e&&(e.prepare&&e.prepare(),t.clearStencil(),r=e.getVisibleCoordinates(),e.getSource().isTileClipped&&t._renderTileClippingMasks(r)),t.isOpaquePass||r.reverse()),t.renderLayer(t,e,s,r),t.currentLayer+=t.isOpaquePass?-1:1}},Painter.prototype.depthMask=function(e){e!==this._depthMask&&(this._depthMask=e,this.gl.depthMask(e))},Painter.prototype.renderLayer=function(e,r,t,i){t.isHidden(this.transform.zoom)||("background"===t.type||i.length)&&(this.id=t.id,draw[t.type](e,r,t,i))},Painter.prototype.setDepthSublayer=function(e){var r=1-((1+this.currentLayer)*this.numSublayers+e)*this.depthEpsilon,t=r-1+this.depthRange;this.gl.depthRange(t,r)},Painter.prototype.translatePosMatrix=function(e,r,t,i){if(!t[0]&&!t[1])return e;if("viewport"===i){var a=Math.sin(-this.transform.angle),s=Math.cos(-this.transform.angle);t=[t[0]*s-t[1]*a,t[0]*a+t[1]*s]}var o=[pixelsToTileUnits(r,t[0],this.transform.zoom),pixelsToTileUnits(r,t[1],this.transform.zoom),0],n=new Float32Array(16);return mat4.translate(n,e,o),n},Painter.prototype.saveTileTexture=function(e){var r=this.reusableTextures.tiles[e.size];r?r.push(e):this.reusableTextures.tiles[e.size]=[e]},Painter.prototype.saveViewportTexture=function(e){this.reusableTextures.viewport=e},Painter.prototype.getTileTexture=function(e){var r=this.reusableTextures.tiles[e];return r&&r.length>0?r.pop():null},Painter.prototype.getViewportTexture=function(e,r){var t=this.reusableTextures.viewport;if(t)return t.width===e&&t.height===r?t:(this.gl.deleteTexture(t),void(this.reusableTextures.viewport=null))},Painter.prototype.lineWidth=function(e){this.gl.lineWidth(util.clamp(e,this.lineWidthRange[0],this.lineWidthRange[1]))},Painter.prototype.showOverdrawInspector=function(e){if(e||this._showOverdrawInspector){this._showOverdrawInspector=e;var r=this.gl;if(e){r.blendFunc(r.CONSTANT_COLOR,r.ONE);var t=8,i=1/t;r.blendColor(i,i,i,0),r.clearColor(0,0,0,1),r.clear(r.COLOR_BUFFER_BIT)}else r.blendFunc(r.ONE,r.ONE_MINUS_SRC_ALPHA)}},Painter.prototype.createProgram=function(e,r){var t=this.gl,i=t.createProgram(),a=shaders[e],s="#define MAPBOX_GL_JS\n#define DEVICE_PIXEL_RATIO "+browser.devicePixelRatio.toFixed(1)+"\n";this._showOverdrawInspector&&(s+="#define OVERDRAW_INSPECTOR;\n");var o=t.createShader(t.FRAGMENT_SHADER);t.shaderSource(o,r.applyPragmas(s+shaders.prelude.fragmentSource+a.fragmentSource,"fragment")),t.compileShader(o),t.attachShader(i,o);var n=t.createShader(t.VERTEX_SHADER);t.shaderSource(n,r.applyPragmas(s+shaders.prelude.vertexSource+a.vertexSource,"vertex")),t.compileShader(n),t.attachShader(i,n),t.linkProgram(i);for(var l=t.getProgramParameter(i,t.ACTIVE_ATTRIBUTES),h={program:i,numAttributes:l},u=0;u<l;u++){var c=t.getActiveAttrib(i,u);h[c.name]=t.getAttribLocation(i,c.name)}for(var p=t.getProgramParameter(i,t.ACTIVE_UNIFORMS),d=0;d<p;d++){var f=t.getActiveUniform(i,d);h[f.name]=t.getUniformLocation(i,f.name)}return h},Painter.prototype._createProgramCached=function(e,r){this.cache=this.cache||{};var t=""+e+(r.cacheKey||"")+(this._showOverdrawInspector?"/overdraw":"");return this.cache[t]||(this.cache[t]=this.createProgram(e,r)),this.cache[t]},Painter.prototype.useProgram=function(e,r){var t=this.gl,i=this._createProgramCached(e,r||this.emptyProgramConfiguration);return this.currentProgram!==i&&(t.useProgram(i.program),this.currentProgram=i),i},module.exports=Painter;
},{"../data/buffer":8,"../data/extent":11,"../data/pos_array":14,"../data/program_configuration":15,"../data/raster_bounds_array":16,"../source/pixels_to_tile_units":46,"../source/source_cache":51,"../util/browser":110,"../util/util":129,"./draw_background":25,"./draw_circle":26,"./draw_debug":28,"./draw_fill":29,"./draw_fill_extrusion":30,"./draw_line":31,"./draw_raster":32,"./draw_symbol":33,"./frame_history":34,"./shaders":38,"./vertex_array_object":39,"@mapbox/gl-matrix":133}],37:[function(require,module,exports){
"use strict";var pixelsToTileUnits=require("../source/pixels_to_tile_units");exports.prepare=function(r,t,i){var o=t.gl,e=t.spriteAtlas.getPosition(r.from,!0),_=t.spriteAtlas.getPosition(r.to,!0);e&&_&&(o.uniform1i(i.u_image,0),o.uniform2fv(i.u_pattern_tl_a,e.tl),o.uniform2fv(i.u_pattern_br_a,e.br),o.uniform2fv(i.u_pattern_tl_b,_.tl),o.uniform2fv(i.u_pattern_br_b,_.br),o.uniform1f(i.u_mix,r.t),o.uniform2fv(i.u_pattern_size_a,e.size),o.uniform2fv(i.u_pattern_size_b,_.size),o.uniform1f(i.u_scale_a,r.fromScale),o.uniform1f(i.u_scale_b,r.toScale),o.activeTexture(o.TEXTURE0),t.spriteAtlas.bind(o,!0))},exports.setTile=function(r,t,i){var o=t.gl;o.uniform1f(i.u_tile_units_to_pixels,1/pixelsToTileUnits(r,1,t.transform.tileZoom));var e=Math.pow(2,r.coord.z),_=r.tileSize*Math.pow(2,t.transform.tileZoom)/e,u=_*(r.coord.x+r.coord.w*e),n=_*r.coord.y;o.uniform2f(i.u_pixel_coord_upper,u>>16,n>>16),o.uniform2f(i.u_pixel_coord_lower,65535&u,65535&n)};
},{"../source/pixels_to_tile_units":46}],38:[function(require,module,exports){
"use strict";var path=require("path");module.exports={prelude:{fragmentSource:"#ifdef GL_ES\nprecision mediump float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif\n",vertexSource:"#ifdef GL_ES\nprecision highp float;\n#else\n\n#if !defined(lowp)\n#define lowp\n#endif\n\n#if !defined(mediump)\n#define mediump\n#endif\n\n#if !defined(highp)\n#define highp\n#endif\n\n#endif\n\nfloat evaluate_zoom_function_1(const vec4 values, const float t) {\n    if (t < 1.0) {\n        return mix(values[0], values[1], t);\n    } else if (t < 2.0) {\n        return mix(values[1], values[2], t - 1.0);\n    } else {\n        return mix(values[2], values[3], t - 2.0);\n    }\n}\nvec4 evaluate_zoom_function_4(const vec4 value0, const vec4 value1, const vec4 value2, const vec4 value3, const float t) {\n    if (t < 1.0) {\n        return mix(value0, value1, t);\n    } else if (t < 2.0) {\n        return mix(value1, value2, t - 1.0);\n    } else {\n        return mix(value2, value3, t - 2.0);\n    }\n}\n\n// The offset depends on how many pixels are between the world origin and the edge of the tile:\n// vec2 offset = mod(pixel_coord, size)\n//\n// At high zoom levels there are a ton of pixels between the world origin and the edge of the tile.\n// The glsl spec only guarantees 16 bits of precision for highp floats. We need more than that.\n//\n// The pixel_coord is passed in as two 16 bit values:\n// pixel_coord_upper = floor(pixel_coord / 2^16)\n// pixel_coord_lower = mod(pixel_coord, 2^16)\n//\n// The offset is calculated in a series of steps that should preserve this precision:\nvec2 get_pattern_pos(const vec2 pixel_coord_upper, const vec2 pixel_coord_lower,\n    const vec2 pattern_size, const float tile_units_to_pixels, const vec2 pos) {\n\n    vec2 offset = mod(mod(mod(pixel_coord_upper, pattern_size) * 256.0, pattern_size) * 256.0 + pixel_coord_lower, pattern_size);\n    return (tile_units_to_pixels * pos + offset) / pattern_size;\n}\n"},circle:{fragmentSource:"#pragma mapbox: define lowp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\n\nvarying vec2 v_extrude;\nvarying lowp float v_antialiasblur;\n\nvoid main() {\n    #pragma mapbox: initialize lowp vec4 color\n    #pragma mapbox: initialize mediump float radius\n    #pragma mapbox: initialize lowp float blur\n    #pragma mapbox: initialize lowp float opacity\n    #pragma mapbox: initialize lowp vec4 stroke_color\n    #pragma mapbox: initialize mediump float stroke_width\n    #pragma mapbox: initialize lowp float stroke_opacity\n\n    float extrude_length = length(v_extrude);\n    float antialiased_blur = -max(blur, v_antialiasblur);\n\n    float opacity_t = smoothstep(0.0, antialiased_blur, extrude_length - 1.0);\n\n    float color_t = stroke_width < 0.01 ? 0.0 : smoothstep(\n        antialiased_blur,\n        0.0,\n        extrude_length - radius / (radius + stroke_width)\n    );\n\n    gl_FragColor = opacity_t * mix(color * opacity, stroke_color * stroke_opacity, color_t);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",vertexSource:"uniform mat4 u_matrix;\nuniform bool u_scale_with_map;\nuniform vec2 u_extrude_scale;\n\nattribute vec2 a_pos;\n\n#pragma mapbox: define lowp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\n\nvarying vec2 v_extrude;\nvarying lowp float v_antialiasblur;\n\nvoid main(void) {\n    #pragma mapbox: initialize lowp vec4 color\n    #pragma mapbox: initialize mediump float radius\n    #pragma mapbox: initialize lowp float blur\n    #pragma mapbox: initialize lowp float opacity\n    #pragma mapbox: initialize lowp vec4 stroke_color\n    #pragma mapbox: initialize mediump float stroke_width\n    #pragma mapbox: initialize lowp float stroke_opacity\n\n    // unencode the extrusion vector that we snuck into the a_pos vector\n    v_extrude = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\n\n    vec2 extrude = v_extrude * (radius + stroke_width) * u_extrude_scale;\n    // multiply a_pos by 0.5, since we had it * 2 in order to sneak\n    // in extrusion data\n    gl_Position = u_matrix * vec4(floor(a_pos * 0.5), 0, 1);\n\n    if (u_scale_with_map) {\n        gl_Position.xy += extrude;\n    } else {\n        gl_Position.xy += extrude * gl_Position.w;\n    }\n\n    // This is a minimum blur distance that serves as a faux-antialiasing for\n    // the circle. since blur is a ratio of the circle's size and the intent is\n    // to keep the blur at roughly 1px, the two are inversely related.\n    v_antialiasblur = 1.0 / DEVICE_PIXEL_RATIO / (radius + stroke_width);\n}\n"},collisionBox:{fragmentSource:"uniform float u_zoom;\nuniform float u_maxzoom;\n\nvarying float v_max_zoom;\nvarying float v_placement_zoom;\n\nvoid main() {\n\n    float alpha = 0.5;\n\n    gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0) * alpha;\n\n    if (v_placement_zoom > u_zoom) {\n        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0) * alpha;\n    }\n\n    if (u_zoom >= v_max_zoom) {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0) * alpha * 0.25;\n    }\n\n    if (v_placement_zoom >= u_maxzoom) {\n        gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0) * alpha * 0.2;\n    }\n}\n",vertexSource:"attribute vec2 a_pos;\nattribute vec2 a_extrude;\nattribute vec2 a_data;\n\nuniform mat4 u_matrix;\nuniform float u_scale;\n\nvarying float v_max_zoom;\nvarying float v_placement_zoom;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos + a_extrude / u_scale, 0.0, 1.0);\n\n    v_max_zoom = a_data.x;\n    v_placement_zoom = a_data.y;\n}\n"},debug:{fragmentSource:"uniform lowp vec4 u_color;\n\nvoid main() {\n    gl_FragColor = u_color;\n}\n",vertexSource:"attribute vec2 a_pos;\n\nuniform mat4 u_matrix;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, step(32767.0, a_pos.x), 1);\n}\n"},fill:{fragmentSource:"#pragma mapbox: define lowp vec4 color\n#pragma mapbox: define lowp float opacity\n\nvoid main() {\n    #pragma mapbox: initialize lowp vec4 color\n    #pragma mapbox: initialize lowp float opacity\n\n    gl_FragColor = color * opacity;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",vertexSource:"attribute vec2 a_pos;\n\nuniform mat4 u_matrix;\n\n#pragma mapbox: define lowp vec4 color\n#pragma mapbox: define lowp float opacity\n\nvoid main() {\n    #pragma mapbox: initialize lowp vec4 color\n    #pragma mapbox: initialize lowp float opacity\n\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n}\n"},fillOutline:{fragmentSource:"#pragma mapbox: define lowp vec4 outline_color\n#pragma mapbox: define lowp float opacity\n\nvarying vec2 v_pos;\n\nvoid main() {\n    #pragma mapbox: initialize lowp vec4 outline_color\n    #pragma mapbox: initialize lowp float opacity\n\n    float dist = length(v_pos - gl_FragCoord.xy);\n    float alpha = smoothstep(1.0, 0.0, dist);\n    gl_FragColor = outline_color * (alpha * opacity);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",vertexSource:"attribute vec2 a_pos;\n\nuniform mat4 u_matrix;\nuniform vec2 u_world;\n\nvarying vec2 v_pos;\n\n#pragma mapbox: define lowp vec4 outline_color\n#pragma mapbox: define lowp float opacity\n\nvoid main() {\n    #pragma mapbox: initialize lowp vec4 outline_color\n    #pragma mapbox: initialize lowp float opacity\n\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n    v_pos = (gl_Position.xy / gl_Position.w + 1.0) / 2.0 * u_world;\n}\n"},fillOutlinePattern:{fragmentSource:"uniform vec2 u_pattern_tl_a;\nuniform vec2 u_pattern_br_a;\nuniform vec2 u_pattern_tl_b;\nuniform vec2 u_pattern_br_b;\nuniform float u_mix;\n\nuniform sampler2D u_image;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\nvarying vec2 v_pos;\n\n#pragma mapbox: define lowp float opacity\n\nvoid main() {\n    #pragma mapbox: initialize lowp float opacity\n\n    vec2 imagecoord = mod(v_pos_a, 1.0);\n    vec2 pos = mix(u_pattern_tl_a, u_pattern_br_a, imagecoord);\n    vec4 color1 = texture2D(u_image, pos);\n\n    vec2 imagecoord_b = mod(v_pos_b, 1.0);\n    vec2 pos2 = mix(u_pattern_tl_b, u_pattern_br_b, imagecoord_b);\n    vec4 color2 = texture2D(u_image, pos2);\n\n    // find distance to outline for alpha interpolation\n\n    float dist = length(v_pos - gl_FragCoord.xy);\n    float alpha = smoothstep(1.0, 0.0, dist);\n\n\n    gl_FragColor = mix(color1, color2, u_mix) * alpha * opacity;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",vertexSource:"uniform mat4 u_matrix;\nuniform vec2 u_world;\nuniform vec2 u_pattern_size_a;\nuniform vec2 u_pattern_size_b;\nuniform vec2 u_pixel_coord_upper;\nuniform vec2 u_pixel_coord_lower;\nuniform float u_scale_a;\nuniform float u_scale_b;\nuniform float u_tile_units_to_pixels;\n\nattribute vec2 a_pos;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\nvarying vec2 v_pos;\n\n#pragma mapbox: define lowp float opacity\n\nvoid main() {\n    #pragma mapbox: initialize lowp float opacity\n\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n\n    v_pos_a = get_pattern_pos(u_pixel_coord_upper, u_pixel_coord_lower, u_scale_a * u_pattern_size_a, u_tile_units_to_pixels, a_pos);\n    v_pos_b = get_pattern_pos(u_pixel_coord_upper, u_pixel_coord_lower, u_scale_b * u_pattern_size_b, u_tile_units_to_pixels, a_pos);\n\n    v_pos = (gl_Position.xy / gl_Position.w + 1.0) / 2.0 * u_world;\n}\n"},fillPattern:{fragmentSource:"uniform vec2 u_pattern_tl_a;\nuniform vec2 u_pattern_br_a;\nuniform vec2 u_pattern_tl_b;\nuniform vec2 u_pattern_br_b;\nuniform float u_mix;\n\nuniform sampler2D u_image;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\n\n#pragma mapbox: define lowp float opacity\n\nvoid main() {\n    #pragma mapbox: initialize lowp float opacity\n\n    vec2 imagecoord = mod(v_pos_a, 1.0);\n    vec2 pos = mix(u_pattern_tl_a, u_pattern_br_a, imagecoord);\n    vec4 color1 = texture2D(u_image, pos);\n\n    vec2 imagecoord_b = mod(v_pos_b, 1.0);\n    vec2 pos2 = mix(u_pattern_tl_b, u_pattern_br_b, imagecoord_b);\n    vec4 color2 = texture2D(u_image, pos2);\n\n    gl_FragColor = mix(color1, color2, u_mix) * opacity;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",vertexSource:"uniform mat4 u_matrix;\nuniform vec2 u_pattern_size_a;\nuniform vec2 u_pattern_size_b;\nuniform vec2 u_pixel_coord_upper;\nuniform vec2 u_pixel_coord_lower;\nuniform float u_scale_a;\nuniform float u_scale_b;\nuniform float u_tile_units_to_pixels;\n\nattribute vec2 a_pos;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\n\n#pragma mapbox: define lowp float opacity\n\nvoid main() {\n    #pragma mapbox: initialize lowp float opacity\n\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n\n    v_pos_a = get_pattern_pos(u_pixel_coord_upper, u_pixel_coord_lower, u_scale_a * u_pattern_size_a, u_tile_units_to_pixels, a_pos);\n    v_pos_b = get_pattern_pos(u_pixel_coord_upper, u_pixel_coord_lower, u_scale_b * u_pattern_size_b, u_tile_units_to_pixels, a_pos);\n}\n"},fillExtrusion:{fragmentSource:"varying vec4 v_color;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 color\n\nvoid main() {\n    #pragma mapbox: initialize lowp float base\n    #pragma mapbox: initialize lowp float height\n    #pragma mapbox: initialize lowp vec4 color\n\n    gl_FragColor = v_color;\n}\n",vertexSource:"uniform mat4 u_matrix;\nuniform vec3 u_lightcolor;\nuniform lowp vec3 u_lightpos;\nuniform lowp float u_lightintensity;\nuniform lowp vec4 u_outline_color;\n\nattribute vec2 a_pos;\nattribute vec3 a_normal;\nattribute float a_edgedistance;\n\nvarying vec4 v_color;\n\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n\n#pragma mapbox: define lowp vec4 color\n\nvoid main() {\n    #pragma mapbox: initialize lowp float base\n    #pragma mapbox: initialize lowp float height\n    #pragma mapbox: initialize lowp vec4 color\n\n    float ed = a_edgedistance; // use each attrib in order to not trip a VAO assert\n    float t = mod(a_normal.x, 2.0);\n\n    gl_Position = u_matrix * vec4(a_pos, t > 0.0 ? height : base, 1);\n\n#ifdef OUTLINE\n    color = u_outline_color;\n#endif\n\n    // Relative luminance (how dark/bright is the surface color?)\n    float colorvalue = color.r * 0.2126 + color.g * 0.7152 + color.b * 0.0722;\n\n    v_color = vec4(0.0, 0.0, 0.0, 1.0);\n\n    // Add slight ambient lighting so no extrusions are totally black\n    vec4 ambientlight = vec4(0.03, 0.03, 0.03, 1.0);\n    color += ambientlight;\n\n    // Calculate cos(theta), where theta is the angle between surface normal and diffuse light ray\n    float directional = clamp(dot(a_normal / 16384.0, u_lightpos), 0.0, 1.0);\n\n    // Adjust directional so that\n    // the range of values for highlight/shading is narrower\n    // with lower light intensity\n    // and with lighter/brighter surface colors\n    directional = mix((1.0 - u_lightintensity), max((1.0 - colorvalue + u_lightintensity), 1.0), directional);\n\n    // Add gradient along z axis of side surfaces\n    if (a_normal.y != 0.0) {\n        directional *= clamp((t + base) * pow(height / 150.0, 0.5), mix(0.7, 0.98, 1.0 - u_lightintensity), 1.0);\n    }\n\n    // Assign final color based on surface + ambient light color, diffuse light directional, and light color\n    // with lower bounds adjusted to hue of light\n    // so that shading is tinted with the complementary (opposite) color to the light color\n    v_color.r += clamp(color.r * directional * u_lightcolor.r, mix(0.0, 0.3, 1.0 - u_lightcolor.r), 1.0);\n    v_color.g += clamp(color.g * directional * u_lightcolor.g, mix(0.0, 0.3, 1.0 - u_lightcolor.g), 1.0);\n    v_color.b += clamp(color.b * directional * u_lightcolor.b, mix(0.0, 0.3, 1.0 - u_lightcolor.b), 1.0);\n}\n"},fillExtrusionPattern:{fragmentSource:"uniform vec2 u_pattern_tl_a;\nuniform vec2 u_pattern_br_a;\nuniform vec2 u_pattern_tl_b;\nuniform vec2 u_pattern_br_b;\nuniform float u_mix;\n\nuniform sampler2D u_image;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\nvarying vec4 v_lighting;\n\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n\nvoid main() {\n    #pragma mapbox: initialize lowp float base\n    #pragma mapbox: initialize lowp float height\n\n    vec2 imagecoord = mod(v_pos_a, 1.0);\n    vec2 pos = mix(u_pattern_tl_a, u_pattern_br_a, imagecoord);\n    vec4 color1 = texture2D(u_image, pos);\n\n    vec2 imagecoord_b = mod(v_pos_b, 1.0);\n    vec2 pos2 = mix(u_pattern_tl_b, u_pattern_br_b, imagecoord_b);\n    vec4 color2 = texture2D(u_image, pos2);\n\n    vec4 mixedColor = mix(color1, color2, u_mix);\n\n    gl_FragColor = mixedColor * v_lighting;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",vertexSource:"uniform mat4 u_matrix;\nuniform vec2 u_pattern_size_a;\nuniform vec2 u_pattern_size_b;\nuniform vec2 u_pixel_coord_upper;\nuniform vec2 u_pixel_coord_lower;\nuniform float u_scale_a;\nuniform float u_scale_b;\nuniform float u_tile_units_to_pixels;\nuniform float u_height_factor;\n\nuniform vec3 u_lightcolor;\nuniform lowp vec3 u_lightpos;\nuniform lowp float u_lightintensity;\n\nattribute vec2 a_pos;\nattribute vec3 a_normal;\nattribute float a_edgedistance;\n\nvarying vec2 v_pos_a;\nvarying vec2 v_pos_b;\nvarying vec4 v_lighting;\nvarying float v_directional;\n\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n\nvoid main() {\n    #pragma mapbox: initialize lowp float base\n    #pragma mapbox: initialize lowp float height\n\n    float t = mod(a_normal.x, 2.0);\n    float z = t > 0.0 ? height : base;\n\n    gl_Position = u_matrix * vec4(a_pos, z, 1);\n\n    vec2 pos = a_normal.x == 1.0 && a_normal.y == 0.0 && a_normal.z == 16384.0\n        ? a_pos // extrusion top\n        : vec2(a_edgedistance, z * u_height_factor); // extrusion side\n\n    v_pos_a = get_pattern_pos(u_pixel_coord_upper, u_pixel_coord_lower, u_scale_a * u_pattern_size_a, u_tile_units_to_pixels, pos);\n    v_pos_b = get_pattern_pos(u_pixel_coord_upper, u_pixel_coord_lower, u_scale_b * u_pattern_size_b, u_tile_units_to_pixels, pos);\n\n    v_lighting = vec4(0.0, 0.0, 0.0, 1.0);\n    float directional = clamp(dot(a_normal / 16383.0, u_lightpos), 0.0, 1.0);\n    directional = mix((1.0 - u_lightintensity), max((0.5 + u_lightintensity), 1.0), directional);\n\n    if (a_normal.y != 0.0) {\n        directional *= clamp((t + base) * pow(height / 150.0, 0.5), mix(0.7, 0.98, 1.0 - u_lightintensity), 1.0);\n    }\n\n    v_lighting.rgb += clamp(directional * u_lightcolor, mix(vec3(0.0), vec3(0.3), 1.0 - u_lightcolor), vec3(1.0));\n}\n"},extrusionTexture:{fragmentSource:"uniform sampler2D u_texture;\nuniform float u_opacity;\n\nvarying vec2 v_pos;\n\nvoid main() {\n    gl_FragColor = texture2D(u_texture, v_pos) * u_opacity;\n}\n",vertexSource:"uniform mat4 u_matrix;\nuniform int u_xdim;\nuniform int u_ydim;\nattribute vec2 a_pos;\nvarying vec2 v_pos;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n\n    v_pos.x = a_pos.x / float(u_xdim);\n    v_pos.y = 1.0 - a_pos.y / float(u_ydim);\n}\n"},line:{fragmentSource:"#pragma mapbox: define lowp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n\nvarying vec2 v_width2;\nvarying vec2 v_normal;\nvarying float v_gamma_scale;\n\nvoid main() {\n    #pragma mapbox: initialize lowp vec4 color\n    #pragma mapbox: initialize lowp float blur\n    #pragma mapbox: initialize lowp float opacity\n\n    // Calculate the distance of the pixel from the line in pixels.\n    float dist = length(v_normal) * v_width2.s;\n\n    // Calculate the antialiasing fade factor. This is either when fading in\n    // the line in case of an offset line (v_width2.t) or when fading out\n    // (v_width2.s)\n    float blur2 = (blur + 1.0 / DEVICE_PIXEL_RATIO) * v_gamma_scale;\n    float alpha = clamp(min(dist - (v_width2.t - blur2), v_width2.s - dist) / blur2, 0.0, 1.0);\n\n    gl_FragColor = color * (alpha * opacity);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",vertexSource:"\n\n// the distance over which the line edge fades out.\n// Retina devices need a smaller distance to avoid aliasing.\n#define ANTIALIASING 1.0 / DEVICE_PIXEL_RATIO / 2.0\n\n// floor(127 / 2) == 63.0\n// the maximum allowed miter limit is 2.0 at the moment. the extrude normal is\n// stored in a byte (-128..127). we scale regular normals up to length 63, but\n// there are also \"special\" normals that have a bigger length (of up to 126 in\n// this case).\n// #define scale 63.0\n#define scale 0.015873016\n\nattribute vec2 a_pos;\nattribute vec4 a_data;\n\nuniform mat4 u_matrix;\nuniform mediump float u_ratio;\nuniform mediump float u_width;\nuniform vec2 u_gl_units_to_pixels;\n\nvarying vec2 v_normal;\nvarying vec2 v_width2;\nvarying float v_gamma_scale;\n\n#pragma mapbox: define lowp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n\nvoid main() {\n    #pragma mapbox: initialize lowp vec4 color\n    #pragma mapbox: initialize lowp float blur\n    #pragma mapbox: initialize lowp float opacity\n    #pragma mapbox: initialize mediump float gapwidth\n    #pragma mapbox: initialize lowp float offset\n\n    vec2 a_extrude = a_data.xy - 128.0;\n    float a_direction = mod(a_data.z, 4.0) - 1.0;\n\n    // We store the texture normals in the most insignificant bit\n    // transform y so that 0 => -1 and 1 => 1\n    // In the texture normal, x is 0 if the normal points straight up/down and 1 if it's a round cap\n    // y is 1 if the normal points up, and -1 if it points down\n    mediump vec2 normal = mod(a_pos, 2.0);\n    normal.y = sign(normal.y - 0.5);\n    v_normal = normal;\n\n\n    // these transformations used to be applied in the JS and native code bases. \n    // moved them into the shader for clarity and simplicity. \n    gapwidth = gapwidth / 2.0;\n    float width = u_width / 2.0;\n    offset = -1.0 * offset; \n\n    float inset = gapwidth + (gapwidth > 0.0 ? ANTIALIASING : 0.0);\n    float outset = gapwidth + width * (gapwidth > 0.0 ? 2.0 : 1.0) + ANTIALIASING;\n\n    // Scale the extrusion vector down to a normal and then up by the line width\n    // of this vertex.\n    mediump vec2 dist = outset * a_extrude * scale;\n\n    // Calculate the offset when drawing a line that is to the side of the actual line.\n    // We do this by creating a vector that points towards the extrude, but rotate\n    // it when we're drawing round end points (a_direction = -1 or 1) since their\n    // extrude vector points in another direction.\n    mediump float u = 0.5 * a_direction;\n    mediump float t = 1.0 - abs(u);\n    mediump vec2 offset2 = offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);\n\n    // Remove the texture normal bit to get the position\n    vec2 pos = floor(a_pos * 0.5);\n\n    vec4 projected_extrude = u_matrix * vec4(dist / u_ratio, 0.0, 0.0);\n    gl_Position = u_matrix * vec4(pos + offset2 / u_ratio, 0.0, 1.0) + projected_extrude;\n\n    // calculate how much the perspective view squishes or stretches the extrude\n    float extrude_length_without_perspective = length(dist);\n    float extrude_length_with_perspective = length(projected_extrude.xy / gl_Position.w * u_gl_units_to_pixels);\n    v_gamma_scale = extrude_length_without_perspective / extrude_length_with_perspective;\n\n    v_width2 = vec2(outset, inset);\n}\n"},linePattern:{fragmentSource:"uniform vec2 u_pattern_size_a;\nuniform vec2 u_pattern_size_b;\nuniform vec2 u_pattern_tl_a;\nuniform vec2 u_pattern_br_a;\nuniform vec2 u_pattern_tl_b;\nuniform vec2 u_pattern_br_b;\nuniform float u_fade;\n\nuniform sampler2D u_image;\n\nvarying vec2 v_normal;\nvarying vec2 v_width2;\nvarying float v_linesofar;\nvarying float v_gamma_scale;\n\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n\nvoid main() {\n    #pragma mapbox: initialize lowp float blur\n    #pragma mapbox: initialize lowp float opacity\n\n    // Calculate the distance of the pixel from the line in pixels.\n    float dist = length(v_normal) * v_width2.s;\n\n    // Calculate the antialiasing fade factor. This is either when fading in\n    // the line in case of an offset line (v_width2.t) or when fading out\n    // (v_width2.s)\n    float blur2 = (blur + 1.0 / DEVICE_PIXEL_RATIO) * v_gamma_scale;\n    float alpha = clamp(min(dist - (v_width2.t - blur2), v_width2.s - dist) / blur2, 0.0, 1.0);\n\n    float x_a = mod(v_linesofar / u_pattern_size_a.x, 1.0);\n    float x_b = mod(v_linesofar / u_pattern_size_b.x, 1.0);\n    float y_a = 0.5 + (v_normal.y * v_width2.s / u_pattern_size_a.y);\n    float y_b = 0.5 + (v_normal.y * v_width2.s / u_pattern_size_b.y);\n    vec2 pos_a = mix(u_pattern_tl_a, u_pattern_br_a, vec2(x_a, y_a));\n    vec2 pos_b = mix(u_pattern_tl_b, u_pattern_br_b, vec2(x_b, y_b));\n\n    vec4 color = mix(texture2D(u_image, pos_a), texture2D(u_image, pos_b), u_fade);\n\n    gl_FragColor = color * alpha * opacity;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",vertexSource:"// floor(127 / 2) == 63.0\n// the maximum allowed miter limit is 2.0 at the moment. the extrude normal is\n// stored in a byte (-128..127). we scale regular normals up to length 63, but\n// there are also \"special\" normals that have a bigger length (of up to 126 in\n// this case).\n// #define scale 63.0\n#define scale 0.015873016\n\n// We scale the distance before adding it to the buffers so that we can store\n// long distances for long segments. Use this value to unscale the distance.\n#define LINE_DISTANCE_SCALE 2.0\n\n// the distance over which the line edge fades out.\n// Retina devices need a smaller distance to avoid aliasing.\n#define ANTIALIASING 1.0 / DEVICE_PIXEL_RATIO / 2.0\n\nattribute vec2 a_pos;\nattribute vec4 a_data;\n\nuniform mat4 u_matrix;\nuniform mediump float u_ratio;\nuniform mediump float u_width;\nuniform vec2 u_gl_units_to_pixels;\n\nvarying vec2 v_normal;\nvarying vec2 v_width2;\nvarying float v_linesofar;\nvarying float v_gamma_scale;\n\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n\nvoid main() {\n    #pragma mapbox: initialize lowp float blur\n    #pragma mapbox: initialize lowp float opacity\n    #pragma mapbox: initialize lowp float offset\n    #pragma mapbox: initialize mediump float gapwidth\n\n    vec2 a_extrude = a_data.xy - 128.0;\n    float a_direction = mod(a_data.z, 4.0) - 1.0;\n    float a_linesofar = (floor(a_data.z / 4.0) + a_data.w * 64.0) * LINE_DISTANCE_SCALE;\n\n    // We store the texture normals in the most insignificant bit\n    // transform y so that 0 => -1 and 1 => 1\n    // In the texture normal, x is 0 if the normal points straight up/down and 1 if it's a round cap\n    // y is 1 if the normal points up, and -1 if it points down\n    mediump vec2 normal = mod(a_pos, 2.0);\n    normal.y = sign(normal.y - 0.5);\n    v_normal = normal;\n\n    // these transformations used to be applied in the JS and native code bases. \n    // moved them into the shader for clarity and simplicity. \n    gapwidth = gapwidth / 2.0;\n    float width = u_width / 2.0;\n    offset = -1.0 * offset; \n\n    float inset = gapwidth + (gapwidth > 0.0 ? ANTIALIASING : 0.0);\n    float outset = gapwidth + width * (gapwidth > 0.0 ? 2.0 : 1.0) + ANTIALIASING;\n\n    // Scale the extrusion vector down to a normal and then up by the line width\n    // of this vertex.\n    mediump vec2 dist = outset * a_extrude * scale;\n\n    // Calculate the offset when drawing a line that is to the side of the actual line.\n    // We do this by creating a vector that points towards the extrude, but rotate\n    // it when we're drawing round end points (a_direction = -1 or 1) since their\n    // extrude vector points in another direction.\n    mediump float u = 0.5 * a_direction;\n    mediump float t = 1.0 - abs(u);\n    mediump vec2 offset2 = offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);\n\n    // Remove the texture normal bit to get the position\n    vec2 pos = floor(a_pos * 0.5);\n\n    vec4 projected_extrude = u_matrix * vec4(dist / u_ratio, 0.0, 0.0);\n    gl_Position = u_matrix * vec4(pos + offset2 / u_ratio, 0.0, 1.0) + projected_extrude;\n\n    // calculate how much the perspective view squishes or stretches the extrude\n    float extrude_length_without_perspective = length(dist);\n    float extrude_length_with_perspective = length(projected_extrude.xy / gl_Position.w * u_gl_units_to_pixels);\n    v_gamma_scale = extrude_length_without_perspective / extrude_length_with_perspective;\n\n    v_linesofar = a_linesofar;\n    v_width2 = vec2(outset, inset);\n}\n"},lineSDF:{fragmentSource:"\nuniform sampler2D u_image;\nuniform float u_sdfgamma;\nuniform float u_mix;\n\nvarying vec2 v_normal;\nvarying vec2 v_width2;\nvarying vec2 v_tex_a;\nvarying vec2 v_tex_b;\nvarying float v_gamma_scale;\n\n#pragma mapbox: define lowp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n\nvoid main() {\n    #pragma mapbox: initialize lowp vec4 color\n    #pragma mapbox: initialize lowp float blur\n    #pragma mapbox: initialize lowp float opacity\n\n    // Calculate the distance of the pixel from the line in pixels.\n    float dist = length(v_normal) * v_width2.s;\n\n    // Calculate the antialiasing fade factor. This is either when fading in\n    // the line in case of an offset line (v_width2.t) or when fading out\n    // (v_width2.s)\n    float blur2 = (blur + 1.0 / DEVICE_PIXEL_RATIO) * v_gamma_scale;\n    float alpha = clamp(min(dist - (v_width2.t - blur2), v_width2.s - dist) / blur2, 0.0, 1.0);\n\n    float sdfdist_a = texture2D(u_image, v_tex_a).a;\n    float sdfdist_b = texture2D(u_image, v_tex_b).a;\n    float sdfdist = mix(sdfdist_a, sdfdist_b, u_mix);\n    alpha *= smoothstep(0.5 - u_sdfgamma, 0.5 + u_sdfgamma, sdfdist);\n\n    gl_FragColor = color * (alpha * opacity);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",vertexSource:"// floor(127 / 2) == 63.0\n// the maximum allowed miter limit is 2.0 at the moment. the extrude normal is\n// stored in a byte (-128..127). we scale regular normals up to length 63, but\n// there are also \"special\" normals that have a bigger length (of up to 126 in\n// this case).\n// #define scale 63.0\n#define scale 0.015873016\n\n// We scale the distance before adding it to the buffers so that we can store\n// long distances for long segments. Use this value to unscale the distance.\n#define LINE_DISTANCE_SCALE 2.0\n\n// the distance over which the line edge fades out.\n// Retina devices need a smaller distance to avoid aliasing.\n#define ANTIALIASING 1.0 / DEVICE_PIXEL_RATIO / 2.0\n\nattribute vec2 a_pos;\nattribute vec4 a_data;\n\nuniform mat4 u_matrix;\nuniform mediump float u_ratio;\nuniform vec2 u_patternscale_a;\nuniform float u_tex_y_a;\nuniform vec2 u_patternscale_b;\nuniform float u_tex_y_b;\nuniform vec2 u_gl_units_to_pixels;\nuniform mediump float u_width;\n\nvarying vec2 v_normal;\nvarying vec2 v_width2;\nvarying vec2 v_tex_a;\nvarying vec2 v_tex_b;\nvarying float v_gamma_scale;\n\n#pragma mapbox: define lowp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n\nvoid main() {\n    #pragma mapbox: initialize lowp vec4 color\n    #pragma mapbox: initialize lowp float blur\n    #pragma mapbox: initialize lowp float opacity\n    #pragma mapbox: initialize mediump float gapwidth\n    #pragma mapbox: initialize lowp float offset\n\n    vec2 a_extrude = a_data.xy - 128.0;\n    float a_direction = mod(a_data.z, 4.0) - 1.0;\n    float a_linesofar = (floor(a_data.z / 4.0) + a_data.w * 64.0) * LINE_DISTANCE_SCALE;\n\n    // We store the texture normals in the most insignificant bit\n    // transform y so that 0 => -1 and 1 => 1\n    // In the texture normal, x is 0 if the normal points straight up/down and 1 if it's a round cap\n    // y is 1 if the normal points up, and -1 if it points down\n    mediump vec2 normal = mod(a_pos, 2.0);\n    normal.y = sign(normal.y - 0.5);\n    v_normal = normal;\n\n    // these transformations used to be applied in the JS and native code bases. \n    // moved them into the shader for clarity and simplicity. \n    gapwidth = gapwidth / 2.0;\n    float width = u_width / 2.0;\n    offset = -1.0 * offset;\n \n    float inset = gapwidth + (gapwidth > 0.0 ? ANTIALIASING : 0.0);\n    float outset = gapwidth + width * (gapwidth > 0.0 ? 2.0 : 1.0) + ANTIALIASING;\n\n    // Scale the extrusion vector down to a normal and then up by the line width\n    // of this vertex.\n    mediump vec2 dist =outset * a_extrude * scale;\n\n    // Calculate the offset when drawing a line that is to the side of the actual line.\n    // We do this by creating a vector that points towards the extrude, but rotate\n    // it when we're drawing round end points (a_direction = -1 or 1) since their\n    // extrude vector points in another direction.\n    mediump float u = 0.5 * a_direction;\n    mediump float t = 1.0 - abs(u);\n    mediump vec2 offset2 = offset * a_extrude * scale * normal.y * mat2(t, -u, u, t);\n\n    // Remove the texture normal bit to get the position\n    vec2 pos = floor(a_pos * 0.5);\n\n    vec4 projected_extrude = u_matrix * vec4(dist / u_ratio, 0.0, 0.0);\n    gl_Position = u_matrix * vec4(pos + offset2 / u_ratio, 0.0, 1.0) + projected_extrude;\n\n    // calculate how much the perspective view squishes or stretches the extrude\n    float extrude_length_without_perspective = length(dist);\n    float extrude_length_with_perspective = length(projected_extrude.xy / gl_Position.w * u_gl_units_to_pixels);\n    v_gamma_scale = extrude_length_without_perspective / extrude_length_with_perspective;\n\n    v_tex_a = vec2(a_linesofar * u_patternscale_a.x, normal.y * u_patternscale_a.y + u_tex_y_a);\n    v_tex_b = vec2(a_linesofar * u_patternscale_b.x, normal.y * u_patternscale_b.y + u_tex_y_b);\n\n    v_width2 = vec2(outset, inset);\n}\n"
},raster:{fragmentSource:"uniform float u_fade_t;\nuniform float u_opacity;\nuniform sampler2D u_image0;\nuniform sampler2D u_image1;\nvarying vec2 v_pos0;\nvarying vec2 v_pos1;\n\nuniform float u_brightness_low;\nuniform float u_brightness_high;\n\nuniform float u_saturation_factor;\nuniform float u_contrast_factor;\nuniform vec3 u_spin_weights;\n\nvoid main() {\n\n    // read and cross-fade colors from the main and parent tiles\n    vec4 color0 = texture2D(u_image0, v_pos0);\n    vec4 color1 = texture2D(u_image1, v_pos1);\n    vec4 color = mix(color0, color1, u_fade_t);\n    color.a *= u_opacity;\n    vec3 rgb = color.rgb;\n\n    // spin\n    rgb = vec3(\n        dot(rgb, u_spin_weights.xyz),\n        dot(rgb, u_spin_weights.zxy),\n        dot(rgb, u_spin_weights.yzx));\n\n    // saturation\n    float average = (color.r + color.g + color.b) / 3.0;\n    rgb += (average - rgb) * u_saturation_factor;\n\n    // contrast\n    rgb = (rgb - 0.5) * u_contrast_factor + 0.5;\n\n    // brightness\n    vec3 u_high_vec = vec3(u_brightness_low, u_brightness_low, u_brightness_low);\n    vec3 u_low_vec = vec3(u_brightness_high, u_brightness_high, u_brightness_high);\n\n    gl_FragColor = vec4(mix(u_high_vec, u_low_vec, rgb) * color.a, color.a);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",vertexSource:"uniform mat4 u_matrix;\nuniform vec2 u_tl_parent;\nuniform float u_scale_parent;\nuniform float u_buffer_scale;\n\nattribute vec2 a_pos;\nattribute vec2 a_texture_pos;\n\nvarying vec2 v_pos0;\nvarying vec2 v_pos1;\n\nvoid main() {\n    gl_Position = u_matrix * vec4(a_pos, 0, 1);\n    v_pos0 = (((a_texture_pos / 32767.0) - 0.5) / u_buffer_scale ) + 0.5;\n    v_pos1 = (v_pos0 * u_scale_parent) + u_tl_parent;\n}\n"},symbolIcon:{fragmentSource:"uniform sampler2D u_texture;\nuniform sampler2D u_fadetexture;\nuniform lowp float u_opacity;\n\nvarying vec2 v_tex;\nvarying vec2 v_fade_tex;\n\nvoid main() {\n    lowp float alpha = texture2D(u_fadetexture, v_fade_tex).a * u_opacity;\n    gl_FragColor = texture2D(u_texture, v_tex) * alpha;\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",vertexSource:"attribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_texture_pos;\nattribute vec4 a_data;\n\n\n// matrix is for the vertex position.\nuniform mat4 u_matrix;\n\nuniform mediump float u_zoom;\nuniform bool u_rotate_with_map;\nuniform vec2 u_extrude_scale;\n\nuniform vec2 u_texsize;\n\nvarying vec2 v_tex;\nvarying vec2 v_fade_tex;\n\nvoid main() {\n    vec2 a_tex = a_texture_pos.xy;\n    mediump float a_labelminzoom = a_data[0];\n    mediump vec2 a_zoom = a_data.pq;\n    mediump float a_minzoom = a_zoom[0];\n    mediump float a_maxzoom = a_zoom[1];\n\n    // u_zoom is the current zoom level adjusted for the change in font size\n    mediump float z = 2.0 - step(a_minzoom, u_zoom) - (1.0 - step(a_maxzoom, u_zoom));\n\n    vec2 extrude = u_extrude_scale * (a_offset / 64.0);\n    if (u_rotate_with_map) {\n        gl_Position = u_matrix * vec4(a_pos + extrude, 0, 1);\n        gl_Position.z += z * gl_Position.w;\n    } else {\n        gl_Position = u_matrix * vec4(a_pos, 0, 1) + vec4(extrude, 0, 0);\n    }\n\n    v_tex = a_tex / u_texsize;\n    v_fade_tex = vec2(a_labelminzoom / 255.0, 0.0);\n}\n"},symbolSDF:{fragmentSource:"uniform sampler2D u_texture;\nuniform sampler2D u_fadetexture;\nuniform lowp vec4 u_color;\nuniform lowp float u_opacity;\nuniform lowp float u_buffer;\nuniform lowp float u_gamma;\n\nvarying vec2 v_tex;\nvarying vec2 v_fade_tex;\nvarying float v_gamma_scale;\n\nvoid main() {\n    lowp float dist = texture2D(u_texture, v_tex).a;\n    lowp float fade_alpha = texture2D(u_fadetexture, v_fade_tex).a;\n    lowp float gamma = u_gamma * v_gamma_scale;\n    lowp float alpha = smoothstep(u_buffer - gamma, u_buffer + gamma, dist) * fade_alpha;\n\n    gl_FragColor = u_color * (alpha * u_opacity);\n\n#ifdef OVERDRAW_INSPECTOR\n    gl_FragColor = vec4(1.0);\n#endif\n}\n",vertexSource:"const float PI = 3.141592653589793;\n\nattribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_texture_pos;\nattribute vec4 a_data;\n\n\n// matrix is for the vertex position.\nuniform mat4 u_matrix;\n\nuniform mediump float u_zoom;\nuniform bool u_rotate_with_map;\nuniform bool u_pitch_with_map;\nuniform mediump float u_pitch;\nuniform mediump float u_bearing;\nuniform mediump float u_aspect_ratio;\nuniform vec2 u_extrude_scale;\n\nuniform vec2 u_texsize;\n\nvarying vec2 v_tex;\nvarying vec2 v_fade_tex;\nvarying float v_gamma_scale;\n\nvoid main() {\n    vec2 a_tex = a_texture_pos.xy;\n    mediump float a_labelminzoom = a_data[0];\n    mediump vec2 a_zoom = a_data.pq;\n    mediump float a_minzoom = a_zoom[0];\n    mediump float a_maxzoom = a_zoom[1];\n\n    // u_zoom is the current zoom level adjusted for the change in font size\n    mediump float z = 2.0 - step(a_minzoom, u_zoom) - (1.0 - step(a_maxzoom, u_zoom));\n\n    // pitch-alignment: map\n    // rotation-alignment: map | viewport\n    if (u_pitch_with_map) {\n        lowp float angle = u_rotate_with_map ? (a_data[1] / 256.0 * 2.0 * PI) : u_bearing;\n        lowp float asin = sin(angle);\n        lowp float acos = cos(angle);\n        mat2 RotationMatrix = mat2(acos, asin, -1.0 * asin, acos);\n        vec2 offset = RotationMatrix * a_offset;\n        vec2 extrude = u_extrude_scale * (offset / 64.0);\n        gl_Position = u_matrix * vec4(a_pos + extrude, 0, 1);\n        gl_Position.z += z * gl_Position.w;\n    // pitch-alignment: viewport\n    // rotation-alignment: map\n    } else if (u_rotate_with_map) {\n        // foreshortening factor to apply on pitched maps\n        // as a label goes from horizontal <=> vertical in angle\n        // it goes from 0% foreshortening to up to around 70% foreshortening\n        lowp float pitchfactor = 1.0 - cos(u_pitch * sin(u_pitch * 0.75));\n\n        lowp float lineangle = a_data[1] / 256.0 * 2.0 * PI;\n\n        // use the lineangle to position points a,b along the line\n        // project the points and calculate the label angle in projected space\n        // this calculation allows labels to be rendered unskewed on pitched maps\n        vec4 a = u_matrix * vec4(a_pos, 0, 1);\n        vec4 b = u_matrix * vec4(a_pos + vec2(cos(lineangle),sin(lineangle)), 0, 1);\n        lowp float angle = atan((b[1]/b[3] - a[1]/a[3])/u_aspect_ratio, b[0]/b[3] - a[0]/a[3]);\n        lowp float asin = sin(angle);\n        lowp float acos = cos(angle);\n        mat2 RotationMatrix = mat2(acos, -1.0 * asin, asin, acos);\n\n        vec2 offset = RotationMatrix * (vec2((1.0-pitchfactor)+(pitchfactor*cos(angle*2.0)), 1.0) * a_offset);\n        vec2 extrude = u_extrude_scale * (offset / 64.0);\n        gl_Position = u_matrix * vec4(a_pos, 0, 1) + vec4(extrude, 0, 0);\n        gl_Position.z += z * gl_Position.w;\n    // pitch-alignment: viewport\n    // rotation-alignment: viewport\n    } else {\n        vec2 extrude = u_extrude_scale * (a_offset / 64.0);\n        gl_Position = u_matrix * vec4(a_pos, 0, 1) + vec4(extrude, 0, 0);\n    }\n\n    v_gamma_scale = gl_Position.w;\n\n    v_tex = a_tex / u_texsize;\n    v_fade_tex = vec2(a_labelminzoom / 255.0, 0.0);\n}\n"}};
},{"path":194}],39:[function(require,module,exports){
"use strict";var VertexArrayObject=function(){this.boundProgram=null,this.boundVertexBuffer=null,this.boundVertexBuffer2=null,this.boundElementBuffer=null,this.boundVertexOffset=null,this.vao=null};VertexArrayObject.prototype.bind=function(e,t,r,i,n,o){void 0===e.extVertexArrayObject&&(e.extVertexArrayObject=e.getExtension("OES_vertex_array_object"));var s=!this.vao||this.boundProgram!==t||this.boundVertexBuffer!==r||this.boundVertexBuffer2!==n||this.boundElementBuffer!==i||this.boundVertexOffset!==o;!e.extVertexArrayObject||s?(this.freshBind(e,t,r,i,n,o),this.gl=e):e.extVertexArrayObject.bindVertexArrayOES(this.vao)},VertexArrayObject.prototype.freshBind=function(e,t,r,i,n,o){var s,u=t.numAttributes;if(e.extVertexArrayObject)this.vao&&this.destroy(),this.vao=e.extVertexArrayObject.createVertexArrayOES(),e.extVertexArrayObject.bindVertexArrayOES(this.vao),s=0,this.boundProgram=t,this.boundVertexBuffer=r,this.boundVertexBuffer2=n,this.boundElementBuffer=i,this.boundVertexOffset=o;else{s=e.currentNumAttributes||0;for(var b=u;b<s;b++)e.disableVertexAttribArray(b)}for(var a=s;a<u;a++)e.enableVertexAttribArray(a);r.bind(e),r.setVertexAttribPointers(e,t,o),n&&(n.bind(e),n.setVertexAttribPointers(e,t,o)),i&&i.bind(e),e.currentNumAttributes=u},VertexArrayObject.prototype.destroy=function(){this.vao&&(this.gl.extVertexArrayObject.deleteVertexArrayOES(this.vao),this.vao=null)},module.exports=VertexArrayObject;
},{}],40:[function(require,module,exports){
"use strict";var ImageSource=require("./image_source"),window=require("../util/window"),CanvasSource=function(t){function i(i,s,a,n){t.call(this,i,s,a,n),this.options=s,this.animate=!s.hasOwnProperty("animate")||s.animate}return t&&(i.__proto__=t),i.prototype=Object.create(t&&t.prototype),i.prototype.constructor=i,i.prototype.load=function(){if(this.canvas=this.canvas||window.document.getElementById(this.options.canvas),this.width=this.canvas.width,this.height=this.canvas.height,this._hasInvalidDimensions(this.canvas))return this.fire("error",new Error("Canvas dimensions cannot be less than or equal to zero."));var t;this.play=function(){t=this.map.style.animationLoop.set(1/0),this.map._rerender()},this.pause=function(){this.map.style.animationLoop.cancel(t)},this._finishLoading()},i.prototype.getCanvas=function(){return this.canvas},i.prototype.onAdd=function(t){this.map||(this.map=t,this.load(),this.canvas&&(this.animate&&this.play(),this.setCoordinates(this.coordinates)))},i.prototype.prepare=function(){var t=!1;this.canvas.width!==this.width&&(this.width=this.canvas.width,t=!0),this.canvas.height!==this.height&&(this.height=this.canvas.height,t=!0),this._hasInvalidDimensions()||this.tile&&this._prepareImage(this.map.painter.gl,this.canvas,t)},i.prototype.serialize=function(){return{type:"canvas",canvas:this.canvas,coordinates:this.coordinates}},i.prototype._hasInvalidDimensions=function(){for(var t=0,i=[this.canvas.width,this.canvas.height];t<i.length;t+=1){var s=i[t];if(isNaN(s)||s<=0)return!0}return!1},i}(ImageSource);module.exports=CanvasSource;
},{"../util/window":112,"./image_source":44}],41:[function(require,module,exports){
"use strict";function resolveURL(t){var e=window.document.createElement("a");return e.href=t,e.href}var Evented=require("../util/evented"),util=require("../util/util"),window=require("../util/window"),EXTENT=require("../data/extent"),GeoJSONSource=function(t){function e(e,o,i,r){t.call(this),o=o||{},this.id=e,this.type="geojson",this.minzoom=0,this.maxzoom=18,this.tileSize=512,this.isTileClipped=!0,this.reparseOverscaled=!0,this.dispatcher=i,this.setEventedParent(r),this._data=o.data,void 0!==o.maxzoom&&(this.maxzoom=o.maxzoom),o.type&&(this.type=o.type);var a=EXTENT/this.tileSize;this.workerOptions=util.extend({source:this.id,cluster:o.cluster||!1,geojsonVtOptions:{buffer:(void 0!==o.buffer?o.buffer:128)*a,tolerance:(void 0!==o.tolerance?o.tolerance:.375)*a,extent:EXTENT,maxZoom:this.maxzoom},superclusterOptions:{maxZoom:Math.min(o.clusterMaxZoom,this.maxzoom-1)||this.maxzoom-1,extent:EXTENT,radius:(o.clusterRadius||50)*a,log:!1}},o.workerOptions)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.load=function(){var t=this;this.fire("dataloading",{dataType:"source"}),this._updateWorkerData(function(e){return e?void t.fire("error",{error:e}):(t.fire("data",{dataType:"source"}),void t.fire("source.load"))})},e.prototype.onAdd=function(t){this.load(),this.map=t},e.prototype.setData=function(t){var e=this;return this._data=t,this.fire("dataloading",{dataType:"source"}),this._updateWorkerData(function(t){return t?e.fire("error",{error:t}):void e.fire("data",{dataType:"source"})}),this},e.prototype._updateWorkerData=function(t){var e=this,o=util.extend({},this.workerOptions),i=this._data;"string"==typeof i?o.url=resolveURL(i):o.data=JSON.stringify(i),this.workerID=this.dispatcher.send(this.type+".loadData",o,function(o){e._loaded=!0,t(o)})},e.prototype.loadTile=function(t,e){var o=this,i=t.coord.z>this.maxzoom?Math.pow(2,t.coord.z-this.maxzoom):1,r={type:this.type,uid:t.uid,coord:t.coord,zoom:t.coord.z,maxZoom:this.maxzoom,tileSize:this.tileSize,source:this.id,overscaling:i,angle:this.map.transform.angle,pitch:this.map.transform.pitch,showCollisionBoxes:this.map.showCollisionBoxes};t.workerID=this.dispatcher.send("loadTile",r,function(i,r){if(t.unloadVectorData(),!t.aborted)return i?e(i):(t.loadVectorData(r,o.map.painter),t.redoWhenDone&&(t.redoWhenDone=!1,t.redoPlacement(o)),e(null))},this.workerID)},e.prototype.abortTile=function(t){t.aborted=!0},e.prototype.unloadTile=function(t){t.unloadVectorData(),this.dispatcher.send("removeTile",{uid:t.uid,type:this.type,source:this.id},function(){},t.workerID)},e.prototype.onRemove=function(){this.dispatcher.broadcast("removeSource",{type:this.type,source:this.id},function(){})},e.prototype.serialize=function(){return{type:this.type,data:this._data}},e}(Evented);module.exports=GeoJSONSource;
},{"../data/extent":11,"../util/evented":118,"../util/util":129,"../util/window":112}],42:[function(require,module,exports){
"use strict";var ajax=require("../util/ajax"),rewind=require("geojson-rewind"),GeoJSONWrapper=require("./geojson_wrapper"),vtpbf=require("vt-pbf"),supercluster=require("supercluster"),geojsonvt=require("geojson-vt"),VectorTileWorkerSource=require("./vector_tile_worker_source"),GeoJSONWorkerSource=function(e){function r(r,t,o){e.call(this,r,t),o&&(this.loadGeoJSON=o),this._geoJSONIndexes={}}return e&&(r.__proto__=e),r.prototype=Object.create(e&&e.prototype),r.prototype.constructor=r,r.prototype.loadVectorData=function(e,r){var t=e.source,o=e.coord;if(!this._geoJSONIndexes[t])return r(null,null);var n=this._geoJSONIndexes[t].getTile(Math.min(o.z,e.maxZoom),o.x,o.y);if(!n)return r(null,null);var u=new GeoJSONWrapper(n.features);u.name="_geojsonTileLayer";var a=vtpbf({layers:{_geojsonTileLayer:u}});0===a.byteOffset&&a.byteLength===a.buffer.byteLength||(a=new Uint8Array(a)),u.rawData=a.buffer,r(null,u)},r.prototype.loadData=function(e,r){var t=function(t,o){var n=this;return t?r(t):"object"!=typeof o?r(new Error("Input data is not a valid GeoJSON object.")):(rewind(o,!0),void this._indexData(o,e,function(t,o){return t?r(t):(n._geoJSONIndexes[e.source]=o,void r(null))}))}.bind(this);this.loadGeoJSON(e,t)},r.prototype.loadGeoJSON=function(e,r){if(e.url)ajax.getJSON(e.url,r);else{if("string"!=typeof e.data)return r(new Error("Input data is not a valid GeoJSON object."));try{return r(null,JSON.parse(e.data))}catch(e){return r(new Error("Input data is not a valid GeoJSON object."))}}},r.prototype.removeSource=function(e){this._geoJSONIndexes[e.source]&&delete this._geoJSONIndexes[e.source]},r.prototype._indexData=function(e,r,t){try{r.cluster?t(null,supercluster(r.superclusterOptions).load(e.features)):t(null,geojsonvt(e,r.geojsonVtOptions))}catch(e){return t(e)}},r}(VectorTileWorkerSource);module.exports=GeoJSONWorkerSource;
},{"../util/ajax":109,"./geojson_wrapper":43,"./vector_tile_worker_source":55,"geojson-rewind":140,"geojson-vt":144,"supercluster":201,"vt-pbf":210}],43:[function(require,module,exports){
"use strict";var Point=require("point-geometry"),VectorTileFeature=require("vector-tile").VectorTileFeature,EXTENT=require("../data/extent"),FeatureWrapper=function(e){var t=this;if(this.type=e.type,1===e.type){this.rawGeometry=[];for(var r=0;r<e.geometry.length;r++)t.rawGeometry.push([e.geometry[r]])}else this.rawGeometry=e.geometry;this.properties=e.tags,this.extent=EXTENT};FeatureWrapper.prototype.loadGeometry=function(){var e=this,t=this.rawGeometry;this.geometry=[];for(var r=0;r<t.length;r++){for(var o=t[r],a=[],i=0;i<o.length;i++)a.push(new Point(o[i][0],o[i][1]));e.geometry.push(a)}return this.geometry},FeatureWrapper.prototype.bbox=function(){this.geometry||this.loadGeometry();for(var e=this.geometry,t=1/0,r=-(1/0),o=1/0,a=-(1/0),i=0;i<e.length;i++)for(var p=e[i],h=0;h<p.length;h++){var n=p[h];t=Math.min(t,n.x),r=Math.max(r,n.x),o=Math.min(o,n.y),a=Math.max(a,n.y)}return[t,o,r,a]},FeatureWrapper.prototype.toGeoJSON=function(){VectorTileFeature.prototype.toGeoJSON.call(this)};var GeoJSONWrapper=function(e){this.features=e,this.length=e.length,this.extent=EXTENT};GeoJSONWrapper.prototype.feature=function(e){return new FeatureWrapper(this.features[e])},module.exports=GeoJSONWrapper;
},{"../data/extent":11,"point-geometry":197,"vector-tile":206}],44:[function(require,module,exports){
"use strict";var util=require("../util/util"),window=require("../util/window"),TileCoord=require("./tile_coord"),LngLat=require("../geo/lng_lat"),Point=require("point-geometry"),Evented=require("../util/evented"),ajax=require("../util/ajax"),EXTENT=require("../data/extent"),RasterBoundsArray=require("../data/raster_bounds_array"),Buffer=require("../data/buffer"),VertexArrayObject=require("../render/vertex_array_object"),ImageSource=function(t){function e(e,o,r,i){t.call(this),this.id=e,this.dispatcher=r,this.coordinates=o.coordinates,this.type="image",this.minzoom=0,this.maxzoom=22,this.tileSize=512,this.setEventedParent(i),this.options=o}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.load=function(){var t=this;this.fire("dataloading",{dataType:"source"}),this.url=this.options.url,ajax.getImage(this.options.url,function(e,o){return e?t.fire("error",{error:e}):(t.image=o,void t._finishLoading())})},e.prototype._finishLoading=function(){this.fire("source.load"),this.map&&this.setCoordinates(this.coordinates)},e.prototype.onAdd=function(t){this.load(),this.map=t,this.image&&this.setCoordinates(this.coordinates)},e.prototype.setCoordinates=function(t){this.coordinates=t;var e=this.map,o=t.map(function(t){return e.transform.locationCoordinate(LngLat.convert(t)).zoomTo(0)}),r=this.centerCoord=util.getCoordinatesCenter(o);return r.column=Math.round(r.column),r.row=Math.round(r.row),this.minzoom=this.maxzoom=r.zoom,this.coord=new TileCoord(r.zoom,r.column,r.row),this._tileCoords=o.map(function(t){var e=t.zoomTo(r.zoom);return new Point(Math.round((e.column-r.column)*EXTENT),Math.round((e.row-r.row)*EXTENT))}),this.fire("data",{dataType:"source"}),this},e.prototype._setTile=function(t){this.tile=t;var e=32767,o=new RasterBoundsArray;o.emplaceBack(this._tileCoords[0].x,this._tileCoords[0].y,0,0),o.emplaceBack(this._tileCoords[1].x,this._tileCoords[1].y,e,0),o.emplaceBack(this._tileCoords[3].x,this._tileCoords[3].y,0,e),o.emplaceBack(this._tileCoords[2].x,this._tileCoords[2].y,e,e),this.tile.buckets={},this.tile.boundsBuffer=Buffer.fromStructArray(o,Buffer.BufferType.VERTEX),this.tile.boundsVAO=new VertexArrayObject},e.prototype.prepare=function(){this.tile&&this.image&&this._prepareImage(this.map.painter.gl,this.image)},e.prototype._prepareImage=function(t,e,o){"loaded"!==this.tile.state?(this.tile.state="loaded",this.tile.texture=t.createTexture(),t.bindTexture(t.TEXTURE_2D,this.tile.texture),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.LINEAR),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,e)):o?t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,e):(e instanceof window.HTMLVideoElement||e instanceof window.ImageData||e instanceof window.HTMLCanvasElement)&&(t.bindTexture(t.TEXTURE_2D,this.tile.texture),t.texSubImage2D(t.TEXTURE_2D,0,0,0,t.RGBA,t.UNSIGNED_BYTE,e))},e.prototype.loadTile=function(t,e){this.coord&&this.coord.toString()===t.coord.toString()?(this._setTile(t),e(null)):(t.state="errored",e(null))},e.prototype.serialize=function(){return{type:"image",urls:this.url,coordinates:this.coordinates}},e}(Evented);module.exports=ImageSource;
},{"../data/buffer":8,"../data/extent":11,"../data/raster_bounds_array":16,"../geo/lng_lat":19,"../render/vertex_array_object":39,"../util/ajax":109,"../util/evented":118,"../util/util":129,"../util/window":112,"./tile_coord":53,"point-geometry":197}],45:[function(require,module,exports){
"use strict";var util=require("../util/util"),ajax=require("../util/ajax"),browser=require("../util/browser"),normalizeURL=require("../util/mapbox").normalizeSourceURL;module.exports=function(r,e){var i=function(r,i){if(r)return e(r);var t=util.pick(i,["tiles","minzoom","maxzoom","attribution"]);i.vector_layers&&(t.vectorLayers=i.vector_layers,t.vectorLayerIds=t.vectorLayers.map(function(r){return r.id})),e(null,t)};r.url?ajax.getJSON(normalizeURL(r.url),i):browser.frame(i.bind(null,null,r))};
},{"../util/ajax":109,"../util/browser":110,"../util/mapbox":125,"../util/util":129}],46:[function(require,module,exports){
"use strict";var EXTENT=require("../data/extent");module.exports=function(e,t,r){return t*(EXTENT/(e.tileSize*Math.pow(2,r-e.coord.z)))};
},{"../data/extent":11}],47:[function(require,module,exports){
"use strict";function sortTilesIn(e,r){var o=e.coord,t=r.coord;return o.z-t.z||o.y-t.y||o.w-t.w||o.x-t.x}function mergeRenderedFeatureLayers(e){for(var r=e[0]||{},o=1;o<e.length;o++){var t=e[o];for(var n in t){var a=t[n],i=r[n];if(void 0===i)i=r[n]=a;else for(var u=0;u<a.length;u++)i.push(a[u])}}return r}var TileCoord=require("./tile_coord");exports.rendered=function(e,r,o,t,n,a){var i=e.tilesIn(o);i.sort(sortTilesIn);for(var u=[],s=0;s<i.length;s++){var d=i[s];d.tile.featureIndex&&u.push(d.tile.featureIndex.query({queryGeometry:d.queryGeometry,scale:d.scale,tileSize:d.tile.tileSize,bearing:a,params:t},r))}return mergeRenderedFeatureLayers(u)},exports.source=function(e,r){for(var o=e.getRenderableIds().map(function(r){return e.getTileByID(r)}),t=[],n={},a=0;a<o.length;a++){var i=o[a],u=new TileCoord(Math.min(i.sourceMaxZoom,i.coord.z),i.coord.x,i.coord.y,0).id;n[u]||(n[u]=!0,i.querySourceFeatures(t,r))}return t};
},{"./tile_coord":53}],48:[function(require,module,exports){
"use strict";var util=require("../util/util"),ajax=require("../util/ajax"),Evented=require("../util/evented"),loadTileJSON=require("./load_tilejson"),normalizeURL=require("../util/mapbox").normalizeTileURL,RasterTileSource=function(e){function t(t,i,r,o){e.call(this),this.id=t,this.dispatcher=r,this.setEventedParent(o),this.type="raster",this.minzoom=0,this.maxzoom=22,this.roundZoom=!0,this.scheme="xyz",this.tileSize=512,this._loaded=!1,this.options=i,util.extend(this,util.pick(i,["url","scheme","tileSize"]))}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.load=function(){var e=this;this.fire("dataloading",{dataType:"source"}),loadTileJSON(this.options,function(t,i){return t?e.fire("error",t):(util.extend(e,i),e.fire("data",{dataType:"source"}),void e.fire("source.load"))})},t.prototype.onAdd=function(e){this.load(),this.map=e},t.prototype.serialize=function(){return{type:"raster",url:this.url,tileSize:this.tileSize,tiles:this.tiles}},t.prototype.loadTile=function(e,t){function i(i,r){if(delete e.request,e.aborted)return this.state="unloaded",t(null);if(i)return this.state="errored",t(i);e.setExpiryData(r),delete r.cacheControl,delete r.expires;var o=this.map.painter.gl;e.texture=this.map.painter.getTileTexture(r.width),e.texture?(o.bindTexture(o.TEXTURE_2D,e.texture),o.texSubImage2D(o.TEXTURE_2D,0,0,0,o.RGBA,o.UNSIGNED_BYTE,r)):(e.texture=o.createTexture(),o.bindTexture(o.TEXTURE_2D,e.texture),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_MIN_FILTER,o.LINEAR_MIPMAP_NEAREST),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_MAG_FILTER,o.LINEAR),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_WRAP_S,o.CLAMP_TO_EDGE),o.texParameteri(o.TEXTURE_2D,o.TEXTURE_WRAP_T,o.CLAMP_TO_EDGE),o.texImage2D(o.TEXTURE_2D,0,o.RGBA,o.RGBA,o.UNSIGNED_BYTE,r),e.texture.size=r.width),o.generateMipmap(o.TEXTURE_2D),e.state="loaded",t(null)}var r=normalizeURL(e.coord.url(this.tiles,null,this.scheme),this.url,this.tileSize);e.request=ajax.getImage(r,i.bind(this))},t.prototype.abortTile=function(e){e.request&&(e.request.abort(),delete e.request)},t.prototype.unloadTile=function(e){e.texture&&this.map.painter.saveTileTexture(e.texture)},t}(Evented);module.exports=RasterTileSource;
},{"../util/ajax":109,"../util/evented":118,"../util/mapbox":125,"../util/util":129,"./load_tilejson":45}],49:[function(require,module,exports){
"use strict";var ajax=require("../util/ajax"),window=require("../util/window"),pluginAvailableCallbacks=[],pluginRequested=!1,pluginBlobURL=null;module.exports.registerForPluginAvailability=function(l){pluginBlobURL?l(pluginBlobURL):pluginAvailableCallbacks.push(l)},module.exports.errorCallback=null,module.exports.setRTLTextPlugin=function(l,e){if(pluginRequested)throw new Error("setRTLTextPlugin cannot be called multiple times.");pluginRequested=!0,module.exports.errorCallback=e,ajax.getArrayBuffer(l,function(l,i){if(l)e(l);else{pluginBlobURL=window.URL.createObjectURL(new window.Blob([i.data]),{type:"text/javascript"});for(var a=0,u=pluginAvailableCallbacks;a<u.length;a+=1){var t=u[a];t(pluginBlobURL)}}})};
},{"../util/ajax":109,"../util/window":112}],50:[function(require,module,exports){
"use strict";var util=require("../util/util"),sourceTypes={vector:require("../source/vector_tile_source"),raster:require("../source/raster_tile_source"),geojson:require("../source/geojson_source"),video:require("../source/video_source"),image:require("../source/image_source"),canvas:require("../source/canvas_source")};exports.create=function(e,r,o,u){if(r=new sourceTypes[r.type](e,r,o,u),r.id!==e)throw new Error("Expected Source id to be "+e+" instead of "+r.id);return util.bindAll(["load","abort","unload","serialize","prepare"],r),r},exports.getType=function(e){return sourceTypes[e]},exports.setType=function(e,r){sourceTypes[e]=r};
},{"../source/canvas_source":40,"../source/geojson_source":41,"../source/image_source":44,"../source/raster_tile_source":48,"../source/vector_tile_source":54,"../source/video_source":56,"../util/util":129}],51:[function(require,module,exports){
"use strict";function coordinateToTilePoint(e,t,o){var i=o.zoomTo(Math.min(e.z,t));return{x:(i.column-(e.x+e.w*Math.pow(2,e.z)))*EXTENT,y:(i.row-e.y)*EXTENT}}function compareKeyZoom(e,t){return e%32-t%32}function isRasterType(e){return"raster"===e||"image"===e||"video"===e}var Source=require("./source"),Tile=require("./tile"),Evented=require("../util/evented"),TileCoord=require("./tile_coord"),Cache=require("../util/lru_cache"),Coordinate=require("../geo/coordinate"),util=require("../util/util"),EXTENT=require("../data/extent"),SourceCache=function(e){function t(t,o,i){e.call(this),this.id=t,this.dispatcher=i,this.on("source.load",function(){this._sourceLoaded=!0}),this.on("error",function(){this._sourceErrored=!0}),this.on("data",function(e){this._sourceLoaded&&"source"===e.dataType&&(this.reload(),this.transform&&this.update(this.transform))}),this._source=Source.create(t,o,i,this),this._tiles={},this._cache=new Cache(0,this.unloadTile.bind(this)),this._timers={},this._cacheTimers={},this._isIdRenderable=this._isIdRenderable.bind(this)}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.onAdd=function(e){this.map=e,this._source&&this._source.onAdd&&this._source.onAdd(e)},t.prototype.onRemove=function(e){this._source&&this._source.onRemove&&this._source.onRemove(e)},t.prototype.loaded=function(){var e=this;if(this._sourceErrored)return!0;if(!this._sourceLoaded)return!1;for(var t in this._tiles){var o=e._tiles[t];if("loaded"!==o.state&&"errored"!==o.state)return!1}return!0},t.prototype.getSource=function(){return this._source},t.prototype.loadTile=function(e,t){return this._source.loadTile(e,t)},t.prototype.unloadTile=function(e){if(this._source.unloadTile)return this._source.unloadTile(e)},t.prototype.abortTile=function(e){if(this._source.abortTile)return this._source.abortTile(e)},t.prototype.serialize=function(){return this._source.serialize()},t.prototype.prepare=function(){if(this._sourceLoaded&&this._source.prepare)return this._source.prepare()},t.prototype.getIds=function(){return Object.keys(this._tiles).map(Number).sort(compareKeyZoom)},t.prototype.getRenderableIds=function(){return this.getIds().filter(this._isIdRenderable)},t.prototype._isIdRenderable=function(e){return this._tiles[e].hasData()&&!this._coveredTiles[e]},t.prototype.reload=function(){var e=this;this._cache.reset();for(var t in this._tiles)e.reloadTile(t,"reloading")},t.prototype.reloadTile=function(e,t){var o=this._tiles[e];"loading"!==o.state&&(o.state=t),this.loadTile(o,this._tileLoaded.bind(this,o,e))},t.prototype._tileLoaded=function(e,t,o){return o?(e.state="errored",void this._source.fire("error",{tile:e,error:o})):(e.sourceCache=this,e.timeAdded=(new Date).getTime(),this._setTileReloadTimer(t,e),this._source.fire("data",{tile:e,coord:e.coord,dataType:"tile"}),void(this.map&&(this.map.painter.tileExtentVAO.vao=null)))},t.prototype.getTile=function(e){return this.getTileByID(e.id)},t.prototype.getTileByID=function(e){return this._tiles[e]},t.prototype.getZoom=function(e){return e.zoom+e.scaleZoom(e.tileSize/this._source.tileSize)},t.prototype.findLoadedChildren=function(e,t,o){var i=this,r=!1;for(var s in this._tiles){var a=i._tiles[s];if(!(o[s]||!a.hasData()||a.coord.z<=e.z||a.coord.z>t)){var n=Math.pow(2,Math.min(a.coord.z,i._source.maxzoom)-Math.min(e.z,i._source.maxzoom));if(Math.floor(a.coord.x/n)===e.x&&Math.floor(a.coord.y/n)===e.y)for(o[s]=!0,r=!0;a&&a.coord.z-1>e.z;){var d=a.coord.parent(i._source.maxzoom).id;a=i._tiles[d],a&&a.hasData()&&(delete o[s],o[d]=!0)}}}return r},t.prototype.findLoadedParent=function(e,t,o){for(var i=this,r=e.z-1;r>=t;r--){e=e.parent(i._source.maxzoom);var s=i._tiles[e.id];if(s&&s.hasData())return o[e.id]=!0,s;if(i._cache.has(e.id))return o[e.id]=!0,i._cache.get(e.id)}},t.prototype.updateCacheSize=function(e){var t=Math.ceil(e.width/e.tileSize)+1,o=Math.ceil(e.height/e.tileSize)+1,i=t*o,r=5;this._cache.setMaxSize(Math.floor(i*r))},t.prototype.update=function(e){var o=this;if(this._sourceLoaded){var i,r,s,a;this.updateCacheSize(e);var n=(this._source.roundZoom?Math.round:Math.floor)(this.getZoom(e)),d=Math.max(n-t.maxOverzooming,this._source.minzoom),c=Math.max(n+t.maxUnderzooming,this._source.minzoom),h={};this._coveredTiles={};var u;for(u=this.used?this._source.coord?[this._source.coord]:e.coveringTiles({tileSize:this._source.tileSize,minzoom:this._source.minzoom,maxzoom:this._source.maxzoom,roundZoom:this._source.roundZoom,reparseOverscaled:this._source.reparseOverscaled}):[],i=0;i<u.length;i++)r=u[i],s=o.addTile(r),h[r.id]=!0,s.hasData()||o.findLoadedChildren(r,c,h)||(a=o.findLoadedParent(r,d,h),a&&o.addTile(a.coord));var l={};if(isRasterType(this._source.type))for(var m=Object.keys(h),p=0;p<m.length;p++){var _=m[p];r=TileCoord.fromID(_),s=o._tiles[_],s&&("undefined"==typeof s.fadeEndTime||s.fadeEndTime>=Date.now())&&(o.findLoadedChildren(r,c,h)&&(h[_]=!0),a=o.findLoadedParent(r,d,l),a&&o.addTile(a.coord))}var f;for(f in l)h[f]||(o._coveredTiles[f]=!0);for(f in l)h[f]=!0;var T=util.keysDifference(this._tiles,h);for(i=0;i<T.length;i++)o.removeTile(+T[i]);this.transform=e}},t.prototype.addTile=function(e){var t=this._tiles[e.id];if(t)return t;var o=e.wrapped();if(t=this._tiles[o.id],t||(t=this._cache.get(o.id),t&&(t.redoPlacement(this._source),this._cacheTimers[o.id]&&(clearTimeout(this._cacheTimers[o.id]),this._cacheTimers[o.id]=void 0,this._setTileReloadTimer(o.id,t)))),!t){var i=e.z,r=i>this._source.maxzoom?Math.pow(2,i-this._source.maxzoom):1;t=new Tile(o,this._source.tileSize*r,this._source.maxzoom),this.loadTile(t,this._tileLoaded.bind(this,t,e.id))}return t.uses++,this._tiles[e.id]=t,this._source.fire("dataloading",{tile:t,coord:t.coord,dataType:"tile"}),t},t.prototype._setTileReloadTimer=function(e,t){var o=this,i=t.getExpiry();i&&(this._timers[e]=setTimeout(function(){o.reloadTile(e,"expired"),o._timers[e]=void 0},i-(new Date).getTime()))},t.prototype._setCacheInvalidationTimer=function(e,t){var o=this,i=t.getExpiry();i&&(this._cacheTimers[e]=setTimeout(function(){o._cache.remove(e),o._cacheTimers[e]=void 0},i-(new Date).getTime()))},t.prototype.removeTile=function(e){var t=this._tiles[e];if(t&&(t.uses--,delete this._tiles[e],this._timers[e]&&(clearTimeout(this._timers[e]),this._timers[e]=void 0),this._source.fire("data",{tile:t,coord:t.coord,dataType:"tile"}),!(t.uses>0)))if(t.hasData()){var o=t.coord.wrapped().id;this._cache.add(o,t),this._setCacheInvalidationTimer(o,t)}else t.aborted=!0,this.abortTile(t),this.unloadTile(t)},t.prototype.clearTiles=function(){var e=this;for(var t in this._tiles)e.removeTile(t);this._cache.reset()},t.prototype.tilesIn=function(e){for(var t=this,o={},i=this.getIds(),r=1/0,s=1/0,a=-(1/0),n=-(1/0),d=e[0].zoom,c=0;c<e.length;c++){var h=e[c];r=Math.min(r,h.column),s=Math.min(s,h.row),a=Math.max(a,h.column),n=Math.max(n,h.row)}for(var u=0;u<i.length;u++){var l=t._tiles[i[u]],m=TileCoord.fromID(i[u]),p=[coordinateToTilePoint(m,l.sourceMaxZoom,new Coordinate(r,s,d)),coordinateToTilePoint(m,l.sourceMaxZoom,new Coordinate(a,n,d))];if(p[0].x<EXTENT&&p[0].y<EXTENT&&p[1].x>=0&&p[1].y>=0){for(var _=[],f=0;f<e.length;f++)_.push(coordinateToTilePoint(m,l.sourceMaxZoom,e[f]));var T=o[l.coord.id];void 0===T&&(T=o[l.coord.id]={tile:l,coord:m,queryGeometry:[],scale:Math.pow(2,t.transform.zoom-l.coord.z)}),T.queryGeometry.push(_)}}var v=[];for(var y in o)v.push(o[y]);return v},t.prototype.redoPlacement=function(){for(var e=this,t=this.getIds(),o=0;o<t.length;o++){var i=e.getTileByID(t[o]);i.redoPlacement(e._source)}},t.prototype.getVisibleCoordinates=function(){for(var e=this,t=this.getRenderableIds().map(TileCoord.fromID),o=0,i=t;o<i.length;o+=1){var r=i[o];r.posMatrix=e.transform.calculatePosMatrix(r,e._source.maxzoom)}return t},t}(Evented);SourceCache.maxOverzooming=10,SourceCache.maxUnderzooming=3,module.exports=SourceCache;
},{"../data/extent":11,"../geo/coordinate":18,"../util/evented":118,"../util/lru_cache":124,"../util/util":129,"./source":50,"./tile":52,"./tile_coord":53}],52:[function(require,module,exports){
"use strict";var util=require("../util/util"),Bucket=require("../data/bucket"),FeatureIndex=require("../data/feature_index"),vt=require("vector-tile"),Protobuf=require("pbf"),GeoJSONFeature=require("../util/vectortile_to_geojson"),featureFilter=require("feature-filter"),CollisionTile=require("../symbol/collision_tile"),CollisionBoxArray=require("../symbol/collision_box"),SymbolInstancesArray=require("../symbol/symbol_instances"),SymbolQuadsArray=require("../symbol/symbol_quads"),Tile=function(e,t,i){this.coord=e,this.uid=util.uniqueId(),this.uses=0,this.tileSize=t,this.sourceMaxZoom=i,this.buckets={},this.expires=null,this.cacheControl=null,this.state="loading"};Tile.prototype.registerFadeDuration=function(e,t){var i=t+this.timeAdded;i<Date.now()||this.fadeEndTime&&i<this.fadeEndTime||(this.fadeEndTime=i,e.set(this.fadeEndTime-Date.now()))},Tile.prototype.loadVectorData=function(e,t){this.hasData()&&this.unloadVectorData(t),this.state="loaded",e&&(e.rawTileData&&(this.rawTileData=e.rawTileData),this.collisionBoxArray=new CollisionBoxArray(e.collisionBoxArray),this.collisionTile=new CollisionTile(e.collisionTile,this.collisionBoxArray),this.symbolInstancesArray=new SymbolInstancesArray(e.symbolInstancesArray),this.symbolQuadsArray=new SymbolQuadsArray(e.symbolQuadsArray),this.featureIndex=new FeatureIndex(e.featureIndex,this.rawTileData,this.collisionTile),this.buckets=Bucket.deserialize(e.buckets,t.style))},Tile.prototype.reloadSymbolData=function(e,t){var i=this;if("unloaded"!==this.state){this.collisionTile=new CollisionTile(e.collisionTile,this.collisionBoxArray),this.featureIndex.setCollisionTile(this.collisionTile);for(var o in this.buckets){var s=i.buckets[o];"symbol"===s.layers[0].type&&(s.destroy(),delete i.buckets[o])}util.extend(this.buckets,Bucket.deserialize(e.buckets,t))}},Tile.prototype.unloadVectorData=function(){var e=this;for(var t in this.buckets)e.buckets[t].destroy();this.buckets={},this.collisionBoxArray=null,this.symbolQuadsArray=null,this.symbolInstancesArray=null,this.collisionTile=null,this.featureIndex=null,this.state="unloaded"},Tile.prototype.redoPlacement=function(e){var t=this;if("vector"===e.type||"geojson"===e.type)return"loaded"!==this.state?void(this.redoWhenDone=!0):void(this.collisionTile&&(this.state="reloading",e.dispatcher.send("redoPlacement",{type:e.type,uid:this.uid,source:e.id,angle:e.map.transform.angle,pitch:e.map.transform.pitch,showCollisionBoxes:e.map.showCollisionBoxes},function(i,o){t.reloadSymbolData(o,e.map.style),e.fire("data",{tile:t,coord:t.coord,dataType:"tile"}),e.map&&(e.map.painter.tileExtentVAO.vao=null),t.state="loaded",t.redoWhenDone&&(t.redoWhenDone=!1,t.redoPlacement(e))},this.workerID)))},Tile.prototype.getBucket=function(e){return this.buckets[e.id]},Tile.prototype.querySourceFeatures=function(e,t){var i=this;if(this.rawTileData){this.vtLayers||(this.vtLayers=new vt.VectorTile(new Protobuf(this.rawTileData)).layers);var o=this.vtLayers._geojsonTileLayer||this.vtLayers[t.sourceLayer];if(o)for(var s=featureFilter(t&&t.filter),r={z:this.coord.z,x:this.coord.x,y:this.coord.y},a=0;a<o.length;a++){var l=o.feature(a);if(s(l)){var n=new GeoJSONFeature(l,i.coord.z,i.coord.x,i.coord.y);n.tile=r,e.push(n)}}}},Tile.prototype.hasData=function(){return"loaded"===this.state||"reloading"===this.state||"expired"===this.state},Tile.prototype.setExpiryData=function(e){e.cacheControl&&(this.cacheControl=e.cacheControl),e.expires&&(this.expires=e.expires)},Tile.prototype.getExpiry=function(){if(this.cacheControl){var e=util.parseCacheControl(this.cacheControl);if(e["max-age"])return this.timeAdded+1e3*e["max-age"]}else if(this.expires)return new Date(this.expires).getTime()},module.exports=Tile;
},{"../data/bucket":2,"../data/feature_index":12,"../symbol/collision_box":78,"../symbol/collision_tile":80,"../symbol/symbol_instances":89,"../symbol/symbol_quads":90,"../util/util":129,"../util/vectortile_to_geojson":130,"feature-filter":138,"pbf":196,"vector-tile":206}],53:[function(require,module,exports){
"use strict";function edge(t,i){if(t.row>i.row){var o=t;t=i,i=o}return{x0:t.column,y0:t.row,x1:i.column,y1:i.row,dx:i.column-t.column,dy:i.row-t.row}}function scanSpans(t,i,o,r,e){var n=Math.max(o,Math.floor(i.y0)),h=Math.min(r,Math.ceil(i.y1));if(t.x0===i.x0&&t.y0===i.y0?t.x0+i.dy/t.dy*t.dx<i.x1:t.x1-i.dy/t.dy*t.dx<i.x0){var s=t;t=i,i=s}for(var a=t.dx/t.dy,d=i.dx/i.dy,y=t.dx>0,l=i.dx<0,u=n;u<h;u++){var x=a*Math.max(0,Math.min(t.dy,u+y-t.y0))+t.x0,c=d*Math.max(0,Math.min(i.dy,u+l-i.y0))+i.x0;e(Math.floor(c),Math.ceil(x),u)}}function scanTriangle(t,i,o,r,e,n){var h,s=edge(t,i),a=edge(i,o),d=edge(o,t);s.dy>a.dy&&(h=s,s=a,a=h),s.dy>d.dy&&(h=s,s=d,d=h),a.dy>d.dy&&(h=a,a=d,d=h),s.dy&&scanSpans(d,s,r,e,n),a.dy&&scanSpans(d,a,r,e,n)}function getQuadkey(t,i,o){for(var r,e="",n=t;n>0;n--)r=1<<n-1,e+=(i&r?1:0)+(o&r?2:0);return e}var WhooTS=require("whoots-js"),Coordinate=require("../geo/coordinate"),TileCoord=function(t,i,o,r){isNaN(r)&&(r=0),this.z=+t,this.x=+i,this.y=+o,this.w=+r,r*=2,r<0&&(r=r*-1-1);var e=1<<this.z;this.id=32*(e*e*r+e*this.y+this.x)+this.z,this.posMatrix=null};TileCoord.prototype.toString=function(){return this.z+"/"+this.x+"/"+this.y},TileCoord.prototype.toCoordinate=function(t){var i=Math.min(this.z,void 0===t?this.z:t),o=Math.pow(2,i),r=this.y,e=this.x+o*this.w;return new Coordinate(e,r,i)},TileCoord.prototype.url=function(t,i,o){var r=WhooTS.getTileBBox(this.x,this.y,this.z),e=getQuadkey(this.z,this.x,this.y);return t[(this.x+this.y)%t.length].replace("{prefix}",(this.x%16).toString(16)+(this.y%16).toString(16)).replace("{z}",Math.min(this.z,i||this.z)).replace("{x}",this.x).replace("{y}","tms"===o?Math.pow(2,this.z)-this.y-1:this.y).replace("{quadkey}",e).replace("{bbox-epsg-3857}",r)},TileCoord.prototype.parent=function(t){return 0===this.z?null:this.z>t?new TileCoord(this.z-1,this.x,this.y,this.w):new TileCoord(this.z-1,Math.floor(this.x/2),Math.floor(this.y/2),this.w)},TileCoord.prototype.wrapped=function(){return new TileCoord(this.z,this.x,this.y,0)},TileCoord.prototype.children=function(t){if(this.z>=t)return[new TileCoord(this.z+1,this.x,this.y,this.w)];var i=this.z+1,o=2*this.x,r=2*this.y;return[new TileCoord(i,o,r,this.w),new TileCoord(i,o+1,r,this.w),new TileCoord(i,o,r+1,this.w),new TileCoord(i,o+1,r+1,this.w)]},TileCoord.cover=function(t,i,o,r){function e(t,i,e){var s,a,d,y;if(e>=0&&e<=n)for(s=t;s<i;s++)a=Math.floor(s/n),d=(s%n+n)%n,0!==a&&r!==!0||(y=new TileCoord(o,d,e,a),h[y.id]=y)}void 0===r&&(r=!0);var n=1<<t,h={};return scanTriangle(i[0],i[1],i[2],0,n,e),scanTriangle(i[2],i[3],i[0],0,n,e),Object.keys(h).map(function(t){return h[t]})},TileCoord.fromID=function(t){var i=t%32,o=1<<i,r=(t-i)/32,e=r%o,n=(r-e)/o%o,h=Math.floor(r/(o*o));return h%2!==0&&(h=h*-1-1),h/=2,new TileCoord(i,e,n,h)},module.exports=TileCoord;
},{"../geo/coordinate":18,"whoots-js":215}],54:[function(require,module,exports){
"use strict";var Evented=require("../util/evented"),util=require("../util/util"),loadTileJSON=require("./load_tilejson"),normalizeURL=require("../util/mapbox").normalizeTileURL,VectorTileSource=function(e){function t(t,i,o,r){if(e.call(this),this.id=t,this.dispatcher=o,this.type="vector",this.minzoom=0,this.maxzoom=22,this.scheme="xyz",this.tileSize=512,this.reparseOverscaled=!0,this.isTileClipped=!0,util.extend(this,util.pick(i,["url","scheme","tileSize"])),this._options=util.extend({type:"vector"},i),512!==this.tileSize)throw new Error("vector tile sources must have a tileSize of 512");this.setEventedParent(r)}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.load=function(){var e=this;this.fire("dataloading",{dataType:"source"}),loadTileJSON(this._options,function(t,i){return t?void e.fire("error",t):(util.extend(e,i),e.fire("data",{dataType:"source"}),void e.fire("source.load"))})},t.prototype.onAdd=function(e){this.load(),this.map=e},t.prototype.serialize=function(){return util.extend({},this._options)},t.prototype.loadTile=function(e,t){function i(i,o){if(!e.aborted){if(i)return t(i);e.setExpiryData(o),e.loadVectorData(o,this.map.painter),e.redoWhenDone&&(e.redoWhenDone=!1,e.redoPlacement(this)),t(null),e.reloadCallback&&(this.loadTile(e,e.reloadCallback),e.reloadCallback=null)}}var o=e.coord.z>this.maxzoom?Math.pow(2,e.coord.z-this.maxzoom):1,r={url:normalizeURL(e.coord.url(this.tiles,this.maxzoom,this.scheme),this.url),uid:e.uid,coord:e.coord,zoom:e.coord.z,tileSize:this.tileSize*o,type:this.type,source:this.id,overscaling:o,angle:this.map.transform.angle,pitch:this.map.transform.pitch,showCollisionBoxes:this.map.showCollisionBoxes};e.workerID&&"expired"!==e.state?"loading"===e.state?e.reloadCallback=t:this.dispatcher.send("reloadTile",r,i.bind(this),e.workerID):e.workerID=this.dispatcher.send("loadTile",r,i.bind(this))},t.prototype.abortTile=function(e){this.dispatcher.send("abortTile",{uid:e.uid,type:this.type,source:this.id},null,e.workerID)},t.prototype.unloadTile=function(e){e.unloadVectorData(),this.dispatcher.send("removeTile",{uid:e.uid,type:this.type,source:this.id},null,e.workerID)},t}(Evented);module.exports=VectorTileSource;
},{"../util/evented":118,"../util/mapbox":125,"../util/util":129,"./load_tilejson":45}],55:[function(require,module,exports){
"use strict";var ajax=require("../util/ajax"),vt=require("vector-tile"),Protobuf=require("pbf"),WorkerTile=require("./worker_tile"),util=require("../util/util"),VectorTileWorkerSource=function(e,r,t){this.actor=e,this.layerIndex=r,t&&(this.loadVectorData=t),this.loading={},this.loaded={}};VectorTileWorkerSource.prototype.loadTile=function(e,r){function t(e,t){return delete this.loading[o][i],e?r(e):t?(a.vectorTile=t,a.parse(t,this.layerIndex,this.actor,function(e,o,i){if(e)return r(e);var a={};t.expires&&(a.expires=t.expires),t.cacheControl&&(a.cacheControl=t.cacheControl),r(null,util.extend({rawTileData:t.rawData},o,a),i)}),this.loaded[o]=this.loaded[o]||{},void(this.loaded[o][i]=a)):r(null,null)}var o=e.source,i=e.uid;this.loading[o]||(this.loading[o]={});var a=this.loading[o][i]=new WorkerTile(e);a.abort=this.loadVectorData(e,t.bind(this))},VectorTileWorkerSource.prototype.reloadTile=function(e,r){function t(e,t){if(this.reloadCallback){var o=this.reloadCallback;delete this.reloadCallback,this.parse(this.vectorTile,a.layerIndex,a.actor,o)}r(e,t)}var o=this.loaded[e.source],i=e.uid,a=this;if(o&&o[i]){var l=o[i];"parsing"===l.status?l.reloadCallback=r:"done"===l.status&&l.parse(l.vectorTile,this.layerIndex,this.actor,t.bind(l))}},VectorTileWorkerSource.prototype.abortTile=function(e){var r=this.loading[e.source],t=e.uid;r&&r[t]&&r[t].abort&&(r[t].abort(),delete r[t])},VectorTileWorkerSource.prototype.removeTile=function(e){var r=this.loaded[e.source],t=e.uid;r&&r[t]&&delete r[t]},VectorTileWorkerSource.prototype.loadVectorData=function(e,r){function t(e,t){if(e)return r(e);var o=new vt.VectorTile(new Protobuf(t.data));o.rawData=t.data,o.cacheControl=t.cacheControl,o.expires=t.expires,r(e,o)}var o=ajax.getArrayBuffer(e.url,t.bind(this));return function(){o.abort()}},VectorTileWorkerSource.prototype.redoPlacement=function(e,r){var t=this.loaded[e.source],o=this.loading[e.source],i=e.uid;if(t&&t[i]){var a=t[i],l=a.redoPlacement(e.angle,e.pitch,e.showCollisionBoxes);l.result&&r(null,l.result,l.transferables)}else o&&o[i]&&(o[i].angle=e.angle)},module.exports=VectorTileWorkerSource;
},{"../util/ajax":109,"../util/util":129,"./worker_tile":58,"pbf":196,"vector-tile":206}],56:[function(require,module,exports){
"use strict";var ajax=require("../util/ajax"),ImageSource=require("./image_source"),VideoSource=function(t){function e(e,o,i,r){t.call(this,e,o,i,r),this.roundZoom=!0,this.type="video",this.options=o}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.load=function(){var t=this,e=this.options;this.urls=e.urls,ajax.getVideo(e.urls,function(e,o){if(e)return t.fire("error",{error:e});t.video=o,t.video.loop=!0;var i;t.video.addEventListener("playing",function(){i=t.map.style.animationLoop.set(1/0),t.map._rerender()}),t.video.addEventListener("pause",function(){t.map.style.animationLoop.cancel(i)}),t.map&&t.video.play(),t._finishLoading()})},e.prototype.getVideo=function(){return this.video},e.prototype.onAdd=function(t){this.map||(this.load(),this.map=t,this.video&&(this.video.play(),this.setCoordinates(this.coordinates)))},e.prototype.prepare=function(){!this.tile||this.video.readyState<2||this._prepareImage(this.map.painter.gl,this.video)},e.prototype.serialize=function(){return{type:"video",urls:this.urls,coordinates:this.coordinates}},e}(ImageSource);module.exports=VideoSource;
},{"../util/ajax":109,"./image_source":44}],57:[function(require,module,exports){
"use strict";var Actor=require("../util/actor"),StyleLayerIndex=require("../style/style_layer_index"),VectorTileWorkerSource=require("./vector_tile_worker_source"),GeoJSONWorkerSource=require("./geojson_worker_source"),globalRTLTextPlugin=require("./rtl_text_plugin"),Worker=function(e){var r=this;this.self=e,this.actor=new Actor(e,this),this.layerIndexes={},this.workerSourceTypes={vector:VectorTileWorkerSource,geojson:GeoJSONWorkerSource},this.workerSources={},this.self.registerWorkerSource=function(e,o){if(r.workerSourceTypes[e])throw new Error('Worker source with name "'+e+'" already registered.');r.workerSourceTypes[e]=o},this.self.registerRTLTextPlugin=function(e){if(globalRTLTextPlugin.applyArabicShaping||globalRTLTextPlugin.processBidirectionalText)throw new Error("RTL text plugin already registered.");globalRTLTextPlugin.applyArabicShaping=e.applyArabicShaping,globalRTLTextPlugin.processBidirectionalText=e.processBidirectionalText}};Worker.prototype.setLayers=function(e,r){this.getLayerIndex(e).replace(r)},Worker.prototype.updateLayers=function(e,r){this.getLayerIndex(e).update(r.layers,r.removedIds,r.symbolOrder)},Worker.prototype.loadTile=function(e,r,o){this.getWorkerSource(e,r.type).loadTile(r,o)},Worker.prototype.reloadTile=function(e,r,o){this.getWorkerSource(e,r.type).reloadTile(r,o)},Worker.prototype.abortTile=function(e,r){this.getWorkerSource(e,r.type).abortTile(r)},Worker.prototype.removeTile=function(e,r){this.getWorkerSource(e,r.type).removeTile(r)},Worker.prototype.removeSource=function(e,r){var o=this.getWorkerSource(e,r.type);void 0!==o.removeSource&&o.removeSource(r)},Worker.prototype.redoPlacement=function(e,r,o){this.getWorkerSource(e,r.type).redoPlacement(r,o)},Worker.prototype.loadWorkerSource=function(e,r,o){try{this.self.importScripts(r.url),o()}catch(e){o(e)}},Worker.prototype.loadRTLTextPlugin=function(e,r,o){try{globalRTLTextPlugin.applyArabicShaping||globalRTLTextPlugin.processBidirectionalText||this.self.importScripts(r)}catch(e){o(e)}},Worker.prototype.getLayerIndex=function(e){var r=this.layerIndexes[e];return r||(r=this.layerIndexes[e]=new StyleLayerIndex),r},Worker.prototype.getWorkerSource=function(e,r){var o=this;if(this.workerSources[e]||(this.workerSources[e]={}),!this.workerSources[e][r]){var t={send:function(r,t,i,n){o.actor.send(r,t,i,n,e)}};this.workerSources[e][r]=new this.workerSourceTypes[r](t,this.getLayerIndex(e))}return this.workerSources[e][r]},module.exports=function(e){return new Worker(e)};
},{"../style/style_layer_index":71,"../util/actor":108,"./geojson_worker_source":42,"./rtl_text_plugin":49,"./vector_tile_worker_source":55}],58:[function(require,module,exports){
"use strict";function recalculateLayers(e,r){for(var i=0,s=e.layers;i<s.length;i+=1){var o=s[i];o.recalculate(r)}}function serializeBuckets(e,r){return e.filter(function(e){return!e.isEmpty()}).map(function(e){return e.serialize(r)})}var FeatureIndex=require("../data/feature_index"),CollisionTile=require("../symbol/collision_tile"),CollisionBoxArray=require("../symbol/collision_box"),DictionaryCoder=require("../util/dictionary_coder"),util=require("../util/util"),SymbolInstancesArray=require("../symbol/symbol_instances"),SymbolQuadsArray=require("../symbol/symbol_quads"),WorkerTile=function(e){this.coord=e.coord,this.uid=e.uid,this.zoom=e.zoom,this.tileSize=e.tileSize,this.source=e.source,this.overscaling=e.overscaling,this.angle=e.angle,this.pitch=e.pitch,this.showCollisionBoxes=e.showCollisionBoxes};WorkerTile.prototype.parse=function(e,r,i,s){var o=this;e.layers||(e={layers:{_geojsonTileLayer:e}}),this.status="parsing",this.data=e,this.collisionBoxArray=new CollisionBoxArray,this.symbolInstancesArray=new SymbolInstancesArray,this.symbolQuadsArray=new SymbolQuadsArray;var l=new DictionaryCoder(Object.keys(e.layers).sort()),t=new FeatureIndex(this.coord,this.overscaling);t.bucketLayerIDs={};var a={},n=0,c={featureIndex:t,iconDependencies:{},glyphDependencies:{}},u=r.familiesBySource[this.source];for(var y in u){var h=e.layers[y];if(h){1===h.version&&util.warnOnce('Vector tile source "'+o.source+'" layer "'+y+'" does not use vector tile spec v2 and therefore may have some rendering errors.');for(var m=l.encode(y),d=[],b=0;b<h.length;b++){var v=h.feature(b);v.index=b,v.sourceLayerIndex=m,d.push(v)}for(var f=0,p=u[y];f<p.length;f+=1){var g=p[f],x=g[0];if(!(x.minzoom&&o.zoom<x.minzoom||x.maxzoom&&o.zoom>=x.maxzoom||x.layout&&"none"===x.layout.visibility)){for(var z=0,A=g;z<A.length;z+=1){var B=A[z];B.recalculate(o.zoom)}var k=a[x.id]=x.createBucket({index:n,layers:g,zoom:o.zoom,overscaling:o.overscaling,collisionBoxArray:o.collisionBoxArray,symbolQuadsArray:o.symbolQuadsArray,symbolInstancesArray:o.symbolInstancesArray});k.populate(d,c),t.bucketLayerIDs[n]=g.map(function(e){return e.id}),n++}}}}var I=function(e){o.status="done";var r=[];s(null,{buckets:serializeBuckets(util.values(a),r),featureIndex:t.serialize(r),collisionTile:e.serialize(r),collisionBoxArray:o.collisionBoxArray.serialize(),symbolInstancesArray:o.symbolInstancesArray.serialize(),symbolQuadsArray:o.symbolQuadsArray.serialize()},r)};this.symbolBuckets=[];for(var w=r.symbolOrder.length-1;w>=0;w--){var C=a[r.symbolOrder[w]];C&&o.symbolBuckets.push(C)}if(0===this.symbolBuckets.length)return I(new CollisionTile(this.angle,this.pitch,this.collisionBoxArray));var T=0,q=Object.keys(c.iconDependencies),D=util.mapObject(c.glyphDependencies,function(e){return Object.keys(e).map(Number)}),O=function(e){if(e)return s(e);if(T++,2===T){for(var r=new CollisionTile(o.angle,o.pitch,o.collisionBoxArray),i=0,l=o.symbolBuckets;i<l.length;i+=1){var t=l[i];recalculateLayers(t,o.zoom),t.prepare(D,q),t.place(r,o.showCollisionBoxes)}I(r)}};Object.keys(D).length?i.send("getGlyphs",{uid:this.uid,stacks:D},function(e,r){D=r,O(e)}):O(),q.length?i.send("getIcons",{icons:q},function(e,r){q=r,O(e)}):O()},WorkerTile.prototype.redoPlacement=function(e,r,i){var s=this;if(this.angle=e,this.pitch=r,"done"!==this.status)return{};for(var o=new CollisionTile(this.angle,this.pitch,this.collisionBoxArray),l=0,t=this.symbolBuckets;l<t.length;l+=1){var a=t[l];recalculateLayers(a,s.zoom),a.place(o,i)}var n=[];return{result:{buckets:serializeBuckets(this.symbolBuckets,n),collisionTile:o.serialize(n)},transferables:n}},module.exports=WorkerTile;
},{"../data/feature_index":12,"../symbol/collision_box":78,"../symbol/collision_tile":80,"../symbol/symbol_instances":89,"../symbol/symbol_quads":90,"../util/dictionary_coder":115,"../util/util":129}],59:[function(require,module,exports){
"use strict";var AnimationLoop=function(){this.n=0,this.times=[]};AnimationLoop.prototype.stopped=function(){return this.times=this.times.filter(function(t){return t.time>=(new Date).getTime()}),!this.times.length},AnimationLoop.prototype.set=function(t){return this.times.push({id:this.n,time:t+(new Date).getTime()}),this.n++},AnimationLoop.prototype.cancel=function(t){this.times=this.times.filter(function(i){return i.id!==t})},module.exports=AnimationLoop;
},{}],60:[function(require,module,exports){
"use strict";var Evented=require("../util/evented"),ajax=require("../util/ajax"),browser=require("../util/browser"),normalizeURL=require("../util/mapbox").normalizeSpriteURL,SpritePosition=function(){this.x=0,this.y=0,this.width=0,this.height=0,this.pixelRatio=1,this.sdf=!1},ImageSprite=function(t){function i(i,e){var a=this;t.call(this),this.base=i,this.retina=browser.devicePixelRatio>1,this.setEventedParent(e);var r=this.retina?"@2x":"";ajax.getJSON(normalizeURL(i,r,".json"),function(t,i){return t?void a.fire("error",{error:t}):(a.data=i,void(a.imgData&&a.fire("data",{dataType:"style"})))}),ajax.getImage(normalizeURL(i,r,".png"),function(t,i){if(t)return void a.fire("error",{error:t});a.imgData=browser.getImageData(i);for(var e=0;e<a.imgData.length;e+=4){var r=a.imgData[e+3]/255;a.imgData[e+0]*=r,a.imgData[e+1]*=r,a.imgData[e+2]*=r}a.width=i.width,a.data&&a.fire("data",{dataType:"style"})})}return t&&(i.__proto__=t),i.prototype=Object.create(t&&t.prototype),i.prototype.constructor=i,i.prototype.toJSON=function(){return this.base},i.prototype.loaded=function(){return!(!this.data||!this.imgData)},i.prototype.resize=function(){var t=this;if(browser.devicePixelRatio>1!==this.retina){var e=new i(this.base);e.on("data",function(){t.data=e.data,t.imgData=e.imgData,t.width=e.width,t.retina=e.retina})}},i.prototype.getSpritePosition=function(t){if(!this.loaded())return new SpritePosition;var i=this.data&&this.data[t];return i&&this.imgData?i:new SpritePosition},i}(Evented);module.exports=ImageSprite;
},{"../util/ajax":109,"../util/browser":110,"../util/evented":118,"../util/mapbox":125}],61:[function(require,module,exports){
"use strict";var styleSpec=require("./style_spec"),util=require("../util/util"),Evented=require("../util/evented"),validateStyle=require("./validate_style"),StyleDeclaration=require("./style_declaration"),StyleTransition=require("./style_transition"),TRANSITION_SUFFIX="-transition",Light=function(t){function i(i){t.call(this),this.properties=["anchor","color","position","intensity"],this._specifications=styleSpec.light,this.set(i)}return t&&(i.__proto__=t),i.prototype=Object.create(t&&t.prototype),i.prototype.constructor=i,i.prototype.set=function(t){var i=this;if(!this._validate(validateStyle.light,t)){this._declarations={},this._transitions={},this._transitionOptions={},this.calculated={},t=util.extend({anchor:this._specifications.anchor.default,color:this._specifications.color.default,position:this._specifications.position.default,intensity:this._specifications.intensity.default},t);for(var e=0,o=this.properties;e<o.length;e+=1){var n=o[e];i._declarations[n]=new StyleDeclaration(i._specifications[n],t[n])}return this}},i.prototype.getLight=function(){return{anchor:this.getLightProperty("anchor"),color:this.getLightProperty("color"),position:this.getLightProperty("position"),intensity:this.getLightProperty("intensity")}},i.prototype.getLightProperty=function(t){return util.endsWith(t,TRANSITION_SUFFIX)?this._transitionOptions[t]:this._declarations[t]&&this._declarations[t].value},i.prototype.getLightValue=function(t,i){if("position"===t){var e=this._transitions[t].calculate(i),o=util.sphericalToCartesian(e);return{x:o[0],y:o[1],z:o[2]}}return this._transitions[t].calculate(i)},i.prototype.setLight=function(t){var i=this;if(!this._validate(validateStyle.light,t))for(var e in t){var o=t[e];util.endsWith(e,TRANSITION_SUFFIX)?i._transitionOptions[e]=o:null===o||void 0===o?delete i._declarations[e]:i._declarations[e]=new StyleDeclaration(i._specifications[e],o)}},i.prototype.recalculate=function(t){var i=this;for(var e in this._declarations)i.calculated[e]=i.getLightValue(e,{zoom:t})},i.prototype._applyLightDeclaration=function(t,i,e,o,n){var r=e.transition?this._transitions[t]:void 0,a=this._specifications[t];if(null!==i&&void 0!==i||(i=new StyleDeclaration(a,a.default)),!r||r.declaration.json!==i.json){var s=util.extend({duration:300,delay:0},o,this.getLightProperty(t+TRANSITION_SUFFIX)),l=this._transitions[t]=new StyleTransition(a,i,r,s);l.instant()||(l.loopID=n.set(l.endTime-Date.now())),r&&n.cancel(r.loopID)}},i.prototype.updateLightTransitions=function(t,i,e){var o,n=this;for(o in this._declarations)n._applyLightDeclaration(o,n._declarations[o],t,i,e)},i.prototype._validate=function(t,i){return validateStyle.emitErrors(this,t.call(validateStyle,util.extend({value:i,style:{glyphs:!0,sprite:!0},styleSpec:styleSpec})))},i}(Evented);module.exports=Light;
},{"../util/evented":118,"../util/util":129,"./style_declaration":64,"./style_spec":72,"./style_transition":73,"./validate_style":74}],62:[function(require,module,exports){
"use strict";var parseColorString=require("csscolorparser").parseCSSColor,util=require("../util/util"),MapboxGLFunction=require("mapbox-gl-function"),cache={};module.exports=function r(o){if(o&&MapboxGLFunction.isFunctionDefinition(o))return o.stops?util.extend({},o,{stops:o.stops.map(function(o){return[o[0],r(o[1])]})}):o;if("string"==typeof o){if(!cache[o]){var i=parseColorString(o);if(!i)throw new Error("Invalid color "+o);cache[o]=[i[0]/255*i[3],i[1]/255*i[3],i[2]/255*i[3],i[3]]}return cache[o]}if(Array.isArray(o))return o;throw new Error("Invalid color "+o)};
},{"../util/util":129,"csscolorparser":135,"mapbox-gl-function":164}],63:[function(require,module,exports){
"use strict";var Evented=require("../util/evented"),StyleLayer=require("./style_layer"),ImageSprite=require("./image_sprite"),Light=require("./light"),GlyphSource=require("../symbol/glyph_source"),SpriteAtlas=require("../symbol/sprite_atlas"),LineAtlas=require("../render/line_atlas"),util=require("../util/util"),ajax=require("../util/ajax"),mapbox=require("../util/mapbox"),browser=require("../util/browser"),Dispatcher=require("../util/dispatcher"),AnimationLoop=require("./animation_loop"),validateStyle=require("./validate_style"),Source=require("../source/source"),QueryFeatures=require("../source/query_features"),SourceCache=require("../source/source_cache"),styleSpec=require("./style_spec"),MapboxGLFunction=require("mapbox-gl-function"),getWorkerPool=require("../global_worker_pool"),deref=require("mapbox-gl-style-spec/lib/deref"),diff=require("mapbox-gl-style-spec/lib/diff"),rtlTextPlugin=require("../source/rtl_text_plugin"),supportedDiffOperations=util.pick(diff.operations,["addLayer","removeLayer","setPaintProperty","setLayoutProperty","setFilter","addSource","removeSource","setLayerZoomRange","setLight","setTransition"]),ignoredDiffOperations=util.pick(diff.operations,["setCenter","setZoom","setBearing","setPitch"]),Style=function(e){function t(t,r,i){var o=this;e.call(this),this.map=r,this.animationLoop=r&&r.animationLoop||new AnimationLoop,this.dispatcher=new Dispatcher(getWorkerPool(),this),this.spriteAtlas=new SpriteAtlas(1024,1024),this.lineAtlas=new LineAtlas(256,512),this._layers={},this._order=[],this.sourceCaches={},this.zoomHistory={},this._loaded=!1,util.bindAll(["_redoPlacement"],this),this._resetUpdates(),i=util.extend({validate:"string"!=typeof t||!mapbox.isMapboxURL(t)},i),this.setEventedParent(r),this.fire("dataloading",{dataType:"style"});var s=this;rtlTextPlugin.registerForPluginAvailability(function(e){s.dispatcher.broadcast("loadRTLTextPlugin",e,rtlTextPlugin.errorCallback);for(var t in s.sourceCaches)s.sourceCaches[t].reload()});var a=function(e,t){if(e)return void o.fire("error",{error:e});if(!i.validate||!validateStyle.emitErrors(o,validateStyle(t))){o._loaded=!0,o.stylesheet=t,o.updateClasses();for(var r in t.sources)o.addSource(r,t.sources[r],i);t.sprite&&(o.sprite=new ImageSprite(t.sprite,o)),o.glyphSource=new GlyphSource(t.glyphs),o._resolve(),o.fire("data",{dataType:"style"}),o.fire("style.load")}};"string"==typeof t?ajax.getJSON(mapbox.normalizeStyleURL(t),a):browser.frame(a.bind(this,null,t)),this.on("source.load",function(e){var t=o.sourceCaches[e.sourceId].getSource();if(t&&t.vectorLayerIds)for(var r in o._layers){var i=o._layers[r];i.source===t.id&&o._validateLayer(i)}})}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype._validateLayer=function(e){var t=this.sourceCaches[e.source];if(e.sourceLayer&&t){var r=t.getSource();("geojson"===r.type||r.vectorLayerIds&&r.vectorLayerIds.indexOf(e.sourceLayer)===-1)&&this.fire("error",{error:new Error('Source layer "'+e.sourceLayer+'" does not exist on source "'+r.id+'" as specified by style layer "'+e.id+'"')})}},t.prototype.loaded=function(){var e=this;if(!this._loaded)return!1;if(Object.keys(this._updatedSources).length)return!1;for(var t in this.sourceCaches)if(!e.sourceCaches[t].loaded())return!1;return!(this.sprite&&!this.sprite.loaded())},t.prototype._resolve=function(){var e=this,t=deref(this.stylesheet.layers);this._order=t.map(function(e){return e.id}),this._layers={};for(var r=0,i=t;r<i.length;r+=1){var o=i[r];o=StyleLayer.create(o),o.setEventedParent(e,{layer:{id:o.id}}),e._layers[o.id]=o}this.dispatcher.broadcast("setLayers",this._serializeLayers(this._order)),this.light=new Light(this.stylesheet.light)},t.prototype._serializeLayers=function(e){var t=this;return e.map(function(e){return t._layers[e].serialize()})},t.prototype._applyClasses=function(e,t){var r=this;if(this._loaded){e=e||[],t=t||{transition:!0};var i=this.stylesheet.transition||{},o=this._updatedAllPaintProps?this._layers:this._updatedPaintProps;for(var s in o){var a=r._layers[s],n=r._updatedPaintProps[s];if(r._updatedAllPaintProps||n.all)a.updatePaintTransitions(e,t,i,r.animationLoop,r.zoomHistory);else for(var l in n)r._layers[s].updatePaintTransition(l,e,t,i,r.animationLoop,r.zoomHistory)}this.light.updateLightTransitions(t,i,this.animationLoop)}},t.prototype._recalculate=function(e){var t=this;if(this._loaded){for(var r in this.sourceCaches)t.sourceCaches[r].used=!1;this._updateZoomHistory(e);for(var i=0,o=this._order;i<o.length;i+=1){var s=o[i],a=t._layers[s];a.recalculate(e),!a.isHidden(e)&&a.source&&(t.sourceCaches[a.source].used=!0)}this.light.recalculate(e);var n=300;Math.floor(this.z)!==Math.floor(e)&&this.animationLoop.set(n),this.z=e}},t.prototype._updateZoomHistory=function(e){var t=this.zoomHistory;void 0===t.lastIntegerZoom&&(t.lastIntegerZoom=Math.floor(e),t.lastIntegerZoomTime=0,t.lastZoom=e),Math.floor(t.lastZoom)<Math.floor(e)?(t.lastIntegerZoom=Math.floor(e),t.lastIntegerZoomTime=Date.now()):Math.floor(t.lastZoom)>Math.floor(e)&&(t.lastIntegerZoom=Math.floor(e+1),t.lastIntegerZoomTime=Date.now()),t.lastZoom=e},t.prototype._checkLoaded=function(){if(!this._loaded)throw new Error("Style is not done loading")},t.prototype.update=function(e,t){var r=this;if(this._changed){var i=Object.keys(this._updatedLayers),o=Object.keys(this._removedLayers);(i.length||o.length||this._updatedSymbolOrder)&&this._updateWorkerLayers(i,o);for(var s in this._updatedSources){var a=r._updatedSources[s];"reload"===a?r._reloadSource(s):"clear"===a&&r._clearSource(s)}this._applyClasses(e,t),this._resetUpdates(),this.fire("data",{dataType:"style"})}},t.prototype._updateWorkerLayers=function(e,t){var r=this,i=this._updatedSymbolOrder?this._order.filter(function(e){return"symbol"===r._layers[e].type}):null;this.dispatcher.broadcast("updateLayers",{layers:this._serializeLayers(e),removedIds:t,symbolOrder:i})},t.prototype._resetUpdates=function(){this._changed=!1,this._updatedLayers={},this._removedLayers={},this._updatedSymbolOrder=!1,this._updatedSources={},this._updatedPaintProps={},this._updatedAllPaintProps=!1},t.prototype.setState=function(e){var t=this;if(this._checkLoaded(),validateStyle.emitErrors(this,validateStyle(e)))return!1;e=util.extend({},e),e.layers=deref(e.layers);var r=diff(this.serialize(),e).filter(function(e){return!(e.command in ignoredDiffOperations)});if(0===r.length)return!1;var i=r.filter(function(e){return!(e.command in supportedDiffOperations)});if(i.length>0)throw new Error("Unimplemented: "+i.map(function(e){return e.command}).join(", ")+".");return r.forEach(function(e){"setTransition"!==e.command&&t[e.command].apply(t,e.args)}),this.stylesheet=e,!0},t.prototype.addSource=function(e,t,r){if(this._checkLoaded(),void 0!==this.sourceCaches[e])throw new Error("There is already a source with this ID");if(!t.type)throw new Error("The type property must be defined, but the only the following properties were given: "+Object.keys(t)+".");var i=["vector","raster","geojson","video","image","canvas"],o=i.indexOf(t.type)>=0;if(!o||!this._validate(validateStyle.source,"sources."+e,t,null,r)){var s=this.sourceCaches[e]=new SourceCache(e,t,this.dispatcher);s.style=this,s.setEventedParent(this,function(){return{isSourceLoaded:s.loaded(),source:s.serialize(),sourceId:e}}),s.onAdd(this.map),this._changed=!0}},t.prototype.removeSource=function(e){if(this._checkLoaded(),void 0===this.sourceCaches[e])throw new Error("There is no source with this ID");var t=this.sourceCaches[e];delete this.sourceCaches[e],delete this._updatedSources[e],t.setEventedParent(null),t.clearTiles(),t.onRemove&&t.onRemove(this.map),this._changed=!0},t.prototype.getSource=function(e){return this.sourceCaches[e]&&this.sourceCaches[e].getSource()},t.prototype.addLayer=function(e,t,r){this._checkLoaded();var i=e.id;if("object"==typeof e.source&&(this.addSource(i,e.source),e=util.extend(e,{source:i})),!this._validate(validateStyle.layer,"layers."+i,e,{arrayIndex:-1},r)){var o=StyleLayer.create(e);this._validateLayer(o),o.setEventedParent(this,{layer:{id:i}});var s=t?this._order.indexOf(t):this._order.length;if(this._order.splice(s,0,i),this._layers[i]=o,this._removedLayers[i]&&o.source){var a=this._removedLayers[i];delete this._removedLayers[i],this._updatedSources[o.source]=a.type!==o.type?"clear":"reload"}this._updateLayer(o),"symbol"===o.type&&(this._updatedSymbolOrder=!0),this.updateClasses(i)}},t.prototype.moveLayer=function(e,t){this._checkLoaded(),this._changed=!0;var r=this._layers[e];if(!r)return void this.fire("error",{error:new Error("The layer '"+e+"' does not exist in the map's style and cannot be moved.")});var i=this._order.indexOf(e);this._order.splice(i,1);var o=t?this._order.indexOf(t):this._order.length;this._order.splice(o,0,e),"symbol"===r.type&&(this._updatedSymbolOrder=!0,r.source&&!this._updatedSources[r.source]&&(this._updatedSources[r.source]="reload"))},t.prototype.removeLayer=function(e){this._checkLoaded();var t=this._layers[e];if(!t)return void this.fire("error",{error:new Error("The layer '"+e+"' does not exist in the map's style and cannot be removed.")});t.setEventedParent(null);var r=this._order.indexOf(e);this._order.splice(r,1),"symbol"===t.type&&(this._updatedSymbolOrder=!0),this._changed=!0,this._removedLayers[e]=t,delete this._layers[e],delete this._updatedLayers[e],delete this._updatedPaintProps[e]},t.prototype.getLayer=function(e){return this._layers[e]},t.prototype.setLayerZoomRange=function(e,t,r){this._checkLoaded();var i=this.getLayer(e);return i?void(i.minzoom===t&&i.maxzoom===r||(null!=t&&(i.minzoom=t),null!=r&&(i.maxzoom=r),this._updateLayer(i))):void this.fire("error",{error:new Error("The layer '"+e+"' does not exist in the map's style and cannot have zoom extent.")})},t.prototype.setFilter=function(e,t){this._checkLoaded();var r=this.getLayer(e);return r?void(null!==t&&void 0!==t&&this._validate(validateStyle.filter,"layers."+r.id+".filter",t)||util.deepEqual(r.filter,t)||(r.filter=util.clone(t),this._updateLayer(r))):void this.fire("error",{error:new Error("The layer '"+e+"' does not exist in the map's style and cannot be filtered.")})},t.prototype.getFilter=function(e){return util.clone(this.getLayer(e).filter)},t.prototype.setLayoutProperty=function(e,t,r){this._checkLoaded();var i=this.getLayer(e);return i?void(util.deepEqual(i.getLayoutProperty(t),r)||(i.setLayoutProperty(t,r),this._updateLayer(i))):void this.fire("error",{error:new Error("The layer '"+e+"' does not exist in the map's style and cannot be styled.")})},t.prototype.getLayoutProperty=function(e,t){return this.getLayer(e).getLayoutProperty(t)},t.prototype.setPaintProperty=function(e,t,r,i){this._checkLoaded();var o=this.getLayer(e);if(!o)return void this.fire("error",{error:new Error("The layer '"+e+"' does not exist in the map's style and cannot be styled.")});if(!util.deepEqual(o.getPaintProperty(t,i),r)){var s=o.isPaintValueFeatureConstant(t);o.setPaintProperty(t,r,i);var a=!(r&&MapboxGLFunction.isFunctionDefinition(r)&&"$zoom"!==r.property&&void 0!==r.property);a&&s||this._updateLayer(o),this.updateClasses(e,t)}},t.prototype.getPaintProperty=function(e,t,r){return this.getLayer(e).getPaintProperty(t,r)},t.prototype.getTransition=function(){return util.extend({duration:300,delay:0},this.stylesheet&&this.stylesheet.transition)},t.prototype.updateClasses=function(e,t){if(this._changed=!0,e){var r=this._updatedPaintProps;r[e]||(r[e]={}),r[e][t||"all"]=!0}else this._updatedAllPaintProps=!0},t.prototype.serialize=function(){var e=this;return util.filterObject({version:this.stylesheet.version,name:this.stylesheet.name,metadata:this.stylesheet.metadata,light:this.stylesheet.light,center:this.stylesheet.center,zoom:this.stylesheet.zoom,bearing:this.stylesheet.bearing,pitch:this.stylesheet.pitch,sprite:this.stylesheet.sprite,glyphs:this.stylesheet.glyphs,transition:this.stylesheet.transition,sources:util.mapObject(this.sourceCaches,function(e){return e.serialize()}),layers:this._order.map(function(t){return e._layers[t].serialize()})},function(e){return void 0!==e})},t.prototype._updateLayer=function(e){this._updatedLayers[e.id]=!0,e.source&&!this._updatedSources[e.source]&&(this._updatedSources[e.source]="reload"),this._changed=!0},t.prototype._flattenRenderedFeatures=function(e){for(var t=this,r=[],i=this._order.length-1;i>=0;i--)for(var o=t._order[i],s=0,a=e;s<a.length;s+=1){var n=a[s],l=n[o];if(l)for(var d=0,h=l;d<h.length;d+=1){var u=h[d];r.push(u)}}return r},t.prototype.queryRenderedFeatures=function(e,t,r,i){var o=this;t&&t.filter&&this._validate(validateStyle.filter,"queryRenderedFeatures.filter",t.filter);var s={};if(t&&t.layers)for(var a=0,n=t.layers;a<n.length;a+=1){var l=n[a],d=o._layers[l];if(!d)return void o.fire("error",{error:"The layer '"+l+"' does not exist in the map's style and cannot be queried for features."});s[d.source]=!0}var h=[];for(var u in this.sourceCaches)if(!t.layers||s[u]){var c=QueryFeatures.rendered(o.sourceCaches[u],o._layers,e,t,r,i);h.push(c)}return this._flattenRenderedFeatures(h)},t.prototype.querySourceFeatures=function(e,t){t&&t.filter&&this._validate(validateStyle.filter,"querySourceFeatures.filter",t.filter);var r=this.sourceCaches[e];return r?QueryFeatures.source(r,t):[]},t.prototype.addSourceType=function(e,t,r){return Source.getType(e)?r(new Error('A source type called "'+e+'" already exists.')):(Source.setType(e,t),t.workerSourceURL?void this.dispatcher.broadcast("loadWorkerSource",{name:e,url:t.workerSourceURL},r):r(null,null))},t.prototype.getLight=function(){return this.light.getLight()},t.prototype.setLight=function(e,t){this._checkLoaded();var r=this.light.getLight(),i=!1;for(var o in e)if(!util.deepEqual(e[o],r[o])){i=!0;break}if(i){var s=this.stylesheet.transition||{};this.light.setLight(e),this.light.updateLightTransitions(t||{transition:!0},s,this.animationLoop)}},t.prototype._validate=function(e,t,r,i,o){return(!o||o.validate!==!1)&&validateStyle.emitErrors(this,e.call(validateStyle,util.extend({key:t,style:this.serialize(),value:r,styleSpec:styleSpec},i)))},t.prototype._remove=function(){var e=this;for(var t in this.sourceCaches)e.sourceCaches[t].clearTiles();this.dispatcher.remove()},t.prototype._clearSource=function(e){this.sourceCaches[e].clearTiles()},t.prototype._reloadSource=function(e){this.sourceCaches[e].reload()},t.prototype._updateSources=function(e){var t=this;for(var r in this.sourceCaches)t.sourceCaches[r].update(e)},t.prototype._redoPlacement=function(){var e=this;for(var t in this.sourceCaches)e.sourceCaches[t].redoPlacement()},t.prototype.getIcons=function(e,t,r){var i=this,o=function(){i.spriteAtlas.setSprite(i.sprite),i.spriteAtlas.addIcons(t.icons,r)};this.sprite.loaded()?o():this.sprite.on("data",o)},t.prototype.getGlyphs=function(e,t,r){function i(e,t,i){e&&console.error(e),n[i]=t,a--,0===a&&r(null,n)}var o=this,s=t.stacks,a=Object.keys(s).length,n={};for(var l in s)o.glyphSource.getSimpleGlyphs(l,s[l],t.uid,i)},t}(Evented);module.exports=Style;
},{"../global_worker_pool":22,"../render/line_atlas":35,"../source/query_features":47,"../source/rtl_text_plugin":49,"../source/source":50,"../source/source_cache":51,"../symbol/glyph_source":83,"../symbol/sprite_atlas":88,"../util/ajax":109,"../util/browser":110,"../util/dispatcher":116,"../util/evented":118,"../util/mapbox":125,"../util/util":129,"./animation_loop":59,"./image_sprite":60,"./light":61,"./style_layer":65,"./style_spec":72,"./validate_style":74,"mapbox-gl-function":164,"mapbox-gl-style-spec/lib/deref":165,"mapbox-gl-style-spec/lib/diff":166}],64:[function(require,module,exports){
"use strict";var MapboxGLFunction=require("mapbox-gl-function"),parseColor=require("./parse_color"),util=require("../util/util"),StyleDeclaration=function(t,o){var i=this;this.value=util.clone(o),this.isFunction=MapboxGLFunction.isFunctionDefinition(o),this.json=JSON.stringify(this.value),this.minimum=t.minimum,this.isColor="color"===t.type;var n=this.isColor&&this.value?parseColor(this.value):o,s=t.default;if(s&&"color"===t.type&&(s=parseColor(s)),this.function=MapboxGLFunction[t.function||"piecewise-constant"](n,s),this.isFeatureConstant=this.function.isFeatureConstant,this.isZoomConstant=this.function.isZoomConstant,!this.isFeatureConstant&&!this.isZoomConstant){this.stopZoomLevels=[];for(var e=[],a=0,r=this.value.stops;a<r.length;a+=1){var l=r[a],u=l[0].zoom;i.stopZoomLevels.indexOf(u)<0&&(i.stopZoomLevels.push(u),e.push([u,e.length]))}this.functionInterpolationT=MapboxGLFunction.interpolated({stops:e,base:o.base,colorSpace:o.colorSpace})}};StyleDeclaration.prototype.calculate=function(t,o){var i=this.function(t&&t.zoom,o||{});return this.isColor&&i?parseColor(i):void 0!==this.minimum&&i<this.minimum?this.minimum:i},StyleDeclaration.prototype.calculateInterpolationT=function(t,o){return this.functionInterpolationT(t&&t.zoom,o||{})},module.exports=StyleDeclaration;
},{"../util/util":129,"./parse_color":62,"mapbox-gl-function":164}],65:[function(require,module,exports){
"use strict";function getDeclarationValue(t){return t.value}var util=require("../util/util"),StyleTransition=require("./style_transition"),StyleDeclaration=require("./style_declaration"),styleSpec=require("./style_spec"),validateStyle=require("./validate_style"),parseColor=require("./parse_color"),Evented=require("../util/evented"),TRANSITION_SUFFIX="-transition",StyleLayer=function(t){function i(i){var a=this;t.call(this),this.id=i.id,this.metadata=i.metadata,this.type=i.type,this.source=i.source,this.sourceLayer=i["source-layer"],this.minzoom=i.minzoom,this.maxzoom=i.maxzoom,this.filter=i.filter,this.paint={},this.layout={},this._paintSpecifications=styleSpec["paint_"+this.type],this._layoutSpecifications=styleSpec["layout_"+this.type],this._paintTransitions={},this._paintTransitionOptions={},this._paintDeclarations={},this._layoutDeclarations={},this._layoutFunctions={};var e,n,o={validate:!1};for(var r in i){var s=r.match(/^paint(?:\.(.*))?$/);if(s){var l=s[1]||"";for(e in i[r])a.setPaintProperty(e,i[r][e],l,o)}}for(n in i.layout)a.setLayoutProperty(n,i.layout[n],o);for(e in this._paintSpecifications)a.paint[e]=a.getPaintValue(e);for(n in this._layoutSpecifications)a._updateLayoutValue(n)}return t&&(i.__proto__=t),i.prototype=Object.create(t&&t.prototype),i.prototype.constructor=i,i.prototype.setLayoutProperty=function(t,i,a){if(null==i)delete this._layoutDeclarations[t];else{var e="layers."+this.id+".layout."+t;if(this._validate(validateStyle.layoutProperty,e,t,i,a))return;this._layoutDeclarations[t]=new StyleDeclaration(this._layoutSpecifications[t],i)}this._updateLayoutValue(t)},i.prototype.getLayoutProperty=function(t){return this._layoutDeclarations[t]&&this._layoutDeclarations[t].value},i.prototype.getLayoutValue=function(t,i,a){var e=this._layoutSpecifications[t],n=this._layoutDeclarations[t];return n?n.calculate(i,a):e.default},i.prototype.setPaintProperty=function(t,i,a,e){var n="layers."+this.id+(a?'["paint.'+a+'"].':".paint.")+t;if(util.endsWith(t,TRANSITION_SUFFIX))if(this._paintTransitionOptions[a||""]||(this._paintTransitionOptions[a||""]={}),null===i||void 0===i)delete this._paintTransitionOptions[a||""][t];else{if(this._validate(validateStyle.paintProperty,n,t,i,e))return;this._paintTransitionOptions[a||""][t]=i}else if(this._paintDeclarations[a||""]||(this._paintDeclarations[a||""]={}),null===i||void 0===i)delete this._paintDeclarations[a||""][t];else{if(this._validate(validateStyle.paintProperty,n,t,i,e))return;this._paintDeclarations[a||""][t]=new StyleDeclaration(this._paintSpecifications[t],i)}},i.prototype.getPaintProperty=function(t,i){return i=i||"",util.endsWith(t,TRANSITION_SUFFIX)?this._paintTransitionOptions[i]&&this._paintTransitionOptions[i][t]:this._paintDeclarations[i]&&this._paintDeclarations[i][t]&&this._paintDeclarations[i][t].value},i.prototype.getPaintValue=function(t,i,a){var e=this._paintSpecifications[t],n=this._paintTransitions[t];return n?n.calculate(i,a):"color"===e.type&&e.default?parseColor(e.default):e.default},i.prototype.getPaintValueStopZoomLevels=function(t){var i=this._paintTransitions[t];return i?i.declaration.stopZoomLevels:[]},i.prototype.getPaintInterpolationT=function(t,i){var a=this._paintTransitions[t];return a.declaration.calculateInterpolationT(i)},i.prototype.isPaintValueFeatureConstant=function(t){var i=this._paintTransitions[t];return!i||i.declaration.isFeatureConstant},i.prototype.isLayoutValueFeatureConstant=function(t){var i=this._layoutDeclarations[t];return!i||i.isFeatureConstant},i.prototype.isPaintValueZoomConstant=function(t){var i=this._paintTransitions[t];return!i||i.declaration.isZoomConstant},i.prototype.isHidden=function(t){return!!(this.minzoom&&t<this.minzoom)||(!!(this.maxzoom&&t>=this.maxzoom)||"none"===this.layout.visibility)},i.prototype.updatePaintTransitions=function(t,i,a,e,n){for(var o=this,r=util.extend({},this._paintDeclarations[""]),s=0;s<t.length;s++)util.extend(r,o._paintDeclarations[t[s]]);var l;for(l in r)o._applyPaintDeclaration(l,r[l],i,a,e,n);for(l in this._paintTransitions)l in r||o._applyPaintDeclaration(l,null,i,a,e,n)},i.prototype.updatePaintTransition=function(t,i,a,e,n,o){for(var r=this,s=this._paintDeclarations[""][t],l=0;l<i.length;l++){var u=r._paintDeclarations[i[l]];u&&u[t]&&(s=u[t])}this._applyPaintDeclaration(t,s,a,e,n,o)},i.prototype.recalculate=function(t){var i=this;for(var a in this._paintTransitions)i.paint[a]=i.getPaintValue(a,{zoom:t});for(var e in this._layoutFunctions)i.layout[e]=i.getLayoutValue(e,{zoom:t})},i.prototype.serialize=function(){var t=this,i={id:this.id,type:this.type,source:this.source,"source-layer":this.sourceLayer,metadata:this.metadata,minzoom:this.minzoom,maxzoom:this.maxzoom,filter:this.filter,layout:util.mapObject(this._layoutDeclarations,getDeclarationValue)};for(var a in this._paintDeclarations){var e=""===a?"paint":"paint."+a;i[e]=util.mapObject(t._paintDeclarations[a],getDeclarationValue)}return util.filterObject(i,function(t,i){return void 0!==t&&!("layout"===i&&!Object.keys(t).length)})},i.prototype._applyPaintDeclaration=function(t,i,a,e,n,o){var r=a.transition?this._paintTransitions[t]:void 0,s=this._paintSpecifications[t];if(null!==i&&void 0!==i||(i=new StyleDeclaration(s,s.default)),!r||r.declaration.json!==i.json){var l=util.extend({duration:300,delay:0},e,this.getPaintProperty(t+TRANSITION_SUFFIX)),u=this._paintTransitions[t]=new StyleTransition(s,i,r,l,o);u.instant()||(u.loopID=n.set(u.endTime-Date.now())),r&&n.cancel(r.loopID)}},i.prototype._updateLayoutValue=function(t){var i=this._layoutDeclarations[t];i&&i.isFunction?this._layoutFunctions[t]=!0:(delete this._layoutFunctions[t],this.layout[t]=this.getLayoutValue(t))},i.prototype._validate=function(t,i,a,e,n){return(!n||n.validate!==!1)&&validateStyle.emitErrors(this,t.call(validateStyle,{key:i,layerType:this.type,objectKey:a,value:e,styleSpec:styleSpec,style:{glyphs:!0,sprite:!0}}))},i}(Evented);module.exports=StyleLayer;var subclasses={circle:require("./style_layer/circle_style_layer"),fill:require("./style_layer/fill_style_layer"),"fill-extrusion":require("./style_layer/fill_extrusion_style_layer"),line:require("./style_layer/line_style_layer"),symbol:require("./style_layer/symbol_style_layer")};StyleLayer.create=function(t){var i=subclasses[t.type]||StyleLayer;return new i(t)};
},{"../util/evented":118,"../util/util":129,"./parse_color":62,"./style_declaration":64,"./style_layer/circle_style_layer":66,"./style_layer/fill_extrusion_style_layer":67,"./style_layer/fill_style_layer":68,"./style_layer/line_style_layer":69,"./style_layer/symbol_style_layer":70,"./style_spec":72,"./style_transition":73,"./validate_style":74}],66:[function(require,module,exports){
"use strict";var StyleLayer=require("../style_layer"),CircleBucket=require("../../data/bucket/circle_bucket"),CircleStyleLayer=function(e){function t(){e.apply(this,arguments)}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.createBucket=function(e){return new CircleBucket(e)},t}(StyleLayer);module.exports=CircleStyleLayer;
},{"../../data/bucket/circle_bucket":3,"../style_layer":65}],67:[function(require,module,exports){
"use strict";var StyleLayer=require("../style_layer"),FillExtrusionBucket=require("../../data/bucket/fill_extrusion_bucket"),FillExtrusionStyleLayer=function(t){function e(){t.apply(this,arguments)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getPaintValue=function(e,r,o){var l=t.prototype.getPaintValue.call(this,e,r,o);return"fill-extrusion-color"===e&&l&&(l[3]=1),l},e.prototype.createBucket=function(t){return new FillExtrusionBucket(t)},e}(StyleLayer);module.exports=FillExtrusionStyleLayer;
},{"../../data/bucket/fill_extrusion_bucket":5,"../style_layer":65}],68:[function(require,module,exports){
"use strict";var StyleLayer=require("../style_layer"),FillBucket=require("../../data/bucket/fill_bucket"),FillStyleLayer=function(t){function o(){t.apply(this,arguments)}return t&&(o.__proto__=t),o.prototype=Object.create(t&&t.prototype),o.prototype.constructor=o,o.prototype.getPaintValue=function(o,l,e){var i=this;if("fill-outline-color"===o){if(void 0===this.getPaintProperty("fill-outline-color"))return t.prototype.getPaintValue.call(this,"fill-color",l,e);for(var r=this._paintTransitions["fill-outline-color"];r;){var n=r&&r.declaration&&r.declaration.value;if(!n)return t.prototype.getPaintValue.call(i,"fill-color",l,e);r=r.oldTransition}}return t.prototype.getPaintValue.call(this,o,l,e)},o.prototype.getPaintValueStopZoomLevels=function(o){return"fill-outline-color"===o&&void 0===this.getPaintProperty("fill-outline-color")?t.prototype.getPaintValueStopZoomLevels.call(this,"fill-color"):t.prototype.getPaintValueStopZoomLevels.call(this,o)},o.prototype.getPaintInterpolationT=function(o,l){return"fill-outline-color"===o&&void 0===this.getPaintProperty("fill-outline-color")?t.prototype.getPaintInterpolationT.call(this,"fill-color",l):t.prototype.getPaintInterpolationT.call(this,o,l)},o.prototype.isPaintValueFeatureConstant=function(o){return"fill-outline-color"===o&&void 0===this.getPaintProperty("fill-outline-color")?t.prototype.isPaintValueFeatureConstant.call(this,"fill-color"):t.prototype.isPaintValueFeatureConstant.call(this,o)},o.prototype.isPaintValueZoomConstant=function(o){return"fill-outline-color"===o&&void 0===this.getPaintProperty("fill-outline-color")?t.prototype.isPaintValueZoomConstant.call(this,"fill-color"):t.prototype.isPaintValueZoomConstant.call(this,o)},o.prototype.createBucket=function(t){return new FillBucket(t)},o}(StyleLayer);module.exports=FillStyleLayer;
},{"../../data/bucket/fill_bucket":4,"../style_layer":65}],69:[function(require,module,exports){
"use strict";var StyleLayer=require("../style_layer"),LineBucket=require("../../data/bucket/line_bucket"),util=require("../../util/util"),LineStyleLayer=function(e){function t(){e.apply(this,arguments)}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.getPaintValue=function(t,r,o){var i=e.prototype.getPaintValue.call(this,t,r,o);if(i&&"line-dasharray"===t){var a=this.getPaintValue("line-width",util.extend({},r,{zoom:Math.floor(r.zoom)}),o);i.fromScale*=a,i.toScale*=a}return i},t.prototype.createBucket=function(e){return new LineBucket(e)},t}(StyleLayer);module.exports=LineStyleLayer;
},{"../../data/bucket/line_bucket":6,"../../util/util":129,"../style_layer":65}],70:[function(require,module,exports){
"use strict";var StyleLayer=require("../style_layer"),SymbolBucket=require("../../data/bucket/symbol_bucket"),SymbolStyleLayer=function(t){function e(){t.apply(this,arguments)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e.prototype.getLayoutValue=function(e,o,r){var a=t.prototype.getLayoutValue.call(this,e,o,r);if("auto"!==a)return a;switch(e){case"text-rotation-alignment":case"icon-rotation-alignment":return"line"===this.getLayoutValue("symbol-placement",o,r)?"map":"viewport";case"text-pitch-alignment":return this.getLayoutValue("text-rotation-alignment",o,r);default:return a}},e.prototype.createBucket=function(t){return new SymbolBucket(t)},e}(StyleLayer);module.exports=SymbolStyleLayer;
},{"../../data/bucket/symbol_bucket":7,"../style_layer":65}],71:[function(require,module,exports){
"use strict";var StyleLayer=require("./style_layer"),util=require("../util/util"),featureFilter=require("feature-filter"),groupByLayout=require("mapbox-gl-style-spec/lib/group_by_layout"),StyleLayerIndex=function(e){e&&this.replace(e)};StyleLayerIndex.prototype.replace=function(e){var r=this;this.symbolOrder=[];for(var t=0,i=e;t<i.length;t+=1){var a=i[t];"symbol"===a.type&&r.symbolOrder.push(a.id)}this._layerConfigs={},this._layers={},this.update(e,[])},StyleLayerIndex.prototype.update=function(e,r,t){for(var i=this,a=0,l=e;a<l.length;a+=1){var y=l[a];i._layerConfigs[y.id]=y;var o=i._layers[y.id]=StyleLayer.create(y);o.updatePaintTransitions({},{transition:!1}),o.filter=featureFilter(o.filter)}for(var s=0,u=r;s<u.length;s+=1){var n=u[s];delete i._layerConfigs[n],delete i._layers[n]}t&&(this.symbolOrder=t),this.familiesBySource={};for(var f=groupByLayout(util.values(this._layerConfigs)),p=0,d=f;p<d.length;p+=1){var h=d[p],v=h.map(function(e){return i._layers[e.id]}),c=v[0];if(!c.layout||"none"!==c.layout.visibility){var g=c.source||"",_=i.familiesBySource[g];_||(_=i.familiesBySource[g]={});var m=c.sourceLayer||"_geojsonTileLayer",L=_[m];L||(L=_[m]=[]),L.push(v)}}},module.exports=StyleLayerIndex;
},{"../util/util":129,"./style_layer":65,"feature-filter":138,"mapbox-gl-style-spec/lib/group_by_layout":168}],72:[function(require,module,exports){
"use strict";module.exports=require("mapbox-gl-style-spec/reference/latest.min");
},{"mapbox-gl-style-spec/reference/latest.min":191}],73:[function(require,module,exports){
"use strict";function interpZoomTransitioned(t,i,o){if(void 0!==t&&void 0!==i)return{from:t.to,fromScale:t.toScale,to:i.to,toScale:i.toScale,t:o}}var util=require("../util/util"),interpolate=require("../util/interpolate"),fakeZoomHistory={lastIntegerZoom:0,lastIntegerZoomTime:0,lastZoom:0},StyleTransition=function(t,i,o,e,a){this.declaration=i,this.startTime=this.endTime=(new Date).getTime(),this.oldTransition=o,this.duration=e.duration||0,this.delay=e.delay||0,this.zoomTransitioned="piecewise-constant"===t.function&&t.transition,this.interp=this.zoomTransitioned?interpZoomTransitioned:interpolate[t.type],this.zoomHistory=a||fakeZoomHistory,this.instant()||(this.endTime=this.startTime+this.duration+this.delay),o&&o.endTime<=this.startTime&&delete o.oldTransition};StyleTransition.prototype.instant=function(){return!this.oldTransition||!this.interp||0===this.duration&&0===this.delay},StyleTransition.prototype.calculate=function(t,i,o){var e=this._calculateTargetValue(t,i);if(this.instant())return e;if(o=o||Date.now(),o>=this.endTime)return e;var a=this.oldTransition.calculate(t,i,this.startTime),n=util.easeCubicInOut((o-this.startTime-this.delay)/this.duration);return this.interp(a,e,n)},StyleTransition.prototype._calculateTargetValue=function(t,i){if(!this.zoomTransitioned)return this.declaration.calculate(t,i);var o=t.zoom,e=this.zoomHistory.lastIntegerZoom,a=o>e?2:.5,n=this.declaration.calculate({zoom:o>e?o-1:o+1},i),r=this.declaration.calculate({zoom:o},i),s=Math.min((Date.now()-this.zoomHistory.lastIntegerZoomTime)/this.duration,1),l=Math.abs(o-e),u=interpolate(s,1,l);return void 0!==n&&void 0!==r?{from:n,fromScale:a,to:r,toScale:1,t:u}:void 0},module.exports=StyleTransition;
},{"../util/interpolate":121,"../util/util":129}],74:[function(require,module,exports){
"use strict";module.exports=require("mapbox-gl-style-spec/lib/validate_style.min"),module.exports.emitErrors=function(r,e){if(e&&e.length){for(var t=0;t<e.length;t++)r.fire("error",{error:new Error(e[t].message)});return!0}return!1};
},{"mapbox-gl-style-spec/lib/validate_style.min":190}],75:[function(require,module,exports){
"use strict";var Point=require("point-geometry"),Anchor=function(t){function o(o,e,n,r){t.call(this,o,e),this.angle=n,void 0!==r&&(this.segment=r)}return t&&(o.__proto__=t),o.prototype=Object.create(t&&t.prototype),o.prototype.constructor=o,o.prototype.clone=function(){return new o(this.x,this.y,this.angle,this.segment)},o}(Point);module.exports=Anchor;
},{"point-geometry":197}],76:[function(require,module,exports){
"use strict";function checkMaxAngle(e,t,a,r,n){if(void 0===t.segment)return!0;for(var i=t,s=t.segment+1,f=0;f>-a/2;){if(s--,s<0)return!1;f-=e[s].dist(i),i=e[s]}f+=e[s].dist(e[s+1]),s++;for(var l=[],o=0;f<a/2;){var u=e[s-1],c=e[s],g=e[s+1];if(!g)return!1;var h=u.angleTo(c)-c.angleTo(g);for(h=Math.abs((h+3*Math.PI)%(2*Math.PI)-Math.PI),l.push({distance:f,angleDelta:h}),o+=h;f-l[0].distance>r;)o-=l.shift().angleDelta;if(o>n)return!1;s++,f+=c.dist(g)}return!0}module.exports=checkMaxAngle;
},{}],77:[function(require,module,exports){
"use strict";function clipLine(n,x,y,o,e){for(var r=[],t=0;t<n.length;t++)for(var i,u=n[t],d=0;d<u.length-1;d++){var P=u[d],w=u[d+1];P.x<x&&w.x<x||(P.x<x?P=new Point(x,P.y+(w.y-P.y)*((x-P.x)/(w.x-P.x)))._round():w.x<x&&(w=new Point(x,P.y+(w.y-P.y)*((x-P.x)/(w.x-P.x)))._round()),P.y<y&&w.y<y||(P.y<y?P=new Point(P.x+(w.x-P.x)*((y-P.y)/(w.y-P.y)),y)._round():w.y<y&&(w=new Point(P.x+(w.x-P.x)*((y-P.y)/(w.y-P.y)),y)._round()),P.x>=o&&w.x>=o||(P.x>=o?P=new Point(o,P.y+(w.y-P.y)*((o-P.x)/(w.x-P.x)))._round():w.x>=o&&(w=new Point(o,P.y+(w.y-P.y)*((o-P.x)/(w.x-P.x)))._round()),P.y>=e&&w.y>=e||(P.y>=e?P=new Point(P.x+(w.x-P.x)*((e-P.y)/(w.y-P.y)),e)._round():w.y>=e&&(w=new Point(P.x+(w.x-P.x)*((e-P.y)/(w.y-P.y)),e)._round()),i&&P.equals(i[i.length-1])||(i=[P],r.push(i)),i.push(w)))))}return r}var Point=require("point-geometry");module.exports=clipLine;
},{"point-geometry":197}],78:[function(require,module,exports){
"use strict";var createStructArrayType=require("../util/struct_array"),Point=require("point-geometry"),CollisionBoxArray=createStructArrayType({members:[{type:"Int16",name:"anchorPointX"},{type:"Int16",name:"anchorPointY"},{type:"Int16",name:"x1"},{type:"Int16",name:"y1"},{type:"Int16",name:"x2"},{type:"Int16",name:"y2"},{type:"Float32",name:"maxScale"},{type:"Uint32",name:"featureIndex"},{type:"Uint16",name:"sourceLayerIndex"},{type:"Uint16",name:"bucketIndex"},{type:"Int16",name:"bbox0"},{type:"Int16",name:"bbox1"},{type:"Int16",name:"bbox2"},{type:"Int16",name:"bbox3"},{type:"Float32",name:"placementScale"}]});Object.defineProperty(CollisionBoxArray.prototype.StructType.prototype,"anchorPoint",{get:function(){return new Point(this.anchorPointX,this.anchorPointY)}}),module.exports=CollisionBoxArray;
},{"../util/struct_array":127,"point-geometry":197}],79:[function(require,module,exports){
"use strict";var CollisionFeature=function(t,e,i,o,s,a,n,r,l,d,u){var h=n.top*r-l,x=n.bottom*r+l,f=n.left*r-l,m=n.right*r+l;if(this.boxStartIndex=t.length,d){var _=x-h,b=m-f;if(_>0)if(_=Math.max(10*r,_),u){var v=e[i.segment+1].sub(e[i.segment])._unit()._mult(b),c=[i.sub(v),i.add(v)];this._addLineCollisionBoxes(t,c,i,0,b,_,o,s,a)}else this._addLineCollisionBoxes(t,e,i,i.segment,b,_,o,s,a)}else t.emplaceBack(i.x,i.y,f,h,m,x,1/0,o,s,a,0,0,0,0,0);this.boxEndIndex=t.length};CollisionFeature.prototype._addLineCollisionBoxes=function(t,e,i,o,s,a,n,r,l){var d=a/2,u=Math.floor(s/d),h=-a/2,x=this.boxes,f=i,m=o+1,_=h;do{if(m--,m<0)return x;_-=e[m].dist(f),f=e[m]}while(_>-s/2);for(var b=e[m].dist(e[m+1]),v=0;v<u;v++){for(var c=-s/2+v*d;_+b<c;){if(_+=b,m++,m+1>=e.length)return x;b=e[m].dist(e[m+1])}var g=c-_,p=e[m],C=e[m+1],B=C.sub(p)._unit()._mult(g)._add(p)._round(),M=Math.max(Math.abs(c-h)-d/2,0),y=s/2/M;t.emplaceBack(B.x,B.y,-a/2,-a/2,a/2,a/2,y,n,r,l,0,0,0,0,0)}return x},module.exports=CollisionFeature;
},{}],80:[function(require,module,exports){
"use strict";var Point=require("point-geometry"),EXTENT=require("../data/extent"),Grid=require("grid-index"),intersectionTests=require("../util/intersection_tests"),CollisionTile=function(t,e,i){if("object"==typeof t){var r=t;i=e,t=r.angle,e=r.pitch,this.grid=new Grid(r.grid),this.ignoredGrid=new Grid(r.ignoredGrid)}else this.grid=new Grid(EXTENT,12,6),this.ignoredGrid=new Grid(EXTENT,12,0);this.minScale=.5,this.maxScale=2,this.angle=t,this.pitch=e;var a=Math.sin(t),o=Math.cos(t);if(this.rotationMatrix=[o,-a,a,o],this.reverseRotationMatrix=[o,a,-a,o],this.yStretch=1/Math.cos(e/180*Math.PI),this.yStretch=Math.pow(this.yStretch,1.3),this.collisionBoxArray=i,0===i.length){i.emplaceBack();var n=32767;i.emplaceBack(0,0,0,-n,0,n,n,0,0,0,0,0,0,0,0,0),i.emplaceBack(EXTENT,0,0,-n,0,n,n,0,0,0,0,0,0,0,0,0),i.emplaceBack(0,0,-n,0,n,0,n,0,0,0,0,0,0,0,0,0),i.emplaceBack(0,EXTENT,-n,0,n,0,n,0,0,0,0,0,0,0,0,0)}this.tempCollisionBox=i.get(0),this.edges=[i.get(1),i.get(2),i.get(3),i.get(4)]};CollisionTile.prototype.serialize=function(t){var e=this.grid.toArrayBuffer(),i=this.ignoredGrid.toArrayBuffer();return t&&(t.push(e),t.push(i)),{angle:this.angle,pitch:this.pitch,grid:e,ignoredGrid:i}},CollisionTile.prototype.placeCollisionFeature=function(t,e,i){for(var r=this,a=this.collisionBoxArray,o=this.minScale,n=this.rotationMatrix,l=this.yStretch,h=t.boxStartIndex;h<t.boxEndIndex;h++){var s=a.get(h),x=s.anchorPoint._matMult(n),c=x.x,g=x.y,y=c+s.x1,d=g+s.y1*l,m=c+s.x2,u=g+s.y2*l;if(s.bbox0=y,s.bbox1=d,s.bbox2=m,s.bbox3=u,!e)for(var p=r.grid.query(y,d,m,u),M=0;M<p.length;M++){var f=a.get(p[M]),v=f.anchorPoint._matMult(n);if(o=r.getPlacementScale(o,x,s,v,f),o>=r.maxScale)return o}if(i){var S;if(r.angle){var P=r.reverseRotationMatrix,b=new Point(s.x1,s.y1).matMult(P),T=new Point(s.x2,s.y1).matMult(P),w=new Point(s.x1,s.y2).matMult(P),N=new Point(s.x2,s.y2).matMult(P);S=r.tempCollisionBox,S.anchorPointX=s.anchorPoint.x,S.anchorPointY=s.anchorPoint.y,S.x1=Math.min(b.x,T.x,w.x,N.x),S.y1=Math.min(b.y,T.x,w.x,N.x),S.x2=Math.max(b.x,T.x,w.x,N.x),S.y2=Math.max(b.y,T.x,w.x,N.x),S.maxScale=s.maxScale}else S=s;for(var B=0;B<this.edges.length;B++){var G=r.edges[B];if(o=r.getPlacementScale(o,s.anchorPoint,S,G.anchorPoint,G),o>=r.maxScale)return o}}}return o},CollisionTile.prototype.queryRenderedSymbols=function(t,e){var i={},r=[];if(0===t.length||0===this.grid.length&&0===this.ignoredGrid.length)return r;for(var a=this.collisionBoxArray,o=this.rotationMatrix,n=this.yStretch,l=[],h=1/0,s=1/0,x=-(1/0),c=-(1/0),g=0;g<t.length;g++)for(var y=t[g],d=0;d<y.length;d++){var m=y[d].matMult(o);h=Math.min(h,m.x),s=Math.min(s,m.y),x=Math.max(x,m.x),c=Math.max(c,m.y),l.push(m)}for(var u=this.grid.query(h,s,x,c),p=this.ignoredGrid.query(h,s,x,c),M=0;M<p.length;M++)u.push(p[M]);for(var f=Math.pow(2,Math.ceil(Math.log(e)/Math.LN2*10)/10),v=0;v<u.length;v++){var S=a.get(u[v]),P=S.sourceLayerIndex,b=S.featureIndex;if(void 0===i[P]&&(i[P]={}),!i[P][b]&&!(f<S.placementScale||f>S.maxScale)){var T=S.anchorPoint.matMult(o),w=T.x+S.x1/e,N=T.y+S.y1/e*n,B=T.x+S.x2/e,G=T.y+S.y2/e*n,E=[new Point(w,N),new Point(B,N),new Point(B,G),new Point(w,G)];intersectionTests.polygonIntersectsPolygon(l,E)&&(i[P][b]=!0,r.push(u[v]))}}return r},CollisionTile.prototype.getPlacementScale=function(t,e,i,r,a){var o=e.x-r.x,n=e.y-r.y,l=(a.x1-i.x2)/o,h=(a.x2-i.x1)/o,s=(a.y1-i.y2)*this.yStretch/n,x=(a.y2-i.y1)*this.yStretch/n;(isNaN(l)||isNaN(h))&&(l=h=1),(isNaN(s)||isNaN(x))&&(s=x=1);var c=Math.min(Math.max(l,h),Math.max(s,x)),g=a.maxScale,y=i.maxScale;return c>g&&(c=g),c>y&&(c=y),c>t&&c>=a.placementScale&&(t=c),t},CollisionTile.prototype.insertCollisionFeature=function(t,e,i){for(var r=this,a=i?this.ignoredGrid:this.grid,o=this.collisionBoxArray,n=t.boxStartIndex;n<t.boxEndIndex;n++){var l=o.get(n);l.placementScale=e,e<r.maxScale&&a.insert(n,l.bbox0,l.bbox1,l.bbox2,l.bbox3)}},module.exports=CollisionTile;
},{"../data/extent":11,"../util/intersection_tests":122,"grid-index":149,"point-geometry":197}],81:[function(require,module,exports){
"use strict";function getAnchors(e,r,t,n,a,l,o,i,h){var c=n?.6*l*o:0,s=Math.max(n?n.right-n.left:0,a?a.right-a.left:0),u=0===e[0].x||e[0].x===h||0===e[0].y||e[0].y===h;r-s*o<r/4&&(r=s*o+r/4);var g=2*l,p=u?r/2*i%r:(s/2+g)*o*i%r;return resample(e,p,r,c,t,s*o,u,!1,h)}function resample(e,r,t,n,a,l,o,i,h){for(var c=l/2,s=0,u=0;u<e.length-1;u++)s+=e[u].dist(e[u+1]);for(var g=0,p=r-t,x=[],f=0;f<e.length-1;f++){for(var v=e[f],m=e[f+1],A=v.dist(m),y=m.angleTo(v);p+t<g+A;){p+=t;var d=(p-g)/A,k=interpolate(v.x,m.x,d),q=interpolate(v.y,m.y,d);if(k>=0&&k<h&&q>=0&&q<h&&p-c>=0&&p+c<=s){var M=new Anchor(k,q,y,f)._round();n&&!checkMaxAngle(e,M,l,n,a)||x.push(M)}}g+=A}return i||x.length||o||(x=resample(e,g/2,t,n,a,l,o,!0,h)),x}var interpolate=require("../util/interpolate"),Anchor=require("../symbol/anchor"),checkMaxAngle=require("./check_max_angle");module.exports=getAnchors;
},{"../symbol/anchor":75,"../util/interpolate":121,"./check_max_angle":76}],82:[function(require,module,exports){
"use strict";var ShelfPack=require("shelf-pack"),util=require("../util/util"),SIZE_GROWTH_RATE=4,DEFAULT_SIZE=128,MAX_SIZE=2048,GlyphAtlas=function(){this.width=DEFAULT_SIZE,this.height=DEFAULT_SIZE,this.bin=new ShelfPack(this.width,this.height),this.index={},this.ids={},this.data=new Uint8Array(this.width*this.height)};GlyphAtlas.prototype.getGlyphs=function(){var t,i,e,h={};for(var r in this.ids)t=r.split("#"),i=t[0],e=t[1],h[i]||(h[i]=[]),h[i].push(e);return h},GlyphAtlas.prototype.getRects=function(){var t,i,e,h=this,r={};for(var s in this.ids)t=s.split("#"),i=t[0],e=t[1],r[i]||(r[i]={}),r[i][e]=h.index[s];return r},GlyphAtlas.prototype.addGlyph=function(t,i,e,h){var r=this;if(!e)return null;var s=i+"#"+e.id;if(this.index[s])return this.ids[s].indexOf(t)<0&&this.ids[s].push(t),this.index[s];if(!e.bitmap)return null;var a=e.width+2*h,n=e.height+2*h,E=1,T=a+2*E,u=n+2*E;T+=4-T%4,u+=4-u%4;var l=this.bin.packOne(T,u);if(l||(this.resize(),l=this.bin.packOne(T,u)),!l)return util.warnOnce("glyph bitmap overflow"),null;this.index[s]=l,this.ids[s]=[t];for(var d=this.data,A=e.bitmap,_=0;_<n;_++)for(var p=r.width*(l.y+_+E)+l.x+E,o=a*_,R=0;R<a;R++)d[p+R]=A[o+R];return this.dirty=!0,l},GlyphAtlas.prototype.resize=function(){var t=this,i=this.width,e=this.height;if(!(i>=MAX_SIZE||e>=MAX_SIZE)){this.texture&&(this.gl&&this.gl.deleteTexture(this.texture),this.texture=null),this.width*=SIZE_GROWTH_RATE,this.height*=SIZE_GROWTH_RATE,this.bin.resize(this.width,this.height);for(var h=new ArrayBuffer(this.width*this.height),r=0;r<e;r++){var s=new Uint8Array(t.data.buffer,e*r,i),a=new Uint8Array(h,e*r*SIZE_GROWTH_RATE,i);a.set(s)}this.data=new Uint8Array(h)}},GlyphAtlas.prototype.bind=function(t){this.gl=t,this.texture?t.bindTexture(t.TEXTURE_2D,this.texture):(this.texture=t.createTexture(),t.bindTexture(t.TEXTURE_2D,this.texture),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texImage2D(t.TEXTURE_2D,0,t.ALPHA,this.width,this.height,0,t.ALPHA,t.UNSIGNED_BYTE,null))},GlyphAtlas.prototype.updateTexture=function(t){this.bind(t),this.dirty&&(t.texSubImage2D(t.TEXTURE_2D,0,0,0,this.width,this.height,t.ALPHA,t.UNSIGNED_BYTE,this.data),this.dirty=!1)},module.exports=GlyphAtlas;
},{"../util/util":129,"shelf-pack":200}],83:[function(require,module,exports){
"use strict";function glyphUrl(t,e,a,l){return l=l||"abc",a.replace("{s}",l[t.length%l.length]).replace("{fontstack}",t).replace("{range}",e)}var normalizeURL=require("../util/mapbox").normalizeGlyphsURL,ajax=require("../util/ajax"),verticalizePunctuation=require("../util/verticalize_punctuation"),Glyphs=require("../util/glyphs"),GlyphAtlas=require("../symbol/glyph_atlas"),Protobuf=require("pbf"),SimpleGlyph=function(t,e,a){var l=1;this.advance=t.advance,this.left=t.left-a-l,this.top=t.top+a+l,this.rect=e},GlyphSource=function(t){this.url=t&&normalizeURL(t),this.atlases={},this.stacks={},this.loading={}};GlyphSource.prototype.getSimpleGlyphs=function(t,e,a,l){var i=this;void 0===this.stacks[t]&&(this.stacks[t]={}),void 0===this.atlases[t]&&(this.atlases[t]=new GlyphAtlas);for(var r={},o=this.stacks[t],s=this.atlases[t],n=3,h={},p=0,u=function(e){var l=Math.floor(e/256);if(o[l]){var i=o[l].glyphs[e],u=s.addGlyph(a,t,i,n);i&&(r[e]=new SimpleGlyph(i,u,n))}else void 0===h[l]&&(h[l]=[],p++),h[l].push(e)},c=0;c<e.length;c++){var y=e[c],f=String.fromCharCode(y);u(y),verticalizePunctuation.lookup[f]&&u(verticalizePunctuation.lookup[f].charCodeAt(0))}p||l(void 0,r,t);var v=function(e,o,u){if(!e)for(var c=i.stacks[t][o]=u.stacks[0],y=0;y<h[o].length;y++){var f=h[o][y],v=c.glyphs[f],d=s.addGlyph(a,t,v,n);v&&(r[f]=new SimpleGlyph(v,d,n))}p--,p||l(void 0,r,t)};for(var d in h)i.loadRange(t,d,v)},GlyphSource.prototype.loadRange=function(t,e,a){if(256*e>65535)return a("glyphs > 65535 not supported");void 0===this.loading[t]&&(this.loading[t]={});var l=this.loading[t];if(l[e])l[e].push(a);else{l[e]=[a];var i=256*e+"-"+(256*e+255),r=glyphUrl(t,i,this.url);ajax.getArrayBuffer(r,function(t,a){for(var i=!t&&new Glyphs(new Protobuf(a.data)),r=0;r<l[e].length;r++)l[e][r](t,e,i);delete l[e]})}},GlyphSource.prototype.getGlyphAtlas=function(t){return this.atlases[t]},module.exports=GlyphSource;
},{"../symbol/glyph_atlas":82,"../util/ajax":109,"../util/glyphs":120,"../util/mapbox":125,"../util/verticalize_punctuation":131,"pbf":196}],84:[function(require,module,exports){
"use strict";module.exports=function(e){function t(t){g.push(e[t]),l++}function r(e,t,r){var n=u[e];return delete u[e],u[t]=n,g[n].geometry[0].pop(),g[n].geometry[0]=g[n].geometry[0].concat(r[0]),n}function n(e,t,r){var n=i[t];return delete i[t],i[e]=n,g[n].geometry[0].shift(),g[n].geometry[0]=r[0].concat(g[n].geometry[0]),n}function o(e,t,r){var n=r?t[0][t[0].length-1]:t[0][0];return e+":"+n.x+":"+n.y}for(var i={},u={},g=[],l=0,m=0;m<e.length;m++){var y=e[m],c=y.geometry,f=y.text;if(f){var a=o(f,c),s=o(f,c,!0);if(a in u&&s in i&&u[a]!==i[s]){var v=n(a,s,c),d=r(a,s,g[v].geometry);delete i[a],delete u[s],u[o(f,g[d].geometry,!0)]=d,g[v].geometry=null}else a in u?r(a,s,c):s in i?n(a,s,c):(t(m),i[a]=l-1,u[s]=l-1)}else t(m)}return g.filter(function(e){return e.geometry})};
},{}],85:[function(require,module,exports){
"use strict";function SymbolQuad(t,e,a,n,i,o,l,h,r,s,g){this.anchorPoint=t,this.tl=e,this.tr=a,this.bl=n,this.br=i,this.tex=o,this.anchorAngle=l,this.glyphAngle=h,this.minScale=r,this.maxScale=s,this.writingMode=g}function getIconQuads(t,e,a,n,i,o,l,h,r){var s,g,u,c,m=e.image.rect,f=i.layout,x=1,d=e.left-x,P=d+m.w/e.image.pixelRatio,y=e.top-x,M=y+m.h/e.image.pixelRatio;if("none"!==f["icon-text-fit"]&&l){var p=P-d,v=M-y,w=f["text-size"]/24,S=l.left*w,b=l.right*w,I=l.top*w,_=l.bottom*w,Q=b-S,G=_-I,k=f["icon-text-fit-padding"][0],q=f["icon-text-fit-padding"][1],A=f["icon-text-fit-padding"][2],R=f["icon-text-fit-padding"][3],z="width"===f["icon-text-fit"]?.5*(G-v):0,L="height"===f["icon-text-fit"]?.5*(Q-p):0,V="width"===f["icon-text-fit"]||"both"===f["icon-text-fit"]?Q:p,j="height"===f["icon-text-fit"]||"both"===f["icon-text-fit"]?G:v;s=new Point(S+L-R,I+z-k),g=new Point(S+L+q+V,I+z-k),u=new Point(S+L+q+V,I+z+A+j),c=new Point(S+L-R,I+z+A+j)}else s=new Point(d,y),g=new Point(P,y),u=new Point(P,M),c=new Point(d,M);var B=i.getLayoutValue("icon-rotate",h,r)*Math.PI/180;if(o){var C=n[t.segment];if(t.y===C.y&&t.x===C.x&&t.segment+1<n.length){var D=n[t.segment+1];B+=Math.atan2(t.y-D.y,t.x-D.x)+Math.PI}else B+=Math.atan2(t.y-C.y,t.x-C.x)}if(B){var E=Math.sin(B),F=Math.cos(B),H=[F,-E,E,F];s=s.matMult(H),g=g.matMult(H),c=c.matMult(H),u=u.matMult(H)}return[new SymbolQuad(new Point(t.x,t.y),s,g,c,u,e.image.rect,0,0,minScale,1/0)]}function getGlyphQuads(t,e,a,n,i,o){for(var l=i.layout["text-rotate"]*Math.PI/180,h=i.layout["text-keep-upright"],r=e.positionedGlyphs,s=[],g=0;g<r.length;g++){var u=r[g],c=u.glyph;if(c){var m=c.rect;if(m){var f,x=(u.x+c.advance/2)*a,d=minScale;o?(f=[],d=getSegmentGlyphs(f,t,x,n,t.segment,!0),h&&(d=Math.min(d,getSegmentGlyphs(f,t,x,n,t.segment,!1)))):f=[{anchorPoint:new Point(t.x,t.y),offset:0,angle:0,maxScale:1/0,minScale:minScale}];var P=u.x+c.left,y=u.y-c.top,M=P+m.w,p=y+m.h,v=new Point(u.x,c.advance/2),w=new Point(P,y),S=new Point(M,y),b=new Point(P,p),I=new Point(M,p);0!==u.angle&&(w._sub(v)._rotate(u.angle)._add(v),S._sub(v)._rotate(u.angle)._add(v),b._sub(v)._rotate(u.angle)._add(v),I._sub(v)._rotate(u.angle)._add(v));for(var _=0;_<f.length;_++){var Q=f[_],G=w,k=S,q=b,A=I;if(l){var R=Math.sin(l),z=Math.cos(l),L=[z,-R,R,z];G=G.matMult(L),k=k.matMult(L),q=q.matMult(L),A=A.matMult(L)}var V=Math.max(Q.minScale,d),j=(t.angle+Q.offset+2*Math.PI)%(2*Math.PI),B=(Q.angle+Q.offset+2*Math.PI)%(2*Math.PI);s.push(new SymbolQuad(Q.anchorPoint,G,k,q,A,m,j,B,V,Q.maxScale,e.writingMode))}}}}return s}function getSegmentGlyphs(t,e,a,n,i,o){var l=!o;a<0&&(o=!o),o&&i++;var h=new Point(e.x,e.y),r=n[i],s=1/0;a=Math.abs(a);for(var g=minScale;;){var u=h.dist(r),c=a/u,m=Math.atan2(r.y-h.y,r.x-h.x);if(o||(m+=Math.PI),t.push({anchorPoint:h,offset:l?Math.PI:0,minScale:c,maxScale:s,angle:(m+2*Math.PI)%(2*Math.PI)}),c<=g)break;for(h=r;h.equals(r);)if(i+=o?1:-1,r=n[i],!r)return c;var f=r.sub(h)._unit();h=h.sub(f._mult(u)),s=c}return g}var Point=require("point-geometry");module.exports={getIconQuads:getIconQuads,getGlyphQuads:getGlyphQuads,SymbolQuad:SymbolQuad};var minScale=.5;
},{"point-geometry":197}],86:[function(require,module,exports){
"use strict";var resolveTokens=require("../util/token");module.exports=function(e,r){var o=resolveTokens(e.properties,r["text-field"]);if(o){o=o.toString();var t=r["text-transform"];return"uppercase"===t?o=o.toLocaleUpperCase():"lowercase"===t&&(o=o.toLocaleLowerCase()),o}};
},{"../util/token":128}],87:[function(require,module,exports){
"use strict";function PositionedGlyph(e,t,i,n,r){this.codePoint=e,this.x=t,this.y=i,this.glyph=n||null,this.angle=r}function Shaping(e,t,i,n,r,a,o){this.positionedGlyphs=e,this.text=t,this.top=i,this.bottom=n,this.left=r,this.right=a,this.writingMode=o}function breakLines(e,t){for(var i=[],n=0,r=0,a=t;r<a.length;r+=1){var o=a[r];i.push(e.substring(n,o)),n=o}return n<e.length&&i.push(e.substring(n,e.length)),i}function shapeText(e,t,i,n,r,a,o,s,h,l,c){var u=e.trim();c===WritingMode.vertical&&(u=verticalizePunctuation(u));var d,g=[],p=new Shaping(g,u,h[1],h[1],h[0],h[0],c);return d=rtlTextPlugin.processBidirectionalText?rtlTextPlugin.processBidirectionalText(u,determineLineBreaks(u,s,i,t)):breakLines(u,determineLineBreaks(u,s,i,t)),shapeLines(p,t,d,n,r,a,o,h,c,s,l),!!g.length&&p}function determineAverageLineWidth(e,t,i,n){var r=0;for(var a in e){var o=n[e.charCodeAt(a)];o&&(r+=o.advance+t)}var s=Math.max(1,Math.ceil(r/i));return r/s}function calculateBadness(e,t,i,n){var r=Math.pow(e-t,2);return n?e<t?r/2:2*r:r+Math.abs(i)*i}function calculatePenalty(e,t){var i=0;return 10===e&&(i-=1e4),40!==e&&65288!==e||(i+=50),41!==t&&65289!==t||(i+=50),i}function evaluateBreak(e,t,i,n,r,a){for(var o=null,s=calculateBadness(t,i,r,a),h=0,l=n;h<l.length;h+=1){var c=l[h],u=t-c.x,d=calculateBadness(u,i,r,a)+c.badness;d<=s&&(o=c,s=d)}return{index:e,x:t,priorBreak:o,badness:s}}function leastBadBreaks(e){return e?leastBadBreaks(e.priorBreak).concat(e.index):[]}function determineLineBreaks(e,t,i,n){if(!i)return[];if(!e)return[];for(var r=[],a=determineAverageLineWidth(e,t,i,n),o=0,s=0;s<e.length;s++){var h=e.charCodeAt(s),l=n[h];l&&!whitespace[h]&&(o+=l.advance+t),s<e.length-1&&(breakable[h]||scriptDetection.charAllowsIdeographicBreaking(h))&&r.push(evaluateBreak(s+1,o,a,r,calculatePenalty(h,e.charCodeAt(s+1)),!1))}return leastBadBreaks(evaluateBreak(e.length,o,a,r,0,!0))}function shapeLines(e,t,i,n,r,a,o,s,h,l,c){var u=-17,d=0,g=u,p=0,v=e.positionedGlyphs;for(var f in i){var x=i[f].trim();if(x.length){for(var B=v.length,k=0;k<x.length;k++){var P=x.charCodeAt(k),b=t[P];b&&(scriptDetection.charHasUprightVerticalOrientation(P)&&h!==WritingMode.horizontal?(v.push(new PositionedGlyph(P,d,0,b,-Math.PI/2)),d+=c+l):(v.push(new PositionedGlyph(P,d,g,b,0)),d+=b.advance+l))}if(v.length!==B){var m=d-l;p=Math.max(m,p),justifyLine(v,t,B,v.length-1,o)}d=0,g+=n}else g+=n}align(v,o,r,a,p,n,i.length,s);var y=i.length*n;e.top+=-a*y,e.bottom=e.top+y,e.left+=-r*p,e.right=e.left+p}function justifyLine(e,t,i,n,r){if(r)for(var a=t[e[n].codePoint].advance,o=(e[n].x+a)*r,s=i;s<=n;s++)e[s].x-=o}function align(e,t,i,n,r,a,o,s){for(var h=(t-i)*r+s[0],l=(-n*o+.5)*a+s[1],c=0;c<e.length;c++)e[c].x+=h,e[c].y+=l}function shapeIcon(e,t){if(!e||!e.rect)return null;var i=t[0],n=t[1],r=i-e.width/2,a=r+e.width,o=n-e.height/2,s=o+e.height;return new PositionedIcon(e,o,s,r,a)}function PositionedIcon(e,t,i,n,r){this.image=e,this.top=t,this.bottom=i,this.left=n,this.right=r}var scriptDetection=require("../util/script_detection"),verticalizePunctuation=require("../util/verticalize_punctuation"),rtlTextPlugin=require("../source/rtl_text_plugin"),WritingMode={horizontal:1,vertical:2};module.exports={shapeText:shapeText,shapeIcon:shapeIcon,WritingMode:WritingMode};var whitespace={9:!0,10:!0,11:!0,12:!0,13:!0,32:!0},breakable={10:!0,32:!0,38:!0,40:!0,41:!0,43:!0,45:!0,47:!0,173:!0,183:!0,8203:!0,8208:!0,8211:!0,8231:!0};
},{"../source/rtl_text_plugin":49,"../util/script_detection":126,"../util/verticalize_punctuation":131}],88:[function(require,module,exports){
"use strict";function copyBitmap(t,i,e,h,a,s,r,o,l,p,n){var u,R,f=h*i+e,x=o*s+r;if(n)for(x-=s,R=-1;R<=p;R++,f=((R+p)%p+h)*i+e,x+=s)for(u=-1;u<=l;u++)a[x+u]=t[f+(u+l)%l];else for(R=0;R<p;R++,f+=i,x+=s)for(u=0;u<l;u++)a[x+u]=t[f+u]}var ShelfPack=require("shelf-pack"),browser=require("../util/browser"),util=require("../util/util"),AtlasImage=function(t,i,e,h,a){this.rect=t,this.width=i,this.height=e,this.sdf=h,this.pixelRatio=a},SpriteAtlas=function(t,i){this.width=t,this.height=i,this.bin=new ShelfPack(t,i),this.images={},this.data=!1,this.texture=0,this.filter=0,this.pixelRatio=1,this.dirty=!0};SpriteAtlas.prototype.allocateImage=function(t,i){t/=this.pixelRatio,i/=this.pixelRatio;var e=2,h=t+e+(4-(t+e)%4),a=i+e+(4-(i+e)%4),s=this.bin.packOne(h,a);return s?s:(util.warnOnce("SpriteAtlas out of space."),null)},SpriteAtlas.prototype.getImage=function(t,i){if(this.images[t])return this.images[t];if(!this.sprite)return null;var e=this.sprite.getSpritePosition(t);if(!e.width||!e.height)return null;var h=this.allocateImage(e.width,e.height);if(!h)return null;var a=new AtlasImage(h,e.width/e.pixelRatio,e.height/e.pixelRatio,e.sdf,e.pixelRatio/this.pixelRatio);return this.images[t]=a,this.copy(h,e,i),a},SpriteAtlas.prototype.getPosition=function(t,i){var e=this.getImage(t,i),h=e&&e.rect;if(!h)return null;var a=e.width*e.pixelRatio,s=e.height*e.pixelRatio,r=1;return{size:[e.width,e.height],tl:[(h.x+r)/this.width,(h.y+r)/this.height],br:[(h.x+r+a)/this.width,(h.y+r+s)/this.height]}},SpriteAtlas.prototype.allocate=function(){var t=this;if(!this.data){var i=Math.floor(this.width*this.pixelRatio),e=Math.floor(this.height*this.pixelRatio);this.data=new Uint32Array(i*e);for(var h=0;h<this.data.length;h++)t.data[h]=0}},SpriteAtlas.prototype.copy=function(t,i,e){if(this.sprite.imgData){var h=new Uint32Array(this.sprite.imgData.buffer);this.allocate();var a=this.data,s=1;copyBitmap(h,this.sprite.width,i.x,i.y,a,this.width*this.pixelRatio,(t.x+s)*this.pixelRatio,(t.y+s)*this.pixelRatio,i.width,i.height,e),this.dirty=!0}},SpriteAtlas.prototype.setSprite=function(t){t&&(this.pixelRatio=browser.devicePixelRatio>1?2:1,this.canvas&&(this.canvas.width=this.width*this.pixelRatio,this.canvas.height=this.height*this.pixelRatio)),this.sprite=t},SpriteAtlas.prototype.addIcons=function(t,i){for(var e=this,h=0;h<t.length;h++)e.getImage(t[h]);i(null,this.images)},SpriteAtlas.prototype.bind=function(t,i){var e=!1;this.texture?t.bindTexture(t.TEXTURE_2D,this.texture):(this.texture=t.createTexture(),t.bindTexture(t.TEXTURE_2D,this.texture),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),e=!0);var h=i?t.LINEAR:t.NEAREST;h!==this.filter&&(t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,h),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,h),this.filter=h),this.dirty&&(this.allocate(),e?t.texImage2D(t.TEXTURE_2D,0,t.RGBA,this.width*this.pixelRatio,this.height*this.pixelRatio,0,t.RGBA,t.UNSIGNED_BYTE,new Uint8Array(this.data.buffer)):t.texSubImage2D(t.TEXTURE_2D,0,0,0,this.width*this.pixelRatio,this.height*this.pixelRatio,t.RGBA,t.UNSIGNED_BYTE,new Uint8Array(this.data.buffer)),this.dirty=!1)},module.exports=SpriteAtlas;
},{"../util/browser":110,"../util/util":129,"shelf-pack":200}],89:[function(require,module,exports){
"use strict";var createStructArrayType=require("../util/struct_array"),Point=require("point-geometry"),SymbolInstancesArray=createStructArrayType({members:[{type:"Uint16",name:"textBoxStartIndex"},{type:"Uint16",name:"textBoxEndIndex"},{type:"Uint16",name:"iconBoxStartIndex"},{type:"Uint16",name:"iconBoxEndIndex"},{type:"Uint16",name:"glyphQuadStartIndex"},{type:"Uint16",name:"glyphQuadEndIndex"},{type:"Uint16",name:"iconQuadStartIndex"},{type:"Uint16",name:"iconQuadEndIndex"},{type:"Int16",name:"anchorPointX"},{type:"Int16",name:"anchorPointY"},{type:"Int8",name:"index"},{type:"Uint8",name:"writingModes"}]});Object.defineProperty(SymbolInstancesArray.prototype.StructType.prototype,"anchorPoint",{get:function(){return new Point(this.anchorPointX,this.anchorPointY)}}),module.exports=SymbolInstancesArray;
},{"../util/struct_array":127,"point-geometry":197}],90:[function(require,module,exports){
"use strict";var createStructArrayType=require("../util/struct_array"),Point=require("point-geometry"),SymbolQuad=require("./quads").SymbolQuad,SymbolQuadsArray=createStructArrayType({members:[{type:"Int16",name:"anchorPointX"},{type:"Int16",name:"anchorPointY"},{type:"Float32",name:"tlX"},{type:"Float32",name:"tlY"},{type:"Float32",name:"trX"},{type:"Float32",name:"trY"},{type:"Float32",name:"blX"},{type:"Float32",name:"blY"},{type:"Float32",name:"brX"},{type:"Float32",name:"brY"},{type:"Int16",name:"texH"},{type:"Int16",name:"texW"},{type:"Int16",name:"texX"},{type:"Int16",name:"texY"},{type:"Float32",name:"anchorAngle"},{type:"Float32",name:"glyphAngle"},{type:"Float32",name:"maxScale"},{type:"Float32",name:"minScale"},{type:"Uint8",name:"writingMode"}]});Object.defineProperty(SymbolQuadsArray.prototype.StructType.prototype,"anchorPoint",{get:function(){return new Point(this.anchorPointX,this.anchorPointY)}}),Object.defineProperty(SymbolQuadsArray.prototype.StructType.prototype,"SymbolQuad",{get:function(){return new SymbolQuad(this.anchorPoint,new Point(this.tlX,this.tlY),new Point(this.trX,this.trY),new Point(this.blX,this.blY),new Point(this.brX,this.brY),{x:this.texX,y:this.texY,h:this.texH,w:this.texW,height:this.texH,width:this.texW},this.anchorAngle,this.glyphAngle,this.minScale,this.maxScale,this.writingMode)}}),module.exports=SymbolQuadsArray;
},{"../util/struct_array":127,"./quads":85,"point-geometry":197}],91:[function(require,module,exports){
"use strict";var DOM=require("../util/dom"),Point=require("point-geometry"),handlers={scrollZoom:require("./handler/scroll_zoom"),boxZoom:require("./handler/box_zoom"),dragRotate:require("./handler/drag_rotate"),dragPan:require("./handler/drag_pan"),keyboard:require("./handler/keyboard"),doubleClickZoom:require("./handler/dblclick_zoom"),touchZoomRotate:require("./handler/touch_zoom_rotate")};module.exports=function(e,t){function n(e){h("mouseout",e)}function o(t){e.stop(),L=DOM.mousePos(g,t),h("mousedown",t),E=!0}function r(t){var n=e.dragRotate&&e.dragRotate.isActive();p&&!n&&h("contextmenu",p),p=null,E=!1,h("mouseup",t)}function a(t){if(!(e.dragPan&&e.dragPan.isActive()||e.dragRotate&&e.dragRotate.isActive())){for(var n=t.toElement||t.target;n&&n!==g;)n=n.parentNode;n===g&&h("mousemove",t)}}function u(t){e.stop(),f("touchstart",t),!t.touches||t.touches.length>1||(b?(clearTimeout(b),b=null,h("dblclick",t)):b=setTimeout(l,300))}function i(e){f("touchmove",e)}function c(e){f("touchend",e)}function d(e){f("touchcancel",e)}function l(){b=null}function s(e){var t=DOM.mousePos(g,e);t.equals(L)&&h("click",e)}function v(e){h("dblclick",e),e.preventDefault()}function m(t){var n=e.dragRotate&&e.dragRotate.isActive();E||n?E&&(p=t):h("contextmenu",t),t.preventDefault()}function h(t,n){var o=DOM.mousePos(g,n);return e.fire(t,{lngLat:e.unproject(o),point:o,originalEvent:n})}function f(t,n){var o=DOM.touchPos(g,n),r=o.reduce(function(e,t,n,o){return e.add(t.div(o.length))},new Point(0,0));return e.fire(t,{lngLat:e.unproject(r),point:r,lngLats:o.map(function(t){return e.unproject(t)},this),points:o,originalEvent:n})}var g=e.getCanvasContainer(),p=null,E=!1,L=null,b=null;for(var q in handlers)e[q]=new handlers[q](e,t),t.interactive&&t[q]&&e[q].enable(t[q]);g.addEventListener("mouseout",n,!1),g.addEventListener("mousedown",o,!1),g.addEventListener("mouseup",r,!1),g.addEventListener("mousemove",a,!1),g.addEventListener("touchstart",u,!1),g.addEventListener("touchend",c,!1),g.addEventListener("touchmove",i,!1),g.addEventListener("touchcancel",d,!1),g.addEventListener("click",s,!1),g.addEventListener("dblclick",v,!1),g.addEventListener("contextmenu",m,!1)};
},{"../util/dom":117,"./handler/box_zoom":97,"./handler/dblclick_zoom":98,"./handler/drag_pan":99,"./handler/drag_rotate":100,"./handler/keyboard":101,"./handler/scroll_zoom":102,"./handler/touch_zoom_rotate":103,"point-geometry":197}],92:[function(require,module,exports){
"use strict";var util=require("../util/util"),interpolate=require("../util/interpolate"),browser=require("../util/browser"),LngLat=require("../geo/lng_lat"),LngLatBounds=require("../geo/lng_lat_bounds"),Point=require("point-geometry"),Evented=require("../util/evented"),Camera=function(t){function i(i,e){t.call(this),this.moving=!1,this.transform=i,this._bearingSnap=e.bearingSnap}return t&&(i.__proto__=t),i.prototype=Object.create(t&&t.prototype),i.prototype.constructor=i,i.prototype.getCenter=function(){return this.transform.center},i.prototype.setCenter=function(t,i){return this.jumpTo({center:t},i),this},i.prototype.panBy=function(t,i,e){return this.panTo(this.transform.center,util.extend({offset:Point.convert(t).mult(-1)},i),e),this},i.prototype.panTo=function(t,i,e){return this.easeTo(util.extend({center:t},i),e)},i.prototype.getZoom=function(){return this.transform.zoom},i.prototype.setZoom=function(t,i){return this.jumpTo({zoom:t},i),this},i.prototype.zoomTo=function(t,i,e){return this.easeTo(util.extend({zoom:t},i),e)},i.prototype.zoomIn=function(t,i){return this.zoomTo(this.getZoom()+1,t,i),this},i.prototype.zoomOut=function(t,i){return this.zoomTo(this.getZoom()-1,t,i),this},i.prototype.getBearing=function(){return this.transform.bearing},i.prototype.setBearing=function(t,i){return this.jumpTo({bearing:t},i),this},i.prototype.rotateTo=function(t,i,e){return this.easeTo(util.extend({bearing:t},i),e)},i.prototype.resetNorth=function(t,i){return this.rotateTo(0,util.extend({duration:1e3},t),i),this},i.prototype.snapToNorth=function(t,i){return Math.abs(this.getBearing())<this._bearingSnap?this.resetNorth(t,i):this},i.prototype.getPitch=function(){return this.transform.pitch},i.prototype.setPitch=function(t,i){return this.jumpTo({pitch:t},i),this},i.prototype.fitBounds=function(t,i,e){i=util.extend({padding:0,offset:[0,0],maxZoom:this.getMaxZoom()},i),t=LngLatBounds.convert(t);var o=Point.convert(i.offset),n=this.transform,r=n.project(t.getNorthWest()),s=n.project(t.getSouthEast()),a=s.sub(r),h=(n.width-2*i.padding-2*Math.abs(o.x))/a.x,u=(n.height-2*i.padding-2*Math.abs(o.y))/a.y;return i.center=n.unproject(r.add(s).div(2)),i.zoom=Math.min(n.scaleZoom(n.scale*Math.min(h,u)),i.maxZoom),i.bearing=0,i.linear?this.easeTo(i,e):this.flyTo(i,e)},i.prototype.jumpTo=function(t,i){this.stop();var e=this.transform,o=!1,n=!1,r=!1;return"zoom"in t&&e.zoom!==+t.zoom&&(o=!0,e.zoom=+t.zoom),"center"in t&&(e.center=LngLat.convert(t.center)),"bearing"in t&&e.bearing!==+t.bearing&&(n=!0,e.bearing=+t.bearing),"pitch"in t&&e.pitch!==+t.pitch&&(r=!0,e.pitch=+t.pitch),this.fire("movestart",i).fire("move",i),o&&this.fire("zoomstart",i).fire("zoom",i).fire("zoomend",i),n&&this.fire("rotate",i),r&&this.fire("pitch",i),this.fire("moveend",i)},i.prototype.easeTo=function(t,i){var e=this;this.stop(),t=util.extend({offset:[0,0],duration:500,easing:util.ease},t);var o,n,r=this.transform,s=Point.convert(t.offset),a=this.getZoom(),h=this.getBearing(),u=this.getPitch(),p="zoom"in t?+t.zoom:a,c="bearing"in t?this._normalizeBearing(t.bearing,h):h,m="pitch"in t?+t.pitch:u;"center"in t?(o=LngLat.convert(t.center),n=r.centerPoint.add(s)):"around"in t?(o=LngLat.convert(t.around),n=r.locationPoint(o)):(n=r.centerPoint.add(s),o=r.pointLocation(n));var g=r.locationPoint(o);return t.animate===!1&&(t.duration=0),this.zooming=p!==a,this.rotating=h!==c,this.pitching=m!==u,t.smoothEasing&&0!==t.duration&&(t.easing=this._smoothOutEasing(t.duration)),t.noMoveStart||(this.moving=!0,this.fire("movestart",i)),this.zooming&&this.fire("zoomstart",i),clearTimeout(this._onEaseEnd),this._ease(function(t){this.zooming&&(r.zoom=interpolate(a,p,t)),this.rotating&&(r.bearing=interpolate(h,c,t)),this.pitching&&(r.pitch=interpolate(u,m,t)),r.setLocationAtPoint(o,g.add(n.sub(g)._mult(t))),this.fire("move",i),this.zooming&&this.fire("zoom",i),this.rotating&&this.fire("rotate",i),this.pitching&&this.fire("pitch",i)},function(){t.delayEndEvents?e._onEaseEnd=setTimeout(e._easeToEnd.bind(e,i),t.delayEndEvents):e._easeToEnd(i)},t),this},i.prototype._easeToEnd=function(t){var i=this.zooming;this.moving=!1,this.zooming=!1,this.rotating=!1,this.pitching=!1,i&&this.fire("zoomend",t),this.fire("moveend",t)},i.prototype.flyTo=function(t,i){function e(t){var i=(y*y-z*z+(t?-1:1)*E*E*_*_)/(2*(t?y:z)*E*_);return Math.log(Math.sqrt(i*i+1)-i)}function o(t){return(Math.exp(t)-Math.exp(-t))/2}function n(t){return(Math.exp(t)+Math.exp(-t))/2}function r(t){return o(t)/n(t)}this.stop(),t=util.extend({offset:[0,0],speed:1.2,curve:1.42,easing:util.ease},t);var s=this.transform,a=Point.convert(t.offset),h=this.getZoom(),u=this.getBearing(),p=this.getPitch(),c="center"in t?LngLat.convert(t.center):this.getCenter(),m="zoom"in t?+t.zoom:h,g="bearing"in t?this._normalizeBearing(t.bearing,u):u,f="pitch"in t?+t.pitch:p;Math.abs(s.center.lng)+Math.abs(c.lng)>180&&(s.center.lng>0&&c.lng<0?c.lng+=360:s.center.lng<0&&c.lng>0&&(c.lng-=360));var d=s.zoomScale(m-h),l=s.point,v="center"in t?s.project(c).sub(a.div(d)):l,b=t.curve,z=Math.max(s.width,s.height),y=z/d,_=v.sub(l).mag();if("minZoom"in t){var M=util.clamp(Math.min(t.minZoom,h,m),s.minZoom,s.maxZoom),T=z/s.zoomScale(M-h);b=Math.sqrt(T/_*2)}var E=b*b,x=e(0),L=function(t){return n(x)/n(x+b*t)},Z=function(t){return z*((n(x)*r(x+b*t)-o(x))/E)/_},P=(e(1)-x)/b;if(Math.abs(_)<1e-6){if(Math.abs(z-y)<1e-6)return this.easeTo(t);var B=y<z?-1:1;P=Math.abs(Math.log(y/z))/b,Z=function(){return 0},L=function(t){return Math.exp(B*b*t)}}if("duration"in t)t.duration=+t.duration;else{var j="screenSpeed"in t?+t.screenSpeed/b:+t.speed;t.duration=1e3*P/j}return this.moving=!0,this.zooming=!0,u!==g&&(this.rotating=!0),p!==f&&(this.pitching=!0),this.fire("movestart",i),this.fire("zoomstart",i),this._ease(function(t){var e=t*P,o=Z(e),n=1/L(e);s.zoom=h+s.scaleZoom(n),s.center=s.unproject(l.add(v.sub(l).mult(o)).mult(n)),this.rotating&&(s.bearing=interpolate(u,g,t)),this.pitching&&(s.pitch=interpolate(p,f,t)),this.fire("move",i),this.fire("zoom",i),this.rotating&&this.fire("rotate",i),this.pitching&&this.fire("pitch",i)},function(){this.moving=!1,this.zooming=!1,this.rotating=!1,this.pitching=!1,this.fire("zoomend",i),this.fire("moveend",i)},t),this},i.prototype.isEasing=function(){return!!this._abortFn},i.prototype.isMoving=function(){return this.moving},i.prototype.stop=function(){return this._abortFn&&(this._abortFn(),this._finishEase()),this},i.prototype._ease=function(t,i,e){this._finishFn=i,this._abortFn=browser.timed(function(i){t.call(this,e.easing(i)),1===i&&this._finishEase()},e.animate===!1?0:e.duration,this)},i.prototype._finishEase=function(){delete this._abortFn;var t=this._finishFn;delete this._finishFn,t.call(this)},i.prototype._normalizeBearing=function(t,i){t=util.wrap(t,-180,180);var e=Math.abs(t-i);return Math.abs(t-360-i)<e&&(t-=360),Math.abs(t+360-i)<e&&(t+=360),t},i.prototype._smoothOutEasing=function(t){var i=util.ease;if(this._prevEase){var e=this._prevEase,o=(Date.now()-e.start)/e.duration,n=e.easing(o+.01)-e.easing(o),r=.27/Math.sqrt(n*n+1e-4)*.01,s=Math.sqrt(.0729-r*r);i=util.bezier(r,s,.25,1)}return this._prevEase={start:(new Date).getTime(),duration:t,easing:i},i},i}(Evented);module.exports=Camera;
},{"../geo/lng_lat":19,"../geo/lng_lat_bounds":20,"../util/browser":110,"../util/evented":118,"../util/interpolate":121,"../util/util":129,"point-geometry":197}],93:[function(require,module,exports){
"use strict";var DOM=require("../../util/dom"),util=require("../../util/util"),AttributionControl=function(t){this.options=t,util.bindAll(["_updateEditLink","_updateData","_updateCompact"],this)};AttributionControl.prototype.getDefaultPosition=function(){return"bottom-right"},AttributionControl.prototype.onAdd=function(t){var i=this.options&&this.options.compact;return this._map=t,this._container=DOM.create("div","mapboxgl-ctrl mapboxgl-ctrl-attrib"),i&&this._container.classList.add("compact"),this._updateAttributions(),this._updateEditLink(),this._map.on("data",this._updateData),this._map.on("moveend",this._updateEditLink),void 0===i&&(this._map.on("resize",this._updateCompact),this._updateCompact()),this._container},AttributionControl.prototype.onRemove=function(){this._container.parentNode.removeChild(this._container),this._map.off("data",this._updateData),this._map.off("moveend",this._updateEditLink),this._map.off("resize",this._updateCompact),this._map=void 0},AttributionControl.prototype._updateEditLink=function(){if(this._editLink||(this._editLink=this._container.querySelector(".mapbox-improve-map")),this._editLink){var t=this._map.getCenter();this._editLink.href="https://www.mapbox.com/map-feedback/#/"+t.lng+"/"+t.lat+"/"+Math.round(this._map.getZoom()+1)}},AttributionControl.prototype._updateData=function(t){"source"===t.dataType&&(this._updateAttributions(),this._updateEditLink())},AttributionControl.prototype._updateAttributions=function(){if(this._map.style){var t=[],i=this._map.style.sourceCaches;for(var o in i){var n=i[o].getSource();n.attribution&&t.indexOf(n.attribution)<0&&t.push(n.attribution)}t.sort(function(t,i){return t.length-i.length}),t=t.filter(function(i,o){for(var n=o+1;n<t.length;n++)if(t[n].indexOf(i)>=0)return!1;return!0}),this._container.innerHTML=t.join(" | "),this._editLink=null}},AttributionControl.prototype._updateCompact=function(){var t=this._map.getCanvasContainer().offsetWidth<=640;this._container.classList[t?"add":"remove"]("compact")},module.exports=AttributionControl;
},{"../../util/dom":117,"../../util/util":129}],94:[function(require,module,exports){
"use strict";function checkGeolocationSupport(t){void 0!==supportsGeolocation?t(supportsGeolocation):void 0!==window.navigator.permissions?window.navigator.permissions.query({name:"geolocation"}).then(function(o){supportsGeolocation="denied"!==o.state,t(supportsGeolocation)}):(supportsGeolocation=!!window.navigator.geolocation,t(supportsGeolocation))}var Evented=require("../../util/evented"),DOM=require("../../util/dom"),window=require("../../util/window"),util=require("../../util/util"),defaultGeoPositionOptions={enableHighAccuracy:!1,timeout:6e3},className="mapboxgl-ctrl",supportsGeolocation,GeolocateControl=function(t){function o(o){t.call(this),this.options=o||{},util.bindAll(["_onSuccess","_onError","_finish","_setupUI"],this)}return t&&(o.__proto__=t),o.prototype=Object.create(t&&t.prototype),o.prototype.constructor=o,o.prototype.onAdd=function(t){return this._map=t,this._container=DOM.create("div",className+" "+className+"-group"),checkGeolocationSupport(this._setupUI),this._container},o.prototype.onRemove=function(){this._container.parentNode.removeChild(this._container),this._map=void 0},o.prototype._onSuccess=function(t){this._map.jumpTo({center:[t.coords.longitude,t.coords.latitude],zoom:17,bearing:0,pitch:0}),this.fire("geolocate",t),this._finish()},o.prototype._onError=function(t){this.fire("error",t),this._finish()},o.prototype._finish=function(){this._timeoutId&&clearTimeout(this._timeoutId),this._timeoutId=void 0},o.prototype._setupUI=function(t){t!==!1&&(this._container.addEventListener("contextmenu",function(t){return t.preventDefault()}),this._geolocateButton=DOM.create("button",className+"-icon "+className+"-geolocate",this._container),this._geolocateButton.type="button",this._geolocateButton.setAttribute("aria-label","Geolocate"),this.options.watchPosition&&this._geolocateButton.setAttribute("aria-pressed",!1),this._geolocateButton.addEventListener("click",this._onClickGeolocate.bind(this)))},o.prototype._onClickGeolocate=function(){var t=util.extend(defaultGeoPositionOptions,this.options&&this.options.positionOptions||{});this.options.watchPosition?void 0!==this._geolocationWatchID?(this._geolocateButton.classList.remove("watching"),this._geolocateButton.setAttribute("aria-pressed",!1),window.navigator.geolocation.clearWatch(this._geolocationWatchID),this._geolocationWatchID=void 0):(this._geolocateButton.classList.add("watching"),this._geolocateButton.setAttribute("aria-pressed",!0),this._geolocationWatchID=window.navigator.geolocation.watchPosition(this._onSuccess,this._onError,t)):(window.navigator.geolocation.getCurrentPosition(this._onSuccess,this._onError,t),this._timeoutId=setTimeout(this._finish,1e4))},o}(Evented);module.exports=GeolocateControl;
},{"../../util/dom":117,"../../util/evented":118,"../../util/util":129,"../../util/window":112}],95:[function(require,module,exports){
"use strict";function copyMouseEvent(t){return new window.MouseEvent(t.type,{button:2,buttons:2,bubbles:!0,cancelable:!0,detail:t.detail,view:t.view,screenX:t.screenX,screenY:t.screenY,clientX:t.clientX,clientY:t.clientY,movementX:t.movementX,movementY:t.movementY,ctrlKey:t.ctrlKey,shiftKey:t.shiftKey,altKey:t.altKey,metaKey:t.metaKey})}var DOM=require("../../util/dom"),window=require("../../util/window"),util=require("../../util/util"),className="mapboxgl-ctrl",NavigationControl=function(){util.bindAll(["_rotateCompassArrow"],this)};NavigationControl.prototype._rotateCompassArrow=function(){var t="rotate("+this._map.transform.angle*(180/Math.PI)+"deg)";this._compassArrow.style.transform=t},NavigationControl.prototype.onAdd=function(t){return this._map=t,this._container=DOM.create("div",className+" "+className+"-group",t.getContainer()),this._container.addEventListener("contextmenu",this._onContextMenu.bind(this)),this._zoomInButton=this._createButton(className+"-icon "+className+"-zoom-in","Zoom In",t.zoomIn.bind(t)),this._zoomOutButton=this._createButton(className+"-icon "+className+"-zoom-out","Zoom Out",t.zoomOut.bind(t)),this._compass=this._createButton(className+"-icon "+className+"-compass","Reset North",t.resetNorth.bind(t)),this._compassArrow=DOM.create("span","arrow",this._compass),this._compass.addEventListener("mousedown",this._onCompassDown.bind(this)),this._onCompassMove=this._onCompassMove.bind(this),this._onCompassUp=this._onCompassUp.bind(this),this._map.on("rotate",this._rotateCompassArrow),this._rotateCompassArrow(),this._container},NavigationControl.prototype.onRemove=function(){this._container.parentNode.removeChild(this._container),this._map.off("rotate",this._rotateCompassArrow),this._map=void 0},NavigationControl.prototype._onContextMenu=function(t){t.preventDefault()},NavigationControl.prototype._onCompassDown=function(t){0===t.button&&(DOM.disableDrag(),window.document.addEventListener("mousemove",this._onCompassMove),window.document.addEventListener("mouseup",this._onCompassUp),this._map.getCanvasContainer().dispatchEvent(copyMouseEvent(t)),t.stopPropagation())},NavigationControl.prototype._onCompassMove=function(t){0===t.button&&(this._map.getCanvasContainer().dispatchEvent(copyMouseEvent(t)),t.stopPropagation())},NavigationControl.prototype._onCompassUp=function(t){0===t.button&&(window.document.removeEventListener("mousemove",this._onCompassMove),window.document.removeEventListener("mouseup",this._onCompassUp),DOM.enableDrag(),this._map.getCanvasContainer().dispatchEvent(copyMouseEvent(t)),t.stopPropagation())},NavigationControl.prototype._createButton=function(t,o,e){var n=DOM.create("button",t,this._container);return n.type="button",n.setAttribute("aria-label",o),n.addEventListener("click",function(){e()}),n},module.exports=NavigationControl;
},{"../../util/dom":117,"../../util/util":129,"../../util/window":112}],96:[function(require,module,exports){
"use strict";function updateScale(t,e,o){var n=o&&o.maxWidth||100,i=t._container.clientHeight/2,a=getDistance(t.unproject([0,i]),t.unproject([n,i]));if(o&&"imperial"===o.unit){var r=3.2808*a;if(r>5280){var l=r/5280;setScale(e,n,l,"mi")}else setScale(e,n,r,"ft")}else setScale(e,n,a,"m")}function setScale(t,e,o,n){var i=getRoundNum(o),a=i/o;"m"===n&&i>=1e3&&(i/=1e3,n="km"),t.style.width=e*a+"px",t.innerHTML=i+n}function getDistance(t,e){var o=6371e3,n=Math.PI/180,i=t.lat*n,a=e.lat*n,r=Math.sin(i)*Math.sin(a)+Math.cos(i)*Math.cos(a)*Math.cos((e.lng-t.lng)*n),l=o*Math.acos(Math.min(r,1));return l}function getRoundNum(t){var e=Math.pow(10,(""+Math.floor(t)).length-1),o=t/e;return o=o>=10?10:o>=5?5:o>=3?3:o>=2?2:1,e*o}var DOM=require("../../util/dom"),util=require("../../util/util"),ScaleControl=function(t){this.options=t,util.bindAll(["_onMove"],this)};ScaleControl.prototype.getDefaultPosition=function(){return"bottom-left"},ScaleControl.prototype._onMove=function(){updateScale(this._map,this._container,this.options)},ScaleControl.prototype.onAdd=function(t){return this._map=t,this._container=DOM.create("div","mapboxgl-ctrl mapboxgl-ctrl-scale",t.getContainer()),this._map.on("move",this._onMove),this._onMove(),this._container},ScaleControl.prototype.onRemove=function(){this._container.parentNode.removeChild(this._container),this._map.off("move",this._onMove),this._map=void 0},module.exports=ScaleControl;
},{"../../util/dom":117,"../../util/util":129}],97:[function(require,module,exports){
"use strict";var DOM=require("../../util/dom"),LngLatBounds=require("../../geo/lng_lat_bounds"),util=require("../../util/util"),window=require("../../util/window"),BoxZoomHandler=function(o){this._map=o,this._el=o.getCanvasContainer(),this._container=o.getContainer(),util.bindAll(["_onMouseDown","_onMouseMove","_onMouseUp","_onKeyDown"],this)};BoxZoomHandler.prototype.isEnabled=function(){return!!this._enabled},BoxZoomHandler.prototype.isActive=function(){return!!this._active},BoxZoomHandler.prototype.enable=function(){this.isEnabled()||(this._el.addEventListener("mousedown",this._onMouseDown,!1),this._enabled=!0)},BoxZoomHandler.prototype.disable=function(){this.isEnabled()&&(this._el.removeEventListener("mousedown",this._onMouseDown),this._enabled=!1)},BoxZoomHandler.prototype._onMouseDown=function(o){o.shiftKey&&0===o.button&&(window.document.addEventListener("mousemove",this._onMouseMove,!1),window.document.addEventListener("keydown",this._onKeyDown,!1),window.document.addEventListener("mouseup",this._onMouseUp,!1),DOM.disableDrag(),this._startPos=DOM.mousePos(this._el,o),this._active=!0)},BoxZoomHandler.prototype._onMouseMove=function(o){var e=this._startPos,t=DOM.mousePos(this._el,o);this._box||(this._box=DOM.create("div","mapboxgl-boxzoom",this._container),this._container.classList.add("mapboxgl-crosshair"),this._fireEvent("boxzoomstart",o));var n=Math.min(e.x,t.x),i=Math.max(e.x,t.x),s=Math.min(e.y,t.y),r=Math.max(e.y,t.y);DOM.setTransform(this._box,"translate("+n+"px,"+s+"px)"),this._box.style.width=i-n+"px",this._box.style.height=r-s+"px"},BoxZoomHandler.prototype._onMouseUp=function(o){if(0===o.button){var e=this._startPos,t=DOM.mousePos(this._el,o),n=(new LngLatBounds).extend(this._map.unproject(e)).extend(this._map.unproject(t));this._finish(),e.x===t.x&&e.y===t.y?this._fireEvent("boxzoomcancel",o):this._map.fitBounds(n,{linear:!0}).fire("boxzoomend",{originalEvent:o,boxZoomBounds:n})}},BoxZoomHandler.prototype._onKeyDown=function(o){27===o.keyCode&&(this._finish(),this._fireEvent("boxzoomcancel",o))},BoxZoomHandler.prototype._finish=function(){this._active=!1,window.document.removeEventListener("mousemove",this._onMouseMove,!1),window.document.removeEventListener("keydown",this._onKeyDown,!1),window.document.removeEventListener("mouseup",this._onMouseUp,!1),this._container.classList.remove("mapboxgl-crosshair"),this._box&&(this._box.parentNode.removeChild(this._box),this._box=null),DOM.enableDrag()},BoxZoomHandler.prototype._fireEvent=function(o,e){return this._map.fire(o,{originalEvent:e})},module.exports=BoxZoomHandler;
},{"../../geo/lng_lat_bounds":20,"../../util/dom":117,"../../util/util":129,"../../util/window":112}],98:[function(require,module,exports){
"use strict";var DoubleClickZoomHandler=function(o){this._map=o,this._onDblClick=this._onDblClick.bind(this)};DoubleClickZoomHandler.prototype.isEnabled=function(){return!!this._enabled},DoubleClickZoomHandler.prototype.enable=function(){this.isEnabled()||(this._map.on("dblclick",this._onDblClick),this._enabled=!0)},DoubleClickZoomHandler.prototype.disable=function(){this.isEnabled()&&(this._map.off("dblclick",this._onDblClick),this._enabled=!1)},DoubleClickZoomHandler.prototype._onDblClick=function(o){this._map.zoomTo(this._map.getZoom()+(o.originalEvent.shiftKey?-1:1),{around:o.lngLat},o)},module.exports=DoubleClickZoomHandler;
},{}],99:[function(require,module,exports){
"use strict";var DOM=require("../../util/dom"),util=require("../../util/util"),window=require("../../util/window"),inertiaLinearity=.3,inertiaEasing=util.bezier(0,0,inertiaLinearity,1),inertiaMaxSpeed=1400,inertiaDeceleration=2500,DragPanHandler=function(t){this._map=t,this._el=t.getCanvasContainer(),util.bindAll(["_onDown","_onMove","_onUp","_onTouchEnd","_onMouseUp"],this)};DragPanHandler.prototype.isEnabled=function(){return!!this._enabled},DragPanHandler.prototype.isActive=function(){return!!this._active},DragPanHandler.prototype.enable=function(){this.isEnabled()||(this._el.addEventListener("mousedown",this._onDown),this._el.addEventListener("touchstart",this._onDown),this._enabled=!0)},DragPanHandler.prototype.disable=function(){this.isEnabled()&&(this._el.removeEventListener("mousedown",this._onDown),this._el.removeEventListener("touchstart",this._onDown),this._enabled=!1)},DragPanHandler.prototype._onDown=function(t){this._ignoreEvent(t)||this.isActive()||(t.touches?(window.document.addEventListener("touchmove",this._onMove),window.document.addEventListener("touchend",this._onTouchEnd)):(window.document.addEventListener("mousemove",this._onMove),window.document.addEventListener("mouseup",this._onMouseUp)),this._active=!1,this._startPos=this._pos=DOM.mousePos(this._el,t),this._inertia=[[Date.now(),this._pos]])},DragPanHandler.prototype._onMove=function(t){if(!this._ignoreEvent(t)){this.isActive()||(this._active=!0,this._fireEvent("dragstart",t),this._fireEvent("movestart",t));var e=DOM.mousePos(this._el,t),n=this._map;n.stop(),this._drainInertiaBuffer(),this._inertia.push([Date.now(),e]),n.transform.setLocationAtPoint(n.transform.pointLocation(this._pos),e),this._fireEvent("drag",t),this._fireEvent("move",t),this._pos=e,t.preventDefault()}},DragPanHandler.prototype._onUp=function(t){var e=this;if(this.isActive()){this._active=!1,this._fireEvent("dragend",t),this._drainInertiaBuffer();var n=function(){return e._fireEvent("moveend",t)},i=this._inertia;if(i.length<2)return void n();var o=i[i.length-1],r=i[0],a=o[1].sub(r[1]),s=(o[0]-r[0])/1e3;if(0===s||o[1].equals(r[1]))return void n();var u=a.mult(inertiaLinearity/s),h=u.mag();h>inertiaMaxSpeed&&(h=inertiaMaxSpeed,u._unit()._mult(h));var d=h/(inertiaDeceleration*inertiaLinearity),v=u.mult(-d/2);this._map.panBy(v,{duration:1e3*d,easing:inertiaEasing,noMoveStart:!0},{originalEvent:t})}},DragPanHandler.prototype._onMouseUp=function(t){this._ignoreEvent(t)||(this._onUp(t),window.document.removeEventListener("mousemove",this._onMove),window.document.removeEventListener("mouseup",this._onMouseUp))},DragPanHandler.prototype._onTouchEnd=function(t){this._ignoreEvent(t)||(this._onUp(t),window.document.removeEventListener("touchmove",this._onMove),window.document.removeEventListener("touchend",this._onTouchEnd))},DragPanHandler.prototype._fireEvent=function(t,e){return this._map.fire(t,{originalEvent:e})},DragPanHandler.prototype._ignoreEvent=function(t){var e=this._map;if(e.boxZoom&&e.boxZoom.isActive())return!0;if(e.dragRotate&&e.dragRotate.isActive())return!0;if(t.touches)return t.touches.length>1;if(t.ctrlKey)return!0;var n=1,i=0;return"mousemove"===t.type?t.buttons&0===n:t.button!==i},DragPanHandler.prototype._drainInertiaBuffer=function(){for(var t=this._inertia,e=Date.now(),n=160;t.length>0&&e-t[0][0]>n;)t.shift()},module.exports=DragPanHandler;
},{"../../util/dom":117,"../../util/util":129,"../../util/window":112}],100:[function(require,module,exports){
"use strict";var DOM=require("../../util/dom"),util=require("../../util/util"),window=require("../../util/window"),inertiaLinearity=.25,inertiaEasing=util.bezier(0,0,inertiaLinearity,1),inertiaMaxSpeed=180,inertiaDeceleration=720,DragRotateHandler=function(t,e){this._map=t,this._el=t.getCanvasContainer(),this._bearingSnap=e.bearingSnap,this._pitchWithRotate=e.pitchWithRotate!==!1,util.bindAll(["_onDown","_onMove","_onUp"],this)};DragRotateHandler.prototype.isEnabled=function(){return!!this._enabled},DragRotateHandler.prototype.isActive=function(){return!!this._active},DragRotateHandler.prototype.enable=function(){this.isEnabled()||(this._el.addEventListener("mousedown",this._onDown),this._enabled=!0)},DragRotateHandler.prototype.disable=function(){this.isEnabled()&&(this._el.removeEventListener("mousedown",this._onDown),this._enabled=!1)},DragRotateHandler.prototype._onDown=function(t){this._ignoreEvent(t)||this.isActive()||(window.document.addEventListener("mousemove",this._onMove),window.document.addEventListener("mouseup",this._onUp),this._active=!1,this._inertia=[[Date.now(),this._map.getBearing()]],this._startPos=this._pos=DOM.mousePos(this._el,t),this._center=this._map.transform.centerPoint,t.preventDefault())},DragRotateHandler.prototype._onMove=function(t){if(!this._ignoreEvent(t)){this.isActive()||(this._active=!0,this._fireEvent("rotatestart",t),this._fireEvent("movestart",t));var e=this._map;e.stop();var i=this._pos,n=DOM.mousePos(this._el,t),r=.8*(i.x-n.x),a=(i.y-n.y)*-.5,o=e.getBearing()-r,s=e.getPitch()-a,h=this._inertia,_=h[h.length-1];this._drainInertiaBuffer(),h.push([Date.now(),e._normalizeBearing(o,_[1])]),e.transform.bearing=o,this._pitchWithRotate&&(e.transform.pitch=s),this._fireEvent("rotate",t),this._fireEvent("move",t),this._pos=n}},DragRotateHandler.prototype._onUp=function(t){var e=this;if(!this._ignoreEvent(t)&&(window.document.removeEventListener("mousemove",this._onMove),window.document.removeEventListener("mouseup",this._onUp),this.isActive())){this._active=!1,this._fireEvent("rotateend",t),this._drainInertiaBuffer();var i=this._map,n=i.getBearing(),r=this._inertia,a=function(){Math.abs(n)<e._bearingSnap?i.resetNorth({noMoveStart:!0},{originalEvent:t}):e._fireEvent("moveend",t)};if(r.length<2)return void a();var o=r[0],s=r[r.length-1],h=r[r.length-2],_=i._normalizeBearing(n,h[1]),v=s[1]-o[1],u=v<0?-1:1,d=(s[0]-o[0])/1e3;if(0===v||0===d)return void a();var l=Math.abs(v*(inertiaLinearity/d));l>inertiaMaxSpeed&&(l=inertiaMaxSpeed);var p=l/(inertiaDeceleration*inertiaLinearity),g=u*l*(p/2);_+=g,Math.abs(i._normalizeBearing(_,0))<this._bearingSnap&&(_=i._normalizeBearing(0,_)),i.rotateTo(_,{duration:1e3*p,easing:inertiaEasing,noMoveStart:!0},{originalEvent:t})}},DragRotateHandler.prototype._fireEvent=function(t,e){return this._map.fire(t,{originalEvent:e})},DragRotateHandler.prototype._ignoreEvent=function(t){var e=this._map;if(e.boxZoom&&e.boxZoom.isActive())return!0;if(e.dragPan&&e.dragPan.isActive())return!0;if(t.touches)return t.touches.length>1;var i=t.ctrlKey?1:2,n=t.ctrlKey?0:2,r=t.button;return"undefined"!=typeof InstallTrigger&&2===t.button&&t.ctrlKey&&window.navigator.platform.toUpperCase().indexOf("MAC")>=0&&(r=0),"mousemove"===t.type?t.buttons&0===i:r!==n},DragRotateHandler.prototype._drainInertiaBuffer=function(){for(var t=this._inertia,e=Date.now(),i=160;t.length>0&&e-t[0][0]>i;)t.shift()},module.exports=DragRotateHandler;
},{"../../util/dom":117,"../../util/util":129,"../../util/window":112}],101:[function(require,module,exports){
"use strict";function easeOut(e){return e*(2-e)}var panStep=100,bearingStep=15,pitchStep=10,KeyboardHandler=function(e){this._map=e,this._el=e.getCanvasContainer(),this._onKeyDown=this._onKeyDown.bind(this)};KeyboardHandler.prototype.isEnabled=function(){return!!this._enabled},KeyboardHandler.prototype.enable=function(){this.isEnabled()||(this._el.addEventListener("keydown",this._onKeyDown,!1),this._enabled=!0)},KeyboardHandler.prototype.disable=function(){this.isEnabled()&&(this._el.removeEventListener("keydown",this._onKeyDown),this._enabled=!1)},KeyboardHandler.prototype._onKeyDown=function(e){if(!(e.altKey||e.ctrlKey||e.metaKey)){var t=0,n=0,a=0,i=0,r=0;switch(e.keyCode){case 61:case 107:case 171:case 187:t=1;break;case 189:case 109:case 173:t=-1;break;case 37:e.shiftKey?n=-1:(e.preventDefault(),i=-1);break;case 39:e.shiftKey?n=1:(e.preventDefault(),i=1);break;case 38:e.shiftKey?a=1:(e.preventDefault(),r=-1);break;case 40:e.shiftKey?a=-1:(r=1,e.preventDefault())}var s=this._map,o=s.getZoom(),d={duration:300,delayEndEvents:500,easing:easeOut,zoom:t?Math.round(o)+t*(e.shiftKey?2:1):o,bearing:s.getBearing()+n*bearingStep,pitch:s.getPitch()+a*pitchStep,offset:[-i*panStep,-r*panStep],center:s.getCenter()};s.easeTo(d,{originalEvent:e})}},module.exports=KeyboardHandler;
},{}],102:[function(require,module,exports){
"use strict";var DOM=require("../../util/dom"),util=require("../../util/util"),browser=require("../../util/browser"),window=require("../../util/window"),ua=window.navigator.userAgent.toLowerCase(),firefox=ua.indexOf("firefox")!==-1,safari=ua.indexOf("safari")!==-1&&ua.indexOf("chrom")===-1,ScrollZoomHandler=function(e){this._map=e,this._el=e.getCanvasContainer(),util.bindAll(["_onWheel","_onTimeout"],this)};ScrollZoomHandler.prototype.isEnabled=function(){return!!this._enabled},ScrollZoomHandler.prototype.enable=function(e){this.isEnabled()||(this._el.addEventListener("wheel",this._onWheel,!1),this._el.addEventListener("mousewheel",this._onWheel,!1),this._enabled=!0,this._aroundCenter=e&&"center"===e.around)},ScrollZoomHandler.prototype.disable=function(){this.isEnabled()&&(this._el.removeEventListener("wheel",this._onWheel),this._el.removeEventListener("mousewheel",this._onWheel),this._enabled=!1)},ScrollZoomHandler.prototype._onWheel=function(e){var t;"wheel"===e.type?(t=e.deltaY,firefox&&e.deltaMode===window.WheelEvent.DOM_DELTA_PIXEL&&(t/=browser.devicePixelRatio),e.deltaMode===window.WheelEvent.DOM_DELTA_LINE&&(t*=40)):"mousewheel"===e.type&&(t=-e.wheelDeltaY,safari&&(t/=3));var o=browser.now(),i=o-(this._time||0);this._pos=DOM.mousePos(this._el,e),this._time=o,0!==t&&t%4.000244140625===0?this._type="wheel":0!==t&&Math.abs(t)<4?this._type="trackpad":i>400?(this._type=null,this._lastValue=t,this._timeout=setTimeout(this._onTimeout,40)):this._type||(this._type=Math.abs(i*t)<200?"trackpad":"wheel",this._timeout&&(clearTimeout(this._timeout),this._timeout=null,t+=this._lastValue)),e.shiftKey&&t&&(t/=4),this._type&&this._zoom(-t,e),e.preventDefault()},ScrollZoomHandler.prototype._onTimeout=function(){this._type="wheel",this._zoom(-this._lastValue)},ScrollZoomHandler.prototype._zoom=function(e,t){if(0!==e){var o=this._map,i=2/(1+Math.exp(-Math.abs(e/100)));e<0&&0!==i&&(i=1/i);var l=o.ease?o.ease.to:o.transform.scale,s=o.transform.scaleZoom(l*i);o.zoomTo(s,{duration:"wheel"===this._type?200:0,around:this._aroundCenter?o.getCenter():o.unproject(this._pos),delayEndEvents:200,smoothEasing:!0},{originalEvent:t})}},module.exports=ScrollZoomHandler;
},{"../../util/browser":110,"../../util/dom":117,"../../util/util":129,"../../util/window":112}],103:[function(require,module,exports){
"use strict";var DOM=require("../../util/dom"),util=require("../../util/util"),window=require("../../util/window"),inertiaLinearity=.15,inertiaEasing=util.bezier(0,0,inertiaLinearity,1),inertiaDeceleration=12,inertiaMaxSpeed=2.5,significantScaleThreshold=.15,significantRotateThreshold=4,TouchZoomRotateHandler=function(t){this._map=t,this._el=t.getCanvasContainer(),util.bindAll(["_onStart","_onMove","_onEnd"],this)};TouchZoomRotateHandler.prototype.isEnabled=function(){return!!this._enabled},TouchZoomRotateHandler.prototype.enable=function(t){this.isEnabled()||(this._el.addEventListener("touchstart",this._onStart,!1),this._enabled=!0,this._aroundCenter=t&&"center"===t.around)},TouchZoomRotateHandler.prototype.disable=function(){this.isEnabled()&&(this._el.removeEventListener("touchstart",this._onStart),this._enabled=!1)},TouchZoomRotateHandler.prototype.disableRotation=function(){this._rotationDisabled=!0},TouchZoomRotateHandler.prototype.enableRotation=function(){this._rotationDisabled=!1},TouchZoomRotateHandler.prototype._onStart=function(t){if(2===t.touches.length){var e=DOM.mousePos(this._el,t.touches[0]),o=DOM.mousePos(this._el,t.touches[1]);this._startVec=e.sub(o),this._startScale=this._map.transform.scale,this._startBearing=this._map.transform.bearing,this._gestureIntent=void 0,this._inertia=[],window.document.addEventListener("touchmove",this._onMove,!1),window.document.addEventListener("touchend",this._onEnd,!1)}},TouchZoomRotateHandler.prototype._onMove=function(t){if(2===t.touches.length){var e=DOM.mousePos(this._el,t.touches[0]),o=DOM.mousePos(this._el,t.touches[1]),i=e.add(o).div(2),n=e.sub(o),a=n.mag()/this._startVec.mag(),r=this._rotationDisabled?0:180*n.angleWith(this._startVec)/Math.PI,s=this._map;if(this._gestureIntent){var h={duration:0,around:s.unproject(i)};"rotate"===this._gestureIntent&&(h.bearing=this._startBearing+r),"zoom"!==this._gestureIntent&&"rotate"!==this._gestureIntent||(h.zoom=s.transform.scaleZoom(this._startScale*a)),s.stop(),this._drainInertiaBuffer(),this._inertia.push([Date.now(),a,i]),s.easeTo(h,{originalEvent:t})}else{var u=Math.abs(1-a)>significantScaleThreshold,d=Math.abs(r)>significantRotateThreshold;d?this._gestureIntent="rotate":u&&(this._gestureIntent="zoom"),this._gestureIntent&&(this._startVec=n,this._startScale=s.transform.scale,this._startBearing=s.transform.bearing)}t.preventDefault()}},TouchZoomRotateHandler.prototype._onEnd=function(t){window.document.removeEventListener("touchmove",this._onMove),window.document.removeEventListener("touchend",this._onEnd),this._drainInertiaBuffer();var e=this._inertia,o=this._map;if(e.length<2)return void o.snapToNorth({},{originalEvent:t});var i=e[e.length-1],n=e[0],a=o.transform.scaleZoom(this._startScale*i[1]),r=o.transform.scaleZoom(this._startScale*n[1]),s=a-r,h=(i[0]-n[0])/1e3,u=i[2];if(0===h||a===r)return void o.snapToNorth({},{originalEvent:t});var d=s*inertiaLinearity/h;Math.abs(d)>inertiaMaxSpeed&&(d=d>0?inertiaMaxSpeed:-inertiaMaxSpeed);var l=1e3*Math.abs(d/(inertiaDeceleration*inertiaLinearity)),c=a+d*l/2e3;c<0&&(c=0),o.easeTo({zoom:c,duration:l,easing:inertiaEasing,around:this._aroundCenter?o.getCenter():o.unproject(u)},{originalEvent:t})},TouchZoomRotateHandler.prototype._drainInertiaBuffer=function(){for(var t=this._inertia,e=Date.now(),o=160;t.length>2&&e-t[0][0]>o;)t.shift()},module.exports=TouchZoomRotateHandler;
},{"../../util/dom":117,"../../util/util":129,"../../util/window":112}],104:[function(require,module,exports){
"use strict";var util=require("../util/util"),window=require("../util/window"),Hash=function(){util.bindAll(["_onHashChange","_updateHash"],this)};Hash.prototype.addTo=function(t){return this._map=t,window.addEventListener("hashchange",this._onHashChange,!1),this._map.on("moveend",this._updateHash),this},Hash.prototype.remove=function(){return window.removeEventListener("hashchange",this._onHashChange,!1),this._map.off("moveend",this._updateHash),delete this._map,this},Hash.prototype._onHashChange=function(){var t=window.location.hash.replace("#","").split("/");return t.length>=3&&(this._map.jumpTo({center:[+t[2],+t[1]],zoom:+t[0],bearing:+(t[3]||0),pitch:+(t[4]||0)}),!0)},Hash.prototype._updateHash=function(){var t=this._map.getCenter(),e=this._map.getZoom(),a=this._map.getBearing(),h=this._map.getPitch(),i=Math.max(0,Math.ceil(Math.log(e)/Math.LN2)),n="#"+Math.round(100*e)/100+"/"+t.lat.toFixed(i)+"/"+t.lng.toFixed(i);(a||h)&&(n+="/"+Math.round(10*a)/10),h&&(n+="/"+Math.round(h)),window.history.replaceState("","",n)},module.exports=Hash;
},{"../util/util":129,"../util/window":112}],105:[function(require,module,exports){
"use strict";function removeNode(t){t.parentNode&&t.parentNode.removeChild(t)}var util=require("../util/util"),browser=require("../util/browser"),window=require("../util/window"),DOM=require("../util/dom"),Style=require("../style/style"),AnimationLoop=require("../style/animation_loop"),Painter=require("../render/painter"),Transform=require("../geo/transform"),Hash=require("./hash"),bindHandlers=require("./bind_handlers"),Camera=require("./camera"),LngLat=require("../geo/lng_lat"),LngLatBounds=require("../geo/lng_lat_bounds"),Point=require("point-geometry"),AttributionControl=require("./control/attribution_control"),isSupported=require("mapbox-gl-supported"),defaultMinZoom=0,defaultMaxZoom=20,defaultOptions={center:[0,0],zoom:0,bearing:0,pitch:0,minZoom:defaultMinZoom,maxZoom:defaultMaxZoom,interactive:!0,scrollZoom:!0,boxZoom:!0,dragRotate:!0,dragPan:!0,keyboard:!0,doubleClickZoom:!0,touchZoomRotate:!0,bearingSnap:7,hash:!1,attributionControl:!0,failIfMajorPerformanceCaveat:!1,preserveDrawingBuffer:!1,trackResize:!0,renderWorldCopies:!0},Map=function(t){function e(e){var i=this;e=util.extend({},defaultOptions,e);var o=new Transform(e.minZoom,e.maxZoom,e.renderWorldCopies);if(t.call(this,o,e),this._interactive=e.interactive,this._failIfMajorPerformanceCaveat=e.failIfMajorPerformanceCaveat,this._preserveDrawingBuffer=e.preserveDrawingBuffer,this._trackResize=e.trackResize,this._bearingSnap=e.bearingSnap,"string"==typeof e.container){if(this._container=window.document.getElementById(e.container),!this._container)throw new Error("Container '"+e.container+"' not found.")}else this._container=e.container;this.animationLoop=new AnimationLoop,e.maxBounds&&this.setMaxBounds(e.maxBounds),util.bindAll(["_onWindowOnline","_onWindowResize","_contextLost","_contextRestored","_update","_render","_onData","_onDataLoading"],this),this._setupContainer(),this._setupPainter(),this.on("move",this._update.bind(this,!1)),this.on("zoom",this._update.bind(this,!0)),this.on("moveend",function(){i.animationLoop.set(300),i._rerender()}),"undefined"!=typeof window&&(window.addEventListener("online",this._onWindowOnline,!1),window.addEventListener("resize",this._onWindowResize,!1)),bindHandlers(this,e),this._hash=e.hash&&(new Hash).addTo(this),this._hash&&this._hash._onHashChange()||this.jumpTo({center:e.center,zoom:e.zoom,bearing:e.bearing,pitch:e.pitch}),this._classes=[],this.resize(),e.classes&&this.setClasses(e.classes),e.style&&this.setStyle(e.style),e.attributionControl&&this.addControl(new AttributionControl),this.on("style.load",function(){this.transform.unmodified&&this.jumpTo(this.style.stylesheet),this.style.update(this._classes,{transition:!1})}),this.on("data",this._onData),this.on("dataloading",this._onDataLoading)}t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e;var i={showTileBoundaries:{},showCollisionBoxes:{},showOverdrawInspector:{},repaint:{},vertices:{}};return e.prototype.addControl=function(t,e){void 0===e&&t.getDefaultPosition&&(e=t.getDefaultPosition()),void 0===e&&(e="top-right");var i=t.onAdd(this),o=this._controlPositions[e];return e.indexOf("bottom")!==-1?o.insertBefore(i,o.firstChild):o.appendChild(i),this},e.prototype.removeControl=function(t){return t.onRemove(this),this},e.prototype.addClass=function(t,e){return util.warnOnce("Style classes are deprecated and will be removed in an upcoming release of Mapbox GL JS."),this._classes.indexOf(t)>=0||""===t?this:(this._classes.push(t),this._classOptions=e,this.style&&this.style.updateClasses(),this._update(!0))},e.prototype.removeClass=function(t,e){util.warnOnce("Style classes are deprecated and will be removed in an upcoming release of Mapbox GL JS.");var i=this._classes.indexOf(t);return i<0||""===t?this:(this._classes.splice(i,1),this._classOptions=e,this.style&&this.style.updateClasses(),this._update(!0))},e.prototype.setClasses=function(t,e){util.warnOnce("Style classes are deprecated and will be removed in an upcoming release of Mapbox GL JS.");for(var i={},o=0;o<t.length;o++)""!==t[o]&&(i[t[o]]=!0);return this._classes=Object.keys(i),this._classOptions=e,this.style&&this.style.updateClasses(),this._update(!0)},e.prototype.hasClass=function(t){return util.warnOnce("Style classes are deprecated and will be removed in an upcoming release of Mapbox GL JS."),this._classes.indexOf(t)>=0},e.prototype.getClasses=function(){return util.warnOnce("Style classes are deprecated and will be removed in an upcoming release of Mapbox GL JS."),this._classes},e.prototype.resize=function(){var t=this._containerDimensions(),e=t[0],i=t[1];this._resizeCanvas(e,i),this.transform.resize(e,i),this.painter.resize(e,i);var o=this.painter.gl,s=o.getParameter(o.MAX_RENDERBUFFER_SIZE)/2;return(this._canvas.width>s||this._canvas.height>s)&&util.warnOnce("Map is larger than maximum size supported by this system ("+s+"px by "+s+"px)."),this.fire("movestart").fire("move").fire("resize").fire("moveend")},e.prototype.getBounds=function(){var t=new LngLatBounds(this.transform.pointLocation(new Point(0,this.transform.height)),this.transform.pointLocation(new Point(this.transform.width,0)));return(this.transform.angle||this.transform.pitch)&&(t.extend(this.transform.pointLocation(new Point(this.transform.size.x,0))),t.extend(this.transform.pointLocation(new Point(0,this.transform.size.y)))),t},e.prototype.setMaxBounds=function(t){if(t){var e=LngLatBounds.convert(t);this.transform.lngRange=[e.getWest(),e.getEast()],this.transform.latRange=[e.getSouth(),e.getNorth()],this.transform._constrain(),this._update()}else null!==t&&void 0!==t||(this.transform.lngRange=[],this.transform.latRange=[],this._update());return this},e.prototype.setMinZoom=function(t){if(t=null===t||void 0===t?defaultMinZoom:t,t>=defaultMinZoom&&t<=this.transform.maxZoom)return this.transform.minZoom=t,this._update(),this.getZoom()<t&&this.setZoom(t),this;throw new Error("minZoom must be between "+defaultMinZoom+" and the current maxZoom, inclusive")},e.prototype.getMinZoom=function(){return this.transform.minZoom},e.prototype.setMaxZoom=function(t){if(t=null===t||void 0===t?defaultMaxZoom:t,t>=this.transform.minZoom)return this.transform.maxZoom=t,this._update(),this.getZoom()>t&&this.setZoom(t),this;throw new Error("maxZoom must be greater than the current minZoom")},e.prototype.getMaxZoom=function(){return this.transform.maxZoom},e.prototype.project=function(t){return this.transform.locationPoint(LngLat.convert(t))},e.prototype.unproject=function(t){return this.transform.pointLocation(Point.convert(t))},e.prototype.queryRenderedFeatures=function(){function t(t){return t instanceof Point||Array.isArray(t)}var e,i={};return 2===arguments.length?(e=arguments[0],i=arguments[1]):1===arguments.length&&t(arguments[0])?e=arguments[0]:1===arguments.length&&(i=arguments[0]),this.style.queryRenderedFeatures(this._makeQueryGeometry(e),i,this.transform.zoom,this.transform.angle)},e.prototype._makeQueryGeometry=function(t){var e=this;void 0===t&&(t=[Point.convert([0,0]),Point.convert([this.transform.width,this.transform.height])]);var i,o=t instanceof Point||"number"==typeof t[0];if(o){var s=Point.convert(t);i=[s]}else{var r=[Point.convert(t[0]),Point.convert(t[1])];i=[r[0],new Point(r[1].x,r[0].y),r[1],new Point(r[0].x,r[1].y),r[0]]}return i=i.map(function(t){return e.transform.pointCoordinate(t)})},e.prototype.querySourceFeatures=function(t,e){return this.style.querySourceFeatures(t,e)},e.prototype.setStyle=function(t,e){var i=(!e||e.diff!==!1)&&this.style&&t&&!(t instanceof Style)&&"string"!=typeof t;if(i)try{return this.style.setState(t)&&this._update(!0),this}catch(t){util.warnOnce("Unable to perform style diff: "+(t.message||t.error||t)+".  Rebuilding the style from scratch.")}return this.style&&(this.style.setEventedParent(null),this.style._remove(),this.off("rotate",this.style._redoPlacement),this.off("pitch",this.style._redoPlacement)),t?(t instanceof Style?this.style=t:this.style=new Style(t,this),this.style.setEventedParent(this,{style:this.style}),this.on("rotate",this.style._redoPlacement),this.on("pitch",this.style._redoPlacement),this):(this.style=null,this)},e.prototype.getStyle=function(){if(this.style)return this.style.serialize()},e.prototype.addSource=function(t,e){return this.style.addSource(t,e),this._update(!0),this},e.prototype.isSourceLoaded=function(t){var e=this.style&&this.style.sourceCaches[t];return void 0===e?void this.fire("error",{error:new Error("There is no source with ID '"+t+"'")}):e.loaded()},e.prototype.addSourceType=function(t,e,i){return this.style.addSourceType(t,e,i)},e.prototype.removeSource=function(t){return this.style.removeSource(t),this._update(!0),this},e.prototype.getSource=function(t){return this.style.getSource(t)},e.prototype.addLayer=function(t,e){return this.style.addLayer(t,e),this._update(!0),this},e.prototype.moveLayer=function(t,e){return this.style.moveLayer(t,e),this._update(!0),this},e.prototype.removeLayer=function(t){return this.style.removeLayer(t),this._update(!0),this},e.prototype.getLayer=function(t){return this.style.getLayer(t)},e.prototype.setFilter=function(t,e){return this.style.setFilter(t,e),this._update(!0),this},e.prototype.setLayerZoomRange=function(t,e,i){return this.style.setLayerZoomRange(t,e,i),this._update(!0),this},e.prototype.getFilter=function(t){return this.style.getFilter(t)},e.prototype.setPaintProperty=function(t,e,i,o){return this.style.setPaintProperty(t,e,i,o),this._update(!0),this},e.prototype.getPaintProperty=function(t,e,i){return this.style.getPaintProperty(t,e,i)},e.prototype.setLayoutProperty=function(t,e,i){return this.style.setLayoutProperty(t,e,i),this._update(!0),this},e.prototype.getLayoutProperty=function(t,e){return this.style.getLayoutProperty(t,e)},e.prototype.setLight=function(t){return this.style.setLight(t),this._update(!0),this},e.prototype.getLight=function(){return this.style.getLight()},e.prototype.getContainer=function(){return this._container},e.prototype.getCanvasContainer=function(){return this._canvasContainer},e.prototype.getCanvas=function(){return this._canvas},e.prototype._containerDimensions=function(){var t=0,e=0;return this._container&&(t=this._container.offsetWidth||400,e=this._container.offsetHeight||300),[t,e]},e.prototype._setupContainer=function(){var t=this._container;t.classList.add("mapboxgl-map");var e=this._canvasContainer=DOM.create("div","mapboxgl-canvas-container",t);this._interactive&&e.classList.add("mapboxgl-interactive"),this._canvas=DOM.create("canvas","mapboxgl-canvas",e),this._canvas.style.position="absolute",this._canvas.addEventListener("webglcontextlost",this._contextLost,!1),this._canvas.addEventListener("webglcontextrestored",this._contextRestored,!1),this._canvas.setAttribute("tabindex",0),this._canvas.setAttribute("aria-label","Map");var i=this._containerDimensions();this._resizeCanvas(i[0],i[1]);var o=this._controlContainer=DOM.create("div","mapboxgl-control-container",t),s=this._controlPositions={};["top-left","top-right","bottom-left","bottom-right"].forEach(function(t){s[t]=DOM.create("div","mapboxgl-ctrl-"+t,o)})},e.prototype._resizeCanvas=function(t,e){var i=window.devicePixelRatio||1;this._canvas.width=i*t,this._canvas.height=i*e,this._canvas.style.width=t+"px",this._canvas.style.height=e+"px"},e.prototype._setupPainter=function(){var t=util.extend({failIfMajorPerformanceCaveat:this._failIfMajorPerformanceCaveat,preserveDrawingBuffer:this._preserveDrawingBuffer},isSupported.webGLContextAttributes),e=this._canvas.getContext("webgl",t)||this._canvas.getContext("experimental-webgl",t);return e?void(this.painter=new Painter(e,this.transform)):void this.fire("error",{error:new Error("Failed to initialize WebGL")})},e.prototype._contextLost=function(t){t.preventDefault(),this._frameId&&browser.cancelFrame(this._frameId),this.fire("webglcontextlost",{originalEvent:t})},e.prototype._contextRestored=function(t){this._setupPainter(),this.resize(),this._update(),this.fire("webglcontextrestored",{originalEvent:t})},e.prototype.loaded=function(){return!this._styleDirty&&!this._sourcesDirty&&!(!this.style||!this.style.loaded())},e.prototype._update=function(t){return this.style?(this._styleDirty=this._styleDirty||t,this._sourcesDirty=!0,this._rerender(),this):this},e.prototype._render=function(){return this.style&&this._styleDirty&&(this._styleDirty=!1,this.style.update(this._classes,this._classOptions),this._classOptions=null,this.style._recalculate(this.transform.zoom)),this.style&&this._sourcesDirty&&(this._sourcesDirty=!1,this.style._updateSources(this.transform)),this.painter.render(this.style,{showTileBoundaries:this.showTileBoundaries,showOverdrawInspector:this._showOverdrawInspector,rotating:this.rotating,zooming:this.zooming}),this.fire("render"),this.loaded()&&!this._loaded&&(this._loaded=!0,this.fire("load")),this._frameId=null,this.animationLoop.stopped()||(this._styleDirty=!0),(this._sourcesDirty||this._repaint||this._styleDirty)&&this._rerender(),this},e.prototype.remove=function(){this._hash&&this._hash.remove(),browser.cancelFrame(this._frameId),this.setStyle(null),"undefined"!=typeof window&&window.removeEventListener("resize",this._onWindowResize,!1);var t=this.painter.gl.getExtension("WEBGL_lose_context");t&&t.loseContext(),removeNode(this._canvasContainer),removeNode(this._controlContainer),this._container.classList.remove("mapboxgl-map"),this.fire("remove")},e.prototype._rerender=function(){this.style&&!this._frameId&&(this._frameId=browser.frame(this._render))},e.prototype._onWindowOnline=function(){this._update()},e.prototype._onWindowResize=function(){this._trackResize&&this.stop().resize()._update()},i.showTileBoundaries.get=function(){return!!this._showTileBoundaries},i.showTileBoundaries.set=function(t){this._showTileBoundaries!==t&&(this._showTileBoundaries=t,this._update())},i.showCollisionBoxes.get=function(){return!!this._showCollisionBoxes},i.showCollisionBoxes.set=function(t){this._showCollisionBoxes!==t&&(this._showCollisionBoxes=t,this.style._redoPlacement())},i.showOverdrawInspector.get=function(){return!!this._showOverdrawInspector},i.showOverdrawInspector.set=function(t){this._showOverdrawInspector!==t&&(this._showOverdrawInspector=t,this._update())},i.repaint.get=function(){return!!this._repaint},i.repaint.set=function(t){this._repaint=t,this._update()},i.vertices.get=function(){return!!this._vertices},i.vertices.set=function(t){this._vertices=t,this._update()},e.prototype._onData=function(t){this._update("style"===t.dataType),this.fire(t.dataType+"data",t)},e.prototype._onDataLoading=function(t){this.fire(t.dataType+"dataloading",t)},Object.defineProperties(e.prototype,i),e}(Camera);module.exports=Map;
},{"../geo/lng_lat":19,"../geo/lng_lat_bounds":20,"../geo/transform":21,"../render/painter":36,"../style/animation_loop":59,"../style/style":63,"../util/browser":110,"../util/dom":117,"../util/util":129,"../util/window":112,"./bind_handlers":91,"./camera":92,"./control/attribution_control":93,"./hash":104,"mapbox-gl-supported":193,"point-geometry":197}],106:[function(require,module,exports){
"use strict";var DOM=require("../util/dom"),LngLat=require("../geo/lng_lat"),Point=require("point-geometry"),Marker=function(t,e){this._offset=Point.convert(e&&e.offset||[0,0]),this._update=this._update.bind(this),this._onMapClick=this._onMapClick.bind(this),t||(t=DOM.create("div")),t.classList.add("mapboxgl-marker"),this._element=t,this._popup=null};Marker.prototype.addTo=function(t){return this.remove(),this._map=t,t.getCanvasContainer().appendChild(this._element),t.on("move",this._update),t.on("moveend",this._update),this._update(),this._map.on("click",this._onMapClick),this},Marker.prototype.remove=function(){return this._map&&(this._map.off("click",this._onMapClick),this._map.off("move",this._update),this._map.off("moveend",this._update),this._map=null),DOM.remove(this._element),this._popup&&this._popup.remove(),this},Marker.prototype.getLngLat=function(){return this._lngLat},Marker.prototype.setLngLat=function(t){return this._lngLat=LngLat.convert(t),this._popup&&this._popup.setLngLat(this._lngLat),this._update(),this},Marker.prototype.getElement=function(){return this._element},Marker.prototype.setPopup=function(t){return this._popup&&(this._popup.remove(),this._popup=null),t&&(this._popup=t,this._popup.setLngLat(this._lngLat)),this},Marker.prototype._onMapClick=function(t){var e=t.originalEvent.target,p=this._element;this._popup&&(e===p||p.contains(e))&&this.togglePopup()},Marker.prototype.getPopup=function(){return this._popup},Marker.prototype.togglePopup=function(){var t=this._popup;t&&(t.isOpen()?t.remove():t.addTo(this._map))},Marker.prototype._update=function(t){if(this._map){var e=this._map.project(this._lngLat)._add(this._offset);t&&"moveend"!==t.type||(e=e.round()),DOM.setTransform(this._element,"translate("+e.x+"px, "+e.y+"px)")}},module.exports=Marker;
},{"../geo/lng_lat":19,"../util/dom":117,"point-geometry":197}],107:[function(require,module,exports){
"use strict";function normalizeOffset(t){if(t){if("number"==typeof t){var o=Math.round(Math.sqrt(.5*Math.pow(t,2)));return{top:new Point(0,t),"top-left":new Point(o,o),"top-right":new Point(-o,o),bottom:new Point(0,-t),"bottom-left":new Point(o,-o),"bottom-right":new Point(-o,-o),left:new Point(t,0),right:new Point(-t,0)}}if(isPointLike(t)){var e=Point.convert(t);return{top:e,"top-left":e,"top-right":e,bottom:e,"bottom-left":e,"bottom-right":e,left:e,right:e}}return{top:Point.convert(t.top||[0,0]),"top-left":Point.convert(t["top-left"]||[0,0]),"top-right":Point.convert(t["top-right"]||[0,0]),bottom:Point.convert(t.bottom||[0,0]),"bottom-left":Point.convert(t["bottom-left"]||[0,0]),"bottom-right":Point.convert(t["bottom-right"]||[0,0]),left:Point.convert(t.left||[0,0]),right:Point.convert(t.right||[0,0])}}return normalizeOffset(new Point(0,0))}function isPointLike(t){return t instanceof Point||Array.isArray(t)}var util=require("../util/util"),Evented=require("../util/evented"),DOM=require("../util/dom"),LngLat=require("../geo/lng_lat"),Point=require("point-geometry"),window=require("../util/window"),defaultOptions={closeButton:!0,closeOnClick:!0},Popup=function(t){function o(o){t.call(this),this.options=util.extend(Object.create(defaultOptions),o),util.bindAll(["_update","_onClickClose"],this)}return t&&(o.__proto__=t),o.prototype=Object.create(t&&t.prototype),o.prototype.constructor=o,o.prototype.addTo=function(t){return this._map=t,this._map.on("move",this._update),this.options.closeOnClick&&this._map.on("click",this._onClickClose),this._update(),this},o.prototype.isOpen=function(){return!!this._map},o.prototype.remove=function(){return this._content&&this._content.parentNode&&this._content.parentNode.removeChild(this._content),this._container&&(this._container.parentNode.removeChild(this._container),delete this._container),this._map&&(this._map.off("move",this._update),this._map.off("click",this._onClickClose),delete this._map),this.fire("close"),this},o.prototype.getLngLat=function(){return this._lngLat},o.prototype.setLngLat=function(t){return this._lngLat=LngLat.convert(t),this._update(),this},o.prototype.setText=function(t){return this.setDOMContent(window.document.createTextNode(t))},o.prototype.setHTML=function(t){var o,e=window.document.createDocumentFragment(),n=window.document.createElement("body");for(n.innerHTML=t;;){if(o=n.firstChild,!o)break;e.appendChild(o)}return this.setDOMContent(e)},o.prototype.setDOMContent=function(t){return this._createContent(),this._content.appendChild(t),this._update(),this},o.prototype._createContent=function(){this._content&&this._content.parentNode&&this._content.parentNode.removeChild(this._content),this._content=DOM.create("div","mapboxgl-popup-content",this._container),this.options.closeButton&&(this._closeButton=DOM.create("button","mapboxgl-popup-close-button",this._content),this._closeButton.type="button",this._closeButton.innerHTML="&#215;",this._closeButton.addEventListener("click",this._onClickClose))},o.prototype._update=function(){if(this._map&&this._lngLat&&this._content){this._container||(this._container=DOM.create("div","mapboxgl-popup",this._map.getContainer()),this._tip=DOM.create("div","mapboxgl-popup-tip",this._container),this._container.appendChild(this._content));var t=this.options.anchor,o=normalizeOffset(this.options.offset),e=this._map.project(this._lngLat).round();if(!t){var n=this._container.offsetWidth,i=this._container.offsetHeight;t=e.y+o.bottom.y<i?["top"]:e.y>this._map.transform.height-i?["bottom"]:[],e.x<n/2?t.push("left"):e.x>this._map.transform.width-n/2&&t.push("right"),t=0===t.length?"bottom":t.join("-")}var r=e.add(o[t]),s={top:"translate(-50%,0)","top-left":"translate(0,0)","top-right":"translate(-100%,0)",bottom:"translate(-50%,-100%)","bottom-left":"translate(0,-100%)","bottom-right":"translate(-100%,-100%)",left:"translate(0,-50%)",right:"translate(-100%,-50%)"},p=this._container.classList;for(var a in s)p.remove("mapboxgl-popup-anchor-"+a);p.add("mapboxgl-popup-anchor-"+t),DOM.setTransform(this._container,s[t]+" translate("+r.x+"px,"+r.y+"px)")}},o.prototype._onClickClose=function(){this.remove()},o}(Evented);module.exports=Popup;
},{"../geo/lng_lat":19,"../util/dom":117,"../util/evented":118,"../util/util":129,"../util/window":112,"point-geometry":197}],108:[function(require,module,exports){
"use strict";var Actor=function(t,e,a){this.target=t,this.parent=e,this.mapId=a,this.callbacks={},this.callbackID=0,this.receive=this.receive.bind(this),this.target.addEventListener("message",this.receive,!1)};Actor.prototype.send=function(t,e,a,r,s){var i=a?this.mapId+":"+this.callbackID++:null;a&&(this.callbacks[i]=a),this.target.postMessage({targetMapId:s,sourceMapId:this.mapId,type:t,id:String(i),data:e},r)},Actor.prototype.receive=function(t){var e,a=this,r=t.data,s=r.id;if(!r.targetMapId||this.mapId===r.targetMapId){var i=function(t,e,r){a.target.postMessage({sourceMapId:a.mapId,type:"<response>",id:String(s),error:t?String(t):null,data:e},r)};if("<response>"===r.type)e=this.callbacks[r.id],delete this.callbacks[r.id],e&&e(r.error||null,r.data);else if("undefined"!=typeof r.id&&this.parent[r.type])this.parent[r.type](r.sourceMapId,r.data,i);else if("undefined"!=typeof r.id&&this.parent.getWorkerSource){var p=r.type.split("."),d=this.parent.getWorkerSource(r.sourceMapId,p[0]);d[p[1]](r.data,i)}else this.parent[r.type](r.data)}},Actor.prototype.remove=function(){this.target.removeEventListener("message",this.receive,!1)},module.exports=Actor;
},{}],109:[function(require,module,exports){
"use strict";function sameOrigin(e){var t=window.document.createElement("a");return t.href=e,t.protocol===window.document.location.protocol&&t.host===window.document.location.host}var window=require("./window");exports.getJSON=function(e,t){var n=new window.XMLHttpRequest;return n.open("GET",e,!0),n.setRequestHeader("Accept","application/json"),n.onerror=function(e){t(e)},n.onload=function(){if(n.status>=200&&n.status<300&&n.response){var e;try{e=JSON.parse(n.response)}catch(e){return t(e)}t(null,e)}else t(new Error(n.statusText))},n.send(),n},exports.getArrayBuffer=function(e,t){var n=new window.XMLHttpRequest;return n.open("GET",e,!0),n.responseType="arraybuffer",n.onerror=function(e){t(e)},n.onload=function(){return 0===n.response.byteLength&&200===n.status?t(new Error("http status 200 returned without content.")):void(n.status>=200&&n.status<300&&n.response?t(null,{data:n.response,cacheControl:n.getResponseHeader("Cache-Control"),expires:n.getResponseHeader("Expires")}):t(new Error(n.statusText)))},n.send(),n};var transparentPngUrl="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";exports.getImage=function(e,t){return exports.getArrayBuffer(e,function(e,n){if(e)return t(e);var r=new window.Image,o=window.URL||window.webkitURL;r.onload=function(){t(null,r),o.revokeObjectURL(r.src)};var a=new window.Blob([new Uint8Array(n.data)],{type:"image/png"});r.cacheControl=n.cacheControl,r.expires=n.expires,r.src=n.data.byteLength?o.createObjectURL(a):transparentPngUrl})},exports.getVideo=function(e,t){var n=window.document.createElement("video");n.onloadstart=function(){t(null,n)};for(var r=0;r<e.length;r++){var o=window.document.createElement("source");sameOrigin(e[r])||(n.crossOrigin="Anonymous"),o.src=e[r],n.appendChild(o)}return n};
},{"./window":112}],110:[function(require,module,exports){
"use strict";var window=require("./window");module.exports.now=function(){return window.performance&&window.performance.now?window.performance.now.bind(window.performance):Date.now.bind(Date)}();var frame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;exports.frame=function(e){return frame(e)};var cancel=window.cancelAnimationFrame||window.mozCancelAnimationFrame||window.webkitCancelAnimationFrame||window.msCancelAnimationFrame;exports.cancelFrame=function(e){cancel(e)},exports.timed=function(e,n,t){function o(i){r||(i=module.exports.now(),i>=a+n?e.call(t,1):(e.call(t,(i-a)/n),exports.frame(o)))}if(!n)return e.call(t,1),null;var r=!1,a=module.exports.now();return exports.frame(o),function(){r=!0}},exports.getImageData=function(e){var n=window.document.createElement("canvas"),t=n.getContext("2d");return n.width=e.width,n.height=e.height,t.drawImage(e,0,0),t.getImageData(0,0,e.width,e.height).data},exports.supported=require("mapbox-gl-supported"),exports.hardwareConcurrency=window.navigator.hardwareConcurrency||4,Object.defineProperty(exports,"devicePixelRatio",{get:function(){return window.devicePixelRatio}}),exports.supportsWebp=!1;var webpImgTest=window.document.createElement("img");webpImgTest.onload=function(){exports.supportsWebp=!0},webpImgTest.src="data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=";
},{"./window":112,"mapbox-gl-supported":193}],111:[function(require,module,exports){
"use strict";var WebWorkify=require("webworkify"),window=require("../window"),workerURL=window.URL.createObjectURL(new WebWorkify(require("../../source/worker"),{bare:!0}));module.exports=function(){return new window.Worker(workerURL)};
},{"../../source/worker":57,"../window":112,"webworkify":213}],112:[function(require,module,exports){
"use strict";module.exports=self;
},{}],113:[function(require,module,exports){
"use strict";function compareAreas(e,r){return r.area-e.area}var quickselect=require("quickselect"),calculateSignedArea=require("./util").calculateSignedArea;module.exports=function(e,r){var a=e.length;if(a<=1)return[e];for(var t,u,c=[],i=0;i<a;i++){var l=calculateSignedArea(e[i]);0!==l&&(e[i].area=Math.abs(l),void 0===u&&(u=l<0),u===l<0?(t&&c.push(t),t=[e[i]]):t.push(e[i]))}if(t&&c.push(t),r>1)for(var n=0;n<c.length;n++)c[n].length<=r||(quickselect(c[n],r,1,c[n].length-1,compareAreas),c[n]=c[n].slice(0,r));return c};
},{"./util":129,"quickselect":199}],114:[function(require,module,exports){
"use strict";var config={API_URL:"https://api.mapbox.com",REQUIRE_ACCESS_TOKEN:!0,ACCESS_TOKEN:null};module.exports=config;
},{}],115:[function(require,module,exports){
"use strict";var DictionaryCoder=function(r){var t=this;this._stringToNumber={},this._numberToString=[];for(var o=0;o<r.length;o++){var i=r[o];t._stringToNumber[i]=o,t._numberToString[o]=i}};DictionaryCoder.prototype.encode=function(r){return this._stringToNumber[r]},DictionaryCoder.prototype.decode=function(r){return this._numberToString[r]},module.exports=DictionaryCoder;
},{}],116:[function(require,module,exports){
"use strict";var util=require("./util"),Actor=require("./actor"),Dispatcher=function(t,r){var o=this;this.workerPool=t,this.actors=[],this.currentActor=0,this.id=util.uniqueId();for(var i=this.workerPool.acquire(this.id),e=0;e<i.length;e++){var s=i[e],c=new Actor(s,r,o.id);c.name="Worker "+e,o.actors.push(c)}};Dispatcher.prototype.broadcast=function(t,r,o){o=o||function(){},util.asyncAll(this.actors,function(o,i){o.send(t,r,i)},o)},Dispatcher.prototype.send=function(t,r,o,i,e){return("number"!=typeof i||isNaN(i))&&(i=this.currentActor=(this.currentActor+1)%this.actors.length),this.actors[i].send(t,r,o,e),i},Dispatcher.prototype.remove=function(){this.actors.forEach(function(t){t.remove()}),this.actors=[],this.workerPool.release(this.id)},module.exports=Dispatcher;
},{"./actor":108,"./util":129}],117:[function(require,module,exports){
"use strict";function testProp(e){for(var t=0;t<e.length;t++)if(e[t]in docStyle)return e[t];return e[0]}function suppressClick(e){e.preventDefault(),e.stopPropagation(),window.removeEventListener("click",suppressClick,!0)}var Point=require("point-geometry"),window=require("./window");exports.create=function(e,t,o){var n=window.document.createElement(e);return t&&(n.className=t),o&&o.appendChild(n),n};var docStyle=window.document.documentElement.style,selectProp=testProp(["userSelect","MozUserSelect","WebkitUserSelect","msUserSelect"]),userSelect;exports.disableDrag=function(){selectProp&&(userSelect=docStyle[selectProp],docStyle[selectProp]="none")},exports.enableDrag=function(){selectProp&&(docStyle[selectProp]=userSelect)};var transformProp=testProp(["transform","WebkitTransform"]);exports.setTransform=function(e,t){e.style[transformProp]=t},exports.suppressClick=function(){window.addEventListener("click",suppressClick,!0),window.setTimeout(function(){window.removeEventListener("click",suppressClick,!0)},0)},exports.mousePos=function(e,t){var o=e.getBoundingClientRect();return t=t.touches?t.touches[0]:t,new Point(t.clientX-o.left-e.clientLeft,t.clientY-o.top-e.clientTop)},exports.touchPos=function(e,t){for(var o=e.getBoundingClientRect(),n=[],r="touchend"===t.type?t.changedTouches:t.touches,s=0;s<r.length;s++)n.push(new Point(r[s].clientX-o.left-e.clientLeft,r[s].clientY-o.top-e.clientTop));return n},exports.remove=function(e){e.parentNode&&e.parentNode.removeChild(e)};
},{"./window":112,"point-geometry":197}],118:[function(require,module,exports){
"use strict";var util=require("./util"),Evented=function(){};Evented.prototype.on=function(e,t){return this._listeners=this._listeners||{},this._listeners[e]=this._listeners[e]||[],this._listeners[e].push(t),this},Evented.prototype.off=function(e,t){if(this._listeners&&this._listeners[e]){var n=this._listeners[e].indexOf(t);n!==-1&&this._listeners[e].splice(n,1)}return this},Evented.prototype.once=function(e,t){var n=this,s=function(i){n.off(e,s),t.call(n,i)};return this.on(e,s),this},Evented.prototype.fire=function(e,t){var n=this;if(this.listens(e)){t=util.extend({},t,{type:e,target:this});for(var s=this._listeners&&this._listeners[e]?this._listeners[e].slice():[],i=0;i<s.length;i++)s[i].call(n,t);this._eventedParent&&this._eventedParent.fire(e,util.extend({},t,this._eventedParentData))}else util.endsWith(e,"error")&&console.error(t&&t.error||t||"Empty error event");return this},Evented.prototype.listens=function(e){return this._listeners&&this._listeners[e]||this._eventedParent&&this._eventedParent.listens(e)},Evented.prototype.setEventedParent=function(e,t){return this._eventedParent=e,this._eventedParentData="function"==typeof t?t():t,this},module.exports=Evented;
},{"./util":129}],119:[function(require,module,exports){
"use strict";function compareMax(e,t){return t.max-e.max}function Cell(e,t,n,r){this.p=new Point(e,t),this.h=n,this.d=pointToPolygonDist(this.p,r),this.max=this.d+this.h*Math.SQRT2}function pointToPolygonDist(e,t){for(var n=!1,r=1/0,o=0;o<t.length;o++)for(var l=t[o],i=0,s=l.length,u=s-1;i<s;u=i++){var a=l[i],h=l[u];a.y>e.y!=h.y>e.y&&e.x<(h.x-a.x)*(e.y-a.y)/(h.y-a.y)+a.x&&(n=!n),r=Math.min(r,distToSegmentSquared(e,a,h))}return(n?1:-1)*Math.sqrt(r)}function getCentroidCell(e){for(var t=0,n=0,r=0,o=e[0],l=0,i=o.length,s=i-1;l<i;s=l++){var u=o[l],a=o[s],h=u.x*a.y-a.x*u.y;n+=(u.x+a.x)*h,r+=(u.y+a.y)*h,t+=3*h}return new Cell(n/t,r/t,0,e)}var Queue=require("tinyqueue"),Point=require("point-geometry"),distToSegmentSquared=require("./intersection_tests").distToSegmentSquared;module.exports=function(e,t,n){t=t||1;for(var r,o,l,i,s=e[0],u=0;u<s.length;u++){var a=s[u];(!u||a.x<r)&&(r=a.x),(!u||a.y<o)&&(o=a.y),(!u||a.x>l)&&(l=a.x),(!u||a.y>i)&&(i=a.y)}for(var h=l-r,p=i-o,y=Math.min(h,p),x=y/2,d=new Queue(null,compareMax),g=r;g<l;g+=y)for(var f=o;f<i;f+=y)d.push(new Cell(g+x,f+x,x,e));for(var m=getCentroidCell(e),c=d.length;d.length;){var v=d.pop();v.d>m.d&&(m=v,n&&console.log("found best %d after %d probes",Math.round(1e4*v.d)/1e4,c)),v.max-m.d<=t||(x=v.h/2,d.push(new Cell(v.p.x-x,v.p.y-x,x,e)),d.push(new Cell(v.p.x+x,v.p.y-x,x,e)),d.push(new Cell(v.p.x-x,v.p.y+x,x,e)),d.push(new Cell(v.p.x+x,v.p.y+x,x,e)),c+=4)}return n&&(console.log("num probes: "+c),console.log("best distance: "+m.d)),m.p};
},{"./intersection_tests":122,"point-geometry":197,"tinyqueue":202}],120:[function(require,module,exports){
"use strict";function Glyphs(a,e){this.stacks=a.readFields(readFontstacks,[],e)}function readFontstacks(a,e,r){if(1===a){var t=r.readMessage(readFontstack,{glyphs:{}});e.push(t)}}function readFontstack(a,e,r){if(1===a)e.name=r.readString();else if(2===a)e.range=r.readString();else if(3===a){var t=r.readMessage(readGlyph,{});e.glyphs[t.id]=t}}function readGlyph(a,e,r){1===a?e.id=r.readVarint():2===a?e.bitmap=r.readBytes():3===a?e.width=r.readVarint():4===a?e.height=r.readVarint():5===a?e.left=r.readSVarint():6===a?e.top=r.readSVarint():7===a&&(e.advance=r.readVarint())}module.exports=Glyphs;
},{}],121:[function(require,module,exports){
"use strict";function interpolate(t,e,n){return t*(1-n)+e*n}module.exports=interpolate,interpolate.number=interpolate,interpolate.vec2=function(t,e,n){return[interpolate(t[0],e[0],n),interpolate(t[1],e[1],n)]},interpolate.color=function(t,e,n){return[interpolate(t[0],e[0],n),interpolate(t[1],e[1],n),interpolate(t[2],e[2],n),interpolate(t[3],e[3],n)]},interpolate.array=function(t,e,n){return t.map(function(t,r){return interpolate(t,e[r],n)})};
},{}],122:[function(require,module,exports){
"use strict";function polygonIntersectsPolygon(n,t){for(var e=0;e<n.length;e++)if(polygonContainsPoint(t,n[e]))return!0;for(var r=0;r<t.length;r++)if(polygonContainsPoint(n,t[r]))return!0;return!!lineIntersectsLine(n,t)}function multiPolygonIntersectsBufferedMultiPoint(n,t,e){for(var r=0;r<n.length;r++)for(var o=n[r],i=0;i<t.length;i++)for(var l=t[i],u=0;u<l.length;u++){var s=l[u];if(polygonContainsPoint(o,s))return!0;if(pointIntersectsBufferedLine(s,o,e))return!0}return!1}function multiPolygonIntersectsMultiPolygon(n,t){if(1===n.length&&1===n[0].length)return multiPolygonContainsPoint(t,n[0][0]);for(var e=0;e<t.length;e++)for(var r=t[e],o=0;o<r.length;o++)if(multiPolygonContainsPoint(n,r[o]))return!0;for(var i=0;i<n.length;i++){for(var l=n[i],u=0;u<l.length;u++)if(multiPolygonContainsPoint(t,l[u]))return!0;for(var s=0;s<t.length;s++)if(lineIntersectsLine(l,t[s]))return!0}return!1}function multiPolygonIntersectsBufferedMultiLine(n,t,e){for(var r=0;r<t.length;r++)for(var o=t[r],i=0;i<n.length;i++){var l=n[i];if(l.length>=3)for(var u=0;u<o.length;u++)if(polygonContainsPoint(l,o[u]))return!0;if(lineIntersectsBufferedLine(l,o,e))return!0}return!1}function lineIntersectsBufferedLine(n,t,e){if(n.length>1){if(lineIntersectsLine(n,t))return!0;for(var r=0;r<t.length;r++)if(pointIntersectsBufferedLine(t[r],n,e))return!0}for(var o=0;o<n.length;o++)if(pointIntersectsBufferedLine(n[o],t,e))return!0;return!1}function lineIntersectsLine(n,t){if(0===n.length||0===t.length)return!1;for(var e=0;e<n.length-1;e++)for(var r=n[e],o=n[e+1],i=0;i<t.length-1;i++){var l=t[i],u=t[i+1];if(lineSegmentIntersectsLineSegment(r,o,l,u))return!0}return!1}function lineSegmentIntersectsLineSegment(n,t,e,r){return isCounterClockwise(n,e,r)!==isCounterClockwise(t,e,r)&&isCounterClockwise(n,t,e)!==isCounterClockwise(n,t,r)}function pointIntersectsBufferedLine(n,t,e){var r=e*e;if(1===t.length)return n.distSqr(t[0])<r;for(var o=1;o<t.length;o++){var i=t[o-1],l=t[o];if(distToSegmentSquared(n,i,l)<r)return!0}return!1}function distToSegmentSquared(n,t,e){var r=t.distSqr(e);if(0===r)return n.distSqr(t);var o=((n.x-t.x)*(e.x-t.x)+(n.y-t.y)*(e.y-t.y))/r;return o<0?n.distSqr(t):o>1?n.distSqr(e):n.distSqr(e.sub(t)._mult(o)._add(t))}function multiPolygonContainsPoint(n,t){for(var e,r,o,i=!1,l=0;l<n.length;l++){e=n[l];for(var u=0,s=e.length-1;u<e.length;s=u++)r=e[u],o=e[s],r.y>t.y!=o.y>t.y&&t.x<(o.x-r.x)*(t.y-r.y)/(o.y-r.y)+r.x&&(i=!i)}return i}function polygonContainsPoint(n,t){for(var e=!1,r=0,o=n.length-1;r<n.length;o=r++){var i=n[r],l=n[o];i.y>t.y!=l.y>t.y&&t.x<(l.x-i.x)*(t.y-i.y)/(l.y-i.y)+i.x&&(e=!e)}return e}var isCounterClockwise=require("./util").isCounterClockwise;module.exports={multiPolygonIntersectsBufferedMultiPoint:multiPolygonIntersectsBufferedMultiPoint,multiPolygonIntersectsMultiPolygon:multiPolygonIntersectsMultiPolygon,multiPolygonIntersectsBufferedMultiLine:multiPolygonIntersectsBufferedMultiLine,polygonIntersectsPolygon:polygonIntersectsPolygon,distToSegmentSquared:distToSegmentSquared};
},{"./util":129}],123:[function(require,module,exports){
"use strict";var unicodeBlockLookup={"Latin-1 Supplement":function(n){return n>=128&&n<=255},"Hangul Jamo":function(n){return n>=4352&&n<=4607},"Unified Canadian Aboriginal Syllabics":function(n){return n>=5120&&n<=5759},"Unified Canadian Aboriginal Syllabics Extended":function(n){return n>=6320&&n<=6399},"General Punctuation":function(n){return n>=8192&&n<=8303},"Letterlike Symbols":function(n){return n>=8448&&n<=8527},"Number Forms":function(n){return n>=8528&&n<=8591},"Miscellaneous Technical":function(n){return n>=8960&&n<=9215},"Control Pictures":function(n){return n>=9216&&n<=9279},"Optical Character Recognition":function(n){return n>=9280&&n<=9311},"Enclosed Alphanumerics":function(n){return n>=9312&&n<=9471},"Geometric Shapes":function(n){return n>=9632&&n<=9727},"Miscellaneous Symbols":function(n){return n>=9728&&n<=9983},"Miscellaneous Symbols and Arrows":function(n){return n>=11008&&n<=11263},"CJK Radicals Supplement":function(n){return n>=11904&&n<=12031},"Kangxi Radicals":function(n){return n>=12032&&n<=12255},"Ideographic Description Characters":function(n){return n>=12272&&n<=12287},"CJK Symbols and Punctuation":function(n){return n>=12288&&n<=12351},Hiragana:function(n){return n>=12352&&n<=12447},Katakana:function(n){return n>=12448&&n<=12543},Bopomofo:function(n){return n>=12544&&n<=12591},"Hangul Compatibility Jamo":function(n){return n>=12592&&n<=12687},Kanbun:function(n){return n>=12688&&n<=12703},"Bopomofo Extended":function(n){return n>=12704&&n<=12735},"CJK Strokes":function(n){return n>=12736&&n<=12783},"Katakana Phonetic Extensions":function(n){return n>=12784&&n<=12799},"Enclosed CJK Letters and Months":function(n){return n>=12800&&n<=13055},"CJK Compatibility":function(n){return n>=13056&&n<=13311},"CJK Unified Ideographs Extension A":function(n){return n>=13312&&n<=19903},"Yijing Hexagram Symbols":function(n){return n>=19904&&n<=19967},"CJK Unified Ideographs":function(n){return n>=19968&&n<=40959},"Yi Syllables":function(n){return n>=40960&&n<=42127},"Yi Radicals":function(n){return n>=42128&&n<=42191},"Hangul Jamo Extended-A":function(n){return n>=43360&&n<=43391},"Hangul Syllables":function(n){return n>=44032&&n<=55215},"Hangul Jamo Extended-B":function(n){return n>=55216&&n<=55295},"Private Use Area":function(n){return n>=57344&&n<=63743},"CJK Compatibility Ideographs":function(n){return n>=63744&&n<=64255},"Vertical Forms":function(n){return n>=65040&&n<=65055},"CJK Compatibility Forms":function(n){return n>=65072&&n<=65103},"Small Form Variants":function(n){return n>=65104&&n<=65135},"Halfwidth and Fullwidth Forms":function(n){return n>=65280&&n<=65519}};module.exports=unicodeBlockLookup;
},{}],124:[function(require,module,exports){
"use strict";var LRUCache=function(t,e){this.max=t,this.onRemove=e,this.reset()};LRUCache.prototype.reset=function(){var t=this;for(var e in this.data)t.onRemove(t.data[e]);return this.data={},this.order=[],this},LRUCache.prototype.add=function(t,e){if(this.has(t))this.order.splice(this.order.indexOf(t),1),this.data[t]=e,this.order.push(t);else if(this.data[t]=e,this.order.push(t),this.order.length>this.max){var r=this.get(this.order[0]);r&&this.onRemove(r)}return this},LRUCache.prototype.has=function(t){return t in this.data},LRUCache.prototype.keys=function(){return this.order},LRUCache.prototype.get=function(t){if(!this.has(t))return null;var e=this.data[t];return delete this.data[t],this.order.splice(this.order.indexOf(t),1),e},LRUCache.prototype.remove=function(t){if(!this.has(t))return this;var e=this.data[t];return delete this.data[t],this.onRemove(e),this.order.splice(this.order.indexOf(t),1),this},LRUCache.prototype.setMaxSize=function(t){var e=this;for(this.max=t;this.order.length>this.max;){var r=e.get(e.order[0]);r&&e.onRemove(r)}return this},module.exports=LRUCache;
},{}],125:[function(require,module,exports){
"use strict";function makeAPIURL(r,e){var t=parseUrl(config.API_URL);if(r.protocol=t.protocol,r.authority=t.authority,!config.REQUIRE_ACCESS_TOKEN)return formatUrl(r);if(e=e||config.ACCESS_TOKEN,!e)throw new Error("An API access token is required to use Mapbox GL. "+help);if("s"===e[0])throw new Error("Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). "+help);return r.params.push("access_token="+e),formatUrl(r)}function isMapboxURL(r){return 0===r.indexOf("mapbox:")}function replaceTempAccessToken(r){for(var e=0;e<r.length;e++)0===r[e].indexOf("access_token=tk.")&&(r[e]="access_token="+(config.ACCESS_TOKEN||""))}function parseUrl(r){var e=r.match(urlRe);if(!e)throw new Error("Unable to parse URL object");return{protocol:e[1],authority:e[2],path:e[3]||"/",params:e[4]?e[4].split("&"):[]}}function formatUrl(r){var e=r.params.length?"?"+r.params.join("&"):"";return r.protocol+"://"+r.authority+r.path+e}var config=require("./config"),browser=require("./browser"),help="See https://www.mapbox.com/developers/api/#access-tokens";exports.isMapboxURL=isMapboxURL,exports.normalizeStyleURL=function(r,e){if(!isMapboxURL(r))return r;var t=parseUrl(r);return t.path="/styles/v1"+t.path,makeAPIURL(t,e)},exports.normalizeGlyphsURL=function(r,e){if(!isMapboxURL(r))return r;var t=parseUrl(r);return t.path="/fonts/v1"+t.path,makeAPIURL(t,e)},exports.normalizeSourceURL=function(r,e){if(!isMapboxURL(r))return r;var t=parseUrl(r);return t.path="/v4/"+t.authority+".json",t.params.push("secure"),makeAPIURL(t,e)},exports.normalizeSpriteURL=function(r,e,t,o){var a=parseUrl(r);return isMapboxURL(r)?(a.path="/styles/v1"+a.path+"/sprite"+e+t,makeAPIURL(a,o)):(a.path+=""+e+t,formatUrl(a))};var imageExtensionRe=/(\.(png|jpg)\d*)(?=$)/;exports.normalizeTileURL=function(r,e,t){if(!e||!isMapboxURL(e))return r;var o=parseUrl(r),a=browser.devicePixelRatio>=2||512===t?"@2x":"",s=browser.supportsWebp?".webp":"$1";return o.path=o.path.replace(imageExtensionRe,""+a+s),replaceTempAccessToken(o.params),formatUrl(o)};var urlRe=/^(\w+):\/\/([^\/?]+)(\/[^?]+)?\??(.+)?/;
},{"./browser":110,"./config":114}],126:[function(require,module,exports){
"use strict";var isChar=require("./is_char_in_unicode_block");module.exports.allowsIdeographicBreaking=function(a){for(var i=0,r=a;i<r.length;i+=1){var s=r[i];if(!exports.charAllowsIdeographicBreaking(s.charCodeAt(0)))return!1}return!0},module.exports.allowsVerticalWritingMode=function(a){for(var i=0,r=a;i<r.length;i+=1){var s=r[i];if(exports.charHasUprightVerticalOrientation(s.charCodeAt(0)))return!0}return!1},module.exports.charAllowsIdeographicBreaking=function(a){return!(a<11904)&&(!!isChar["Bopomofo Extended"](a)||(!!isChar.Bopomofo(a)||(!!isChar["CJK Compatibility Forms"](a)||(!!isChar["CJK Compatibility Ideographs"](a)||(!!isChar["CJK Compatibility"](a)||(!!isChar["CJK Radicals Supplement"](a)||(!!isChar["CJK Strokes"](a)||(!!isChar["CJK Symbols and Punctuation"](a)||(!!isChar["CJK Unified Ideographs Extension A"](a)||(!!isChar["CJK Unified Ideographs"](a)||(!!isChar["Enclosed CJK Letters and Months"](a)||(!!isChar["Halfwidth and Fullwidth Forms"](a)||(!!isChar.Hiragana(a)||(!!isChar["Ideographic Description Characters"](a)||(!!isChar["Kangxi Radicals"](a)||(!!isChar["Katakana Phonetic Extensions"](a)||(!!isChar.Katakana(a)||(!!isChar["Vertical Forms"](a)||(!!isChar["Yi Radicals"](a)||!!isChar["Yi Syllables"](a))))))))))))))))))))},exports.charHasUprightVerticalOrientation=function(a){return 746===a||747===a||!(a<4352)&&(!!isChar["Bopomofo Extended"](a)||(!!isChar.Bopomofo(a)||(!(!isChar["CJK Compatibility Forms"](a)||a>=65097&&a<=65103)||(!!isChar["CJK Compatibility Ideographs"](a)||(!!isChar["CJK Compatibility"](a)||(!!isChar["CJK Radicals Supplement"](a)||(!!isChar["CJK Strokes"](a)||(!(!isChar["CJK Symbols and Punctuation"](a)||a>=12296&&a<=12305||a>=12308&&a<=12319||12336===a)||(!!isChar["CJK Unified Ideographs Extension A"](a)||(!!isChar["CJK Unified Ideographs"](a)||(!!isChar["Enclosed CJK Letters and Months"](a)||(!!isChar["Hangul Compatibility Jamo"](a)||(!!isChar["Hangul Jamo Extended-A"](a)||(!!isChar["Hangul Jamo Extended-B"](a)||(!!isChar["Hangul Jamo"](a)||(!!isChar["Hangul Syllables"](a)||(!!isChar.Hiragana(a)||(!!isChar["Ideographic Description Characters"](a)||(!!isChar.Kanbun(a)||(!!isChar["Kangxi Radicals"](a)||(!!isChar["Katakana Phonetic Extensions"](a)||(!(!isChar.Katakana(a)||12540===a)||(!(!isChar["Halfwidth and Fullwidth Forms"](a)||65288===a||65289===a||65293===a||a>=65306&&a<=65310||65339===a||65341===a||65343===a||a>=65371&&a<=65503||65507===a||a>=65512&&a<=65519)||(!(!isChar["Small Form Variants"](a)||a>=65112&&a<=65118||a>=65123&&a<=65126)||(!!isChar["Unified Canadian Aboriginal Syllabics"](a)||(!!isChar["Unified Canadian Aboriginal Syllabics Extended"](a)||(!!isChar["Vertical Forms"](a)||(!!isChar["Yijing Hexagram Symbols"](a)||(!!isChar["Yi Syllables"](a)||!!isChar["Yi Radicals"](a))))))))))))))))))))))))))))))},exports.charHasNeutralVerticalOrientation=function(a){return!(!isChar["Latin-1 Supplement"](a)||167!==a&&169!==a&&174!==a&&177!==a&&188!==a&&189!==a&&190!==a&&215!==a&&247!==a)||(!(!isChar["General Punctuation"](a)||8214!==a&&8224!==a&&8225!==a&&8240!==a&&8241!==a&&8251!==a&&8252!==a&&8258!==a&&8263!==a&&8264!==a&&8265!==a&&8273!==a)||(!!isChar["Letterlike Symbols"](a)||(!!isChar["Number Forms"](a)||(!(!isChar["Miscellaneous Technical"](a)||!(a>=8960&&a<=8967||a>=8972&&a<=8991||a>=8996&&a<=9e3||9003===a||a>=9085&&a<=9114||a>=9150&&a<=9165||9167===a||a>=9169&&a<=9179||a>=9186&&a<=9215))||(!(!isChar["Control Pictures"](a)||9251===a)||(!!isChar["Optical Character Recognition"](a)||(!!isChar["Enclosed Alphanumerics"](a)||(!!isChar["Geometric Shapes"](a)||(!(!isChar["Miscellaneous Symbols"](a)||a>=9754&&a<=9759)||(!(!isChar["Miscellaneous Symbols and Arrows"](a)||!(a>=11026&&a<=11055||a>=11088&&a<=11097||a>=11192&&a<=11243))||(!!isChar["CJK Symbols and Punctuation"](a)||(!!isChar.Katakana(a)||(!!isChar["Private Use Area"](a)||(!!isChar["CJK Compatibility Forms"](a)||(!!isChar["Small Form Variants"](a)||(!!isChar["Halfwidth and Fullwidth Forms"](a)||(8734===a||8756===a||8757===a||a>=9984&&a<=10087||a>=10102&&a<=10131||65532===a||65533===a)))))))))))))))))},exports.charHasRotatedVerticalOrientation=function(a){return!(exports.charHasUprightVerticalOrientation(a)||exports.charHasNeutralVerticalOrientation(a))};
},{"./is_char_in_unicode_block":123}],127:[function(require,module,exports){
"use strict";function createStructArrayType(t){var e=JSON.stringify(t);if(structArrayTypeCache[e])return structArrayTypeCache[e];var r=void 0===t.alignment?1:t.alignment,i=0,n=0,a=["Uint8"],o=t.members.map(function(t){a.indexOf(t.type)<0&&a.push(t.type);var e=sizeOf(t.type),o=i=align(i,Math.max(r,e)),s=t.components||1;return n=Math.max(n,e),i+=e*s,{name:t.name,type:t.type,components:s,offset:o}}),s=align(i,Math.max(n,r)),p=function(t){function e(){t.apply(this,arguments)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(Struct);p.prototype.alignment=r,p.prototype.size=s;for(var y=0,c=o;y<c.length;y+=1)for(var h=c[y],u=0;u<h.components;u++){var f=h.name+(1===h.components?"":u);Object.defineProperty(p.prototype,f,{get:createGetter(h,u),set:createSetter(h,u)})}var m=function(t){function e(){t.apply(this,arguments)}return t&&(e.__proto__=t),e.prototype=Object.create(t&&t.prototype),e.prototype.constructor=e,e}(StructArray);return m.prototype.members=o,m.prototype.StructType=p,m.prototype.bytesPerElement=s,m.prototype.emplaceBack=createEmplaceBack(o,s),m.prototype._usedTypes=a,structArrayTypeCache[e]=m,m}function align(t,e){return Math.ceil(t/e)*e}function sizeOf(t){return viewTypes[t].BYTES_PER_ELEMENT}function getArrayViewName(t){return t.toLowerCase()}function createEmplaceBack(t,e){for(var r=[],i=[],n="var i = this.length;\nthis.resize(this.length + 1);\n",a=0,o=t;a<o.length;a+=1){var s=o[a],p=sizeOf(s.type);r.indexOf(p)<0&&(r.push(p),n+="var o"+p.toFixed(0)+" = i * "+(e/p).toFixed(0)+";\n");for(var y=0;y<s.components;y++){var c="v"+i.length,h="o"+p.toFixed(0)+" + "+(s.offset/p+y).toFixed(0);n+="this."+getArrayViewName(s.type)+"["+h+"] = "+c+";\n",i.push(c)}}return n+="return i;",new Function(i.toString(),n)}function createMemberComponentString(t,e){var r="this._pos"+sizeOf(t.type).toFixed(0),i=(t.offset/sizeOf(t.type)+e).toFixed(0),n=r+" + "+i;return"this._structArray."+getArrayViewName(t.type)+"["+n+"]"}function createGetter(t,e){return new Function("return "+createMemberComponentString(t,e)+";")}function createSetter(t,e){return new Function("x",createMemberComponentString(t,e)+" = x;")}module.exports=createStructArrayType;var viewTypes={Int8:Int8Array,Uint8:Uint8Array,Uint8Clamped:Uint8ClampedArray,Int16:Int16Array,Uint16:Uint16Array,Int32:Int32Array,Uint32:Uint32Array,Float32:Float32Array,Float64:Float64Array},Struct=function(t,e){this._structArray=t,this._pos1=e*this.size,this._pos2=this._pos1/2,this._pos4=this._pos1/4,this._pos8=this._pos1/8},DEFAULT_CAPACITY=128,RESIZE_MULTIPLIER=5,StructArray=function(t){this.isTransferred=!1,void 0!==t?(this.arrayBuffer=t.arrayBuffer,this.length=t.length,this.capacity=this.arrayBuffer.byteLength/this.bytesPerElement,this._refreshViews()):(this.capacity=-1,this.resize(0))};StructArray.serialize=function(){return{members:this.prototype.members,alignment:this.prototype.StructType.prototype.alignment,bytesPerElement:this.prototype.bytesPerElement}},StructArray.prototype.serialize=function(t){return this._trim(),t&&(this.isTransferred=!0,t.push(this.arrayBuffer)),{length:this.length,arrayBuffer:this.arrayBuffer}},StructArray.prototype.get=function(t){return new this.StructType(this,t)},StructArray.prototype._trim=function(){this.length!==this.capacity&&(this.capacity=this.length,this.arrayBuffer=this.arrayBuffer.slice(0,this.length*this.bytesPerElement),this._refreshViews())},StructArray.prototype.resize=function(t){if(this.length=t,t>this.capacity){this.capacity=Math.max(t,Math.floor(this.capacity*RESIZE_MULTIPLIER),DEFAULT_CAPACITY),this.arrayBuffer=new ArrayBuffer(this.capacity*this.bytesPerElement);var e=this.uint8;this._refreshViews(),e&&this.uint8.set(e)}},StructArray.prototype._refreshViews=function(){for(var t=this,e=0,r=this._usedTypes;e<r.length;e+=1){var i=r[e];t[getArrayViewName(i)]=new viewTypes[i](t.arrayBuffer)}},StructArray.prototype.toArray=function(t,e){for(var r=this,i=[],n=t;n<e;n++){var a=r.get(n);i.push(a)}return i};var structArrayTypeCache={};
},{}],128:[function(require,module,exports){
"use strict";function resolveTokens(e,n){return n.replace(/{([^{}]+)}/g,function(n,r){return r in e?e[r]:""})}module.exports=resolveTokens;
},{}],129:[function(require,module,exports){
"use strict";var UnitBezier=require("@mapbox/unitbezier"),Coordinate=require("../geo/coordinate"),Point=require("point-geometry");exports.easeCubicInOut=function(r){if(r<=0)return 0;if(r>=1)return 1;var e=r*r,t=e*r;return 4*(r<.5?t:3*(r-e)+t-.75)},exports.bezier=function(r,e,t,n){var o=new UnitBezier(r,e,t,n);return function(r){return o.solve(r)}},exports.ease=exports.bezier(.25,.1,.25,1),exports.clamp=function(r,e,t){return Math.min(t,Math.max(e,r))},exports.wrap=function(r,e,t){var n=t-e,o=((r-e)%n+n)%n+e;return o===e?t:o},exports.asyncAll=function(r,e,t){if(!r.length)return t(null,[]);var n=r.length,o=new Array(r.length),a=null;r.forEach(function(r,i){e(r,function(r,e){r&&(a=r),o[i]=e,0===--n&&t(a,o)})})},exports.values=function(r){var e=[];for(var t in r)e.push(r[t]);return e},exports.keysDifference=function(r,e){var t=[];for(var n in r)n in e||t.push(n);return t},exports.extend=function(r,e,t,n){for(var o=arguments,a=1;a<arguments.length;a++){var i=o[a];for(var u in i)r[u]=i[u]}return r},exports.pick=function(r,e){for(var t={},n=0;n<e.length;n++){var o=e[n];o in r&&(t[o]=r[o])}return t};var id=1;exports.uniqueId=function(){return id++},exports.bindAll=function(r,e){r.forEach(function(r){e[r]&&(e[r]=e[r].bind(e))})},exports.getCoordinatesCenter=function(r){for(var e=1/0,t=1/0,n=-(1/0),o=-(1/0),a=0;a<r.length;a++)e=Math.min(e,r[a].column),t=Math.min(t,r[a].row),n=Math.max(n,r[a].column),o=Math.max(o,r[a].row);var i=n-e,u=o-t,s=Math.max(i,u);return new Coordinate((e+n)/2,(t+o)/2,0).zoomTo(Math.floor(-Math.log(s)/Math.LN2))},exports.endsWith=function(r,e){return r.indexOf(e,r.length-e.length)!==-1},exports.mapObject=function(r,e,t){var n=this,o={};for(var a in r)o[a]=e.call(t||n,r[a],a,r);return o},exports.filterObject=function(r,e,t){var n=this,o={};for(var a in r)e.call(t||n,r[a],a,r)&&(o[a]=r[a]);return o},exports.deepEqual=function(r,e){if(Array.isArray(r)){if(!Array.isArray(e)||r.length!==e.length)return!1;for(var t=0;t<r.length;t++)if(!exports.deepEqual(r[t],e[t]))return!1;return!0}if("object"==typeof r&&null!==r&&null!==e){if("object"!=typeof e)return!1;var n=Object.keys(r);if(n.length!==Object.keys(e).length)return!1;for(var o in r)if(!exports.deepEqual(r[o],e[o]))return!1;return!0}return r===e},exports.clone=function(r){return Array.isArray(r)?r.map(exports.clone):"object"==typeof r&&r?exports.mapObject(r,exports.clone):r},exports.arraysIntersect=function(r,e){for(var t=0;t<r.length;t++)if(e.indexOf(r[t])>=0)return!0;return!1};var warnOnceHistory={};exports.warnOnce=function(r){warnOnceHistory[r]||("undefined"!=typeof console&&console.warn(r),warnOnceHistory[r]=!0)},exports.isCounterClockwise=function(r,e,t){return(t.y-r.y)*(e.x-r.x)>(e.y-r.y)*(t.x-r.x)},exports.calculateSignedArea=function(r){for(var e,t,n=0,o=0,a=r.length,i=a-1;o<a;i=o++)e=r[o],t=r[i],n+=(t.x-e.x)*(e.y+t.y);return n},exports.isClosedPolygon=function(r){if(r.length<4)return!1;var e=r[0],t=r[r.length-1];return!(Math.abs(e.x-t.x)>0||Math.abs(e.y-t.y)>0)&&Math.abs(exports.calculateSignedArea(r))>.01},exports.sphericalToCartesian=function(r){var e=r[0],t=r[1],n=r[2];return t+=90,t*=Math.PI/180,n*=Math.PI/180,[e*Math.cos(t)*Math.sin(n),e*Math.sin(t)*Math.sin(n),e*Math.cos(n)]},exports.parseCacheControl=function(r){var e=/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g,t={};if(r.replace(e,function(r,e,n,o){var a=n||o;return t[e]=!a||a.toLowerCase(),""}),t["max-age"]){var n=parseInt(t["max-age"],10);isNaN(n)?delete t["max-age"]:t["max-age"]=n}return t};
},{"../geo/coordinate":18,"@mapbox/unitbezier":134,"point-geometry":197}],130:[function(require,module,exports){
"use strict";var Feature=function(e,t,r,o){this.type="Feature",this._vectorTileFeature=e,e._z=t,e._x=r,e._y=o,this.properties=e.properties,null!=e.id&&(this.id=e.id)},prototypeAccessors={geometry:{}};prototypeAccessors.geometry.get=function(){return void 0===this._geometry&&(this._geometry=this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x,this._vectorTileFeature._y,this._vectorTileFeature._z).geometry),this._geometry},prototypeAccessors.geometry.set=function(e){this._geometry=e},Feature.prototype.toJSON=function(){var e=this,t={geometry:this.geometry};for(var r in this)"_geometry"!==r&&"_vectorTileFeature"!==r&&(t[r]=e[r]);return t},Object.defineProperties(Feature.prototype,prototypeAccessors),module.exports=Feature;
},{}],131:[function(require,module,exports){
"use strict";var scriptDetection=require("./script_detection");module.exports=function(t){for(var o="",e=0;e<t.length;e++){var r=t.charCodeAt(e+1)||null,l=t.charCodeAt(e-1)||null,i=(!r||!scriptDetection.charHasRotatedVerticalOrientation(r)||module.exports.lookup[t[e+1]])&&(!l||!scriptDetection.charHasRotatedVerticalOrientation(l)||module.exports.lookup[t[e-1]]);o+=i&&module.exports.lookup[t[e]]?module.exports.lookup[t[e]]:t[e]}return o},module.exports.lookup={"!":"︕","#":"＃",$:"＄","%":"％","&":"＆","(":"︵",")":"︶","*":"＊","+":"＋",",":"︐","-":"︲",".":"・","/":"／",":":"︓",";":"︔","<":"︿","=":"＝",">":"﹀","?":"︖","@":"＠","[":"﹇","\\":"＼","]":"﹈","^":"＾",_:"︳","`":"｀","{":"︷","|":"―","}":"︸","~":"～","¢":"￠","£":"￡","¥":"￥","¦":"￤","¬":"￢","¯":"￣","–":"︲","—":"︱","‘":"﹃","’":"﹄","“":"﹁","”":"﹂","…":"︙","‧":"・","₩":"￦","、":"︑","。":"︒","〈":"︿","〉":"﹀","《":"︽","》":"︾","「":"﹁","」":"﹂","『":"﹃","』":"﹄","【":"︻","】":"︼","〔":"︹","〕":"︺","〖":"︗","〗":"︘","！":"︕","（":"︵","）":"︶","，":"︐","－":"︲","．":"・","：":"︓","；":"︔","＜":"︿","＞":"﹀","？":"︖","［":"﹇","］":"﹈","＿":"︳","｛":"︷","｜":"―","｝":"︸","｟":"︵","｠":"︶","｡":"︒","｢":"﹁","｣":"﹂"};
},{"./script_detection":126}],132:[function(require,module,exports){
"use strict";var WebWorker=require("./web_worker"),WorkerPool=function(){this.active={}};WorkerPool.prototype.acquire=function(r){var e=this;if(!this.workers){var o=require("../mapbox-gl").workerCount;for(this.workers=[];this.workers.length<o;)e.workers.push(new WebWorker)}return this.active[r]=!0,this.workers.slice()},WorkerPool.prototype.release=function(r){delete this.active[r],0===Object.keys(this.active).length&&(this.workers.forEach(function(r){r.terminate()}),this.workers=null)},module.exports=WorkerPool;
},{"../mapbox-gl":24,"./web_worker":111}],133:[function(require,module,exports){
!function(t,r){"object"==typeof exports&&"undefined"!=typeof module?module.exports=r():"function"==typeof define&&define.amd?define(r):t.glMatrix=r()}(this,function(){"use strict";function t(){var t=new Float32Array(3);return t[0]=0,t[1]=0,t[2]=0,t}function r(t,r,n){var e=r[0],a=r[1],o=r[2];return t[0]=e*n[0]+a*n[3]+o*n[6],t[1]=e*n[1]+a*n[4]+o*n[7],t[2]=e*n[2]+a*n[5]+o*n[8],t}function n(){var t=new Float32Array(4);return t[0]=0,t[1]=0,t[2]=0,t[3]=0,t}function e(t,r,n){var e=r[0],a=r[1],o=r[2],u=r[3];return t[0]=n[0]*e+n[4]*a+n[8]*o+n[12]*u,t[1]=n[1]*e+n[5]*a+n[9]*o+n[13]*u,t[2]=n[2]*e+n[6]*a+n[10]*o+n[14]*u,t[3]=n[3]*e+n[7]*a+n[11]*o+n[15]*u,t}function a(){var t=new Float32Array(4);return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t}function o(t,r,n){var e=r[0],a=r[1],o=r[2],u=r[3],i=Math.sin(n),c=Math.cos(n);return t[0]=e*c+o*i,t[1]=a*c+u*i,t[2]=e*-i+o*c,t[3]=a*-i+u*c,t}function u(t,r,n){var e=r[0],a=r[1],o=r[2],u=r[3],i=n[0],c=n[1];return t[0]=e*i,t[1]=a*i,t[2]=o*c,t[3]=u*c,t}function i(){var t=new Float32Array(9);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t}function c(t,r){var n=Math.sin(r),e=Math.cos(r);return t[0]=e,t[1]=n,t[2]=0,t[3]=-n,t[4]=e,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t}function f(){var t=new Float32Array(16);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function v(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function s(t,r){var n=r[0],e=r[1],a=r[2],o=r[3],u=r[4],i=r[5],c=r[6],f=r[7],v=r[8],s=r[9],l=r[10],M=r[11],h=r[12],m=r[13],y=r[14],d=r[15],p=n*i-e*u,w=n*c-a*u,A=n*f-o*u,F=e*c-a*i,x=e*f-o*i,b=a*f-o*c,g=v*m-s*h,j=v*y-l*h,R=v*d-M*h,X=s*y-l*m,Z=s*d-M*m,k=l*d-M*y,q=p*k-w*Z+A*X+F*R-x*j+b*g;return q?(q=1/q,t[0]=(i*k-c*Z+f*X)*q,t[1]=(a*Z-e*k-o*X)*q,t[2]=(m*b-y*x+d*F)*q,t[3]=(l*x-s*b-M*F)*q,t[4]=(c*R-u*k-f*j)*q,t[5]=(n*k-a*R+o*j)*q,t[6]=(y*A-h*b-d*w)*q,t[7]=(v*b-l*A+M*w)*q,t[8]=(u*Z-i*R+f*g)*q,t[9]=(e*R-n*Z-o*g)*q,t[10]=(h*x-m*A+d*p)*q,t[11]=(s*A-v*x-M*p)*q,t[12]=(i*j-u*X-c*g)*q,t[13]=(n*X-e*j+a*g)*q,t[14]=(m*w-h*F-y*p)*q,t[15]=(v*F-s*w+l*p)*q,t):null}function l(t,r,n){var e=r[0],a=r[1],o=r[2],u=r[3],i=r[4],c=r[5],f=r[6],v=r[7],s=r[8],l=r[9],M=r[10],h=r[11],m=r[12],y=r[13],d=r[14],p=r[15],w=n[0],A=n[1],F=n[2],x=n[3];return t[0]=w*e+A*i+F*s+x*m,t[1]=w*a+A*c+F*l+x*y,t[2]=w*o+A*f+F*M+x*d,t[3]=w*u+A*v+F*h+x*p,w=n[4],A=n[5],F=n[6],x=n[7],t[4]=w*e+A*i+F*s+x*m,t[5]=w*a+A*c+F*l+x*y,t[6]=w*o+A*f+F*M+x*d,t[7]=w*u+A*v+F*h+x*p,w=n[8],A=n[9],F=n[10],x=n[11],t[8]=w*e+A*i+F*s+x*m,t[9]=w*a+A*c+F*l+x*y,t[10]=w*o+A*f+F*M+x*d,t[11]=w*u+A*v+F*h+x*p,w=n[12],A=n[13],F=n[14],x=n[15],t[12]=w*e+A*i+F*s+x*m,t[13]=w*a+A*c+F*l+x*y,t[14]=w*o+A*f+F*M+x*d,t[15]=w*u+A*v+F*h+x*p,t}function M(t,r,n){var e,a,o,u,i,c,f,v,s,l,M,h,m=n[0],y=n[1],d=n[2];return r===t?(t[12]=r[0]*m+r[4]*y+r[8]*d+r[12],t[13]=r[1]*m+r[5]*y+r[9]*d+r[13],t[14]=r[2]*m+r[6]*y+r[10]*d+r[14],t[15]=r[3]*m+r[7]*y+r[11]*d+r[15]):(e=r[0],a=r[1],o=r[2],u=r[3],i=r[4],c=r[5],f=r[6],v=r[7],s=r[8],l=r[9],M=r[10],h=r[11],t[0]=e,t[1]=a,t[2]=o,t[3]=u,t[4]=i,t[5]=c,t[6]=f,t[7]=v,t[8]=s,t[9]=l,t[10]=M,t[11]=h,t[12]=e*m+i*y+s*d+r[12],t[13]=a*m+c*y+l*d+r[13],t[14]=o*m+f*y+M*d+r[14],t[15]=u*m+v*y+h*d+r[15]),t}function h(t,r,n){var e=n[0],a=n[1],o=n[2];return t[0]=r[0]*e,t[1]=r[1]*e,t[2]=r[2]*e,t[3]=r[3]*e,t[4]=r[4]*a,t[5]=r[5]*a,t[6]=r[6]*a,t[7]=r[7]*a,t[8]=r[8]*o,t[9]=r[9]*o,t[10]=r[10]*o,t[11]=r[11]*o,t[12]=r[12],t[13]=r[13],t[14]=r[14],t[15]=r[15],t}function m(t,r,n){var e=Math.sin(n),a=Math.cos(n),o=r[4],u=r[5],i=r[6],c=r[7],f=r[8],v=r[9],s=r[10],l=r[11];return r!==t&&(t[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3],t[12]=r[12],t[13]=r[13],t[14]=r[14],t[15]=r[15]),t[4]=o*a+f*e,t[5]=u*a+v*e,t[6]=i*a+s*e,t[7]=c*a+l*e,t[8]=f*a-o*e,t[9]=v*a-u*e,t[10]=s*a-i*e,t[11]=l*a-c*e,t}function y(t,r,n){var e=Math.sin(n),a=Math.cos(n),o=r[0],u=r[1],i=r[2],c=r[3],f=r[4],v=r[5],s=r[6],l=r[7];return r!==t&&(t[8]=r[8],t[9]=r[9],t[10]=r[10],t[11]=r[11],t[12]=r[12],t[13]=r[13],t[14]=r[14],t[15]=r[15]),t[0]=o*a+f*e,t[1]=u*a+v*e,t[2]=i*a+s*e,t[3]=c*a+l*e,t[4]=f*a-o*e,t[5]=v*a-u*e,t[6]=s*a-i*e,t[7]=l*a-c*e,t}function d(t,r,n,e,a){var o=1/Math.tan(r/2),u=1/(e-a);return t[0]=o/n,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=o,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=(a+e)*u,t[11]=-1,t[12]=0,t[13]=0,t[14]=2*a*e*u,t[15]=0,t}function p(t,r,n,e,a,o,u){var i=1/(r-n),c=1/(e-a),f=1/(o-u);return t[0]=-2*i,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*c,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*f,t[11]=0,t[12]=(r+n)*i,t[13]=(a+e)*c,t[14]=(u+o)*f,t[15]=1,t}var w=(t(),n(),{vec3:{transformMat3:r},vec4:{transformMat4:e},mat2:{create:a,rotate:o,scale:u},mat3:{create:i,fromRotation:c},mat4:{create:f,identity:v,translate:M,scale:h,multiply:l,perspective:d,rotateX:m,rotateZ:y,invert:s,ortho:p}});return w});
},{}],134:[function(require,module,exports){
function UnitBezier(t,i,e,r){this.cx=3*t,this.bx=3*(e-t)-this.cx,this.ax=1-this.cx-this.bx,this.cy=3*i,this.by=3*(r-i)-this.cy,this.ay=1-this.cy-this.by,this.p1x=t,this.p1y=r,this.p2x=e,this.p2y=r}module.exports=UnitBezier,UnitBezier.prototype.sampleCurveX=function(t){return((this.ax*t+this.bx)*t+this.cx)*t},UnitBezier.prototype.sampleCurveY=function(t){return((this.ay*t+this.by)*t+this.cy)*t},UnitBezier.prototype.sampleCurveDerivativeX=function(t){return(3*this.ax*t+2*this.bx)*t+this.cx},UnitBezier.prototype.solveCurveX=function(t,i){"undefined"==typeof i&&(i=1e-6);var e,r,s,h,n;for(s=t,n=0;n<8;n++){if(h=this.sampleCurveX(s)-t,Math.abs(h)<i)return s;var u=this.sampleCurveDerivativeX(s);if(Math.abs(u)<1e-6)break;s-=h/u}if(e=0,r=1,s=t,s<e)return e;if(s>r)return r;for(;e<r;){if(h=this.sampleCurveX(s),Math.abs(h-t)<i)return s;t>h?e=s:r=s,s=.5*(r-e)+e}return s},UnitBezier.prototype.solve=function(t,i){return this.sampleCurveY(this.solveCurveX(t,i))};
},{}],135:[function(require,module,exports){
function clamp_css_byte(e){return e=Math.round(e),e<0?0:e>255?255:e}function clamp_css_float(e){return e<0?0:e>1?1:e}function parse_css_int(e){return clamp_css_byte("%"===e[e.length-1]?parseFloat(e)/100*255:parseInt(e))}function parse_css_float(e){return clamp_css_float("%"===e[e.length-1]?parseFloat(e)/100:parseFloat(e))}function css_hue_to_rgb(e,r,l){return l<0?l+=1:l>1&&(l-=1),6*l<1?e+(r-e)*l*6:2*l<1?r:3*l<2?e+(r-e)*(2/3-l)*6:e}function parseCSSColor(e){var r=e.replace(/ /g,"").toLowerCase();if(r in kCSSColorTable)return kCSSColorTable[r].slice();if("#"===r[0]){if(4===r.length){var l=parseInt(r.substr(1),16);return l>=0&&l<=4095?[(3840&l)>>4|(3840&l)>>8,240&l|(240&l)>>4,15&l|(15&l)<<4,1]:null}if(7===r.length){var l=parseInt(r.substr(1),16);return l>=0&&l<=16777215?[(16711680&l)>>16,(65280&l)>>8,255&l,1]:null}return null}var a=r.indexOf("("),t=r.indexOf(")");if(a!==-1&&t+1===r.length){var n=r.substr(0,a),s=r.substr(a+1,t-(a+1)).split(","),o=1;switch(n){case"rgba":if(4!==s.length)return null;o=parse_css_float(s.pop());case"rgb":return 3!==s.length?null:[parse_css_int(s[0]),parse_css_int(s[1]),parse_css_int(s[2]),o];case"hsla":if(4!==s.length)return null;o=parse_css_float(s.pop());case"hsl":if(3!==s.length)return null;var i=(parseFloat(s[0])%360+360)%360/360,u=parse_css_float(s[1]),g=parse_css_float(s[2]),d=g<=.5?g*(u+1):g+u-g*u,c=2*g-d;return[clamp_css_byte(255*css_hue_to_rgb(c,d,i+1/3)),clamp_css_byte(255*css_hue_to_rgb(c,d,i)),clamp_css_byte(255*css_hue_to_rgb(c,d,i-1/3)),o];default:return null}}return null}var kCSSColorTable={transparent:[0,0,0,0],aliceblue:[240,248,255,1],antiquewhite:[250,235,215,1],aqua:[0,255,255,1],aquamarine:[127,255,212,1],azure:[240,255,255,1],beige:[245,245,220,1],bisque:[255,228,196,1],black:[0,0,0,1],blanchedalmond:[255,235,205,1],blue:[0,0,255,1],blueviolet:[138,43,226,1],brown:[165,42,42,1],burlywood:[222,184,135,1],cadetblue:[95,158,160,1],chartreuse:[127,255,0,1],chocolate:[210,105,30,1],coral:[255,127,80,1],cornflowerblue:[100,149,237,1],cornsilk:[255,248,220,1],crimson:[220,20,60,1],cyan:[0,255,255,1],darkblue:[0,0,139,1],darkcyan:[0,139,139,1],darkgoldenrod:[184,134,11,1],darkgray:[169,169,169,1],darkgreen:[0,100,0,1],darkgrey:[169,169,169,1],darkkhaki:[189,183,107,1],darkmagenta:[139,0,139,1],darkolivegreen:[85,107,47,1],darkorange:[255,140,0,1],darkorchid:[153,50,204,1],darkred:[139,0,0,1],darksalmon:[233,150,122,1],darkseagreen:[143,188,143,1],darkslateblue:[72,61,139,1],darkslategray:[47,79,79,1],darkslategrey:[47,79,79,1],darkturquoise:[0,206,209,1],darkviolet:[148,0,211,1],deeppink:[255,20,147,1],deepskyblue:[0,191,255,1],dimgray:[105,105,105,1],dimgrey:[105,105,105,1],dodgerblue:[30,144,255,1],firebrick:[178,34,34,1],floralwhite:[255,250,240,1],forestgreen:[34,139,34,1],fuchsia:[255,0,255,1],gainsboro:[220,220,220,1],ghostwhite:[248,248,255,1],gold:[255,215,0,1],goldenrod:[218,165,32,1],gray:[128,128,128,1],green:[0,128,0,1],greenyellow:[173,255,47,1],grey:[128,128,128,1],honeydew:[240,255,240,1],hotpink:[255,105,180,1],indianred:[205,92,92,1],indigo:[75,0,130,1],ivory:[255,255,240,1],khaki:[240,230,140,1],lavender:[230,230,250,1],lavenderblush:[255,240,245,1],lawngreen:[124,252,0,1],lemonchiffon:[255,250,205,1],lightblue:[173,216,230,1],lightcoral:[240,128,128,1],lightcyan:[224,255,255,1],lightgoldenrodyellow:[250,250,210,1],lightgray:[211,211,211,1],lightgreen:[144,238,144,1],lightgrey:[211,211,211,1],lightpink:[255,182,193,1],lightsalmon:[255,160,122,1],lightseagreen:[32,178,170,1],lightskyblue:[135,206,250,1],lightslategray:[119,136,153,1],lightslategrey:[119,136,153,1],lightsteelblue:[176,196,222,1],lightyellow:[255,255,224,1],lime:[0,255,0,1],limegreen:[50,205,50,1],linen:[250,240,230,1],magenta:[255,0,255,1],maroon:[128,0,0,1],mediumaquamarine:[102,205,170,1],mediumblue:[0,0,205,1],mediumorchid:[186,85,211,1],mediumpurple:[147,112,219,1],mediumseagreen:[60,179,113,1],mediumslateblue:[123,104,238,1],mediumspringgreen:[0,250,154,1],mediumturquoise:[72,209,204,1],mediumvioletred:[199,21,133,1],midnightblue:[25,25,112,1],mintcream:[245,255,250,1],mistyrose:[255,228,225,1],moccasin:[255,228,181,1],navajowhite:[255,222,173,1],navy:[0,0,128,1],oldlace:[253,245,230,1],olive:[128,128,0,1],olivedrab:[107,142,35,1],orange:[255,165,0,1],orangered:[255,69,0,1],orchid:[218,112,214,1],palegoldenrod:[238,232,170,1],palegreen:[152,251,152,1],paleturquoise:[175,238,238,1],palevioletred:[219,112,147,1],papayawhip:[255,239,213,1],peachpuff:[255,218,185,1],peru:[205,133,63,1],pink:[255,192,203,1],plum:[221,160,221,1],powderblue:[176,224,230,1],purple:[128,0,128,1],rebeccapurple:[102,51,153,1],red:[255,0,0,1],rosybrown:[188,143,143,1],royalblue:[65,105,225,1],saddlebrown:[139,69,19,1],salmon:[250,128,114,1],sandybrown:[244,164,96,1],seagreen:[46,139,87,1],seashell:[255,245,238,1],sienna:[160,82,45,1],silver:[192,192,192,1],skyblue:[135,206,235,1],slateblue:[106,90,205,1],slategray:[112,128,144,1],slategrey:[112,128,144,1],snow:[255,250,250,1],springgreen:[0,255,127,1],steelblue:[70,130,180,1],tan:[210,180,140,1],teal:[0,128,128,1],thistle:[216,191,216,1],tomato:[255,99,71,1],turquoise:[64,224,208,1],violet:[238,130,238,1],wheat:[245,222,179,1],white:[255,255,255,1],whitesmoke:[245,245,245,1],yellow:[255,255,0,1],yellowgreen:[154,205,50,1]};try{exports.parseCSSColor=parseCSSColor}catch(e){}
},{}],136:[function(require,module,exports){
"use strict";function earcut(e,n,r){r=r||2;var t=n&&n.length,i=t?n[0]*r:e.length,x=linkedList(e,0,i,r,!0),a=[];if(!x)return a;var o,l,u,s,v,f,y;if(t&&(x=eliminateHoles(e,n,x,r)),e.length>80*r){o=u=e[0],l=s=e[1];for(var d=r;d<i;d+=r)v=e[d],f=e[d+1],v<o&&(o=v),f<l&&(l=f),v>u&&(u=v),f>s&&(s=f);y=Math.max(u-o,s-l)}return earcutLinked(x,a,r,o,l,y),a}function linkedList(e,n,r,t,i){var x,a;if(i===signedArea(e,n,r,t)>0)for(x=n;x<r;x+=t)a=insertNode(x,e[x],e[x+1],a);else for(x=r-t;x>=n;x-=t)a=insertNode(x,e[x],e[x+1],a);return a&&equals(a,a.next)&&(removeNode(a),a=a.next),a}function filterPoints(e,n){if(!e)return e;n||(n=e);var r,t=e;do if(r=!1,t.steiner||!equals(t,t.next)&&0!==area(t.prev,t,t.next))t=t.next;else{if(removeNode(t),t=n=t.prev,t===t.next)return null;r=!0}while(r||t!==n);return n}function earcutLinked(e,n,r,t,i,x,a){if(e){!a&&x&&indexCurve(e,t,i,x);for(var o,l,u=e;e.prev!==e.next;)if(o=e.prev,l=e.next,x?isEarHashed(e,t,i,x):isEar(e))n.push(o.i/r),n.push(e.i/r),n.push(l.i/r),removeNode(e),e=l.next,u=l.next;else if(e=l,e===u){a?1===a?(e=cureLocalIntersections(e,n,r),earcutLinked(e,n,r,t,i,x,2)):2===a&&splitEarcut(e,n,r,t,i,x):earcutLinked(filterPoints(e),n,r,t,i,x,1);break}}}function isEar(e){var n=e.prev,r=e,t=e.next;if(area(n,r,t)>=0)return!1;for(var i=e.next.next;i!==e.prev;){if(pointInTriangle(n.x,n.y,r.x,r.y,t.x,t.y,i.x,i.y)&&area(i.prev,i,i.next)>=0)return!1;i=i.next}return!0}function isEarHashed(e,n,r,t){var i=e.prev,x=e,a=e.next;if(area(i,x,a)>=0)return!1;for(var o=i.x<x.x?i.x<a.x?i.x:a.x:x.x<a.x?x.x:a.x,l=i.y<x.y?i.y<a.y?i.y:a.y:x.y<a.y?x.y:a.y,u=i.x>x.x?i.x>a.x?i.x:a.x:x.x>a.x?x.x:a.x,s=i.y>x.y?i.y>a.y?i.y:a.y:x.y>a.y?x.y:a.y,v=zOrder(o,l,n,r,t),f=zOrder(u,s,n,r,t),y=e.nextZ;y&&y.z<=f;){if(y!==e.prev&&y!==e.next&&pointInTriangle(i.x,i.y,x.x,x.y,a.x,a.y,y.x,y.y)&&area(y.prev,y,y.next)>=0)return!1;y=y.nextZ}for(y=e.prevZ;y&&y.z>=v;){if(y!==e.prev&&y!==e.next&&pointInTriangle(i.x,i.y,x.x,x.y,a.x,a.y,y.x,y.y)&&area(y.prev,y,y.next)>=0)return!1;y=y.prevZ}return!0}function cureLocalIntersections(e,n,r){var t=e;do{var i=t.prev,x=t.next.next;!equals(i,x)&&intersects(i,t,t.next,x)&&locallyInside(i,x)&&locallyInside(x,i)&&(n.push(i.i/r),n.push(t.i/r),n.push(x.i/r),removeNode(t),removeNode(t.next),t=e=x),t=t.next}while(t!==e);return t}function splitEarcut(e,n,r,t,i,x){var a=e;do{for(var o=a.next.next;o!==a.prev;){if(a.i!==o.i&&isValidDiagonal(a,o)){var l=splitPolygon(a,o);return a=filterPoints(a,a.next),l=filterPoints(l,l.next),earcutLinked(a,n,r,t,i,x),void earcutLinked(l,n,r,t,i,x)}o=o.next}a=a.next}while(a!==e)}function eliminateHoles(e,n,r,t){var i,x,a,o,l,u=[];for(i=0,x=n.length;i<x;i++)a=n[i]*t,o=i<x-1?n[i+1]*t:e.length,l=linkedList(e,a,o,t,!1),l===l.next&&(l.steiner=!0),u.push(getLeftmost(l));for(u.sort(compareX),i=0;i<u.length;i++)eliminateHole(u[i],r),r=filterPoints(r,r.next);return r}function compareX(e,n){return e.x-n.x}function eliminateHole(e,n){if(n=findHoleBridge(e,n)){var r=splitPolygon(n,e);filterPoints(r,r.next)}}function findHoleBridge(e,n){var r,t=n,i=e.x,x=e.y,a=-(1/0);do{if(x<=t.y&&x>=t.next.y){var o=t.x+(x-t.y)*(t.next.x-t.x)/(t.next.y-t.y);if(o<=i&&o>a){if(a=o,o===i){if(x===t.y)return t;if(x===t.next.y)return t.next}r=t.x<t.next.x?t:t.next}}t=t.next}while(t!==n);if(!r)return null;if(i===a)return r.prev;var l,u=r,s=r.x,v=r.y,f=1/0;for(t=r.next;t!==u;)i>=t.x&&t.x>=s&&pointInTriangle(x<v?i:a,x,s,v,x<v?a:i,x,t.x,t.y)&&(l=Math.abs(x-t.y)/(i-t.x),(l<f||l===f&&t.x>r.x)&&locallyInside(t,e)&&(r=t,f=l)),t=t.next;return r}function indexCurve(e,n,r,t){var i=e;do null===i.z&&(i.z=zOrder(i.x,i.y,n,r,t)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==e);i.prevZ.nextZ=null,i.prevZ=null,sortLinked(i)}function sortLinked(e){var n,r,t,i,x,a,o,l,u=1;do{for(r=e,e=null,x=null,a=0;r;){for(a++,t=r,o=0,n=0;n<u&&(o++,t=t.nextZ,t);n++);for(l=u;o>0||l>0&&t;)0===o?(i=t,t=t.nextZ,l--):0!==l&&t?r.z<=t.z?(i=r,r=r.nextZ,o--):(i=t,t=t.nextZ,l--):(i=r,r=r.nextZ,o--),x?x.nextZ=i:e=i,i.prevZ=x,x=i;r=t}x.nextZ=null,u*=2}while(a>1);return e}function zOrder(e,n,r,t,i){return e=32767*(e-r)/i,n=32767*(n-t)/i,e=16711935&(e|e<<8),e=252645135&(e|e<<4),e=858993459&(e|e<<2),e=1431655765&(e|e<<1),n=16711935&(n|n<<8),n=252645135&(n|n<<4),n=858993459&(n|n<<2),n=1431655765&(n|n<<1),e|n<<1}function getLeftmost(e){var n=e,r=e;do n.x<r.x&&(r=n),n=n.next;while(n!==e);return r}function pointInTriangle(e,n,r,t,i,x,a,o){return(i-a)*(n-o)-(e-a)*(x-o)>=0&&(e-a)*(t-o)-(r-a)*(n-o)>=0&&(r-a)*(x-o)-(i-a)*(t-o)>=0}function isValidDiagonal(e,n){return e.next.i!==n.i&&e.prev.i!==n.i&&!intersectsPolygon(e,n)&&locallyInside(e,n)&&locallyInside(n,e)&&middleInside(e,n)}function area(e,n,r){return(n.y-e.y)*(r.x-n.x)-(n.x-e.x)*(r.y-n.y)}function equals(e,n){return e.x===n.x&&e.y===n.y}function intersects(e,n,r,t){return!!(equals(e,n)&&equals(r,t)||equals(e,t)&&equals(r,n))||area(e,n,r)>0!=area(e,n,t)>0&&area(r,t,e)>0!=area(r,t,n)>0}function intersectsPolygon(e,n){var r=e;do{if(r.i!==e.i&&r.next.i!==e.i&&r.i!==n.i&&r.next.i!==n.i&&intersects(r,r.next,e,n))return!0;r=r.next}while(r!==e);return!1}function locallyInside(e,n){return area(e.prev,e,e.next)<0?area(e,n,e.next)>=0&&area(e,e.prev,n)>=0:area(e,n,e.prev)<0||area(e,e.next,n)<0}function middleInside(e,n){var r=e,t=!1,i=(e.x+n.x)/2,x=(e.y+n.y)/2;do r.y>x!=r.next.y>x&&i<(r.next.x-r.x)*(x-r.y)/(r.next.y-r.y)+r.x&&(t=!t),r=r.next;while(r!==e);return t}function splitPolygon(e,n){var r=new Node(e.i,e.x,e.y),t=new Node(n.i,n.x,n.y),i=e.next,x=n.prev;return e.next=n,n.prev=e,r.next=i,i.prev=r,t.next=r,r.prev=t,x.next=t,t.prev=x,t}function insertNode(e,n,r,t){var i=new Node(e,n,r);return t?(i.next=t.next,i.prev=t,t.next.prev=i,t.next=i):(i.prev=i,i.next=i),i}function removeNode(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function Node(e,n,r){this.i=e,this.x=n,this.y=r,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function signedArea(e,n,r,t){for(var i=0,x=n,a=r-t;x<r;x+=t)i+=(e[a]-e[x])*(e[x+1]+e[a+1]),a=x;return i}module.exports=earcut,earcut.deviation=function(e,n,r,t){var i=n&&n.length,x=i?n[0]*r:e.length,a=Math.abs(signedArea(e,0,x,r));if(i)for(var o=0,l=n.length;o<l;o++){var u=n[o]*r,s=o<l-1?n[o+1]*r:e.length;a-=Math.abs(signedArea(e,u,s,r))}var v=0;for(o=0;o<t.length;o+=3){var f=t[o]*r,y=t[o+1]*r,d=t[o+2]*r;v+=Math.abs((e[f]-e[d])*(e[y+1]-e[f+1])-(e[f]-e[y])*(e[d+1]-e[f+1]))}return 0===a&&0===v?0:Math.abs((v-a)/a)},earcut.flatten=function(e){for(var n=e[0][0].length,r={vertices:[],holes:[],dimensions:n},t=0,i=0;i<e.length;i++){for(var x=0;x<e[i].length;x++)for(var a=0;a<n;a++)r.vertices.push(e[i][x][a]);i>0&&(t+=e[i-1].length,r.holes.push(t))}return r};
},{}],137:[function(require,module,exports){
function sss(r){var e,t,s,n,u,a;switch(typeof r){case"object":if(null===r)return null;if(isArray(r)){for(s="[",t=r.length-1,e=0;e<t;e++)s+=sss(r[e])+",";return t>-1&&(s+=sss(r[e])),s+"]"}for(n=objKeys(r).sort(),t=n.length,s="{",u=n[e=0],a=t>0&&void 0!==r[u];e<t;)a?(s+='"'+u.replace(strReg,strReplace)+'":'+sss(r[u]),u=n[++e],a=e<t&&void 0!==r[u],a&&(s+=",")):(u=n[++e],a=e<t&&void 0!==r[u]);return s+"}";case"undefined":return null;case"string":return'"'+r.replace(strReg,strReplace)+'"';default:return r}}var toString={}.toString,isArray=Array.isArray||function(r){return"[object Array]"===toString.call(r)},objKeys=Object.keys||function(r){var e=[];for(var t in r)r.hasOwnProperty(t)&&e.push(t);return e},strReg=/[\u0000-\u001f"\\]/g,strReplace=function(r){var e=r.charCodeAt(0);switch(e){case 34:return'\\"';case 92:return"\\\\";case 12:return"\\f";case 10:return"\\n";case 13:return"\\r";case 9:return"\\t";case 8:return"\\b";default:return e>15?"\\u00"+e.toString(16):"\\u000"+e.toString(16)}};module.exports=function(r){if(void 0!==r)return""+sss(r)},module.exports.stringSearch=strReg,module.exports.stringReplace=strReplace;
},{}],138:[function(require,module,exports){
"use strict";function createFilter(e){return new Function("f","var p = (f && f.properties || {}); return "+compile(e))}function compile(e){if(!e)return"true";var i=e[0];if(e.length<=1)return"any"===i?"false":"true";var n="=="===i?compileComparisonOp(e[1],e[2],"===",!1):"!="===i?compileComparisonOp(e[1],e[2],"!==",!1):"<"===i||">"===i||"<="===i||">="===i?compileComparisonOp(e[1],e[2],i,!0):"any"===i?compileLogicalOp(e.slice(1),"||"):"all"===i?compileLogicalOp(e.slice(1),"&&"):"none"===i?compileNegation(compileLogicalOp(e.slice(1),"||")):"in"===i?compileInOp(e[1],e.slice(2)):"!in"===i?compileNegation(compileInOp(e[1],e.slice(2))):"has"===i?compileHasOp(e[1]):"!has"===i?compileNegation(compileHasOp([e[1]])):"true";return"("+n+")"}function compilePropertyReference(e){return"$type"===e?"f.type":"$id"===e?"f.id":"p["+JSON.stringify(e)+"]"}function compileComparisonOp(e,i,n,r){var o=compilePropertyReference(e),t="$type"===e?types.indexOf(i):JSON.stringify(i);return(r?"typeof "+o+"=== typeof "+t+"&&":"")+o+n+t}function compileLogicalOp(e,i){return e.map(compile).join(i)}function compileInOp(e,i){"$type"===e&&(i=i.map(function(e){return types.indexOf(e)}));var n=JSON.stringify(i.sort(compare)),r=compilePropertyReference(e);return i.length<=200?n+".indexOf("+r+") !== -1":"function(v, a, i, j) {while (i <= j) { var m = (i + j) >> 1;    if (a[m] === v) return true; if (a[m] > v) j = m - 1; else i = m + 1;}return false; }("+r+", "+n+",0,"+(i.length-1)+")"}function compileHasOp(e){return JSON.stringify(e)+" in p"}function compileNegation(e){return"!("+e+")"}function compare(e,i){return e<i?-1:e>i?1:0}module.exports=createFilter;var types=["Unknown","Point","LineString","Polygon"];
},{}],139:[function(require,module,exports){
function geometry(r){if("Polygon"===r.type)return polygonArea(r.coordinates);if("MultiPolygon"===r.type){for(var e=0,n=0;n<r.coordinates.length;n++)e+=polygonArea(r.coordinates[n]);return e}return null}function polygonArea(r){var e=0;if(r&&r.length>0){e+=Math.abs(ringArea(r[0]));for(var n=1;n<r.length;n++)e-=Math.abs(ringArea(r[n]))}return e}function ringArea(r){var e=0;if(r.length>2){for(var n,t,o=0;o<r.length-1;o++)n=r[o],t=r[o+1],e+=rad(t[0]-n[0])*(2+Math.sin(rad(n[1]))+Math.sin(rad(t[1])));e=e*wgs84.RADIUS*wgs84.RADIUS/2}return e}function rad(r){return r*Math.PI/180}var wgs84=require("wgs84");module.exports.geometry=geometry,module.exports.ring=ringArea;
},{"wgs84":214}],140:[function(require,module,exports){
function rewind(r,e){switch(r&&r.type||null){case"FeatureCollection":return r.features=r.features.map(curryOuter(rewind,e)),r;case"Feature":return r.geometry=rewind(r.geometry,e),r;case"Polygon":case"MultiPolygon":return correct(r,e);default:return r}}function curryOuter(r,e){return function(n){return r(n,e)}}function correct(r,e){return"Polygon"===r.type?r.coordinates=correctRings(r.coordinates,e):"MultiPolygon"===r.type&&(r.coordinates=r.coordinates.map(curryOuter(correctRings,e))),r}function correctRings(r,e){e=!!e,r[0]=wind(r[0],!e);for(var n=1;n<r.length;n++)r[n]=wind(r[n],e);return r}function wind(r,e){return cw(r)===e?r:r.reverse()}function cw(r){return geojsonArea.ring(r)>=0}var geojsonArea=require("geojson-area");module.exports=rewind;
},{"geojson-area":139}],141:[function(require,module,exports){
"use strict";function clip(e,r,t,n,u,i,l,s){if(t/=r,n/=r,l>=t&&s<=n)return e;if(l>n||s<t)return null;for(var h=[],p=0;p<e.length;p++){var a,c,o=e[p],f=o.geometry,g=o.type;if(a=o.min[u],c=o.max[u],a>=t&&c<=n)h.push(o);else if(!(a>n||c<t)){var v=1===g?clipPoints(f,t,n,u):clipGeometry(f,t,n,u,i,3===g);v.length&&h.push(createFeature(o.tags,g,v,o.id))}}return h.length?h:null}function clipPoints(e,r,t,n){for(var u=[],i=0;i<e.length;i++){var l=e[i],s=l[n];s>=r&&s<=t&&u.push(l)}return u}function clipGeometry(e,r,t,n,u,i){for(var l=[],s=0;s<e.length;s++){var h,p,a,c=0,o=0,f=null,g=e[s],v=g.area,m=g.dist,w=g.outer,S=g.length,d=[];for(p=0;p<S-1;p++)h=f||g[p],f=g[p+1],c=o||h[n],o=f[n],c<r?o>t?(d.push(u(h,f,r),u(h,f,t)),i||(d=newSlice(l,d,v,m,w))):o>=r&&d.push(u(h,f,r)):c>t?o<r?(d.push(u(h,f,t),u(h,f,r)),i||(d=newSlice(l,d,v,m,w))):o<=t&&d.push(u(h,f,t)):(d.push(h),o<r?(d.push(u(h,f,r)),i||(d=newSlice(l,d,v,m,w))):o>t&&(d.push(u(h,f,t)),i||(d=newSlice(l,d,v,m,w))));h=g[S-1],c=h[n],c>=r&&c<=t&&d.push(h),a=d[d.length-1],i&&a&&(d[0][0]!==a[0]||d[0][1]!==a[1])&&d.push(d[0]),newSlice(l,d,v,m,w)}return l}function newSlice(e,r,t,n,u){return r.length&&(r.area=t,r.dist=n,void 0!==u&&(r.outer=u),e.push(r)),[]}module.exports=clip;var createFeature=require("./feature");
},{"./feature":143}],142:[function(require,module,exports){
"use strict";function convert(e,t){var r=[];if("FeatureCollection"===e.type)for(var o=0;o<e.features.length;o++)convertFeature(r,e.features[o],t);else"Feature"===e.type?convertFeature(r,e,t):convertFeature(r,{geometry:e},t);return r}function convertFeature(e,t,r){if(null!==t.geometry){var o,a,i,n,u=t.geometry,c=u.type,l=u.coordinates,s=t.properties,p=t.id;if("Point"===c)e.push(createFeature(s,1,[projectPoint(l)],p));else if("MultiPoint"===c)e.push(createFeature(s,1,project(l),p));else if("LineString"===c)e.push(createFeature(s,2,[project(l,r)],p));else if("MultiLineString"===c||"Polygon"===c){for(i=[],o=0;o<l.length;o++)n=project(l[o],r),"Polygon"===c&&(n.outer=0===o),i.push(n);e.push(createFeature(s,"Polygon"===c?3:2,i,p))}else if("MultiPolygon"===c){for(i=[],o=0;o<l.length;o++)for(a=0;a<l[o].length;a++)n=project(l[o][a],r),n.outer=0===a,i.push(n);e.push(createFeature(s,3,i,p))}else{if("GeometryCollection"!==c)throw new Error("Input data is not a valid GeoJSON object.");for(o=0;o<u.geometries.length;o++)convertFeature(e,{geometry:u.geometries[o],properties:s},r)}}}function project(e,t){for(var r=[],o=0;o<e.length;o++)r.push(projectPoint(e[o]));return t&&(simplify(r,t),calcSize(r)),r}function projectPoint(e){var t=Math.sin(e[1]*Math.PI/180),r=e[0]/360+.5,o=.5-.25*Math.log((1+t)/(1-t))/Math.PI;return o=o<0?0:o>1?1:o,[r,o,0]}function calcSize(e){for(var t,r,o=0,a=0,i=0;i<e.length-1;i++)t=r||e[i],r=e[i+1],o+=t[0]*r[1]-r[0]*t[1],a+=Math.abs(r[0]-t[0])+Math.abs(r[1]-t[1]);e.area=Math.abs(o/2),e.dist=a}module.exports=convert;var simplify=require("./simplify"),createFeature=require("./feature");
},{"./feature":143,"./simplify":145}],143:[function(require,module,exports){
"use strict";function createFeature(e,t,a,n){var r={id:n||null,type:t,geometry:a,tags:e||null,min:[1/0,1/0],max:[-(1/0),-(1/0)]};return calcBBox(r),r}function calcBBox(e){var t=e.geometry,a=e.min,n=e.max;if(1===e.type)calcRingBBox(a,n,t);else for(var r=0;r<t.length;r++)calcRingBBox(a,n,t[r]);return e}function calcRingBBox(e,t,a){for(var n,r=0;r<a.length;r++)n=a[r],e[0]=Math.min(n[0],e[0]),t[0]=Math.max(n[0],t[0]),e[1]=Math.min(n[1],e[1]),t[1]=Math.max(n[1],t[1])}module.exports=createFeature;
},{}],144:[function(require,module,exports){
"use strict";function geojsonvt(e,t){return new GeoJSONVT(e,t)}function GeoJSONVT(e,t){t=this.options=extend(Object.create(this.options),t);var i=t.debug;i&&console.time("preprocess data");var o=1<<t.maxZoom,n=convert(e,t.tolerance/(o*t.extent));this.tiles={},this.tileCoords=[],i&&(console.timeEnd("preprocess data"),console.log("index: maxZoom: %d, maxPoints: %d",t.indexMaxZoom,t.indexMaxPoints),console.time("generate tiles"),this.stats={},this.total=0),n=wrap(n,t.buffer/t.extent,intersectX),n.length&&this.splitTile(n,0,0,0),i&&(n.length&&console.log("features: %d, points: %d",this.tiles[0].numFeatures,this.tiles[0].numPoints),console.timeEnd("generate tiles"),console.log("tiles generated:",this.total,JSON.stringify(this.stats)))}function toID(e,t,i){return 32*((1<<e)*i+t)+e}function intersectX(e,t,i){return[i,(i-e[0])*(t[1]-e[1])/(t[0]-e[0])+e[1],1]}function intersectY(e,t,i){return[(i-e[1])*(t[0]-e[0])/(t[1]-e[1])+e[0],i,1]}function extend(e,t){for(var i in t)e[i]=t[i];return e}function isClippedSquare(e,t,i){var o=e.source;if(1!==o.length)return!1;var n=o[0];if(3!==n.type||n.geometry.length>1)return!1;var r=n.geometry[0].length;if(5!==r)return!1;for(var s=0;s<r;s++){var l=transform.point(n.geometry[0][s],t,e.z2,e.x,e.y);if(l[0]!==-i&&l[0]!==t+i||l[1]!==-i&&l[1]!==t+i)return!1}return!0}module.exports=geojsonvt;var convert=require("./convert"),transform=require("./transform"),clip=require("./clip"),wrap=require("./wrap"),createTile=require("./tile");GeoJSONVT.prototype.options={maxZoom:14,indexMaxZoom:5,indexMaxPoints:1e5,solidChildren:!1,tolerance:3,extent:4096,buffer:64,debug:0},GeoJSONVT.prototype.splitTile=function(e,t,i,o,n,r,s){for(var l=[e,t,i,o],a=this.options,u=a.debug,c=null;l.length;){o=l.pop(),i=l.pop(),t=l.pop(),e=l.pop();var p=1<<t,d=toID(t,i,o),m=this.tiles[d],f=t===a.maxZoom?0:a.tolerance/(p*a.extent);if(!m&&(u>1&&console.time("creation"),m=this.tiles[d]=createTile(e,p,i,o,f,t===a.maxZoom),this.tileCoords.push({z:t,x:i,y:o}),u)){u>1&&(console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)",t,i,o,m.numFeatures,m.numPoints,m.numSimplified),console.timeEnd("creation"));var h="z"+t;this.stats[h]=(this.stats[h]||0)+1,this.total++}if(m.source=e,n){if(t===a.maxZoom||t===n)continue;var x=1<<n-t;if(i!==Math.floor(r/x)||o!==Math.floor(s/x))continue}else if(t===a.indexMaxZoom||m.numPoints<=a.indexMaxPoints)continue;if(a.solidChildren||!isClippedSquare(m,a.extent,a.buffer)){m.source=null,u>1&&console.time("clipping");var g,v,M,T,b,y,S=.5*a.buffer/a.extent,Z=.5-S,q=.5+S,w=1+S;g=v=M=T=null,b=clip(e,p,i-S,i+q,0,intersectX,m.min[0],m.max[0]),y=clip(e,p,i+Z,i+w,0,intersectX,m.min[0],m.max[0]),b&&(g=clip(b,p,o-S,o+q,1,intersectY,m.min[1],m.max[1]),v=clip(b,p,o+Z,o+w,1,intersectY,m.min[1],m.max[1])),y&&(M=clip(y,p,o-S,o+q,1,intersectY,m.min[1],m.max[1]),T=clip(y,p,o+Z,o+w,1,intersectY,m.min[1],m.max[1])),u>1&&console.timeEnd("clipping"),e.length&&(l.push(g||[],t+1,2*i,2*o),l.push(v||[],t+1,2*i,2*o+1),l.push(M||[],t+1,2*i+1,2*o),l.push(T||[],t+1,2*i+1,2*o+1))}else n&&(c=t)}return c},GeoJSONVT.prototype.getTile=function(e,t,i){var o=this.options,n=o.extent,r=o.debug,s=1<<e;t=(t%s+s)%s;var l=toID(e,t,i);if(this.tiles[l])return transform.tile(this.tiles[l],n);r>1&&console.log("drilling down to z%d-%d-%d",e,t,i);for(var a,u=e,c=t,p=i;!a&&u>0;)u--,c=Math.floor(c/2),p=Math.floor(p/2),a=this.tiles[toID(u,c,p)];if(!a||!a.source)return null;if(r>1&&console.log("found parent tile z%d-%d-%d",u,c,p),isClippedSquare(a,n,o.buffer))return transform.tile(a,n);r>1&&console.time("drilling down");var d=this.splitTile(a.source,u,c,p,e,t,i);if(r>1&&console.timeEnd("drilling down"),null!==d){var m=1<<e-d;l=toID(d,Math.floor(t/m),Math.floor(i/m))}return this.tiles[l]?transform.tile(this.tiles[l],n):null};
},{"./clip":141,"./convert":142,"./tile":146,"./transform":147,"./wrap":148}],145:[function(require,module,exports){
"use strict";function simplify(t,i){var e,p,r,s,o=i*i,f=t.length,u=0,n=f-1,g=[];for(t[u][2]=1,t[n][2]=1;n;){for(p=0,e=u+1;e<n;e++)r=getSqSegDist(t[e],t[u],t[n]),r>p&&(s=e,p=r);p>o?(t[s][2]=p,g.push(u),g.push(s),u=s):(n=g.pop(),u=g.pop())}}function getSqSegDist(t,i,e){var p=i[0],r=i[1],s=e[0],o=e[1],f=t[0],u=t[1],n=s-p,g=o-r;if(0!==n||0!==g){var l=((f-p)*n+(u-r)*g)/(n*n+g*g);l>1?(p=s,r=o):l>0&&(p+=n*l,r+=g*l)}return n=f-p,g=u-r,n*n+g*g}module.exports=simplify;
},{}],146:[function(require,module,exports){
"use strict";function createTile(e,n,r,i,t,u){for(var a={features:[],numPoints:0,numSimplified:0,numFeatures:0,source:null,x:r,y:i,z2:n,transformed:!1,min:[2,1],max:[-1,0]},m=0;m<e.length;m++){a.numFeatures++,addFeature(a,e[m],t,u);var s=e[m].min,l=e[m].max;s[0]<a.min[0]&&(a.min[0]=s[0]),s[1]<a.min[1]&&(a.min[1]=s[1]),l[0]>a.max[0]&&(a.max[0]=l[0]),l[1]>a.max[1]&&(a.max[1]=l[1])}return a}function addFeature(e,n,r,i){var t,u,a,m,s=n.geometry,l=n.type,o=[],f=r*r;if(1===l)for(t=0;t<s.length;t++)o.push(s[t]),e.numPoints++,e.numSimplified++;else for(t=0;t<s.length;t++)if(a=s[t],i||!(2===l&&a.dist<r||3===l&&a.area<f)){var d=[];for(u=0;u<a.length;u++)m=a[u],(i||m[2]>f)&&(d.push(m),e.numSimplified++),e.numPoints++;3===l&&rewind(d,a.outer),o.push(d)}else e.numPoints+=a.length;if(o.length){var g={geometry:o,type:l,tags:n.tags||null};null!==n.id&&(g.id=n.id),e.features.push(g)}}function rewind(e,n){var r=signedArea(e);r<0===n&&e.reverse()}function signedArea(e){for(var n,r,i=0,t=0,u=e.length,a=u-1;t<u;a=t++)n=e[t],r=e[a],i+=(r[0]-n[0])*(n[1]+r[1]);return i}module.exports=createTile;
},{}],147:[function(require,module,exports){
"use strict";function transformTile(r,t){if(r.transformed)return r;var n,e,o,f=r.z2,a=r.x,s=r.y;for(n=0;n<r.features.length;n++){var i=r.features[n],u=i.geometry,m=i.type;if(1===m)for(e=0;e<u.length;e++)u[e]=transformPoint(u[e],t,f,a,s);else for(e=0;e<u.length;e++){var l=u[e];for(o=0;o<l.length;o++)l[o]=transformPoint(l[o],t,f,a,s)}}return r.transformed=!0,r}function transformPoint(r,t,n,e,o){var f=Math.round(t*(r[0]*n-e)),a=Math.round(t*(r[1]*n-o));return[f,a]}exports.tile=transformTile,exports.point=transformPoint;
},{}],148:[function(require,module,exports){
"use strict";function wrap(r,e,t){var o=r,a=clip(r,1,-1-e,e,0,t,-1,2),s=clip(r,1,1-e,2+e,0,t,-1,2);return(a||s)&&(o=clip(r,1,-e,1+e,0,t,-1,2)||[],a&&(o=shiftFeatureCoords(a,1).concat(o)),s&&(o=o.concat(shiftFeatureCoords(s,-1)))),o}function shiftFeatureCoords(r,e){for(var t=[],o=0;o<r.length;o++){var a,s=r[o],i=s.type;if(1===i)a=shiftCoords(s.geometry,e);else{a=[];for(var u=0;u<s.geometry.length;u++)a.push(shiftCoords(s.geometry[u],e))}t.push(createFeature(s.tags,i,a,s.id))}return t}function shiftCoords(r,e){var t=[];t.area=r.area,t.dist=r.dist;for(var o=0;o<r.length;o++)t.push([r[o][0]+e,r[o][1],r[o][2]]);return t}var clip=require("./clip"),createFeature=require("./feature");module.exports=wrap;
},{"./clip":141,"./feature":143}],149:[function(require,module,exports){
"use strict";function GridIndex(t,r,e){var s=this.cells=[];if(t instanceof ArrayBuffer){this.arrayBuffer=t;var i=new Int32Array(this.arrayBuffer);t=i[0],r=i[1],e=i[2],this.d=r+2*e;for(var h=0;h<this.d*this.d;h++){var n=i[NUM_PARAMS+h],o=i[NUM_PARAMS+h+1];s.push(n===o?null:i.subarray(n,o))}var l=i[NUM_PARAMS+s.length],a=i[NUM_PARAMS+s.length+1];this.keys=i.subarray(l,a),this.bboxes=i.subarray(a),this.insert=this._insertReadonly}else{this.d=r+2*e;for(var d=0;d<this.d*this.d;d++)s.push([]);this.keys=[],this.bboxes=[]}this.n=r,this.extent=t,this.padding=e,this.scale=r/t,this.uid=0;var f=e/r*t;this.min=-f,this.max=t+f}module.exports=GridIndex;var NUM_PARAMS=3;GridIndex.prototype.insert=function(t,r,e,s,i){this._forEachCell(r,e,s,i,this._insertCell,this.uid++),this.keys.push(t),this.bboxes.push(r),this.bboxes.push(e),this.bboxes.push(s),this.bboxes.push(i)},GridIndex.prototype._insertReadonly=function(){throw"Cannot insert into a GridIndex created from an ArrayBuffer."},GridIndex.prototype._insertCell=function(t,r,e,s,i,h){this.cells[i].push(h)},GridIndex.prototype.query=function(t,r,e,s){var i=this.min,h=this.max;if(t<=i&&r<=i&&h<=e&&h<=s)return Array.prototype.slice.call(this.keys);var n=[],o={};return this._forEachCell(t,r,e,s,this._queryCell,n,o),n},GridIndex.prototype._queryCell=function(t,r,e,s,i,h,n){var o=this.cells[i];if(null!==o)for(var l=this.keys,a=this.bboxes,d=0;d<o.length;d++){var f=o[d];if(void 0===n[f]){var u=4*f;t<=a[u+2]&&r<=a[u+3]&&e>=a[u+0]&&s>=a[u+1]?(n[f]=!0,h.push(l[f])):n[f]=!1}}},GridIndex.prototype._forEachCell=function(t,r,e,s,i,h,n){for(var o=this._convertToCellCoord(t),l=this._convertToCellCoord(r),a=this._convertToCellCoord(e),d=this._convertToCellCoord(s),f=o;f<=a;f++)for(var u=l;u<=d;u++){var y=this.d*u+f;if(i.call(this,t,r,e,s,y,h,n))return}},GridIndex.prototype._convertToCellCoord=function(t){return Math.max(0,Math.min(this.d-1,Math.floor(t*this.scale)+this.padding))},GridIndex.prototype.toArrayBuffer=function(){if(this.arrayBuffer)return this.arrayBuffer;for(var t=this.cells,r=NUM_PARAMS+this.cells.length+1+1,e=0,s=0;s<this.cells.length;s++)e+=this.cells[s].length;var i=new Int32Array(r+e+this.keys.length+this.bboxes.length);i[0]=this.extent,i[1]=this.n,i[2]=this.padding;for(var h=r,n=0;n<t.length;n++){var o=t[n];i[NUM_PARAMS+n]=h,i.set(o,h),h+=o.length}return i[NUM_PARAMS+t.length]=h,i.set(this.keys,h),h+=this.keys.length,i[NUM_PARAMS+t.length+1]=h,i.set(this.bboxes,h),h+=this.bboxes.length,i.buffer};
},{}],150:[function(require,module,exports){
exports.read=function(a,o,t,r,h){var M,p,w=8*h-r-1,f=(1<<w)-1,e=f>>1,i=-7,N=t?h-1:0,n=t?-1:1,s=a[o+N];for(N+=n,M=s&(1<<-i)-1,s>>=-i,i+=w;i>0;M=256*M+a[o+N],N+=n,i-=8);for(p=M&(1<<-i)-1,M>>=-i,i+=r;i>0;p=256*p+a[o+N],N+=n,i-=8);if(0===M)M=1-e;else{if(M===f)return p?NaN:(s?-1:1)*(1/0);p+=Math.pow(2,r),M-=e}return(s?-1:1)*p*Math.pow(2,M-r)},exports.write=function(a,o,t,r,h,M){var p,w,f,e=8*M-h-1,i=(1<<e)-1,N=i>>1,n=23===h?Math.pow(2,-24)-Math.pow(2,-77):0,s=r?0:M-1,u=r?1:-1,l=o<0||0===o&&1/o<0?1:0;for(o=Math.abs(o),isNaN(o)||o===1/0?(w=isNaN(o)?1:0,p=i):(p=Math.floor(Math.log(o)/Math.LN2),o*(f=Math.pow(2,-p))<1&&(p--,f*=2),o+=p+N>=1?n/f:n*Math.pow(2,1-N),o*f>=2&&(p++,f/=2),p+N>=i?(w=0,p=i):p+N>=1?(w=(o*f-1)*Math.pow(2,h),p+=N):(w=o*Math.pow(2,N-1)*Math.pow(2,h),p=0));h>=8;a[t+s]=255&w,s+=u,w/=256,h-=8);for(p=p<<h|w,e+=h;e>0;a[t+s]=255&p,s+=u,p/=256,e-=8);a[t+s-u]|=128*l};
},{}],151:[function(require,module,exports){
"use strict";function kdbush(t,i,e,s,n){return new KDBush(t,i,e,s,n)}function KDBush(t,i,e,s,n){i=i||defaultGetX,e=e||defaultGetY,n=n||Array,this.nodeSize=s||64,this.points=t,this.ids=new n(t.length),this.coords=new n(2*t.length);for(var r=0;r<t.length;r++)this.ids[r]=r,this.coords[2*r]=i(t[r]),this.coords[2*r+1]=e(t[r]);sort(this.ids,this.coords,this.nodeSize,0,this.ids.length-1,0)}function defaultGetX(t){return t[0]}function defaultGetY(t){return t[1]}var sort=require("./sort"),range=require("./range"),within=require("./within");module.exports=kdbush,KDBush.prototype={range:function(t,i,e,s){return range(this.ids,this.coords,t,i,e,s,this.nodeSize)},within:function(t,i,e){return within(this.ids,this.coords,t,i,e,this.nodeSize)}};
},{"./range":152,"./sort":153,"./within":154}],152:[function(require,module,exports){
"use strict";function range(p,r,s,u,h,e,o){for(var a,t,n=[0,p.length-1,0],f=[];n.length;){var l=n.pop(),v=n.pop(),g=n.pop();if(v-g<=o)for(var i=g;i<=v;i++)a=r[2*i],t=r[2*i+1],a>=s&&a<=h&&t>=u&&t<=e&&f.push(p[i]);else{var c=Math.floor((g+v)/2);a=r[2*c],t=r[2*c+1],a>=s&&a<=h&&t>=u&&t<=e&&f.push(p[c]);var d=(l+1)%2;(0===l?s<=a:u<=t)&&(n.push(g),n.push(c-1),n.push(d)),(0===l?h>=a:e>=t)&&(n.push(c+1),n.push(v),n.push(d))}}return f}module.exports=range;
},{}],153:[function(require,module,exports){
"use strict";function sortKD(t,a,o,s,r,e){if(!(r-s<=o)){var f=Math.floor((s+r)/2);select(t,a,f,s,r,e%2),sortKD(t,a,o,s,f-1,e+1),sortKD(t,a,o,f+1,r,e+1)}}function select(t,a,o,s,r,e){for(;r>s;){if(r-s>600){var f=r-s+1,p=o-s+1,w=Math.log(f),m=.5*Math.exp(2*w/3),n=.5*Math.sqrt(w*m*(f-m)/f)*(p-f/2<0?-1:1),c=Math.max(s,Math.floor(o-p*m/f+n)),h=Math.min(r,Math.floor(o+(f-p)*m/f+n));select(t,a,o,c,h,e)}var i=a[2*o+e],l=s,M=r;for(swapItem(t,a,s,o),a[2*r+e]>i&&swapItem(t,a,s,r);l<M;){for(swapItem(t,a,l,M),l++,M--;a[2*l+e]<i;)l++;for(;a[2*M+e]>i;)M--}a[2*s+e]===i?swapItem(t,a,s,M):(M++,swapItem(t,a,M,r)),M<=o&&(s=M+1),o<=M&&(r=M-1)}}function swapItem(t,a,o,s){swap(t,o,s),swap(a,2*o,2*s),swap(a,2*o+1,2*s+1)}function swap(t,a,o){var s=t[a];t[a]=t[o],t[o]=s}module.exports=sortKD;
},{}],154:[function(require,module,exports){
"use strict";function within(s,p,r,t,u,h){for(var i=[0,s.length-1,0],o=[],n=u*u;i.length;){var e=i.pop(),a=i.pop(),f=i.pop();if(a-f<=h)for(var v=f;v<=a;v++)sqDist(p[2*v],p[2*v+1],r,t)<=n&&o.push(s[v]);else{var l=Math.floor((f+a)/2),c=p[2*l],q=p[2*l+1];sqDist(c,q,r,t)<=n&&o.push(s[l]);var D=(e+1)%2;(0===e?r-u<=c:t-u<=q)&&(i.push(f),i.push(l-1),i.push(D)),(0===e?r+u>=c:t+u>=q)&&(i.push(l+1),i.push(a),i.push(D))}}return o}function sqDist(s,p,r,t){var u=s-r,h=p-t;return u*u+h*h}module.exports=within;
},{}],155:[function(require,module,exports){
function isObjectLike(r){return!!r&&"object"==typeof r}function arraySome(r,e){for(var a=-1,t=r.length;++a<t;)if(e(r[a],a,r))return!0;return!1}function baseIsEqual(r,e,a,t,o,n){return r===e||(null==r||null==e||!isObject(r)&&!isObjectLike(e)?r!==r&&e!==e:baseIsEqualDeep(r,e,baseIsEqual,a,t,o,n))}function baseIsEqualDeep(r,e,a,t,o,n,u){var c=isArray(r),s=isArray(e),i=arrayTag,g=arrayTag;c||(i=objToString.call(r),i==argsTag?i=objectTag:i!=objectTag&&(c=isTypedArray(r))),s||(g=objToString.call(e),g==argsTag?g=objectTag:g!=objectTag&&(s=isTypedArray(e)));var b=i==objectTag,l=g==objectTag,f=i==g;if(f&&!c&&!b)return equalByTag(r,e,i);if(!o){var y=b&&hasOwnProperty.call(r,"__wrapped__"),T=l&&hasOwnProperty.call(e,"__wrapped__");if(y||T)return a(y?r.value():r,T?e.value():e,t,o,n,u)}if(!f)return!1;n||(n=[]),u||(u=[]);for(var j=n.length;j--;)if(n[j]==r)return u[j]==e;n.push(r),u.push(e);var p=(c?equalArrays:equalObjects)(r,e,a,t,o,n,u);return n.pop(),u.pop(),p}function equalArrays(r,e,a,t,o,n,u){var c=-1,s=r.length,i=e.length;if(s!=i&&!(o&&i>s))return!1;for(;++c<s;){var g=r[c],b=e[c],l=t?t(o?b:g,o?g:b,c):void 0;if(void 0!==l){if(l)continue;return!1}if(o){if(!arraySome(e,function(r){return g===r||a(g,r,t,o,n,u)}))return!1}else if(g!==b&&!a(g,b,t,o,n,u))return!1}return!0}function equalByTag(r,e,a){switch(a){case boolTag:case dateTag:return+r==+e;case errorTag:return r.name==e.name&&r.message==e.message;case numberTag:return r!=+r?e!=+e:r==+e;case regexpTag:case stringTag:return r==e+""}return!1}function equalObjects(r,e,a,t,o,n,u){var c=keys(r),s=c.length,i=keys(e),g=i.length;if(s!=g&&!o)return!1;for(var b=s;b--;){var l=c[b];if(!(o?l in e:hasOwnProperty.call(e,l)))return!1}for(var f=o;++b<s;){l=c[b];var y=r[l],T=e[l],j=t?t(o?T:y,o?y:T,l):void 0;if(!(void 0===j?a(y,T,t,o,n,u):j))return!1;f||(f="constructor"==l)}if(!f){var p=r.constructor,v=e.constructor;if(p!=v&&"constructor"in r&&"constructor"in e&&!("function"==typeof p&&p instanceof p&&"function"==typeof v&&v instanceof v))return!1}return!0}function isObject(r){var e=typeof r;return!!r&&("object"==e||"function"==e)}var isArray=require("lodash.isarray"),isTypedArray=require("lodash.istypedarray"),keys=require("lodash.keys"),argsTag="[object Arguments]",arrayTag="[object Array]",boolTag="[object Boolean]",dateTag="[object Date]",errorTag="[object Error]",numberTag="[object Number]",objectTag="[object Object]",regexpTag="[object RegExp]",stringTag="[object String]",objectProto=Object.prototype,hasOwnProperty=objectProto.hasOwnProperty,objToString=objectProto.toString;module.exports=baseIsEqual;
},{"lodash.isarray":159,"lodash.istypedarray":161,"lodash.keys":162}],156:[function(require,module,exports){
function bindCallback(n,t,r){if("function"!=typeof n)return identity;if(void 0===t)return n;switch(r){case 1:return function(r){return n.call(t,r)};case 3:return function(r,e,u){return n.call(t,r,e,u)};case 4:return function(r,e,u,c){return n.call(t,r,e,u,c)};case 5:return function(r,e,u,c,i){return n.call(t,r,e,u,c,i)}}return function(){return n.apply(t,arguments)}}function identity(n){return n}module.exports=bindCallback;
},{}],157:[function(require,module,exports){
function isObjectLike(t){return!!t&&"object"==typeof t}function getNative(t,o){var e=null==t?void 0:t[o];return isNative(e)?e:void 0}function isFunction(t){return isObject(t)&&objToString.call(t)==funcTag}function isObject(t){var o=typeof t;return!!t&&("object"==o||"function"==o)}function isNative(t){return null!=t&&(isFunction(t)?reIsNative.test(fnToString.call(t)):isObjectLike(t)&&reIsHostCtor.test(t))}var funcTag="[object Function]",reIsHostCtor=/^\[object .+?Constructor\]$/,objectProto=Object.prototype,fnToString=Function.prototype.toString,hasOwnProperty=objectProto.hasOwnProperty,objToString=objectProto.toString,reIsNative=RegExp("^"+fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");module.exports=getNative;
},{}],158:[function(require,module,exports){
function isArguments(t){return isArrayLikeObject(t)&&hasOwnProperty.call(t,"callee")&&(!propertyIsEnumerable.call(t,"callee")||objectToString.call(t)==argsTag)}function isArrayLike(t){return null!=t&&isLength(t.length)&&!isFunction(t)}function isArrayLikeObject(t){return isObjectLike(t)&&isArrayLike(t)}function isFunction(t){var e=isObject(t)?objectToString.call(t):"";return e==funcTag||e==genTag}function isLength(t){return"number"==typeof t&&t>-1&&t%1==0&&t<=MAX_SAFE_INTEGER}function isObject(t){var e=typeof t;return!!t&&("object"==e||"function"==e)}function isObjectLike(t){return!!t&&"object"==typeof t}var MAX_SAFE_INTEGER=9007199254740991,argsTag="[object Arguments]",funcTag="[object Function]",genTag="[object GeneratorFunction]",objectProto=Object.prototype,hasOwnProperty=objectProto.hasOwnProperty,objectToString=objectProto.toString,propertyIsEnumerable=objectProto.propertyIsEnumerable;module.exports=isArguments;
},{}],159:[function(require,module,exports){
function isObjectLike(t){return!!t&&"object"==typeof t}function getNative(t,r){var e=null==t?void 0:t[r];return isNative(e)?e:void 0}function isLength(t){return"number"==typeof t&&t>-1&&t%1==0&&t<=MAX_SAFE_INTEGER}function isFunction(t){return isObject(t)&&objToString.call(t)==funcTag}function isObject(t){var r=typeof t;return!!t&&("object"==r||"function"==r)}function isNative(t){return null!=t&&(isFunction(t)?reIsNative.test(fnToString.call(t)):isObjectLike(t)&&reIsHostCtor.test(t))}var arrayTag="[object Array]",funcTag="[object Function]",reIsHostCtor=/^\[object .+?Constructor\]$/,objectProto=Object.prototype,fnToString=Function.prototype.toString,hasOwnProperty=objectProto.hasOwnProperty,objToString=objectProto.toString,reIsNative=RegExp("^"+fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),nativeIsArray=getNative(Array,"isArray"),MAX_SAFE_INTEGER=9007199254740991,isArray=nativeIsArray||function(t){return isObjectLike(t)&&isLength(t.length)&&objToString.call(t)==arrayTag};module.exports=isArray;
},{}],160:[function(require,module,exports){
function isEqual(a,l,i,e){i="function"==typeof i?bindCallback(i,e,3):void 0;var s=i?i(a,l):void 0;return void 0===s?baseIsEqual(a,l,i):!!s}var baseIsEqual=require("lodash._baseisequal"),bindCallback=require("lodash._bindcallback");module.exports=isEqual;
},{"lodash._baseisequal":155,"lodash._bindcallback":156}],161:[function(require,module,exports){
function isLength(a){return"number"==typeof a&&a>-1&&a%1==0&&a<=MAX_SAFE_INTEGER}function isObjectLike(a){return!!a&&"object"==typeof a}function isTypedArray(a){return isObjectLike(a)&&isLength(a.length)&&!!typedArrayTags[objectToString.call(a)]}var MAX_SAFE_INTEGER=9007199254740991,argsTag="[object Arguments]",arrayTag="[object Array]",boolTag="[object Boolean]",dateTag="[object Date]",errorTag="[object Error]",funcTag="[object Function]",mapTag="[object Map]",numberTag="[object Number]",objectTag="[object Object]",regexpTag="[object RegExp]",setTag="[object Set]",stringTag="[object String]",weakMapTag="[object WeakMap]",arrayBufferTag="[object ArrayBuffer]",dataViewTag="[object DataView]",float32Tag="[object Float32Array]",float64Tag="[object Float64Array]",int8Tag="[object Int8Array]",int16Tag="[object Int16Array]",int32Tag="[object Int32Array]",uint8Tag="[object Uint8Array]",uint8ClampedTag="[object Uint8ClampedArray]",uint16Tag="[object Uint16Array]",uint32Tag="[object Uint32Array]",typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=!0,typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dataViewTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=!1;var objectProto=Object.prototype,objectToString=objectProto.toString;module.exports=isTypedArray;
},{}],162:[function(require,module,exports){
function baseProperty(e){return function(t){return null==t?void 0:t[e]}}function isArrayLike(e){return null!=e&&isLength(getLength(e))}function isIndex(e,t){return e="number"==typeof e||reIsUint.test(e)?+e:-1,t=null==t?MAX_SAFE_INTEGER:t,e>-1&&e%1==0&&e<t}function isLength(e){return"number"==typeof e&&e>-1&&e%1==0&&e<=MAX_SAFE_INTEGER}function shimKeys(e){for(var t=keysIn(e),r=t.length,n=r&&e.length,s=!!n&&isLength(n)&&(isArray(e)||isArguments(e)),o=-1,i=[];++o<r;){var u=t[o];(s&&isIndex(u,n)||hasOwnProperty.call(e,u))&&i.push(u)}return i}function isObject(e){var t=typeof e;return!!e&&("object"==t||"function"==t)}function keysIn(e){if(null==e)return[];isObject(e)||(e=Object(e));var t=e.length;t=t&&isLength(t)&&(isArray(e)||isArguments(e))&&t||0;for(var r=e.constructor,n=-1,s="function"==typeof r&&r.prototype===e,o=Array(t),i=t>0;++n<t;)o[n]=n+"";for(var u in e)i&&isIndex(u,t)||"constructor"==u&&(s||!hasOwnProperty.call(e,u))||o.push(u);return o}var getNative=require("lodash._getnative"),isArguments=require("lodash.isarguments"),isArray=require("lodash.isarray"),reIsUint=/^\d+$/,objectProto=Object.prototype,hasOwnProperty=objectProto.hasOwnProperty,nativeKeys=getNative(Object,"keys"),MAX_SAFE_INTEGER=9007199254740991,getLength=baseProperty("length"),keys=nativeKeys?function(e){var t=null==e?void 0:e.constructor;return"function"==typeof t&&t.prototype===e||"function"!=typeof e&&isArrayLike(e)?shimKeys(e):isObject(e)?nativeKeys(e):[]}:shimKeys;module.exports=keys;
},{"lodash._getnative":157,"lodash.isarguments":158,"lodash.isarray":159}],163:[function(require,module,exports){
function xyz2lab(r){return r>t3?Math.pow(r,1/3):r/t2+t0}function lab2xyz(r){return r>t1?r*r*r:t2*(r-t0)}function xyz2rgb(r){return 255*(r<=.0031308?12.92*r:1.055*Math.pow(r,1/2.4)-.055)}function rgb2xyz(r){return(r/=255)<=.04045?r/12.92:Math.pow((r+.055)/1.055,2.4)}function rgbToLab(r){var t=rgb2xyz(r[0]),a=rgb2xyz(r[1]),n=rgb2xyz(r[2]),b=xyz2lab((.4124564*t+.3575761*a+.1804375*n)/Xn),o=xyz2lab((.2126729*t+.7151522*a+.072175*n)/Yn),g=xyz2lab((.0193339*t+.119192*a+.9503041*n)/Zn);return[116*o-16,500*(b-o),200*(o-g),r[3]]}function labToRgb(r){var t=(r[0]+16)/116,a=isNaN(r[1])?t:t+r[1]/500,n=isNaN(r[2])?t:t-r[2]/200;return t=Yn*lab2xyz(t),a=Xn*lab2xyz(a),n=Zn*lab2xyz(n),[xyz2rgb(3.2404542*a-1.5371385*t-.4985314*n),xyz2rgb(-.969266*a+1.8760108*t+.041556*n),xyz2rgb(.0556434*a-.2040259*t+1.0572252*n),r[3]]}function rgbToHcl(r){var t=rgbToLab(r),a=t[0],n=t[1],b=t[2],o=Math.atan2(b,n)*rad2deg;return[o<0?o+360:o,Math.sqrt(n*n+b*b),a,r[3]]}function hclToRgb(r){var t=r[0]*deg2rad,a=r[1],n=r[2];return labToRgb([n,Math.cos(t)*a,Math.sin(t)*a,r[3]])}var Kn=18,Xn=.95047,Yn=1,Zn=1.08883,t0=4/29,t1=6/29,t2=3*t1*t1,t3=t1*t1*t1,deg2rad=Math.PI/180,rad2deg=180/Math.PI;module.exports={lab:{forward:rgbToLab,reverse:labToRgb},hcl:{forward:rgbToHcl,reverse:hclToRgb}};
},{}],164:[function(require,module,exports){
"use strict";function identityFunction(t){return t}function createFunction(t,o){var e;if(isFunctionDefinition(t)){var n,r=t.stops&&"object"==typeof t.stops[0][0],i=r||void 0!==t.property,s=r||!i,a=t.stops&&typeof(r?t.stops[0][0].property:t.stops[0][0]),p=t.type||o||("string"===a?"categorical":"exponential");if("exponential"===p)n=evaluateExponentialFunction;else if("interval"===p)n=evaluateIntervalFunction;else if("categorical"===p)n=evaluateCategoricalFunction;else{if("identity"!==p)throw new Error('Unknown function type "'+p+'"');n=evaluateIdentityFunction}var u;if(t.colorSpace&&"rgb"!==t.colorSpace){if(!colorSpaces[t.colorSpace])throw new Error("Unknown color space: "+t.colorSpace);var c=colorSpaces[t.colorSpace];t=JSON.parse(JSON.stringify(t));for(var l=0;l<t.stops.length;l++)t.stops[l]=[t.stops[l][0],c.forward(t.stops[l][1])];u=c.reverse}else u=identityFunction;if(r){var f={},v=[];for(l=0;l<t.stops.length;l++){var y=t.stops[l];void 0===f[y[0].zoom]&&(f[y[0].zoom]={zoom:y[0].zoom,type:t.type,property:t.property,stops:[]}),f[y[0].zoom].stops.push([y[0].value,y[1]])}for(var F in f)v.push([f[F].zoom,createFunction(f[F])]);e=function(o,e){return u(evaluateExponentialFunction({stops:v,base:t.base},o)(o,e))},e.isFeatureConstant=!1,e.isZoomConstant=!1}else s?(e=function(o){return u(n(t,o))},e.isFeatureConstant=!0,e.isZoomConstant=!1):(e=function(o,e){return u(n(t,e[t.property]))},e.isFeatureConstant=!1,e.isZoomConstant=!0)}else e=function(){return t},e.isFeatureConstant=!0,e.isZoomConstant=!0;return e}function evaluateCategoricalFunction(t,o){for(var e=0;e<t.stops.length;e++)if(o===t.stops[e][0])return t.stops[e][1];return t.stops[0][1]}function evaluateIntervalFunction(t,o){for(var e=0;e<t.stops.length&&!(o<t.stops[e][0]);e++);return t.stops[Math.max(e-1,0)][1]}function evaluateExponentialFunction(t,o){for(var e=void 0!==t.base?t.base:1,n=0;;){if(n>=t.stops.length)break;if(o<=t.stops[n][0])break;n++}return 0===n?t.stops[n][1]:n===t.stops.length?t.stops[n-1][1]:interpolate(o,e,t.stops[n-1][0],t.stops[n][0],t.stops[n-1][1],t.stops[n][1])}function evaluateIdentityFunction(t,o){return o}function interpolate(t,o,e,n,r,i){return"function"==typeof r?function(){var s=r.apply(void 0,arguments),a=i.apply(void 0,arguments);return interpolate(t,o,e,n,s,a)}:r.length?interpolateArray(t,o,e,n,r,i):interpolateNumber(t,o,e,n,r,i)}function interpolateNumber(t,o,e,n,r,i){var s,a=n-e,p=t-e;return s=1===o?p/a:(Math.pow(o,p)-1)/(Math.pow(o,a)-1),r*(1-s)+i*s}function interpolateArray(t,o,e,n,r,i){for(var s=[],a=0;a<r.length;a++)s[a]=interpolateNumber(t,o,e,n,r[a],i[a]);return s}function isFunctionDefinition(t){return"object"==typeof t&&(t.stops||"identity"===t.type)}var colorSpaces=require("./color_spaces");module.exports.isFunctionDefinition=isFunctionDefinition,module.exports.interpolated=function(t){return createFunction(t,"exponential")},module.exports["piecewise-constant"]=function(t){return createFunction(t,"interval")};
},{"./color_spaces":163}],165:[function(require,module,exports){
"use strict";function deref(e,r){var f={};for(var t in e)"ref"!==t&&(f[t]=e[t]);return refProperties.forEach(function(e){e in r&&(f[e]=r[e])}),f}function derefLayers(e){e=e.slice();var r,f=Object.create(null);for(r=0;r<e.length;r++)f[e[r].id]=e[r];for(r=0;r<e.length;r++)"ref"in e[r]&&(e[r]=deref(e[r],f[e[r].ref]));return e}var refProperties=require("./util/ref_properties");module.exports=derefLayers;
},{"./util/ref_properties":171}],166:[function(require,module,exports){
"use strict";function diffSources(e,r,o,a){e=e||{},r=r||{};var s;for(s in e)e.hasOwnProperty(s)&&(r.hasOwnProperty(s)||(o.push({command:operations.removeSource,args:[s]}),a[s]=!0));for(s in r)r.hasOwnProperty(s)&&(e.hasOwnProperty(s)?isEqual(e[s],r[s])||(o.push({command:operations.removeSource,args:[s]}),o.push({command:operations.addSource,args:[s,r[s]]}),a[s]=!0):o.push({command:operations.addSource,args:[s,r[s]]}))}function diffLayerPropertyChanges(e,r,o,a,s,t){e=e||{},r=r||{};var n;for(n in e)e.hasOwnProperty(n)&&(isEqual(e[n],r[n])||o.push({command:t,args:[a,n,r[n],s]}));for(n in r)r.hasOwnProperty(n)&&!e.hasOwnProperty(n)&&(isEqual(e[n],r[n])||o.push({command:t,args:[a,n,r[n],s]}))}function pluckId(e){return e.id}function indexById(e,r){return e[r.id]=r,e}function diffLayers(e,r,o){e=e||[],r=r||[];var a,s,t,n,i,p,m,u=e.map(pluckId),l=r.map(pluckId),y=e.reduce(indexById,{}),c=r.reduce(indexById,{}),d=u.slice(),h=Object.create(null);for(a=0,s=0;a<u.length;a++)t=u[a],c.hasOwnProperty(t)?s++:(o.push({command:operations.removeLayer,args:[t]}),d.splice(d.indexOf(t,s),1));for(a=0,s=0;a<l.length;a++)t=l[l.length-1-a],d[d.length-1-a]!==t&&(y.hasOwnProperty(t)?(o.push({command:operations.removeLayer,args:[t]}),d.splice(d.lastIndexOf(t,d.length-s),1)):s++,p=d[d.length-a],o.push({command:operations.addLayer,args:[c[t],p]}),d.splice(d.length-a,0,t),h[t]=!0);for(a=0;a<l.length;a++)if(t=l[a],n=y[t],i=c[t],!h[t]&&!isEqual(n,i))if(isEqual(n.source,i.source)&&isEqual(n["source-layer"],i["source-layer"])&&isEqual(n.type,i.type)){diffLayerPropertyChanges(n.layout,i.layout,o,t,null,operations.setLayoutProperty),diffLayerPropertyChanges(n.paint,i.paint,o,t,null,operations.setPaintProperty),isEqual(n.filter,i.filter)||o.push({command:operations.setFilter,args:[t,i.filter]}),isEqual(n.minzoom,i.minzoom)&&isEqual(n.maxzoom,i.maxzoom)||o.push({command:operations.setLayerZoomRange,args:[t,i.minzoom,i.maxzoom]});for(m in n)n.hasOwnProperty(m)&&"layout"!==m&&"paint"!==m&&"filter"!==m&&"metadata"!==m&&"minzoom"!==m&&"maxzoom"!==m&&(0===m.indexOf("paint.")?diffLayerPropertyChanges(n[m],i[m],o,t,m.slice(6),operations.setPaintProperty):isEqual(n[m],i[m])||o.push({command:operations.setLayerProperty,args:[t,m,i[m]]}));for(m in i)i.hasOwnProperty(m)&&!n.hasOwnProperty(m)&&"layout"!==m&&"paint"!==m&&"filter"!==m&&"metadata"!==m&&"minzoom"!==m&&"maxzoom"!==m&&(0===m.indexOf("paint.")?diffLayerPropertyChanges(n[m],i[m],o,t,m.slice(6),operations.setPaintProperty):isEqual(n[m],i[m])||o.push({command:operations.setLayerProperty,args:[t,m,i[m]]}))}else o.push({command:operations.removeLayer,args:[t]}),p=d[d.lastIndexOf(t)+1],o.push({command:operations.addLayer,args:[i,p]})}function diffStyles(e,r){if(!e)return[{command:operations.setStyle,args:[r]}];var o=[];try{if(!isEqual(e.version,r.version))return[{command:operations.setStyle,args:[r]}];isEqual(e.center,r.center)||o.push({command:operations.setCenter,args:[r.center]}),isEqual(e.zoom,r.zoom)||o.push({command:operations.setZoom,args:[r.zoom]}),isEqual(e.bearing,r.bearing)||o.push({command:operations.setBearing,args:[r.bearing]}),isEqual(e.pitch,r.pitch)||o.push({command:operations.setPitch,args:[r.pitch]}),isEqual(e.sprite,r.sprite)||o.push({command:operations.setSprite,args:[r.sprite]}),isEqual(e.glyphs,r.glyphs)||o.push({command:operations.setGlyphs,args:[r.glyphs]}),isEqual(e.transition,r.transition)||o.push({command:operations.setTransition,args:[r.transition]}),isEqual(e.light,r.light)||o.push({command:operations.setLight,args:[r.light]});var a={},s=[];diffSources(e.sources,r.sources,s,a);var t=[];e.layers&&e.layers.forEach(function(e){a[e.source]?o.push({command:operations.removeLayer,args:[e.id]}):t.push(e)}),o=o.concat(s),diffLayers(t,r.layers,o)}catch(e){console.warn("Unable to compute style diff:",e),o=[{command:operations.setStyle,args:[r]}]}return o}var isEqual=require("lodash.isequal"),operations={setStyle:"setStyle",addLayer:"addLayer",removeLayer:"removeLayer",setPaintProperty:"setPaintProperty",setLayoutProperty:"setLayoutProperty",setFilter:"setFilter",addSource:"addSource",removeSource:"removeSource",setLayerZoomRange:"setLayerZoomRange",setLayerProperty:"setLayerProperty",setCenter:"setCenter",setZoom:"setZoom",setBearing:"setBearing",setPitch:"setPitch",setSprite:"setSprite",setGlyphs:"setGlyphs",setTransition:"setTransition",setLight:"setLight"};module.exports=diffStyles,module.exports.operations=operations;
},{"lodash.isequal":160}],167:[function(require,module,exports){
"use strict";function ValidationError(r,i){this.message=(r?r+": ":"")+format.apply(format,Array.prototype.slice.call(arguments,2)),null!==i&&void 0!==i&&i.__line__&&(this.line=i.__line__)}var format=require("util").format;module.exports=ValidationError;
},{"util":205}],168:[function(require,module,exports){
"use strict";function key(r){return stringify(refProperties.map(function(e){return r[e]}))}function groupByLayout(r){var e,t,i={};for(e=0;e<r.length;e++){t=key(r[e]);var u=i[t];u||(u=i[t]=[]),u.push(r[e])}var n=[];for(t in i)n.push(i[t]);return n}var refProperties=require("./util/ref_properties"),stringify=require("fast-stable-stringify");module.exports=groupByLayout;
},{"./util/ref_properties":171,"fast-stable-stringify":137}],169:[function(require,module,exports){
"use strict";module.exports=function(r){for(var t=1;t<arguments.length;t++){var e=arguments[t];for(var n in e)r[n]=e[n]}return r};
},{}],170:[function(require,module,exports){
"use strict";module.exports=function(n){return n instanceof Number?"number":n instanceof String?"string":n instanceof Boolean?"boolean":Array.isArray(n)?"array":null===n?"null":typeof n};
},{}],171:[function(require,module,exports){
"use strict";module.exports=["type","source","source-layer","minzoom","maxzoom","filter","layout"];
},{}],172:[function(require,module,exports){
"use strict";module.exports=function(n){return n instanceof Number||n instanceof String||n instanceof Boolean?n.valueOf():n};
},{}],173:[function(require,module,exports){
"use strict";var ValidationError=require("../error/validation_error"),getType=require("../util/get_type"),extend=require("../util/extend");module.exports=function(e){var r=require("./validate_function"),t=require("./validate_object"),i={"*":function(){return[]},array:require("./validate_array"),boolean:require("./validate_boolean"),number:require("./validate_number"),color:require("./validate_color"),constants:require("./validate_constants"),enum:require("./validate_enum"),filter:require("./validate_filter"),function:require("./validate_function"),layer:require("./validate_layer"),object:require("./validate_object"),source:require("./validate_source"),light:require("./validate_light"),string:require("./validate_string")},a=e.value,n=e.valueSpec,u=e.key,o=e.styleSpec,l=e.style;if("string"===getType(a)&&"@"===a[0]){if(o.$version>7)return[new ValidationError(u,a,"constants have been deprecated as of v8")];if(!(a in l.constants))return[new ValidationError(u,a,'constant "%s" not found',a)];e=extend({},e,{value:l.constants[a]})}return n.function&&"object"===getType(a)?r(e):n.type&&i[n.type]?i[n.type](e):t(extend({},e,{valueSpec:n.type?o[n.type]:n}))};
},{"../error/validation_error":167,"../util/extend":169,"../util/get_type":170,"./validate_array":174,"./validate_boolean":175,"./validate_color":176,"./validate_constants":177,"./validate_enum":178,"./validate_filter":179,"./validate_function":180,"./validate_layer":182,"./validate_light":184,"./validate_number":185,"./validate_object":186,"./validate_source":188,"./validate_string":189}],174:[function(require,module,exports){
"use strict";var getType=require("../util/get_type"),validate=require("./validate"),ValidationError=require("../error/validation_error");module.exports=function(e){var r=e.value,t=e.valueSpec,a=e.style,n=e.styleSpec,l=e.key,i=e.arrayElementValidator||validate;if("array"!==getType(r))return[new ValidationError(l,r,"array expected, %s found",getType(r))];if(t.length&&r.length!==t.length)return[new ValidationError(l,r,"array length %d expected, length %d found",t.length,r.length)];if(t["min-length"]&&r.length<t["min-length"])return[new ValidationError(l,r,"array length at least %d expected, length %d found",t["min-length"],r.length)];var o={type:t.value};n.$version<7&&(o.function=t.function),"object"===getType(t.value)&&(o=t.value);for(var u=[],d=0;d<r.length;d++)u=u.concat(i({array:r,arrayIndex:d,value:r[d],valueSpec:o,style:a,styleSpec:n,key:l+"["+d+"]"}));return u};
},{"../error/validation_error":167,"../util/get_type":170,"./validate":173}],175:[function(require,module,exports){
"use strict";var getType=require("../util/get_type"),ValidationError=require("../error/validation_error");module.exports=function(e){var r=e.value,o=e.key,t=getType(r);return"boolean"!==t?[new ValidationError(o,r,"boolean expected, %s found",t)]:[]};
},{"../error/validation_error":167,"../util/get_type":170}],176:[function(require,module,exports){
"use strict";var ValidationError=require("../error/validation_error"),getType=require("../util/get_type"),parseCSSColor=require("csscolorparser").parseCSSColor;module.exports=function(r){var e=r.key,o=r.value,t=getType(o);return"string"!==t?[new ValidationError(e,o,"color expected, %s found",t)]:null===parseCSSColor(o)?[new ValidationError(e,o,'color expected, "%s" found',o)]:[]};
},{"../error/validation_error":167,"../util/get_type":170,"csscolorparser":135}],177:[function(require,module,exports){
"use strict";var ValidationError=require("../error/validation_error"),getType=require("../util/get_type");module.exports=function(r){var e=r.key,t=r.value,a=r.styleSpec;if(a.$version>7)return t?[new ValidationError(e,t,"constants have been deprecated as of v8")]:[];var o=getType(t);if("object"!==o)return[new ValidationError(e,t,"object expected, %s found",o)];var n=[];for(var i in t)"@"!==i[0]&&n.push(new ValidationError(e+"."+i,t[i],'constants must start with "@"'));return n};
},{"../error/validation_error":167,"../util/get_type":170}],178:[function(require,module,exports){
"use strict";var ValidationError=require("../error/validation_error"),unbundle=require("../util/unbundle_jsonlint");module.exports=function(e){var r=e.key,n=e.value,u=e.valueSpec,o=[];return Array.isArray(u.values)?u.values.indexOf(unbundle(n))===-1&&o.push(new ValidationError(r,n,"expected one of [%s], %s found",u.values.join(", "),n)):Object.keys(u.values).indexOf(unbundle(n))===-1&&o.push(new ValidationError(r,n,"expected one of [%s], %s found",Object.keys(u.values).join(", "),n)),o};
},{"../error/validation_error":167,"../util/unbundle_jsonlint":172}],179:[function(require,module,exports){
"use strict";var ValidationError=require("../error/validation_error"),validateEnum=require("./validate_enum"),getType=require("../util/get_type"),unbundle=require("../util/unbundle_jsonlint");module.exports=function e(t){var r,a=t.value,n=t.key,l=t.styleSpec,s=[];if("array"!==getType(a))return[new ValidationError(n,a,"array expected, %s found",getType(a))];if(a.length<1)return[new ValidationError(n,a,"filter array must have at least 1 element")];switch(s=s.concat(validateEnum({key:n+"[0]",value:a[0],valueSpec:l.filter_operator,style:t.style,styleSpec:t.styleSpec})),unbundle(a[0])){case"<":case"<=":case">":case">=":a.length>=2&&"$type"==a[1]&&s.push(new ValidationError(n,a,'"$type" cannot be use with operator "%s"',a[0]));case"==":case"!=":3!=a.length&&s.push(new ValidationError(n,a,'filter array for operator "%s" must have 3 elements',a[0]));case"in":case"!in":a.length>=2&&(r=getType(a[1]),"string"!==r?s.push(new ValidationError(n+"[1]",a[1],"string expected, %s found",r)):"@"===a[1][0]&&s.push(new ValidationError(n+"[1]",a[1],"filter key cannot be a constant")));for(var o=2;o<a.length;o++)r=getType(a[o]),"$type"==a[1]?s=s.concat(validateEnum({key:n+"["+o+"]",value:a[o],valueSpec:l.geometry_type,style:t.style,styleSpec:t.styleSpec})):"string"===r&&"@"===a[o][0]?s.push(new ValidationError(n+"["+o+"]",a[o],"filter value cannot be a constant")):"string"!==r&&"number"!==r&&"boolean"!==r&&s.push(new ValidationError(n+"["+o+"]",a[o],"string, number, or boolean expected, %s found",r));break;case"any":case"all":case"none":for(o=1;o<a.length;o++)s=s.concat(e({key:n+"["+o+"]",value:a[o],style:t.style,styleSpec:t.styleSpec}));break;case"has":case"!has":r=getType(a[1]),2!==a.length?s.push(new ValidationError(n,a,'filter array for "%s" operator must have 2 elements',a[0])):"string"!==r?s.push(new ValidationError(n+"[1]",a[1],"string expected, %s found",r)):"@"===a[1][0]&&s.push(new ValidationError(n+"[1]",a[1],"filter key cannot be a constant"))}return s};
},{"../error/validation_error":167,"../util/get_type":170,"../util/unbundle_jsonlint":172,"./validate_enum":178}],180:[function(require,module,exports){
"use strict";var ValidationError=require("../error/validation_error"),getType=require("../util/get_type"),validate=require("./validate"),validateObject=require("./validate_object"),validateArray=require("./validate_array"),validateNumber=require("./validate_number"),unbundle=require("../util/unbundle_jsonlint");module.exports=function(e){function t(e){if("identity"===u)return[new ValidationError(e.key,e.value,'identity function may not have a "stops" property')];var t=[],a=e.value;return t=t.concat(validateArray({key:e.key,value:a,valueSpec:e.valueSpec,style:e.style,styleSpec:e.styleSpec,arrayElementValidator:r})),"array"===getType(a)&&0===a.length&&t.push(new ValidationError(e.key,a,"array must have at least one stop")),t}function r(e){var t=[],r=e.value,o=e.key;if("array"!==getType(r))return[new ValidationError(o,r,"array expected, %s found",getType(r))];if(2!==r.length)return[new ValidationError(o,r,"array length %d expected, length %d found",2,r.length)];if(c){if("object"!==getType(r[0]))return[new ValidationError(o,r,"object expected, %s found",getType(r[0]))];if(void 0===r[0].zoom)return[new ValidationError(o,r,"object stop key must have zoom")];if(void 0===r[0].value)return[new ValidationError(o,r,"object stop key must have value")];if(i&&i>unbundle(r[0].zoom))return[new ValidationError(o,r[0].zoom,"stop zoom values must appear in ascending order")];unbundle(r[0].zoom)!==i&&(i=unbundle(r[0].zoom),n=void 0),t=t.concat(validateObject({key:o+"[0]",value:r[0],valueSpec:{zoom:{}},style:e.style,styleSpec:e.styleSpec,objectElementValidators:{zoom:validateNumber,value:a}}))}else t=t.concat(a({key:o+"[0]",value:r[0],valueSpec:{},style:e.style,styleSpec:e.styleSpec}));return t=t.concat(validate({key:o+"[1]",value:r[1],valueSpec:l,style:e.style,styleSpec:e.styleSpec})),"number"===getType(r[0])&&"piecewise-constant"===l.function&&r[0]%1!==0&&t.push(new ValidationError(o+"[0]",r[0],"zoom level for piecewise-constant functions must be an integer")),t}function a(e){var t=getType(e.value),r=unbundle(e.value);if(o){if(t!==o)return[new ValidationError(e.key,e.value,"%s stop domain type must match previous stop domain type %s",t,o)]}else o=t,u||"string"!==t||(u="categorical");return"number"!==t&&"string"!==t?[new ValidationError(e.key,e.value,"property value must be a number or string")]:"number"!==t&&"categorical"!==u?[new ValidationError(e.key,e.value,"number expected, %s found",t)]:"categorical"!==u||"number"!==t||isFinite(r)&&Math.floor(r)===r?"number"===t&&void 0!==n&&r<n?[new ValidationError(e.key,e.value,"stop domain values must appear in ascending order")]:(n=r,"categorical"===u&&r in s?[new ValidationError(e.key,e.value,"stop domain values must be unique")]:(s[r]=!0,[])):[new ValidationError(e.key,e.value,"integer expected, found %s",r)]}var o,n,i,l=e.valueSpec,u=unbundle(e.value.type),s={},p="categorical"!==u&&void 0===e.value.property,y=!p,c="array"===getType(e.value.stops)&&"array"===getType(e.value.stops[0])&&"object"===getType(e.value.stops[0][0]),d=validateObject({key:e.key,value:e.value,valueSpec:e.styleSpec.function,style:e.style,styleSpec:e.styleSpec,objectElementValidators:{stops:t}});return"identity"===u||e.value.stops||d.push(new ValidationError(e.key,e.value,'missing required property "stops"')),"exponential"===u&&"piecewise-constant"===e.valueSpec.function&&d.push(new ValidationError(e.key,e.value,"exponential functions not supported")),e.styleSpec.$version>=8&&(y&&!e.valueSpec["property-function"]?d.push(new ValidationError(e.key,e.value,"property functions not supported")):p&&!e.valueSpec["zoom-function"]&&d.push(new ValidationError(e.key,e.value,"zoom functions not supported"))),"categorical"!==u&&!c||void 0!==e.value.property||d.push(new ValidationError(e.key,e.value,'"property" property is required')),d};
},{"../error/validation_error":167,"../util/get_type":170,"../util/unbundle_jsonlint":172,"./validate":173,"./validate_array":174,"./validate_number":185,"./validate_object":186}],181:[function(require,module,exports){
"use strict";var ValidationError=require("../error/validation_error"),validateString=require("./validate_string");module.exports=function(r){var e=r.value,t=r.key,a=validateString(r);return a.length?a:(e.indexOf("{fontstack}")===-1&&a.push(new ValidationError(t,e,'"glyphs" url must include a "{fontstack}" token')),e.indexOf("{range}")===-1&&a.push(new ValidationError(t,e,'"glyphs" url must include a "{range}" token')),a)};
},{"../error/validation_error":167,"./validate_string":189}],182:[function(require,module,exports){
"use strict";var ValidationError=require("../error/validation_error"),unbundle=require("../util/unbundle_jsonlint"),validateObject=require("./validate_object"),validateFilter=require("./validate_filter"),validatePaintProperty=require("./validate_paint_property"),validateLayoutProperty=require("./validate_layout_property"),extend=require("../util/extend");module.exports=function(e){var r=[],t=e.value,a=e.key,i=e.style,l=e.styleSpec;t.type||t.ref||r.push(new ValidationError(a,t,'either "type" or "ref" is required'));var o=unbundle(t.type),u=unbundle(t.ref);if(t.id)for(var n=0;n<e.arrayIndex;n++){var s=i.layers[n];unbundle(s.id)===unbundle(t.id)&&r.push(new ValidationError(a,t.id,'duplicate layer id "%s", previously used at line %d',t.id,s.id.__line__))}if("ref"in t){["type","source","source-layer","filter","layout"].forEach(function(e){e in t&&r.push(new ValidationError(a,t[e],'"%s" is prohibited for ref layers',e))});var d;i.layers.forEach(function(e){e.id==u&&(d=e)}),d?d.ref?r.push(new ValidationError(a,t.ref,"ref cannot reference another ref layer")):o=unbundle(d.type):r.push(new ValidationError(a,t.ref,'ref layer "%s" not found',u))}else if("background"!==o)if(t.source){var y=i.sources&&i.sources[t.source];y?"vector"==y.type&&"raster"==o?r.push(new ValidationError(a,t.source,'layer "%s" requires a raster source',t.id)):"raster"==y.type&&"raster"!=o?r.push(new ValidationError(a,t.source,'layer "%s" requires a vector source',t.id)):"vector"!=y.type||t["source-layer"]||r.push(new ValidationError(a,t,'layer "%s" must specify a "source-layer"',t.id)):r.push(new ValidationError(a,t.source,'source "%s" not found',t.source))}else r.push(new ValidationError(a,t,'missing required property "source"'));return r=r.concat(validateObject({key:a,value:t,valueSpec:l.layer,style:e.style,styleSpec:e.styleSpec,objectElementValidators:{"*":function(){return[]},filter:validateFilter,layout:function(e){return validateObject({layer:t,key:e.key,value:e.value,style:e.style,styleSpec:e.styleSpec,objectElementValidators:{"*":function(e){return validateLayoutProperty(extend({layerType:o},e))}}})},paint:function(e){return validateObject({layer:t,key:e.key,value:e.value,style:e.style,styleSpec:e.styleSpec,objectElementValidators:{"*":function(e){return validatePaintProperty(extend({layerType:o},e))}}})}}}))};
},{"../error/validation_error":167,"../util/extend":169,"../util/unbundle_jsonlint":172,"./validate_filter":179,"./validate_layout_property":183,"./validate_object":186,"./validate_paint_property":187}],183:[function(require,module,exports){
"use strict";var validate=require("./validate"),ValidationError=require("../error/validation_error");module.exports=function(e){var r=e.key,t=e.style,a=e.styleSpec,i=e.value,l=e.objectKey,o=a["layout_"+e.layerType];if(!o)return[];if(e.valueSpec||o[l]){var s=[];return"symbol"===e.layerType&&("icon-image"===l&&t&&!t.sprite?s.push(new ValidationError(r,i,'use of "icon-image" requires a style "sprite" property')):"text-field"===l&&t&&!t.glyphs&&s.push(new ValidationError(r,i,'use of "text-field" requires a style "glyphs" property'))),s.concat(validate({key:e.key,value:i,valueSpec:e.valueSpec||o[l],style:t,styleSpec:a}))}return[new ValidationError(r,i,'unknown property "%s"',l)]};
},{"../error/validation_error":167,"./validate":173}],184:[function(require,module,exports){
"use strict";var ValidationError=require("../error/validation_error"),getType=require("../util/get_type"),validate=require("./validate");module.exports=function(e){var t=e.value,r=e.styleSpec,a=r.light,i=e.style,n=[],o=getType(t);if(void 0===t)return n;if("object"!==o)return n=n.concat([new ValidationError("light",t,"object expected, %s found",o)]);for(var l in t){var c=l.match(/^(.*)-transition$/);n=c&&a[c[1]]&&a[c[1]].transition?n.concat(validate({key:l,value:t[l],valueSpec:r.transition,style:i,styleSpec:r})):a[l]?n.concat(validate({key:l,value:t[l],valueSpec:a[l],style:i,styleSpec:r})):n.concat([new ValidationError(l,t[l],'unknown property "%s"',l)])}return n};
},{"../error/validation_error":167,"../util/get_type":170,"./validate":173}],185:[function(require,module,exports){
"use strict";var getType=require("../util/get_type"),ValidationError=require("../error/validation_error");module.exports=function(e){var r=e.key,i=e.value,m=e.valueSpec,a=getType(i);return"number"!==a?[new ValidationError(r,i,"number expected, %s found",a)]:"minimum"in m&&i<m.minimum?[new ValidationError(r,i,"%s is less than the minimum value %s",i,m.minimum)]:"maximum"in m&&i>m.maximum?[new ValidationError(r,i,"%s is greater than the maximum value %s",i,m.maximum)]:[]};
},{"../error/validation_error":167,"../util/get_type":170}],186:[function(require,module,exports){
"use strict";var ValidationError=require("../error/validation_error"),getType=require("../util/get_type"),validateSpec=require("./validate");module.exports=function(e){var r=e.key,t=e.value,i=e.valueSpec||{},a=e.objectElementValidators||{},o=e.style,l=e.styleSpec,n=[],u=getType(t);if("object"!==u)return[new ValidationError(r,t,"object expected, %s found",u)];for(var p in t){var s,c=p.split(".")[0],d=i[c]||i["*"];if(a[c])s=a[c];else if(i[c])s=validateSpec;else if(a["*"])s=a["*"];else{if(!i["*"]){n.push(new ValidationError(r,t[p],'unknown property "%s"',p));continue}s=validateSpec}n=n.concat(s({key:(r?r+".":r)+p,value:t[p],valueSpec:d,style:o,styleSpec:l,object:t,objectKey:p}))}for(c in i)i[c].required&&void 0===i[c].default&&void 0===t[c]&&n.push(new ValidationError(r,t,'missing required property "%s"',c));return n};
},{"../error/validation_error":167,"../util/get_type":170,"./validate":173}],187:[function(require,module,exports){
"use strict";var validate=require("./validate"),ValidationError=require("../error/validation_error");module.exports=function(e){var r=e.key,a=e.style,t=e.styleSpec,i=e.value,l=e.objectKey,n=t["paint_"+e.layerType];if(!n)return[];var o=l.match(/^(.*)-transition$/);return o&&n[o[1]]&&n[o[1]].transition?validate({key:r,value:i,valueSpec:t.transition,style:a,styleSpec:t}):e.valueSpec||n[l]?validate({key:e.key,value:i,valueSpec:e.valueSpec||n[l],style:a,styleSpec:t}):[new ValidationError(r,i,'unknown property "%s"',l)]};
},{"../error/validation_error":167,"./validate":173}],188:[function(require,module,exports){
"use strict";var ValidationError=require("../error/validation_error"),unbundle=require("../util/unbundle_jsonlint"),validateObject=require("./validate_object"),validateEnum=require("./validate_enum");module.exports=function(e){var a=e.value,t=e.key,r=e.styleSpec,l=e.style;if(!a.type)return[new ValidationError(t,a,'"type" is required')];var u=unbundle(a.type);switch(u){case"vector":case"raster":var i=[];if(i=i.concat(validateObject({key:t,value:a,valueSpec:r.source_tile,style:e.style,styleSpec:r})),"url"in a)for(var s in a)["type","url","tileSize"].indexOf(s)<0&&i.push(new ValidationError(t+"."+s,a[s],'a source with a "url" property may not include a "%s" property',s));return i;case"geojson":return validateObject({key:t,value:a,valueSpec:r.source_geojson,style:l,styleSpec:r});case"video":return validateObject({key:t,value:a,valueSpec:r.source_video,style:l,styleSpec:r});case"image":return validateObject({key:t,value:a,valueSpec:r.source_image,style:l,styleSpec:r});case"canvas":return validateObject({key:t,value:a,valueSpec:r.source_canvas,style:l,styleSpec:r});default:return validateEnum({key:t+".type",value:a.type,valueSpec:{values:["vector","raster","geojson","video","image","canvas"]},style:l,styleSpec:r})}};
},{"../error/validation_error":167,"../util/unbundle_jsonlint":172,"./validate_enum":178,"./validate_object":186}],189:[function(require,module,exports){
"use strict";var getType=require("../util/get_type"),ValidationError=require("../error/validation_error");module.exports=function(r){var e=r.value,t=r.key,i=getType(e);return"string"!==i?[new ValidationError(t,e,"string expected, %s found",i)]:[]};
},{"../error/validation_error":167,"../util/get_type":170}],190:[function(require,module,exports){
"use strict";function validateStyleMin(e,a){a=a||latestStyleSpec;var t=[];return t=t.concat(validate({key:"",value:e,valueSpec:a.$root,styleSpec:a,style:e,objectElementValidators:{glyphs:validateGlyphsURL,"*":function(){return[]}}})),a.$version>7&&e.constants&&(t=t.concat(validateConstants({key:"constants",value:e.constants,style:e,styleSpec:a}))),sortErrors(t)}function sortErrors(e){return[].concat(e).sort(function(e,a){return e.line-a.line})}function wrapCleanErrors(e){return function(){return sortErrors(e.apply(this,arguments))}}var validateConstants=require("./validate/validate_constants"),validate=require("./validate/validate"),latestStyleSpec=require("../reference/latest.min"),validateGlyphsURL=require("./validate/validate_glyphs_url");validateStyleMin.source=wrapCleanErrors(require("./validate/validate_source")),validateStyleMin.light=wrapCleanErrors(require("./validate/validate_light")),validateStyleMin.layer=wrapCleanErrors(require("./validate/validate_layer")),validateStyleMin.filter=wrapCleanErrors(require("./validate/validate_filter")),validateStyleMin.paintProperty=wrapCleanErrors(require("./validate/validate_paint_property")),validateStyleMin.layoutProperty=wrapCleanErrors(require("./validate/validate_layout_property")),module.exports=validateStyleMin;
},{"../reference/latest.min":191,"./validate/validate":173,"./validate/validate_constants":177,"./validate/validate_filter":179,"./validate/validate_glyphs_url":181,"./validate/validate_layer":182,"./validate/validate_layout_property":183,"./validate/validate_light":184,"./validate/validate_paint_property":187,"./validate/validate_source":188}],191:[function(require,module,exports){
module.exports=require("./v8.min.json");
},{"./v8.min.json":192}],192:[function(require,module,exports){
module.exports={"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360,"units":"degrees"},"pitch":{"type":"number","default":0,"units":"degrees"},"light":{"type":"light"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string"},"transition":{"type":"transition"},"layers":{"required":true,"type":"array","value":"layer"}},"sources":{"*":{"type":"source"}},"source":["source_tile","source_geojson","source_video","source_image","source_canvas"],"source_tile":{"type":{"required":true,"type":"enum","values":{"vector":{},"raster":{}}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512,"units":"pixels"},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":{}}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":{}}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":{}}},"url":{"required":true,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_canvas":{"type":{"required":true,"type":"enum","values":{"canvas":{}}},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}},"animate":{"type":"boolean","default":"true"},"canvas":{"type":"string","required":true}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"fill-extrusion":{},"raster":{},"background":{}}},"metadata":{"type":"*"},"ref":{"type":"string"},"source":{"type":"string"},"source-layer":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"},"paint.*":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_fill-extrusion","layout_symbol","layout_raster","layout_background"],"layout_background":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible"}},"layout_fill":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible"}},"layout_circle":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible"}},"layout_line":{"line-cap":{"type":"enum","function":"piecewise-constant","zoom-function":true,"values":{"butt":{},"round":{},"square":{}},"default":"butt"},"line-join":{"type":"enum","function":"piecewise-constant","zoom-function":true,"values":{"bevel":{},"round":{},"miter":{}},"default":"miter"},"line-miter-limit":{"type":"number","default":2,"function":"interpolated","zoom-function":true,"requires":[{"line-join":"miter"}]},"line-round-limit":{"type":"number","default":1.05,"function":"interpolated","zoom-function":true,"requires":[{"line-join":"round"}]},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible"}},"layout_symbol":{"symbol-placement":{"type":"enum","function":"piecewise-constant","zoom-function":true,"values":{"point":{},"line":{}},"default":"point"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"function":"interpolated","zoom-function":true,"units":"pixels","requires":[{"symbol-placement":"line"}]},"symbol-avoid-edges":{"type":"boolean","function":"piecewise-constant","zoom-function":true,"default":false},"icon-allow-overlap":{"type":"boolean","function":"piecewise-constant","zoom-function":true,"default":false,"requires":["icon-image"]},"icon-ignore-placement":{"type":"boolean","function":"piecewise-constant","zoom-function":true,"default":false,"requires":["icon-image"]},"icon-optional":{"type":"boolean","function":"piecewise-constant","zoom-function":true,"default":false,"requires":["icon-image","text-field"]},"icon-rotation-alignment":{"type":"enum","function":"piecewise-constant","zoom-function":true,"values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["icon-image"]},"icon-size":{"type":"number","default":1,"minimum":0,"function":"interpolated","zoom-function":true,"requires":["icon-image"]},"icon-text-fit":{"type":"enum","function":"piecewise-constant","zoom-function":true,"values":{"none":{},"width":{},"height":{},"both":{}},"default":"none","requires":["icon-image","text-field"]},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"units":"pixels","function":"interpolated","zoom-function":true,"requires":["icon-image","text-field",{"icon-text-fit":["both","width","height"]}]},"icon-image":{"type":"string","function":"piecewise-constant","zoom-function":true,"tokens":true},"icon-rotate":{"type":"number","default":0,"period":360,"function":"interpolated","zoom-function":true,"property-function":true,"units":"degrees","requires":["icon-image"]},"icon-padding":{"type":"number","default":2,"minimum":0,"function":"interpolated","zoom-function":true,"units":"pixels","requires":["icon-image"]},"icon-keep-upright":{"type":"boolean","function":"piecewise-constant","zoom-function":true,"default":false,"requires":["icon-image",{"icon-rotation-alignment":"map"},{"symbol-placement":"line"}]},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"function":"interpolated","zoom-function":true,"property-function":true,"requires":["icon-image"]},"text-pitch-alignment":{"type":"enum","function":"piecewise-constant","zoom-function":true,"values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"]},"text-rotation-alignment":{"type":"enum","function":"piecewise-constant","zoom-function":true,"values":{"map":{},"viewport":{},"auto":{}},"default":"auto","requires":["text-field"]},"text-field":{"type":"string","function":"piecewise-constant","zoom-function":true,"default":"","tokens":true},"text-font":{"type":"array","value":"string","function":"piecewise-constant","zoom-function":true,"default":["Open Sans Regular","Arial Unicode MS Regular"],"requires":["text-field"]},"text-size":{"type":"number","default":16,"minimum":0,"units":"pixels","function":"interpolated","zoom-function":true,"requires":["text-field"]},"text-max-width":{"type":"number","default":10,"minimum":0,"units":"ems","function":"interpolated","zoom-function":true,"requires":["text-field"]},"text-line-height":{"type":"number","default":1.2,"units":"ems","function":"interpolated","zoom-function":true,"requires":["text-field"]},"text-letter-spacing":{"type":"number","default":0,"units":"ems","function":"interpolated","zoom-function":true,"requires":["text-field"]},"text-justify":{"type":"enum","function":"piecewise-constant","zoom-function":true,"values":{"left":{},"center":{},"right":{}},"default":"center","requires":["text-field"]},"text-anchor":{"type":"enum","function":"piecewise-constant","zoom-function":true,"values":{"center":{},"left":{},"right":{},"top":{},"bottom":{},"top-left":{},"top-right":{},"bottom-left":{},"bottom-right":{}},"default":"center","requires":["text-field"]},"text-max-angle":{"type":"number","default":45,"units":"degrees","function":"interpolated","zoom-function":true,"requires":["text-field",{"symbol-placement":"line"}]},"text-rotate":{"type":"number","default":0,"period":360,"units":"degrees","function":"interpolated","zoom-function":true,"requires":["text-field"]},"text-padding":{"type":"number","default":2,"minimum":0,"units":"pixels","function":"interpolated","zoom-function":true,"requires":["text-field"]},"text-keep-upright":{"type":"boolean","function":"piecewise-constant","zoom-function":true,"default":true,"requires":["text-field",{"text-rotation-alignment":"map"},{"symbol-placement":"line"}]},"text-transform":{"type":"enum","function":"piecewise-constant","zoom-function":true,"values":{"none":{},"uppercase":{},"lowercase":{}},"default":"none","requires":["text-field"]},"text-offset":{"type":"array","value":"number","units":"ems","function":"interpolated","zoom-function":true,"length":2,"default":[0,0],"requires":["text-field"]},"text-allow-overlap":{"type":"boolean","function":"piecewise-constant","zoom-function":true,"default":false,"requires":["text-field"]},"text-ignore-placement":{"type":"boolean","function":"piecewise-constant","zoom-function":true,"default":false,"requires":["text-field"]},"text-optional":{"type":"boolean","function":"piecewise-constant","zoom-function":true,"default":false,"requires":["text-field","icon-image"]},"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":{},"none":{}},"default":"visible"}},"filter":{"type":"array","value":"*"},"filter_operator":{"type":"enum","values":{"==":{},"!=":{},">":{},">=":{},"<":{},"<=":{},"in":{},"!in":{},"all":{},"any":{},"none":{},"has":{},"!has":{}}},"geometry_type":{"type":"enum","values":{"Point":{},"LineString":{},"Polygon":{}}},"function":{"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":{},"exponential":{},"interval":{},"categorical":{}},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":{},"lab":{},"hcl":{}},"default":"rgb"}},"function_stop":{"type":"array","minimum":0,"maximum":22,"value":["number","color"],"length":2},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":{},"viewport":{}},"transition":false},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","transition":true,"function":"interpolated","zoom-function":true,"property-function":false},"color":{"type":"color","default":"#ffffff","function":"interpolated","zoom-function":true,"property-function":false,"transition":true},"intensity":{"type":"number","default":0.5,"minimum":0,"maximum":1,"function":"interpolated","zoom-function":true,"property-function":false,"transition":true}},"paint":["paint_fill","paint_line","paint_circle","paint_fill-extrusion","paint_symbol","paint_raster","paint_background"],"paint_fill":{"fill-antialias":{"type":"boolean","function":"piecewise-constant","zoom-function":true,"default":true},"fill-opacity":{"type":"number","function":"interpolated","zoom-function":true,"property-function":true,"default":1,"minimum":0,"maximum":1,"transition":true},"fill-color":{"type":"color","default":"#000000","function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"requires":[{"!":"fill-pattern"}]},"fill-outline-color":{"type":"color","function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"requires":[{"!":"fill-pattern"},{"fill-antialias":true}]},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"function":"interpolated","zoom-function":true,"transition":true,"units":"pixels"},"fill-translate-anchor":{"type":"enum","function":"piecewise-constant","zoom-function":true,"values":{"map":{},"viewport":{}},"default":"map","requires":["fill-translate"]},"fill-pattern":{"type":"string","function":"piecewise-constant","zoom-function":true,"transition":true}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","function":"interpolated","zoom-function":true,"property-function":false,"default":1,"minimum":0,"maximum":1,"transition":true},"fill-extrusion-color":{"type":"color","default":"#000000","function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"requires":[{"!":"fill-extrusion-pattern"}]},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"function":"interpolated","zoom-function":true,"transition":true,"units":"pixels"},"fill-extrusion-translate-anchor":{"type":"enum","function":"piecewise-constant","zoom-function":true,"values":{"map":{},"viewport":{}},"default":"map","requires":["fill-extrusion-translate"]},"fill-extrusion-pattern":{"type":"string","function":"piecewise-constant","zoom-function":true,"transition":true},"fill-extrusion-height":{"type":"number","function":"interpolated","zoom-function":true,"property-function":true,"default":0,"minimum":0,"units":"meters","transition":true},"fill-extrusion-base":{"type":"number","function":"interpolated","zoom-function":true,"property-function":true,"default":0,"minimum":0,"units":"meters","transition":true,"requires":["fill-extrusion-height"]}},"paint_line":{"line-opacity":{"type":"number","function":"interpolated","zoom-function":true,"property-function":true,"default":1,"minimum":0,"maximum":1,"transition":true},"line-color":{"type":"color","default":"#000000","function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"requires":[{"!":"line-pattern"}]},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"function":"interpolated","zoom-function":true,"transition":true,"units":"pixels"},"line-translate-anchor":{"type":"enum","function":"piecewise-constant","zoom-function":true,"values":{"map":{},"viewport":{}},"default":"map","requires":["line-translate"]},"line-width":{"type":"number","default":1,"minimum":0,"function":"interpolated","zoom-function":true,"transition":true,"units":"pixels"},"line-gap-width":{"type":"number","default":0,"minimum":0,"function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"units":"pixels"},"line-offset":{"type":"number","default":0,"function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"units":"pixels"},"line-blur":{"type":"number","default":0,"minimum":0,"function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"units":"pixels"},"line-dasharray":{"type":"array","value":"number","function":"piecewise-constant","zoom-function":true,"minimum":0,"transition":true,"units":"line widths","requires":[{"!":"line-pattern"}]},"line-pattern":{"type":"string","function":"piecewise-constant","zoom-function":true,"transition":true}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"units":"pixels"},"circle-color":{"type":"color","default":"#000000","function":"interpolated","zoom-function":true,"property-function":true,"transition":true},"circle-blur":{"type":"number","default":0,"function":"interpolated","zoom-function":true,"property-function":true,"transition":true},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"function":"interpolated","zoom-function":true,"property-function":true,"transition":true},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"function":"interpolated","zoom-function":true,"transition":true,"units":"pixels"},"circle-translate-anchor":{"type":"enum","function":"piecewise-constant","zoom-function":true,"values":{"map":{},"viewport":{}},"default":"map","requires":["circle-translate"]},"circle-pitch-scale":{"type":"enum","function":"piecewise-constant","zoom-function":true,"values":{"map":{},"viewport":{}},"default":"map"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"function":"interpolated","zoom-function":true,"property-function":true,"transition":true,"units":"pixels"},"circle-stroke-color":{"type":"color","default":"#000000","function":"interpolated","zoom-function":true,"property-function":true,"transition":true},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"function":"interpolated","zoom-function":true,"property-function":true,"transition":true}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"function":"interpolated","zoom-function":true,"transition":true,"requires":["icon-image"]},"icon-color":{"type":"color","default":"#000000","function":"interpolated","zoom-function":true,"transition":true,"requires":["icon-image"]},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","function":"interpolated","zoom-function":true,"transition":true,"requires":["icon-image"]},"icon-halo-width":{"type":"number","default":0,"minimum":0,"function":"interpolated","zoom-function":true,"transition":true,"units":"pixels","requires":["icon-image"]},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"function":"interpolated","zoom-function":true,"transition":true,"units":"pixels","requires":["icon-image"]},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"function":"interpolated","zoom-function":true,"transition":true,"units":"pixels","requires":["icon-image"]},"icon-translate-anchor":{"type":"enum","function":"piecewise-constant","zoom-function":true,"values":{"map":{},"viewport":{}},"default":"map","requires":["icon-image","icon-translate"]},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"function":"interpolated","zoom-function":true,"transition":true,"requires":["text-field"]},"text-color":{"type":"color","default":"#000000","function":"interpolated","zoom-function":true,"transition":true,"requires":["text-field"]},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","function":"interpolated","zoom-function":true,"transition":true,"requires":["text-field"]},"text-halo-width":{"type":"number","default":0,"minimum":0,"function":"interpolated","zoom-function":true,"transition":true,"units":"pixels","requires":["text-field"]},"text-halo-blur":{"type":"number","default":0,"minimum":0,"function":"interpolated","zoom-function":true,"transition":true,"units":"pixels","requires":["text-field"]},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"function":"interpolated","zoom-function":true,"transition":true,"units":"pixels","requires":["text-field"]},"text-translate-anchor":{"type":"enum","function":"piecewise-constant","zoom-function":true,"values":{"map":{},"viewport":{}},"default":"map","requires":["text-field","text-translate"]}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"function":"interpolated","zoom-function":true,"transition":true},"raster-hue-rotate":{"type":"number","default":0,"period":360,"function":"interpolated","zoom-function":true,"transition":true,"units":"degrees"},"raster-brightness-min":{"type":"number","function":"interpolated","zoom-function":true,"default":0,"minimum":0,"maximum":1,"transition":true},"raster-brightness-max":{"type":"number","function":"interpolated","zoom-function":true,"default":1,"minimum":0,"maximum":1,"transition":true},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"function":"interpolated","zoom-function":true,"transition":true},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"function":"interpolated","zoom-function":true,"transition":true},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"function":"interpolated","zoom-function":true,"transition":true,"units":"milliseconds"}},"paint_background":{"background-color":{"type":"color","default":"#000000","function":"interpolated","zoom-function":true,"transition":true,"requires":[{"!":"background-pattern"}]},"background-pattern":{"type":"string","function":"piecewise-constant","zoom-function":true,"transition":true},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"function":"interpolated","zoom-function":true,"transition":true}},"transition":{"duration":{"type":"number","default":300,"minimum":0,"units":"milliseconds"},"delay":{"type":"number","default":0,"minimum":0,"units":"milliseconds"}}}
},{}],193:[function(require,module,exports){
"use strict";function isSupported(e){return!!(isBrowser()&&isArraySupported()&&isFunctionSupported()&&isObjectSupported()&&isJSONSupported()&&isWorkerSupported()&&isUint8ClampedArraySupported()&&isWebGLSupportedCached(e&&e.failIfMajorPerformanceCaveat))}function isBrowser(){return"undefined"!=typeof window&&"undefined"!=typeof document}function isArraySupported(){return Array.prototype&&Array.prototype.every&&Array.prototype.filter&&Array.prototype.forEach&&Array.prototype.indexOf&&Array.prototype.lastIndexOf&&Array.prototype.map&&Array.prototype.some&&Array.prototype.reduce&&Array.prototype.reduceRight&&Array.isArray}function isFunctionSupported(){return Function.prototype&&Function.prototype.bind}function isObjectSupported(){return Object.keys&&Object.create&&Object.getPrototypeOf&&Object.getOwnPropertyNames&&Object.isSealed&&Object.isFrozen&&Object.isExtensible&&Object.getOwnPropertyDescriptor&&Object.defineProperty&&Object.defineProperties&&Object.seal&&Object.freeze&&Object.preventExtensions}function isJSONSupported(){return"JSON"in window&&"parse"in JSON&&"stringify"in JSON}function isWorkerSupported(){return"Worker"in window}function isUint8ClampedArraySupported(){return"Uint8ClampedArray"in window}function isWebGLSupportedCached(e){return void 0===isWebGLSupportedCache[e]&&(isWebGLSupportedCache[e]=isWebGLSupported(e)),isWebGLSupportedCache[e]}function isWebGLSupported(e){var t=document.createElement("canvas"),r=Object.create(isSupported.webGLContextAttributes);return r.failIfMajorPerformanceCaveat=e,t.probablySupportsContext?t.probablySupportsContext("webgl",r)||t.probablySupportsContext("experimental-webgl",r):t.supportsContext?t.supportsContext("webgl",r)||t.supportsContext("experimental-webgl",r):t.getContext("webgl",r)||t.getContext("experimental-webgl",r)}"undefined"!=typeof module&&module.exports?module.exports=isSupported:window&&(window.mapboxgl=window.mapboxgl||{},window.mapboxgl.supported=isSupported);var isWebGLSupportedCache={};isSupported.webGLContextAttributes={antialias:!1,alpha:!0,stencil:!0,depth:!0};
},{}],194:[function(require,module,exports){
(function (process){
function normalizeArray(r,t){for(var e=0,n=r.length-1;n>=0;n--){var s=r[n];"."===s?r.splice(n,1):".."===s?(r.splice(n,1),e++):e&&(r.splice(n,1),e--)}if(t)for(;e--;e)r.unshift("..");return r}function filter(r,t){if(r.filter)return r.filter(t);for(var e=[],n=0;n<r.length;n++)t(r[n],n,r)&&e.push(r[n]);return e}var splitPathRe=/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/,splitPath=function(r){return splitPathRe.exec(r).slice(1)};exports.resolve=function(){for(var r="",t=!1,e=arguments.length-1;e>=-1&&!t;e--){var n=e>=0?arguments[e]:process.cwd();if("string"!=typeof n)throw new TypeError("Arguments to path.resolve must be strings");n&&(r=n+"/"+r,t="/"===n.charAt(0))}return r=normalizeArray(filter(r.split("/"),function(r){return!!r}),!t).join("/"),(t?"/":"")+r||"."},exports.normalize=function(r){var t=exports.isAbsolute(r),e="/"===substr(r,-1);return r=normalizeArray(filter(r.split("/"),function(r){return!!r}),!t).join("/"),r||t||(r="."),r&&e&&(r+="/"),(t?"/":"")+r},exports.isAbsolute=function(r){return"/"===r.charAt(0)},exports.join=function(){var r=Array.prototype.slice.call(arguments,0);return exports.normalize(filter(r,function(r,t){if("string"!=typeof r)throw new TypeError("Arguments to path.join must be strings");return r}).join("/"))},exports.relative=function(r,t){function e(r){for(var t=0;t<r.length&&""===r[t];t++);for(var e=r.length-1;e>=0&&""===r[e];e--);return t>e?[]:r.slice(t,e-t+1)}r=exports.resolve(r).substr(1),t=exports.resolve(t).substr(1);for(var n=e(r.split("/")),s=e(t.split("/")),i=Math.min(n.length,s.length),o=i,u=0;u<i;u++)if(n[u]!==s[u]){o=u;break}for(var l=[],u=o;u<n.length;u++)l.push("..");return l=l.concat(s.slice(o)),l.join("/")},exports.sep="/",exports.delimiter=":",exports.dirname=function(r){var t=splitPath(r),e=t[0],n=t[1];return e||n?(n&&(n=n.substr(0,n.length-1)),e+n):"."},exports.basename=function(r,t){var e=splitPath(r)[2];return t&&e.substr(-1*t.length)===t&&(e=e.substr(0,e.length-t.length)),e},exports.extname=function(r){return splitPath(r)[3]};var substr="b"==="ab".substr(-1)?function(r,t,e){return r.substr(t,e)}:function(r,t,e){return t<0&&(t=r.length+t),r.substr(t,e)};
}).call(this,require('_process'))

},{"_process":198}],195:[function(require,module,exports){
"use strict";function Buffer(t){var e;t&&t.length&&(e=t,t=e.length);var r=new Uint8Array(t||0);return e&&r.set(e),r.readUInt32LE=BufferMethods.readUInt32LE,r.writeUInt32LE=BufferMethods.writeUInt32LE,r.readInt32LE=BufferMethods.readInt32LE,r.writeInt32LE=BufferMethods.writeInt32LE,r.readFloatLE=BufferMethods.readFloatLE,r.writeFloatLE=BufferMethods.writeFloatLE,r.readDoubleLE=BufferMethods.readDoubleLE,r.writeDoubleLE=BufferMethods.writeDoubleLE,r.toString=BufferMethods.toString,r.write=BufferMethods.write,r.slice=BufferMethods.slice,r.copy=BufferMethods.copy,r._isBuffer=!0,r}function encodeString(t){for(var e,r,n=t.length,i=[],o=0;o<n;o++){if(e=t.charCodeAt(o),e>55295&&e<57344){if(!r){e>56319||o+1===n?i.push(239,191,189):r=e;continue}if(e<56320){i.push(239,191,189),r=e;continue}e=r-55296<<10|e-56320|65536,r=null}else r&&(i.push(239,191,189),r=null);e<128?i.push(e):e<2048?i.push(e>>6|192,63&e|128):e<65536?i.push(e>>12|224,e>>6&63|128,63&e|128):i.push(e>>18|240,e>>12&63|128,e>>6&63|128,63&e|128)}return i}module.exports=Buffer;var ieee754=require("ieee754"),BufferMethods,lastStr,lastStrEncoded;BufferMethods={readUInt32LE:function(t){return(this[t]|this[t+1]<<8|this[t+2]<<16)+16777216*this[t+3]},writeUInt32LE:function(t,e){this[e]=t,this[e+1]=t>>>8,this[e+2]=t>>>16,this[e+3]=t>>>24},readInt32LE:function(t){return(this[t]|this[t+1]<<8|this[t+2]<<16)+(this[t+3]<<24)},readFloatLE:function(t){return ieee754.read(this,t,!0,23,4)},readDoubleLE:function(t){return ieee754.read(this,t,!0,52,8)},writeFloatLE:function(t,e){return ieee754.write(this,t,e,!0,23,4)},writeDoubleLE:function(t,e){return ieee754.write(this,t,e,!0,52,8)},toString:function(t,e,r){var n="",i="";e=e||0,r=Math.min(this.length,r||this.length);for(var o=e;o<r;o++){var u=this[o];u<=127?(n+=decodeURIComponent(i)+String.fromCharCode(u),i=""):i+="%"+u.toString(16)}return n+=decodeURIComponent(i)},write:function(t,e){for(var r=t===lastStr?lastStrEncoded:encodeString(t),n=0;n<r.length;n++)this[e+n]=r[n]},slice:function(t,e){return this.subarray(t,e)},copy:function(t,e){e=e||0;for(var r=0;r<this.length;r++)t[e+r]=this[r]}},BufferMethods.writeInt32LE=BufferMethods.writeUInt32LE,Buffer.byteLength=function(t){return lastStr=t,lastStrEncoded=encodeString(t),lastStrEncoded.length},Buffer.isBuffer=function(t){return!(!t||!t._isBuffer)};
},{"ieee754":150}],196:[function(require,module,exports){
(function (global){
"use strict";function Pbf(t){this.buf=Buffer.isBuffer(t)?t:new Buffer(t||0),this.pos=0,this.length=this.buf.length}function readVarintRemainder(t,i){var e,r=i.buf;if(e=r[i.pos++],t+=268435456*(127&e),e<128)return t;if(e=r[i.pos++],t+=34359738368*(127&e),e<128)return t;if(e=r[i.pos++],t+=4398046511104*(127&e),e<128)return t;if(e=r[i.pos++],t+=562949953421312*(127&e),e<128)return t;if(e=r[i.pos++],t+=72057594037927940*(127&e),e<128)return t;if(e=r[i.pos++],t+=0x8000000000000000*(127&e),e<128)return t;throw new Error("Expected varint not more than 10 bytes")}function writeBigVarint(t,i){i.realloc(10);for(var e=i.pos+10;t>=1;){if(i.pos>=e)throw new Error("Given varint doesn't fit into 10 bytes");var r=255&t;i.buf[i.pos++]=r|(t>=128?128:0),t/=128}}function reallocForRawMessage(t,i,e){var r=i<=16383?1:i<=2097151?2:i<=268435455?3:Math.ceil(Math.log(i)/(7*Math.LN2));e.realloc(r);for(var s=e.pos-1;s>=t;s--)e.buf[s+r]=e.buf[s]}function writePackedVarint(t,i){for(var e=0;e<t.length;e++)i.writeVarint(t[e])}function writePackedSVarint(t,i){for(var e=0;e<t.length;e++)i.writeSVarint(t[e])}function writePackedFloat(t,i){for(var e=0;e<t.length;e++)i.writeFloat(t[e])}function writePackedDouble(t,i){for(var e=0;e<t.length;e++)i.writeDouble(t[e])}function writePackedBoolean(t,i){for(var e=0;e<t.length;e++)i.writeBoolean(t[e])}function writePackedFixed32(t,i){for(var e=0;e<t.length;e++)i.writeFixed32(t[e])}function writePackedSFixed32(t,i){for(var e=0;e<t.length;e++)i.writeSFixed32(t[e])}function writePackedFixed64(t,i){for(var e=0;e<t.length;e++)i.writeFixed64(t[e])}function writePackedSFixed64(t,i){for(var e=0;e<t.length;e++)i.writeSFixed64(t[e])}module.exports=Pbf;var Buffer=global.Buffer||require("./buffer");Pbf.Varint=0,Pbf.Fixed64=1,Pbf.Bytes=2,Pbf.Fixed32=5;var SHIFT_LEFT_32=4294967296,SHIFT_RIGHT_32=1/SHIFT_LEFT_32,POW_2_63=Math.pow(2,63);Pbf.prototype={destroy:function(){this.buf=null},readFields:function(t,i,e){for(e=e||this.length;this.pos<e;){var r=this.readVarint(),s=r>>3,n=this.pos;t(s,i,this),this.pos===n&&this.skip(r)}return i},readMessage:function(t,i){return this.readFields(t,i,this.readVarint()+this.pos)},readFixed32:function(){var t=this.buf.readUInt32LE(this.pos);return this.pos+=4,t},readSFixed32:function(){var t=this.buf.readInt32LE(this.pos);return this.pos+=4,t},readFixed64:function(){var t=this.buf.readUInt32LE(this.pos)+this.buf.readUInt32LE(this.pos+4)*SHIFT_LEFT_32;return this.pos+=8,t},readSFixed64:function(){var t=this.buf.readUInt32LE(this.pos)+this.buf.readInt32LE(this.pos+4)*SHIFT_LEFT_32;return this.pos+=8,t},readFloat:function(){var t=this.buf.readFloatLE(this.pos);return this.pos+=4,t},readDouble:function(){var t=this.buf.readDoubleLE(this.pos);return this.pos+=8,t},readVarint:function(){var t,i,e=this.buf;return i=e[this.pos++],t=127&i,i<128?t:(i=e[this.pos++],t|=(127&i)<<7,i<128?t:(i=e[this.pos++],t|=(127&i)<<14,i<128?t:(i=e[this.pos++],t|=(127&i)<<21,i<128?t:readVarintRemainder(t,this))))},readVarint64:function(){var t=this.pos,i=this.readVarint();if(i<POW_2_63)return i;for(var e=this.pos-2;255===this.buf[e];)e--;e<t&&(e=t),i=0;for(var r=0;r<e-t+1;r++){var s=127&~this.buf[t+r];i+=r<4?s<<7*r:s*Math.pow(2,7*r)}return-i-1},readSVarint:function(){var t=this.readVarint();return t%2===1?(t+1)/-2:t/2},readBoolean:function(){return Boolean(this.readVarint())},readString:function(){var t=this.readVarint()+this.pos,i=this.buf.toString("utf8",this.pos,t);return this.pos=t,i},readBytes:function(){var t=this.readVarint()+this.pos,i=this.buf.slice(this.pos,t);return this.pos=t,i},readPackedVarint:function(){for(var t=this.readVarint()+this.pos,i=[];this.pos<t;)i.push(this.readVarint());return i},readPackedSVarint:function(){for(var t=this.readVarint()+this.pos,i=[];this.pos<t;)i.push(this.readSVarint());return i},readPackedBoolean:function(){for(var t=this.readVarint()+this.pos,i=[];this.pos<t;)i.push(this.readBoolean());return i},readPackedFloat:function(){for(var t=this.readVarint()+this.pos,i=[];this.pos<t;)i.push(this.readFloat());return i},readPackedDouble:function(){for(var t=this.readVarint()+this.pos,i=[];this.pos<t;)i.push(this.readDouble());return i},readPackedFixed32:function(){for(var t=this.readVarint()+this.pos,i=[];this.pos<t;)i.push(this.readFixed32());return i},readPackedSFixed32:function(){for(var t=this.readVarint()+this.pos,i=[];this.pos<t;)i.push(this.readSFixed32());return i},readPackedFixed64:function(){for(var t=this.readVarint()+this.pos,i=[];this.pos<t;)i.push(this.readFixed64());return i},readPackedSFixed64:function(){for(var t=this.readVarint()+this.pos,i=[];this.pos<t;)i.push(this.readSFixed64());return i},skip:function(t){var i=7&t;if(i===Pbf.Varint)for(;this.buf[this.pos++]>127;);else if(i===Pbf.Bytes)this.pos=this.readVarint()+this.pos;else if(i===Pbf.Fixed32)this.pos+=4;else{if(i!==Pbf.Fixed64)throw new Error("Unimplemented type: "+i);this.pos+=8}},writeTag:function(t,i){this.writeVarint(t<<3|i)},realloc:function(t){for(var i=this.length||16;i<this.pos+t;)i*=2;if(i!==this.length){var e=new Buffer(i);this.buf.copy(e),this.buf=e,this.length=i}},finish:function(){return this.length=this.pos,this.pos=0,this.buf.slice(0,this.length)},writeFixed32:function(t){this.realloc(4),this.buf.writeUInt32LE(t,this.pos),this.pos+=4},writeSFixed32:function(t){this.realloc(4),this.buf.writeInt32LE(t,this.pos),this.pos+=4},writeFixed64:function(t){this.realloc(8),this.buf.writeInt32LE(t&-1,this.pos),this.buf.writeUInt32LE(Math.floor(t*SHIFT_RIGHT_32),this.pos+4),this.pos+=8},writeSFixed64:function(t){this.realloc(8),this.buf.writeInt32LE(t&-1,this.pos),this.buf.writeInt32LE(Math.floor(t*SHIFT_RIGHT_32),this.pos+4),this.pos+=8},writeVarint:function(t){return t=+t,t>268435455?void writeBigVarint(t,this):(this.realloc(4),this.buf[this.pos++]=127&t|(t>127?128:0),void(t<=127||(this.buf[this.pos++]=127&(t>>>=7)|(t>127?128:0),t<=127||(this.buf[this.pos++]=127&(t>>>=7)|(t>127?128:0),t<=127||(this.buf[this.pos++]=t>>>7&127)))))},writeSVarint:function(t){this.writeVarint(t<0?2*-t-1:2*t)},writeBoolean:function(t){this.writeVarint(Boolean(t))},writeString:function(t){t=String(t);var i=Buffer.byteLength(t);this.writeVarint(i),this.realloc(i),this.buf.write(t,this.pos),this.pos+=i},writeFloat:function(t){this.realloc(4),this.buf.writeFloatLE(t,this.pos),this.pos+=4},writeDouble:function(t){this.realloc(8),this.buf.writeDoubleLE(t,this.pos),this.pos+=8},writeBytes:function(t){var i=t.length;this.writeVarint(i),this.realloc(i);for(var e=0;e<i;e++)this.buf[this.pos++]=t[e]},writeRawMessage:function(t,i){this.pos++;var e=this.pos;t(i,this);var r=this.pos-e;r>=128&&reallocForRawMessage(e,r,this),this.pos=e-1,this.writeVarint(r),this.pos+=r},writeMessage:function(t,i,e){this.writeTag(t,Pbf.Bytes),this.writeRawMessage(i,e)},writePackedVarint:function(t,i){this.writeMessage(t,writePackedVarint,i)},writePackedSVarint:function(t,i){this.writeMessage(t,writePackedSVarint,i)},writePackedBoolean:function(t,i){this.writeMessage(t,writePackedBoolean,i)},writePackedFloat:function(t,i){this.writeMessage(t,writePackedFloat,i)},writePackedDouble:function(t,i){this.writeMessage(t,writePackedDouble,i)},writePackedFixed32:function(t,i){this.writeMessage(t,writePackedFixed32,i)},writePackedSFixed32:function(t,i){this.writeMessage(t,writePackedSFixed32,i)},writePackedFixed64:function(t,i){this.writeMessage(t,writePackedFixed64,i)},writePackedSFixed64:function(t,i){this.writeMessage(t,writePackedSFixed64,i)},writeBytesField:function(t,i){this.writeTag(t,Pbf.Bytes),this.writeBytes(i)},writeFixed32Field:function(t,i){this.writeTag(t,Pbf.Fixed32),this.writeFixed32(i)},writeSFixed32Field:function(t,i){this.writeTag(t,Pbf.Fixed32),this.writeSFixed32(i)},writeFixed64Field:function(t,i){this.writeTag(t,Pbf.Fixed64),this.writeFixed64(i)},writeSFixed64Field:function(t,i){this.writeTag(t,Pbf.Fixed64),this.writeSFixed64(i)},writeVarintField:function(t,i){this.writeTag(t,Pbf.Varint),this.writeVarint(i)},writeSVarintField:function(t,i){this.writeTag(t,Pbf.Varint),this.writeSVarint(i)},writeStringField:function(t,i){this.writeTag(t,Pbf.Bytes),this.writeString(i)},writeFloatField:function(t,i){this.writeTag(t,Pbf.Fixed32),this.writeFloat(i)},writeDoubleField:function(t,i){this.writeTag(t,Pbf.Fixed64),this.writeDouble(i)},writeBooleanField:function(t,i){this.writeVarintField(t,Boolean(i))}};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./buffer":195}],197:[function(require,module,exports){
"use strict";function Point(t,n){this.x=t,this.y=n}module.exports=Point,Point.prototype={clone:function(){return new Point(this.x,this.y)},add:function(t){return this.clone()._add(t)},sub:function(t){return this.clone()._sub(t)},mult:function(t){return this.clone()._mult(t)},div:function(t){return this.clone()._div(t)},rotate:function(t){return this.clone()._rotate(t)},matMult:function(t){return this.clone()._matMult(t)},unit:function(){return this.clone()._unit()},perp:function(){return this.clone()._perp()},round:function(){return this.clone()._round()},mag:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},equals:function(t){return this.x===t.x&&this.y===t.y},dist:function(t){return Math.sqrt(this.distSqr(t))},distSqr:function(t){var n=t.x-this.x,i=t.y-this.y;return n*n+i*i},angle:function(){return Math.atan2(this.y,this.x)},angleTo:function(t){return Math.atan2(this.y-t.y,this.x-t.x)},angleWith:function(t){return this.angleWithSep(t.x,t.y)},angleWithSep:function(t,n){return Math.atan2(this.x*n-this.y*t,this.x*t+this.y*n)},_matMult:function(t){var n=t[0]*this.x+t[1]*this.y,i=t[2]*this.x+t[3]*this.y;return this.x=n,this.y=i,this},_add:function(t){return this.x+=t.x,this.y+=t.y,this},_sub:function(t){return this.x-=t.x,this.y-=t.y,this},_mult:function(t){return this.x*=t,this.y*=t,this},_div:function(t){return this.x/=t,this.y/=t,this},_unit:function(){return this._div(this.mag()),this},_perp:function(){var t=this.y;return this.y=this.x,this.x=-t,this},_rotate:function(t){var n=Math.cos(t),i=Math.sin(t),s=n*this.x-i*this.y,r=i*this.x+n*this.y;return this.x=s,this.y=r,this},_round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}},Point.convert=function(t){return t instanceof Point?t:Array.isArray(t)?new Point(t[0],t[1]):t};
},{}],198:[function(require,module,exports){
function defaultSetTimout(){throw new Error("setTimeout has not been defined")}function defaultClearTimeout(){throw new Error("clearTimeout has not been defined")}function runTimeout(e){if(cachedSetTimeout===setTimeout)return setTimeout(e,0);if((cachedSetTimeout===defaultSetTimout||!cachedSetTimeout)&&setTimeout)return cachedSetTimeout=setTimeout,setTimeout(e,0);try{return cachedSetTimeout(e,0)}catch(t){try{return cachedSetTimeout.call(null,e,0)}catch(t){return cachedSetTimeout.call(this,e,0)}}}function runClearTimeout(e){if(cachedClearTimeout===clearTimeout)return clearTimeout(e);if((cachedClearTimeout===defaultClearTimeout||!cachedClearTimeout)&&clearTimeout)return cachedClearTimeout=clearTimeout,clearTimeout(e);try{return cachedClearTimeout(e)}catch(t){try{return cachedClearTimeout.call(null,e)}catch(t){return cachedClearTimeout.call(this,e)}}}function cleanUpNextTick(){draining&&currentQueue&&(draining=!1,currentQueue.length?queue=currentQueue.concat(queue):queueIndex=-1,queue.length&&drainQueue())}function drainQueue(){if(!draining){var e=runTimeout(cleanUpNextTick);draining=!0;for(var t=queue.length;t;){for(currentQueue=queue,queue=[];++queueIndex<t;)currentQueue&&currentQueue[queueIndex].run();queueIndex=-1,t=queue.length}currentQueue=null,draining=!1,runClearTimeout(e)}}function Item(e,t){this.fun=e,this.array=t}function noop(){}var process=module.exports={},cachedSetTimeout,cachedClearTimeout;!function(){try{cachedSetTimeout="function"==typeof setTimeout?setTimeout:defaultSetTimout}catch(e){cachedSetTimeout=defaultSetTimout}try{cachedClearTimeout="function"==typeof clearTimeout?clearTimeout:defaultClearTimeout}catch(e){cachedClearTimeout=defaultClearTimeout}}();var queue=[],draining=!1,currentQueue,queueIndex=-1;process.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var u=1;u<arguments.length;u++)t[u-1]=arguments[u];queue.push(new Item(e,t)),1!==queue.length||draining||runTimeout(drainQueue)},Item.prototype.run=function(){this.fun.apply(null,this.array)},process.title="browser",process.browser=!0,process.env={},process.argv=[],process.version="",process.versions={},process.on=noop,process.addListener=noop,process.once=noop,process.off=noop,process.removeListener=noop,process.removeAllListeners=noop,process.emit=noop,process.binding=function(e){throw new Error("process.binding is not supported")},process.cwd=function(){return"/"},process.chdir=function(e){throw new Error("process.chdir is not supported")},process.umask=function(){return 0};
},{}],199:[function(require,module,exports){
"use strict";function partialSort(a,t,r,o,p){for(r=r||0,o=o||a.length-1,p=p||defaultCompare;o>r;){if(o-r>600){var f=o-r+1,e=t-r+1,l=Math.log(f),s=.5*Math.exp(2*l/3),i=.5*Math.sqrt(l*s*(f-s)/f)*(e-f/2<0?-1:1),n=Math.max(r,Math.floor(t-e*s/f+i)),h=Math.min(o,Math.floor(t+(f-e)*s/f+i));partialSort(a,t,n,h,p)}var u=a[t],M=r,w=o;for(swap(a,r,t),p(a[o],u)>0&&swap(a,r,o);M<w;){for(swap(a,M,w),M++,w--;p(a[M],u)<0;)M++;for(;p(a[w],u)>0;)w--}0===p(a[r],u)?swap(a,r,w):(w++,swap(a,w,o)),w<=t&&(r=w+1),t<=w&&(o=w-1)}}function swap(a,t,r){var o=a[t];a[t]=a[r],a[r]=o}function defaultCompare(a,t){return a<t?-1:a>t?1:0}module.exports=partialSort;
},{}],200:[function(require,module,exports){
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):t.ShelfPack=e()}(this,function(){function t(t,e,s){s=s||{},this.w=t||64,this.h=e||64,this.autoResize=!!s.autoResize,this.shelves=[],this.stats={},this.count=function(t){this.stats[t]=(0|this.stats[t])+1}}function e(t,e,s){this.x=0,this.y=t,this.w=this.free=e,this.h=s}return t.prototype.pack=function(t,e){t=[].concat(t),e=e||{};for(var s,h,i,n=[],r=0;r<t.length;r++)if(s=t[r].w||t[r].width,h=t[r].h||t[r].height,s&&h){if(i=this.packOne(s,h),!i)continue;e.inPlace&&(t[r].x=i.x,t[r].y=i.y),n.push(i)}if(this.shelves.length>0){for(var o=0,f=0,u=0;u<this.shelves.length;u++){var l=this.shelves[u];f+=l.h,o=Math.max(l.w-l.free,o)}this.resize(o,f)}return n},t.prototype.packOne=function(t,s){for(var h,i,n=0,r={shelf:-1,waste:1/0},o=0;o<this.shelves.length;o++){if(h=this.shelves[o],n+=h.h,s===h.h&&t<=h.free)return this.count(s),h.alloc(t,s);s>h.h||t>h.free||s<h.h&&t<=h.free&&(i=h.h-s,i<r.waste&&(r.waste=i,r.shelf=o))}if(r.shelf!==-1)return h=this.shelves[r.shelf],this.count(s),h.alloc(t,s);if(s<=this.h-n&&t<=this.w)return h=new e(n,this.w,s),this.shelves.push(h),this.count(s),h.alloc(t,s);if(this.autoResize){var f,u,l,a;return f=u=this.h,l=a=this.w,(l<=f||t>l)&&(a=2*Math.max(t,l)),(f<l||s>f)&&(u=2*Math.max(s,f)),this.resize(a,u),this.packOne(t,s)}return null},t.prototype.clear=function(){this.shelves=[],this.stats={}},t.prototype.resize=function(t,e){this.w=t,this.h=e;for(var s=0;s<this.shelves.length;s++)this.shelves[s].resize(t);return!0},e.prototype.alloc=function(t,e){if(t>this.free||e>this.h)return null;var s=this.x;return this.x+=t,this.free-=t,{x:s,y:this.y,w:t,h:e,width:t,height:e}},e.prototype.resize=function(t){return this.free+=t-this.w,this.w=t,!0},t});
},{}],201:[function(require,module,exports){
"use strict";function supercluster(t){return new SuperCluster(t)}function SuperCluster(t){this.options=extend(Object.create(this.options),t),this.trees=new Array(this.options.maxZoom+1)}function createCluster(t,e,o,n){return{x:t,y:e,zoom:1/0,id:n,numPoints:o}}function createPointCluster(t,e){var o=t.geometry.coordinates;return createCluster(lngX(o[0]),latY(o[1]),1,e)}function getClusterJSON(t){return{type:"Feature",properties:getClusterProperties(t),geometry:{type:"Point",coordinates:[xLng(t.x),yLat(t.y)]}}}function getClusterProperties(t){var e=t.numPoints,o=e>=1e4?Math.round(e/1e3)+"k":e>=1e3?Math.round(e/100)/10+"k":e;return{cluster:!0,point_count:e,point_count_abbreviated:o}}function lngX(t){return t/360+.5}function latY(t){var e=Math.sin(t*Math.PI/180),o=.5-.25*Math.log((1+e)/(1-e))/Math.PI;return o<0?0:o>1?1:o}function xLng(t){return 360*(t-.5)}function yLat(t){var e=(180-360*t)*Math.PI/180;return 360*Math.atan(Math.exp(e))/Math.PI-90}function extend(t,e){for(var o in e)t[o]=e[o];return t}function getX(t){return t.x}function getY(t){return t.y}var kdbush=require("kdbush");module.exports=supercluster,SuperCluster.prototype={options:{minZoom:0,maxZoom:16,radius:40,extent:512,nodeSize:64,log:!1},load:function(t){var e=this.options.log;e&&console.time("total time");var o="prepare "+t.length+" points";e&&console.time(o),this.points=t;var n=t.map(createPointCluster);e&&console.timeEnd(o);for(var r=this.options.maxZoom;r>=this.options.minZoom;r--){var i=+Date.now();this.trees[r+1]=kdbush(n,getX,getY,this.options.nodeSize,Float32Array),n=this._cluster(n,r),e&&console.log("z%d: %d clusters in %dms",r,n.length,+Date.now()-i)}return this.trees[this.options.minZoom]=kdbush(n,getX,getY,this.options.nodeSize,Float32Array),e&&console.timeEnd("total time"),this},getClusters:function(t,e){for(var o=this.trees[this._limitZoom(e)],n=o.range(lngX(t[0]),latY(t[3]),lngX(t[2]),latY(t[1])),r=[],i=0;i<n.length;i++){var s=o.points[n[i]];r.push(s.id!==-1?this.points[s.id]:getClusterJSON(s))}return r},getTile:function(t,e,o){var n=this.trees[this._limitZoom(t)],r=Math.pow(2,t),i=this.options.extent,s=this.options.radius,u=s/i,a=(o-u)/r,h=(o+1+u)/r,l={features:[]};return this._addTileFeatures(n.range((e-u)/r,a,(e+1+u)/r,h),n.points,e,o,r,l),0===e&&this._addTileFeatures(n.range(1-u/r,a,1,h),n.points,r,o,r,l),e===r-1&&this._addTileFeatures(n.range(0,a,u/r,h),n.points,-1,o,r,l),l.features.length?l:null},_addTileFeatures:function(t,e,o,n,r,i){for(var s=0;s<t.length;s++){var u=e[t[s]];i.features.push({type:1,geometry:[[Math.round(this.options.extent*(u.x*r-o)),Math.round(this.options.extent*(u.y*r-n))]],tags:u.id!==-1?this.points[u.id].properties:getClusterProperties(u)})}},_limitZoom:function(t){return Math.max(this.options.minZoom,Math.min(t,this.options.maxZoom+1))},_cluster:function(t,e){for(var o=[],n=this.options.radius/(this.options.extent*Math.pow(2,e)),r=0;r<t.length;r++){var i=t[r];if(!(i.zoom<=e)){i.zoom=e;for(var s=this.trees[e+1],u=s.within(i.x,i.y,n),a=!1,h=i.numPoints,l=i.x*h,p=i.y*h,m=0;m<u.length;m++){var c=s.points[u[m]];e<c.zoom&&(a=!0,c.zoom=e,l+=c.x*c.numPoints,p+=c.y*c.numPoints,h+=c.numPoints)}o.push(a?createCluster(l/h,p/h,h,-1):i)}}return o}};
},{"kdbush":151}],202:[function(require,module,exports){
"use strict";function TinyQueue(t,i){if(!(this instanceof TinyQueue))return new TinyQueue(t,i);if(this.data=t||[],this.length=this.data.length,this.compare=i||defaultCompare,t)for(var a=Math.floor(this.length/2);a>=0;a--)this._down(a)}function defaultCompare(t,i){return t<i?-1:t>i?1:0}function swap(t,i,a){var n=t[i];t[i]=t[a],t[a]=n}module.exports=TinyQueue,TinyQueue.prototype={push:function(t){this.data.push(t),this.length++,this._up(this.length-1)},pop:function(){var t=this.data[0];return this.data[0]=this.data[this.length-1],this.length--,this.data.pop(),this._down(0),t},peek:function(){return this.data[0]},_up:function(t){for(var i=this.data,a=this.compare;t>0;){var n=Math.floor((t-1)/2);if(!(a(i[t],i[n])<0))break;swap(i,n,t),t=n}},_down:function(t){for(var i=this.data,a=this.compare,n=this.length;;){var e=2*t+1,h=e+1,s=t;if(e<n&&a(i[e],i[s])<0&&(s=e),h<n&&a(i[h],i[s])<0&&(s=h),s===t)return;swap(i,s,t),t=s}}};
},{}],203:[function(require,module,exports){
"function"==typeof Object.create?module.exports=function(t,e){t.super_=e,t.prototype=Object.create(e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}})}:module.exports=function(t,e){t.super_=e;var o=function(){};o.prototype=e.prototype,t.prototype=new o,t.prototype.constructor=t};
},{}],204:[function(require,module,exports){
module.exports=function(o){return o&&"object"==typeof o&&"function"==typeof o.copy&&"function"==typeof o.fill&&"function"==typeof o.readUInt8};
},{}],205:[function(require,module,exports){
(function (process,global){
function inspect(e,r){var t={seen:[],stylize:stylizeNoColor};return arguments.length>=3&&(t.depth=arguments[2]),arguments.length>=4&&(t.colors=arguments[3]),isBoolean(r)?t.showHidden=r:r&&exports._extend(t,r),isUndefined(t.showHidden)&&(t.showHidden=!1),isUndefined(t.depth)&&(t.depth=2),isUndefined(t.colors)&&(t.colors=!1),isUndefined(t.customInspect)&&(t.customInspect=!0),t.colors&&(t.stylize=stylizeWithColor),formatValue(t,e,t.depth)}function stylizeWithColor(e,r){var t=inspect.styles[r];return t?"["+inspect.colors[t][0]+"m"+e+"["+inspect.colors[t][1]+"m":e}function stylizeNoColor(e,r){return e}function arrayToHash(e){var r={};return e.forEach(function(e,t){r[e]=!0}),r}function formatValue(e,r,t){if(e.customInspect&&r&&isFunction(r.inspect)&&r.inspect!==exports.inspect&&(!r.constructor||r.constructor.prototype!==r)){var n=r.inspect(t,e);return isString(n)||(n=formatValue(e,n,t)),n}var i=formatPrimitive(e,r);if(i)return i;var o=Object.keys(r),s=arrayToHash(o);if(e.showHidden&&(o=Object.getOwnPropertyNames(r)),isError(r)&&(o.indexOf("message")>=0||o.indexOf("description")>=0))return formatError(r);if(0===o.length){if(isFunction(r)){var u=r.name?": "+r.name:"";return e.stylize("[Function"+u+"]","special")}if(isRegExp(r))return e.stylize(RegExp.prototype.toString.call(r),"regexp");if(isDate(r))return e.stylize(Date.prototype.toString.call(r),"date");if(isError(r))return formatError(r)}var c="",a=!1,l=["{","}"];if(isArray(r)&&(a=!0,l=["[","]"]),isFunction(r)){var p=r.name?": "+r.name:"";c=" [Function"+p+"]"}if(isRegExp(r)&&(c=" "+RegExp.prototype.toString.call(r)),isDate(r)&&(c=" "+Date.prototype.toUTCString.call(r)),isError(r)&&(c=" "+formatError(r)),0===o.length&&(!a||0==r.length))return l[0]+c+l[1];if(t<0)return isRegExp(r)?e.stylize(RegExp.prototype.toString.call(r),"regexp"):e.stylize("[Object]","special");e.seen.push(r);var f;return f=a?formatArray(e,r,t,s,o):o.map(function(n){return formatProperty(e,r,t,s,n,a)}),e.seen.pop(),reduceToSingleString(f,c,l)}function formatPrimitive(e,r){if(isUndefined(r))return e.stylize("undefined","undefined");if(isString(r)){var t="'"+JSON.stringify(r).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return e.stylize(t,"string")}return isNumber(r)?e.stylize(""+r,"number"):isBoolean(r)?e.stylize(""+r,"boolean"):isNull(r)?e.stylize("null","null"):void 0}function formatError(e){return"["+Error.prototype.toString.call(e)+"]"}function formatArray(e,r,t,n,i){for(var o=[],s=0,u=r.length;s<u;++s)hasOwnProperty(r,String(s))?o.push(formatProperty(e,r,t,n,String(s),!0)):o.push("");return i.forEach(function(i){i.match(/^\d+$/)||o.push(formatProperty(e,r,t,n,i,!0))}),o}function formatProperty(e,r,t,n,i,o){var s,u,c;if(c=Object.getOwnPropertyDescriptor(r,i)||{value:r[i]},c.get?u=c.set?e.stylize("[Getter/Setter]","special"):e.stylize("[Getter]","special"):c.set&&(u=e.stylize("[Setter]","special")),hasOwnProperty(n,i)||(s="["+i+"]"),u||(e.seen.indexOf(c.value)<0?(u=isNull(t)?formatValue(e,c.value,null):formatValue(e,c.value,t-1),u.indexOf("\n")>-1&&(u=o?u.split("\n").map(function(e){return"  "+e}).join("\n").substr(2):"\n"+u.split("\n").map(function(e){return"   "+e}).join("\n"))):u=e.stylize("[Circular]","special")),isUndefined(s)){if(o&&i.match(/^\d+$/))return u;s=JSON.stringify(""+i),s.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(s=s.substr(1,s.length-2),s=e.stylize(s,"name")):(s=s.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),s=e.stylize(s,"string"))}return s+": "+u}function reduceToSingleString(e,r,t){var n=0,i=e.reduce(function(e,r){return n++,r.indexOf("\n")>=0&&n++,e+r.replace(/\u001b\[\d\d?m/g,"").length+1},0);return i>60?t[0]+(""===r?"":r+"\n ")+" "+e.join(",\n  ")+" "+t[1]:t[0]+r+" "+e.join(", ")+" "+t[1]}function isArray(e){return Array.isArray(e)}function isBoolean(e){return"boolean"==typeof e}function isNull(e){return null===e}function isNullOrUndefined(e){return null==e}function isNumber(e){return"number"==typeof e}function isString(e){return"string"==typeof e}function isSymbol(e){return"symbol"==typeof e}function isUndefined(e){return void 0===e}function isRegExp(e){return isObject(e)&&"[object RegExp]"===objectToString(e)}function isObject(e){return"object"==typeof e&&null!==e}function isDate(e){return isObject(e)&&"[object Date]"===objectToString(e)}function isError(e){return isObject(e)&&("[object Error]"===objectToString(e)||e instanceof Error)}function isFunction(e){return"function"==typeof e}function isPrimitive(e){return null===e||"boolean"==typeof e||"number"==typeof e||"string"==typeof e||"symbol"==typeof e||"undefined"==typeof e}function objectToString(e){return Object.prototype.toString.call(e)}function pad(e){return e<10?"0"+e.toString(10):e.toString(10)}function timestamp(){var e=new Date,r=[pad(e.getHours()),pad(e.getMinutes()),pad(e.getSeconds())].join(":");return[e.getDate(),months[e.getMonth()],r].join(" ")}function hasOwnProperty(e,r){return Object.prototype.hasOwnProperty.call(e,r)}var formatRegExp=/%[sdj%]/g;exports.format=function(e){if(!isString(e)){for(var r=[],t=0;t<arguments.length;t++)r.push(inspect(arguments[t]));return r.join(" ")}for(var t=1,n=arguments,i=n.length,o=String(e).replace(formatRegExp,function(e){if("%%"===e)return"%";if(t>=i)return e;switch(e){case"%s":return String(n[t++]);case"%d":return Number(n[t++]);case"%j":try{return JSON.stringify(n[t++])}catch(e){return"[Circular]"}default:return e}}),s=n[t];t<i;s=n[++t])o+=isNull(s)||!isObject(s)?" "+s:" "+inspect(s);return o},exports.deprecate=function(e,r){function t(){if(!n){if(process.throwDeprecation)throw new Error(r);process.traceDeprecation?console.trace(r):console.error(r),n=!0}return e.apply(this,arguments)}if(isUndefined(global.process))return function(){return exports.deprecate(e,r).apply(this,arguments)};if(process.noDeprecation===!0)return e;var n=!1;return t};var debugs={},debugEnviron;exports.debuglog=function(e){if(isUndefined(debugEnviron)&&(debugEnviron=process.env.NODE_DEBUG||""),e=e.toUpperCase(),!debugs[e])if(new RegExp("\\b"+e+"\\b","i").test(debugEnviron)){var r=process.pid;debugs[e]=function(){var t=exports.format.apply(exports,arguments);console.error("%s %d: %s",e,r,t)}}else debugs[e]=function(){};return debugs[e]},exports.inspect=inspect,inspect.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},inspect.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"},exports.isArray=isArray,exports.isBoolean=isBoolean,exports.isNull=isNull,exports.isNullOrUndefined=isNullOrUndefined,exports.isNumber=isNumber,exports.isString=isString,exports.isSymbol=isSymbol,exports.isUndefined=isUndefined,exports.isRegExp=isRegExp,exports.isObject=isObject,exports.isDate=isDate,exports.isError=isError,exports.isFunction=isFunction,exports.isPrimitive=isPrimitive,exports.isBuffer=require("./support/isBuffer");var months=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];exports.log=function(){console.log("%s - %s",timestamp(),exports.format.apply(exports,arguments))},exports.inherits=require("inherits"),exports._extend=function(e,r){if(!r||!isObject(r))return e;for(var t=Object.keys(r),n=t.length;n--;)e[t[n]]=r[t[n]];return e};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":204,"_process":198,"inherits":203}],206:[function(require,module,exports){
module.exports.VectorTile=require("./lib/vectortile.js"),module.exports.VectorTileFeature=require("./lib/vectortilefeature.js"),module.exports.VectorTileLayer=require("./lib/vectortilelayer.js");
},{"./lib/vectortile.js":207,"./lib/vectortilefeature.js":208,"./lib/vectortilelayer.js":209}],207:[function(require,module,exports){
"use strict";function VectorTile(e,r){this.layers=e.readFields(readTile,{},r)}function readTile(e,r,i){if(3===e){var t=new VectorTileLayer(i,i.readVarint()+i.pos);t.length&&(r[t.name]=t)}}var VectorTileLayer=require("./vectortilelayer");module.exports=VectorTile;
},{"./vectortilelayer":209}],208:[function(require,module,exports){
"use strict";function VectorTileFeature(e,t,r,i,a){this.properties={},this.extent=r,this.type=0,this._pbf=e,this._geometry=-1,this._keys=i,this._values=a,e.readFields(readFeature,this,t)}function readFeature(e,t,r){1==e?t.id=r.readVarint():2==e?readTag(r,t):3==e?t.type=r.readVarint():4==e&&(t._geometry=r.pos)}function readTag(e,t){for(var r=e.readVarint()+e.pos;e.pos<r;){var i=t._keys[e.readVarint()],a=t._values[e.readVarint()];t.properties[i]=a}}function classifyRings(e){var t=e.length;if(t<=1)return[e];for(var r,i,a=[],o=0;o<t;o++){var n=signedArea(e[o]);0!==n&&(void 0===i&&(i=n<0),i===n<0?(r&&a.push(r),r=[e[o]]):r.push(e[o]))}return r&&a.push(r),a}function signedArea(e){for(var t,r,i=0,a=0,o=e.length,n=o-1;a<o;n=a++)t=e[a],r=e[n],i+=(r.x-t.x)*(t.y+r.y);return i}var Point=require("point-geometry");module.exports=VectorTileFeature,VectorTileFeature.types=["Unknown","Point","LineString","Polygon"],VectorTileFeature.prototype.loadGeometry=function(){var e=this._pbf;e.pos=this._geometry;for(var t,r=e.readVarint()+e.pos,i=1,a=0,o=0,n=0,s=[];e.pos<r;){if(!a){var p=e.readVarint();i=7&p,a=p>>3}if(a--,1===i||2===i)o+=e.readSVarint(),n+=e.readSVarint(),1===i&&(t&&s.push(t),t=[]),t.push(new Point(o,n));else{if(7!==i)throw new Error("unknown command "+i);t&&t.push(t[0].clone())}}return t&&s.push(t),s},VectorTileFeature.prototype.bbox=function(){var e=this._pbf;e.pos=this._geometry;for(var t=e.readVarint()+e.pos,r=1,i=0,a=0,o=0,n=1/0,s=-(1/0),p=1/0,h=-(1/0);e.pos<t;){if(!i){var u=e.readVarint();r=7&u,i=u>>3}if(i--,1===r||2===r)a+=e.readSVarint(),o+=e.readSVarint(),a<n&&(n=a),a>s&&(s=a),o<p&&(p=o),o>h&&(h=o);else if(7!==r)throw new Error("unknown command "+r)}return[n,p,s,h]},VectorTileFeature.prototype.toGeoJSON=function(e,t,r){function i(e){for(var t=0;t<e.length;t++){var r=e[t],i=180-360*(r.y+p)/n;e[t]=[360*(r.x+s)/n-180,360/Math.PI*Math.atan(Math.exp(i*Math.PI/180))-90]}}var a,o,n=this.extent*Math.pow(2,r),s=this.extent*e,p=this.extent*t,h=this.loadGeometry(),u=VectorTileFeature.types[this.type];switch(this.type){case 1:var d=[];for(a=0;a<h.length;a++)d[a]=h[a][0];h=d,i(h);break;case 2:for(a=0;a<h.length;a++)i(h[a]);break;case 3:for(h=classifyRings(h),a=0;a<h.length;a++)for(o=0;o<h[a].length;o++)i(h[a][o])}1===h.length?h=h[0]:u="Multi"+u;var f={type:"Feature",geometry:{type:u,coordinates:h},properties:this.properties};return"id"in this&&(f.id=this.id),f};
},{"point-geometry":197}],209:[function(require,module,exports){
"use strict";function VectorTileLayer(e,t){this.version=1,this.name=null,this.extent=4096,this.length=0,this._pbf=e,this._keys=[],this._values=[],this._features=[],e.readFields(readLayer,this,t),this.length=this._features.length}function readLayer(e,t,r){15===e?t.version=r.readVarint():1===e?t.name=r.readString():5===e?t.extent=r.readVarint():2===e?t._features.push(r.pos):3===e?t._keys.push(r.readString()):4===e&&t._values.push(readValueMessage(r))}function readValueMessage(e){for(var t=null,r=e.readVarint()+e.pos;e.pos<r;){var a=e.readVarint()>>3;t=1===a?e.readString():2===a?e.readFloat():3===a?e.readDouble():4===a?e.readVarint64():5===a?e.readVarint():6===a?e.readSVarint():7===a?e.readBoolean():null}return t}var VectorTileFeature=require("./vectortilefeature.js");module.exports=VectorTileLayer,VectorTileLayer.prototype.feature=function(e){if(e<0||e>=this._features.length)throw new Error("feature index out of bounds");this._pbf.pos=this._features[e];var t=this._pbf.readVarint()+this._pbf.pos;return new VectorTileFeature(this._pbf,t,this.extent,this._keys,this._values)};
},{"./vectortilefeature.js":208}],210:[function(require,module,exports){
function fromVectorTileJs(e){var r=[];for(var o in e.layers)r.push(prepareLayer(e.layers[o]));var t=new Pbf;return vtpb.tile.write({layers:r},t),t.finish()}function fromGeojsonVt(e){var r={};for(var o in e)r[o]=new GeoJSONWrapper(e[o].features),r[o].name=o;return fromVectorTileJs({layers:r})}function prepareLayer(e){for(var r={name:e.name||"",version:e.version||1,extent:e.extent||4096,keys:[],values:[],features:[]},o={},t={},n=0;n<e.length;n++){var a=e.feature(n);a.geometry=encodeGeometry(a.loadGeometry());var u=[];for(var s in a.properties){var i=o[s];"undefined"==typeof i&&(r.keys.push(s),i=r.keys.length-1,o[s]=i);var p=wrapValue(a.properties[s]),l=t[p.key];"undefined"==typeof l&&(r.values.push(p),l=r.values.length-1,t[p.key]=l),u.push(i),u.push(l)}a.tags=u,r.features.push(a)}return r}function command(e,r){return(r<<3)+(7&e)}function zigzag(e){return e<<1^e>>31}function encodeGeometry(e){for(var r=[],o=0,t=0,n=e.length,a=0;a<n;a++){var u=e[a];r.push(command(1,1));for(var s=0;s<u.length;s++){1===s&&r.push(command(2,u.length-1));var i=u[s].x-o,p=u[s].y-t;r.push(zigzag(i),zigzag(p)),o+=i,t+=p}}return r}function wrapValue(e){var r,o=typeof e;return"string"===o?r={string_value:e}:"boolean"===o?r={bool_value:e}:"number"===o?r=e%1!==0?{double_value:e}:e<0?{sint_value:e}:{uint_value:e}:(e=JSON.stringify(e),r={string_value:e}),r.key=o+":"+e,r}var Pbf=require("pbf"),vtpb=require("./vector-tile-pb"),GeoJSONWrapper=require("./lib/geojson_wrapper");module.exports=fromVectorTileJs,module.exports.fromVectorTileJs=fromVectorTileJs,module.exports.fromGeojsonVt=fromGeojsonVt,module.exports.GeoJSONWrapper=GeoJSONWrapper;
},{"./lib/geojson_wrapper":211,"./vector-tile-pb":212,"pbf":196}],211:[function(require,module,exports){
"use strict";function GeoJSONWrapper(e){this.features=e,this.length=e.length}function FeatureWrapper(e){this.id="number"==typeof e.id?e.id:void 0,this.type=e.type,this.rawGeometry=1===e.type?[e.geometry]:e.geometry,this.properties=e.tags,this.extent=4096}var Point=require("point-geometry"),VectorTileFeature=require("vector-tile").VectorTileFeature;module.exports=GeoJSONWrapper,GeoJSONWrapper.prototype.feature=function(e){return new FeatureWrapper(this.features[e])},FeatureWrapper.prototype.loadGeometry=function(){var e=this.rawGeometry;this.geometry=[];for(var t=0;t<e.length;t++){for(var r=e[t],o=[],a=0;a<r.length;a++)o.push(new Point(r[a][0],r[a][1]));this.geometry.push(o)}return this.geometry},FeatureWrapper.prototype.bbox=function(){this.geometry||this.loadGeometry();for(var e=this.geometry,t=1/0,r=-(1/0),o=1/0,a=-(1/0),i=0;i<e.length;i++)for(var p=e[i],n=0;n<p.length;n++){var h=p[n];t=Math.min(t,h.x),r=Math.max(r,h.x),o=Math.min(o,h.y),a=Math.max(a,h.y)}return[t,o,r,a]},FeatureWrapper.prototype.toGeoJSON=VectorTileFeature.prototype.toGeoJSON;
},{"point-geometry":197,"vector-tile":206}],212:[function(require,module,exports){
"use strict";function readTile(e,r){return e.readFields(readTileField,{layers:[]},r)}function readTileField(e,r,i){3===e&&r.layers.push(readLayer(i,i.readVarint()+i.pos))}function writeTile(e,r){var i;if(void 0!==e.layers)for(i=0;i<e.layers.length;i++)r.writeMessage(3,writeLayer,e.layers[i])}function readValue(e,r){return e.readFields(readValueField,{},r)}function readValueField(e,r,i){1===e?r.string_value=i.readString():2===e?r.float_value=i.readFloat():3===e?r.double_value=i.readDouble():4===e?r.int_value=i.readVarint():5===e?r.uint_value=i.readVarint():6===e?r.sint_value=i.readSVarint():7===e&&(r.bool_value=i.readBoolean())}function writeValue(e,r){void 0!==e.string_value&&r.writeStringField(1,e.string_value),void 0!==e.float_value&&r.writeFloatField(2,e.float_value),void 0!==e.double_value&&r.writeDoubleField(3,e.double_value),void 0!==e.int_value&&r.writeVarintField(4,e.int_value),void 0!==e.uint_value&&r.writeVarintField(5,e.uint_value),void 0!==e.sint_value&&r.writeSVarintField(6,e.sint_value),void 0!==e.bool_value&&r.writeBooleanField(7,e.bool_value)}function readFeature(e,r){var i=e.readFields(readFeatureField,{},r);return void 0===i.type&&(i.type="Unknown"),i}function readFeatureField(e,r,i){1===e?r.id=i.readVarint():2===e?r.tags=i.readPackedVarint():3===e?r.type=i.readVarint():4===e&&(r.geometry=i.readPackedVarint())}function writeFeature(e,r){void 0!==e.id&&r.writeVarintField(1,e.id),void 0!==e.tags&&r.writePackedVarint(2,e.tags),void 0!==e.type&&r.writeVarintField(3,e.type),void 0!==e.geometry&&r.writePackedVarint(4,e.geometry)}function readLayer(e,r){return e.readFields(readLayerField,{features:[],keys:[],values:[]},r)}function readLayerField(e,r,i){15===e?r.version=i.readVarint():1===e?r.name=i.readString():2===e?r.features.push(readFeature(i,i.readVarint()+i.pos)):3===e?r.keys.push(i.readString()):4===e?r.values.push(readValue(i,i.readVarint()+i.pos)):5===e&&(r.extent=i.readVarint())}function writeLayer(e,r){void 0!==e.version&&r.writeVarintField(15,e.version),void 0!==e.name&&r.writeStringField(1,e.name);var i;if(void 0!==e.features)for(i=0;i<e.features.length;i++)r.writeMessage(2,writeFeature,e.features[i]);if(void 0!==e.keys)for(i=0;i<e.keys.length;i++)r.writeStringField(3,e.keys[i]);if(void 0!==e.values)for(i=0;i<e.values.length;i++)r.writeMessage(4,writeValue,e.values[i]);void 0!==e.extent&&r.writeVarintField(5,e.extent)}var tile=exports.tile={read:readTile,write:writeTile};tile.GeomType={Unknown:0,Point:1,LineString:2,Polygon:3},tile.value={read:readValue,write:writeValue},tile.feature={read:readFeature,write:writeFeature},tile.layer={read:readLayer,write:writeLayer};
},{}],213:[function(require,module,exports){
var bundleFn=arguments[3],sources=arguments[4],cache=arguments[5],stringify=JSON.stringify;module.exports=function(r,e){function t(r){d[r]=!0;for(var e in sources[r][1]){var n=sources[r][1][e];d[n]||t(n)}}for(var n,o=Object.keys(cache),a=0,i=o.length;a<i;a++){var s=o[a],u=cache[s].exports;if(u===r||u&&u.default===r){n=s;break}}if(!n){n=Math.floor(Math.pow(16,8)*Math.random()).toString(16);for(var f={},a=0,i=o.length;a<i;a++){var s=o[a];f[s]=s}sources[n]=[Function(["require","module","exports"],"("+r+")(self)"),f]}var c=Math.floor(Math.pow(16,8)*Math.random()).toString(16),l={};l[n]=n,sources[c]=[Function(["require"],"var f = require("+stringify(n)+");(f.default ? f.default : f)(self);"),l];var d={};t(c);var g="("+bundleFn+")({"+Object.keys(d).map(function(r){return stringify(r)+":["+sources[r][0]+","+stringify(sources[r][1])+"]"}).join(",")+"},{},["+stringify(c)+"])",v=window.URL||window.webkitURL||window.mozURL||window.msURL,w=new Blob([g],{type:"text/javascript"});if(e&&e.bare)return w;var h=v.createObjectURL(w),b=new Worker(h);return b.objectURL=h,b};
},{}],214:[function(require,module,exports){
module.exports.RADIUS=6378137,module.exports.FLATTENING=1/298.257223563,module.exports.POLAR_RADIUS=6356752.3142;
},{}],215:[function(require,module,exports){
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t(e.WhooTS=e.WhooTS||{})}(this,function(e){function t(e,t,r,n,i,s){s=s||{};var f=e+"?"+["bbox="+o(r,n,i),"format="+(s.format||"image/png"),"service="+(s.service||"WMS"),"version="+(s.version||"1.1.1"),"request="+(s.request||"GetMap"),"srs="+(s.srs||"EPSG:3857"),"width="+(s.width||256),"height="+(s.height||256),"layers="+t].join("&");return f}function o(e,t,o){t=Math.pow(2,o)-t-1;var n=r(256*e,256*t,o),i=r(256*(e+1),256*(t+1),o);return n[0]+","+n[1]+","+i[0]+","+i[1]}function r(e,t,o){var r=2*Math.PI*6378137/256/Math.pow(2,o),n=e*r-2*Math.PI*6378137/2,i=t*r-2*Math.PI*6378137/2;return[n,i]}e.getURL=t,e.getTileBBox=o,e.getMercCoords=r,Object.defineProperty(e,"__esModule",{value:!0})});
},{}],216:[function(require,module,exports){
module.exports={"version":"0.32.1"}
},{}]},{},[24])(24)
});


//# sourceMappingURL=mapbox-gl.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(232).Buffer, __webpack_require__(85)))

/***/ }),
/* 470 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 471 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof process === "object" && process.domain) {
      invoke = process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(85), __webpack_require__(470)))

/***/ }),
/* 472 */
/***/ (function(module, exports) {

/*
 * A collection of interpolators
 * @param {Number} x1, x2, y1, y2 - boundary points
 * @param {Number} x - point of interpolation
 * @return {Number} y - interpolated value
 */
//
module.exports = {
    linear: function(x1, x2, y1, y2, x) {
      return +y1 + (x - x1) / (x2 - x1) * (y2 - y1);
    },
    exp: function(x1, x2, y1, y2, x) {
      return Math.exp((Math.log(y1) * (x2 - x) - Math.log(y2) * (x1 - x)) / (x2 - x1));
    },
    stepBefore: function(x1, x2, y1, y2, x) {
        return y2;
    },
    stepAfter: function(x1, x2, y1, y2, x) {
        return y1;
    },
    stepMiddle: function(x1, x2, y1, y2, x) {
        return (x < (x1 + x2)/2) ? y1 : y2;
    }
};


/***/ }),
/* 473 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./bubblesize/bubblesize.js": 86,
	"./buttonlist/buttonlist.js": 22,
	"./buttonlist/optionsbuttonlist/optionsbuttonlist.js": 117,
	"./colorlegend/colorlegend.js": 87,
	"./datanotes/datanotes.js": 35,
	"./datawarning/datawarning.js": 40,
	"./dialogs/_dialog.js": 11,
	"./dialogs/about/about.js": 118,
	"./dialogs/axes/axes.js": 119,
	"./dialogs/axesmc/axesmc.js": 120,
	"./dialogs/colors/colors.js": 121,
	"./dialogs/dialogs.js": 23,
	"./dialogs/find/find.js": 122,
	"./dialogs/label/label.js": 123,
	"./dialogs/mapoptions/mapoptions.js": 124,
	"./dialogs/moreoptions/moreoptions.js": 125,
	"./dialogs/opacity/opacity.js": 126,
	"./dialogs/presentation/presentation.js": 127,
	"./dialogs/show/show.js": 128,
	"./dialogs/side/side.js": 129,
	"./dialogs/size/size.js": 130,
	"./dialogs/speed/speed.js": 131,
	"./dialogs/stack/stack.js": 132,
	"./dialogs/timedisplay/timedisplay.js": 133,
	"./dialogs/zoom/zoom.js": 134,
	"./draggablelist/draggablelist.js": 135,
	"./indicatorpicker/indicatorpicker.js": 48,
	"./minmaxinputs/minmaxinputs.js": 88,
	"./simplecheckbox/simplecheckbox.js": 59,
	"./simpleslider/simpleslider.js": 67,
	"./sizeslider/sizeslider.js": 136,
	"./steppedspeedslider/steppedspeedslider.js": 49,
	"./timeslider/timeslider.js": 26,
	"./treemenu/treemenu.js": 27,
	"./zoombuttonlist/zoombuttonlist.js": 137
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 473;


/***/ }),
/* 474 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./about/about.html": 436,
	"./axes/axes.html": 437,
	"./axesmc/axesmc.html": 438,
	"./colors/colors.html": 439,
	"./find/find.html": 440,
	"./label/label.html": 441,
	"./mapoptions/mapoptions.html": 442,
	"./moreoptions/moreoptions.html": 443,
	"./opacity/opacity.html": 444,
	"./presentation/presentation.html": 445,
	"./show/show.html": 446,
	"./side/side.html": 447,
	"./size/size.html": 448,
	"./speed/speed.html": 449,
	"./stack/stack.html": 450,
	"./timedisplay/timedisplay.html": 451,
	"./zoom/zoom.html": 452
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 474;


/***/ }),
/* 475 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./_dialog.js": 11,
	"./about/about.js": 118,
	"./axes/axes.js": 119,
	"./axesmc/axesmc.js": 120,
	"./colors/colors.js": 121,
	"./dialogs.js": 23,
	"./find/find.js": 122,
	"./label/label.js": 123,
	"./mapoptions/mapoptions.js": 124,
	"./moreoptions/moreoptions.js": 125,
	"./opacity/opacity.js": 126,
	"./presentation/presentation.js": 127,
	"./show/show.js": 128,
	"./side/side.js": 129,
	"./size/size.js": 130,
	"./speed/speed.js": 131,
	"./stack/stack.js": 132,
	"./timedisplay/timedisplay.js": 133,
	"./zoom/zoom.js": 134
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 475;


/***/ }),
/* 476 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./axis": 90,
	"./axis.js": 90,
	"./color": 140,
	"./color.js": 140,
	"./data": 141,
	"./data.js": 141,
	"./dataconnected": 61,
	"./dataconnected.js": 61,
	"./entities": 142,
	"./entities.js": 142,
	"./group": 143,
	"./group.js": 143,
	"./hook": 42,
	"./hook.js": 42,
	"./label": 144,
	"./label.js": 144,
	"./locale": 145,
	"./locale.js": 145,
	"./marker": 146,
	"./marker.js": 146,
	"./side": 147,
	"./side.js": 147,
	"./size": 148,
	"./size.js": 148,
	"./stack": 149,
	"./stack.js": 149,
	"./time": 150,
	"./time.js": 150,
	"./ui": 151,
	"./ui.js": 151
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 476;


/***/ }),
/* 477 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./csv-time_in_columns/csv-time_in_columns.js": 213,
	"./csv/csv.js": 152,
	"./inline/inline.js": 214
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 477;


/***/ }),
/* 478 */,
/* 479 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

__webpack_require__(193);

var _globals = __webpack_require__(34);

var _globals2 = _interopRequireDefault(_globals);

var _utils = __webpack_require__(1);

var utils = _interopRequireWildcard(_utils);

var _tool = __webpack_require__(15);

var _tool2 = _interopRequireDefault(_tool);

var _vizabi = __webpack_require__(192);

var _vizabi2 = _interopRequireDefault(_vizabi);

__webpack_require__(194);

var _requireAll = __webpack_require__(71);

var _requireAll2 = _interopRequireDefault(_requireAll);

var _bubblechart = __webpack_require__(185);

var _bubblechart2 = _interopRequireDefault(_bubblechart);

var _barrankchart = __webpack_require__(184);

var _barrankchart2 = _interopRequireDefault(_barrankchart);

var _mountainchart = __webpack_require__(191);

var _mountainchart2 = _interopRequireDefault(_mountainchart);

var _barchart = __webpack_require__(183);

var _barchart2 = _interopRequireDefault(_barchart);

var _bubblemap = __webpack_require__(186);

var _bubblemap2 = _interopRequireDefault(_bubblemap);

var _bubblemap3 = __webpack_require__(189);

var _bubblemap4 = _interopRequireDefault(_bubblemap3);

var _linechart = __webpack_require__(190);

var _linechart2 = _interopRequireDefault(_linechart);

var _donutchart = __webpack_require__(188);

var _donutchart2 = _interopRequireDefault(_donutchart);

var _cartogram = __webpack_require__(187);

var _cartogram2 = _interopRequireDefault(_cartogram);

var _axislabeler = __webpack_require__(182);

var _axislabeler2 = _interopRequireDefault(_axislabeler);

var _agepyramid = __webpack_require__(181);

var _agepyramid2 = _interopRequireDefault(_agepyramid);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Fallback in case if WS is not available - requesting data from local files
/*!
 * VIZABI GAPMINDER PREFERENCES (included only in Gapminder build)
 */

var locationArray = window.location.href.split("/");

//import tools

var localUrl = locationArray.splice(0, locationArray.indexOf("preview")).join("/") + "/preview/";

_globals2.default.ext_resources = utils.deepExtend({
  host: localUrl,
  preloadPath: "data/",
  dataPath: "data/waffles/"
}, _globals2.default.ext_resources);

exports.default = _vizabi2.default;

module.exports = _vizabi2.default;

/***/ })
/******/ ]);
});